<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[修复 Win10 变更默认浏览器时设置 App 崩溃的问题]]></title>
    <url>%2F2019%2F05%2F10%2FSetting-App-crash-when-changing-default-browswer-to-Chrome-due-to-Edge%2F</url>
    <content type="text"><![CDATA[单位配发的电脑问题比较多。昨天提交 IT 修复电脑时，出现了更多问题，不得不重装系统并升级为 Windows 10。初次接触 Windows 10 的我，又遇到了不少问题。所幸，大多数问题都经由 Google 帮助解决。但仍有一个问题始终无法解决： Microsoft Edge 闪退； 退而求其次使用 Google Chrome，但尝试将 Chrome 设置为默认浏览器时，设置 App 崩溃，设置失败。 显而易见，本质上是 Edge 有问题，连累了设置 App。Google 搜索的结果千篇一律，无非是删除当前用户 AppData 目录下 Edge 的相关文件后在 Powershell 中重新注册 Edge。但反复试验之后都无法解决问题。 最后在英文版 Microsoft Community 上找到了解决办法： 设置 -&gt; 应用 -&gt; 应用和功能 搜索 Edge -&gt; 单击 -&gt; 高级选项 重置 -&gt; 修复 -&gt; 重置 这样一路操作会把 Edge 整个重置掉。此后再去设置当中修改默认浏览器就能绕过 Edge 崩溃的问题了。]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Edge</tag>
        <tag>Chrome</tag>
        <tag>Windows 10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 SumatraPDF 反向搜索时复用 VSCode 窗口]]></title>
    <url>%2F2019%2F03%2F27%2Freuse-active-window-for-inverse-search-SumatraPDF-and-LaTeXworkshop-on-VSCode%2F</url>
    <content type="text"><![CDATA[这是一篇简单的记录。 最近升级 VSCode 之后发现 SumatraPDF 的反向搜索出了些问题。具体来说，反向搜索能够定位到 VSCode 里的代码位置，但是每次反向搜索都会打开新的 VSCode 窗口。烦不胜烦。 遂上网检索，找到 VSCode 的命令行参数文档。原来，默认情况下，使用命令行打开 VSCode 会打开新的窗口。为了重用上一个活动窗口，需要在命令行参数上加上 -r 或者完整版本 --reuse-window。 于是，LaTeXworkshop 的配置变成了这样： 12345678910111213"latex-workshop.view.pdf.external.synctex": &#123; "command": "C:\\Program Files (x86)\\SumatraPDF\\SumatraPDF.exe", "args": [ "-forward-search", "%TEX%", "%LINE%", "-reuse-instance", "-inverse-search", "\"C:\\Users\\huangchencheng\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe\" \"C:\\Users\\huangchencheng\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\out\\cli.js\" -r -g \"%f:%l\"", "%PDF%" ]&#125;,]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
        <tag>SumatraPDF</tag>
        <tag>Inverse Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈因子分解机模型（FM）]]></title>
    <url>%2F2019%2F03%2F25%2FFactorization-Machine%2F</url>
    <content type="text"><![CDATA[先前我们讨论过逻辑回归。作为线性模型，它最大的优势是简单，于是可以以很高的效率去学习和预测，因而在很多领域都被广泛应用。但「成也萧何败萧何」，由于 LR 只能捕捉关于特征的线性信息，而无法捕捉非线性信息——特别是交叉特征信息，人们对 LR 进行了各种升级改造。 此篇介绍因子分解机模型（Factorization Machine）。 背景首先我们介绍一下在实际工程中模型的使用背景。 特征稀疏性在诸如 CTR 预估、推荐或搜索 ranking 的场景中，特征是非常稀疏的。特征的稀疏性往往来自分类特征的 one-hot 编码。举例来说，我们有以下数据集。数据集中的「点击」是 label，而性别、地区、频道则是特征。 点击 性别 地区 频道 1 男 天津 相声 0 女 甘肃 体育 1 女 云南 电视剧 不难发现，在这个场景下，性别、地区、频道都是分类特征。其中性别有 2 个取值；地区按省级行政单位划分全中国有 30 余个取值；频道则可能更多，可能有上百个取值。由于类别特征的不同取址之间，在数值上是不可比较和不可计算的——例如我们没法说「天津与甘肃哪个更大」，或者去计算「云南 * 3 是多少」——因此我们通常会对这些分类特征进行 one-hot 编码。 点击 性别 = 男 性别 = 女 地区 = 天津 地区 = 甘肃 地区 = 云南 频道 = 相声 频道 = 体育 频道 = 电视剧 1 1 0 1 0 0 1 0 0 0 0 1 0 1 0 0 1 0 1 0 1 0 0 1 0 0 1 这里仅列出了 8 维特征。但实际上，如前所述，实际上由性别、地区、频道 one-hot 编码之后，特征维度会升高到 100+ 维。但对于每一条样本，这 100+ 维特征中，大多数的取值都是 0。具体来说，由于它们来自三个原始的分类特征，因此这 100+ 维特征中只有 3 维取值为 1，其余都是 0。 由此可见其稀疏性。 交叉特征用户是否会点击某个 item，往往与不同特征的组合高度相关。例如，地处天津的用户点击相声类 item 的概率可能显著高于全国用户的平均水平。因此，若一条样本的 地区 = 天津 和 频道 = 相声 同时出现，则其 CTR 应该相对较高。 对于这些特征，对产品形态和策略较熟悉的工程师，可以根据这些先验知识，进行人工的特征组合，作为新的组合特征交付给模型使用。使用 LR 作为 CTR 预估模型/ranking 模型时，往往会需要工程师进行大量的特征工程操作，以便提升模型的预测性能。 不过，当分类特征增多，特别是取值多的分类特征越来越多，进行人工特征交叉的工作量会越来越大。此外，全凭经验的特征工程，可能无法完全捕捉到特征中蕴含的规律，从而降低模型预测性能的天花板。这是这类做法的主要缺陷之一。 问题如此一来，我们就会希望设计一些模型，使得它们 能够处理大规模的稀疏数据，并保有足够好的泛化性能（generalization performance）； 同时，我们还要求这些模型能够自动地学习到特征交叉带来的信息。 模型演进的背后讲清楚了背景情况和总结了问题之后，我们就能分析模型演进背后的原理了。 线性模型这里说的线性模型指的是线性回归和逻辑回归模型。假设模型的输入是特征向量 $\vec x$，则它们的预测函数分别是： 线性回归：$\hat y = f(\vec x) = w_0 + \sum_{i = 1}^{n}w_ix_i$； 逻辑回归：$\hat y = f(\vec x) = \sigma(\vec w\vec x) = \frac{1}{1 + \exp{\{w_0 + \sum_{i = 1}^{n}w_ix_i\}}}$。 线性模型的优势是简单可解释易扩展易并行。因此，逻辑回归模型是 CTR 预估领域早期最成功的模型。并且时至今日，仍有工业级的系统仍然采用逻辑回归模型。 不过，如前所述，由于线性模型无法捕获交叉特征带来的信息，因此其预测效果依赖大量的人工特征工程。随着特征量和样本量的增加，人工特征工程的成本越来越高，考虑让模型自动学习特征组合是必然的模型演进方向。 二阶多项式核 SVM既然单纯的线性模型无法捕获交叉特征。那么，最简单直接的做法就是为两两的特征组合分配一个权重参数。这些新的权重参数和原始特征对应的参数一样，交给模型去在训练阶段学习。如此一来就形成了如下的预测函数： $$\hat y = f(\vec x) = w_0 + \sum_{i = 1}^{n}w_ix_i + \sum_{0 &lt; i &lt; j &lt;= n}w_{i, j}x_ix_j.$$ 这实际上就是核函数选择为二阶多项式核的 SVM 模型。 这样设计的模型看起来能够学习到特征两两交叉带来的信息了。但这只是理论上的改进，别忘了我们从工程背景中抽象出来的问题中的第一条要求： 能够处理大规模的稀疏数据，并保有足够好的泛化性能（generalization performance）。 由于 $w_{i, j}$ 的取值完全取决于 $x_i$ 和 $x_j$ 的乘积，在数据稀疏的场景下，可能存在训练集中 $x_ix_j$ 始终为零的情况。这样一来，模型就无法有效地更新权重 $w_{i, j}$ 了；更进一步，在预测阶段，模型遇到 $x_ix_j$ 不为零的情况可能就很难有效地泛化。 因子分解机模型既然二阶多项式核 SVM 泛化性能不足的原因是「$w_{i, j}$ 的取值完全取决于 $x_i$ 和 $x_j$ 的乘积」，那么最直接的办法就是突破这一限制了。 FM 模型的解决办法是为每个维度的特征（$x_i$）学习一个表征向量（$v_i$，其实可以理解为是特征 ID 的 embedding 向量）。而后将 $x_i$ 和 $x_j$ 的乘积的权重设定为各自表征向量的点积。也就是有如下形式的预测函数： $$\hat y = f(\vec x) = w_0 + \sum_{i = 1}^{n}w_ix_i + \sum_{0 &lt; i &lt; j &lt;= n}\langle \vec v_i, \vec v_j\rangle x_ix_j.$$ 显然，FM 模型也具有二阶多项式核 SVM 的优点：能够学习到特征两两交叉带来的信息。那么现在的问题是，为什么相对二阶多项式核 SVM 做出的改进能够提高模型的泛化性能？ 如果你熟悉现在深度学习中各种对 item 的 embedding 操作，那么这个问题就不难理解了。FM 模型的表征向量相比深度学习中各种 embedding 其实是一回事——只是少了若干层 MLP，而是直接对交叉特征的组合进行建模。 我们回到上一小节举的例子：训练集中 $x_ix_j$ 始终为零。在二阶多项式核 SVM 中，由于参数权重 $w_{i, j}$ 得不到更新，模型无法学到 $x_i$ 和 $x_j$ 交叉带来的信息。但是在 FM 中，$x_i$ 和 $x_j$ 的参数并不完全由 $x_i$ 和 $x_j$ 的乘积决定。具体来说，每一维特征的表征向量由该维特征与其它所有维度特征的交叉共同决定。于是，只要存在某个 $k$ 使得 $x_i$ 和 $x_k$ 的乘积不总是为零，那么第 $i$ 维特征的表征向量 $\vec v_i$ 就能够学到有效的信息——同理对 $\vec v_j$ 也有同样的结论。于是乎，哪怕在训练集中，$x_ix_j$ 始终为零，其参数 $\langle \vec v_i, \vec v_j\rangle$ 也是经过了学习更新的，因此能够表现出很好的泛化性能。 也许有人会说，如果不存在这样的 $k$ 使得 $x_i$ 和 $x_k$ 的乘积不总是为零，会怎么样呢？好吧，这就意味着这一维特征的取值永远是零——那它还有什么意义？从特征列表中删掉它就好啦！ 效率问题在文章开篇，我们提到「LR 可以以很高的效率去学习和预测，因而在很多领域都被广泛应用」。那么 FM 模型如何呢？如果 FM 模型训练和预测都死慢死慢地，那么工程师迭代模型的效率会非常低，上线后 serving 的开销也会很大。这样一来，等待 FM 模型的最终结果必然是被抛弃…… 考虑到 FM 模型会对特征进行二阶组合，在有 $n$ 个原始特征时，交叉特征就会有 $\frac{n ^ 2 - n}{2}$ 个。因此，如果不做任何优化，FM 模型的复杂度会是 $O(n^2)$，具体来说是 $O(kn^2)$（其中 $k$ 是表征向量的长度）。在特征规模非常大的场景中，这是不可接受的。 那么问题来了，是否有办法将复杂度降低到 $O(kn)$ 呢？答案是可以的，我们来看针对特征交叉项的一系列变换。 $$\begin{aligned} \sum_{0 &lt; i &lt; j &lt;= n}\langle \vec v_i, \vec v_j\rangle x_ix_j &amp;{} = \sum_{i = 1}^{n - 1}\sum_{j = i + 1}^{n} \langle \vec v_i, \vec v_j\rangle x_ix_j \\ &amp;{} = \frac{1}{2}\sum_{i = 1}^{n}\sum_{j = 1}^{n}\langle \vec v_i, \vec v_j\rangle x_ix_j - \frac{1}{2}\sum_{i = 1}^{n}\langle \vec v_i, \vec v_i\rangle x_ix_i \\ &amp;{} = \frac{1}{2}\biggl(\sum_{i = 1}^{n}\sum_{j = 1}^{n}\sum_{d = 1}^{k}\vec v_{i, d}\vec v_{j, d}x_ix_j - \sum_{i = 1}^{n}\sum_{d = 1}^{k}\vec v_{i, d}^2x_i^2\biggr) \\ &amp;{} = \frac{1}{2}\sum_{d = 1}^{k}\biggl(\sum_{i = 1}^{n}\sum_{j = 1}^{n}\vec v_{i, d}\vec v_{j, d}x_ix_j - \sum_{i = 1}^{n}\vec v_{i, d}^2x_i^2\biggr) \\ &amp;{} = \frac{1}{2}\sum_{d = 1}^{k}\biggl(\Bigl(\sum_{i = 1}^{n}\vec v_{i, d}x_i\Bigr)\Bigl(\sum_{j = 1}^{n}\vec v_{j, d}x_j\Bigr) - \sum_{i = 1}^{n}\vec v_{i, d}^2x_i^2\biggr) \\ &amp;{} = \frac{1}{2}\sum_{d = 1}^{k}\biggl(\Bigl(\sum_{i = 1}^{n}\vec v_{i, d}x_i\Bigr)^2 - \sum_{i = 1}^{n}\vec v_{i, d}^2x_i^2\biggr). \end{aligned}$$ 等式第一行是一个平凡的变换，很容易理解。 等式第二行修改了求和符号的范围。原本的求和符号中有 $\frac{n ^ 2 - n}{2}$ 项；变换之后第一项中的求和符号有 $n^2$ 项，第二项中的求和符号有 $n$ 项。因此两式恰好相等。 等式第三行是对向量内积的展开，很容易理解。 等式第四行是运用了加法的结合律，将 $\sum_{d = 1}^{k}$ 抽到外面，这步容易理解。 等式第五行是连续两次逆向使用了乘法对加法的分配率（提取公因子），这一步可能稍微难理解一些。简便起见，我们将 $\vec v_{i, d}x_i$ 记作 $a_i$；将 $\vec v_{j, d}x_j$ 记作 $a_j$。则变换前的公式记作 $\sum_{i = 1}^{n}\sum_{j = 1}^{n}a_ia_j$。将它展开是： $$ \begin{aligned} \sum_{i = 1}^{n}\sum_{j = 1}^{n}a_ia_j = {}&amp; a_1a_1 + a_1a_2 + \cdots + a_1a_n + \\ {}&amp; a_2a_1 + a_2a_2 + \cdots + a_2a_n + \\ {}&amp; \cdots + \\ {}&amp; a_na_1 + a_na_2 + \cdots + a_na_n \\ = {}&amp; a_1\bigl(a_1 + a_2 + \cdots + a_n\bigr) + \\ {}&amp; a_2\bigl(a_1 + a_2 + \cdots + a_n\bigr) + \\ {}&amp; \cdots + \\ {}&amp; a_n\bigl(a_1 + a_2 + \cdots + a_n\bigr) \\ = {}&amp; a_1\Bigl(\sum_{j = 1}^{n}a_j\Bigr) + a_2\Bigl(\sum_{j = 1}^{n}a_j\Bigr) + \cdots + a_n\Bigl(\sum_{j = 1}^{n}a_j\Bigr) \\ = {}&amp; \sum_{i = 1}^{n}a_i\sum_{j = 1}^{n}a_j \\ = {}&amp; \Bigl(\sum_{i = 1}^{n}\vec v_{i, d}x_i\Bigr)\Bigl(\sum_{j = 1}^{n}\vec v_{j, d}x_j\Bigr). \end{aligned} $$ 等式第六行也很明显。第五行的结果中的两个求和项仅仅是下标不同，实际上完全是一回事，因此直接平方就好了。 如此一来，FM 的预测公式变成了下面这样 $$ \begin{aligned} \hat y &amp;{} = f(\vec x) \\ &amp;{} = w_0 + \sum_{i = 1}^{n}w_ix_i + \frac{1}{2}\sum_{d = 1}^{k}\biggl(\Bigl(\sum_{i = 1}^{n}\vec v_{i, d}x_i\Bigr)^2 - \sum_{i = 1}^{n}\vec v_{i, d}^2x_i^2\biggr). \end{aligned} $$ 显然，它的复杂度是 $O(kn)$。考虑到特征的稀疏性，尽管 $n$ 可能很大，但很多 $x_i$ 都是零。因此其实际复杂度应该是 $O(k\bar n)$——其中 $\bar n$ 表示样本不为零的特征维度数量的平均值。 总结总结一下。FM 模型不仅在模型本身能够满足下列两个特性，还保证了训练和预测的效率为 $O(k\bar n)$，因而是非常优秀的模型、被广泛运用： 能够处理大规模的稀疏数据，并保有足够好的泛化性能（generalization performance）； 同时，能够自动地学习到特征交叉带来的信息。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Ranking</tag>
        <tag>Logistic Regression</tag>
        <tag>Factorization Machine</tag>
        <tag>SVM</tag>
        <tag>CTR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[于 CentOS 7 上编译安装 Python 3.7.2]]></title>
    <url>%2F2019%2F03%2F19%2Fcompile-and-install-Python-3-7-2-on-CentOS-7%2F</url>
    <content type="text"><![CDATA[又到了愉悦地配置系统的时间……今日的任务是在 CentOS 7 上安装最新版本的 Python 3.7.2。 由于前些日子，蛤力橙表示 Anaconda 是 some what 邪恶的，所以这次不打算偷懒用 Anaconda 了，而是选择从源码编译安装。这里记录一些踩过的坑。 安装完成后 yum 等脚本挂掉原因：yum 等脚本依赖 Python2 而非 Python3。这次跨大版本升级，会破坏 yum 等脚本 shebang 头部的指令。 解决办法：使 yum 等脚本显式依赖 Python2。 具体：修改 /usr/bin 下 yum 相关脚本的 shebang 头，将 python 修改为 python2。 123456789$ cd /usr/bin$ ls -al yum*-rwxr-xr-x. 1 root root 801 11月 15 2016 yum-rwxr-xr-x. 1 root root 9429 11月 6 2016 yum-builddep-rwxr-xr-x. 1 root root 8582 11月 6 2016 yum-config-manager-rwxr-xr-x. 1 root root 7609 11月 6 2016 yum-debug-dump-rwxr-xr-x. 1 root root 7903 11月 6 2016 yum-debug-restore-rwxr-xr-x. 1 root root 10999 11月 6 2016 yumdownloader-rwxr-xr-x. 1 root root 11031 11月 6 2016 yum-groups-manager 安装过程中缺胳膊少腿原因：Python 依赖其他第三方库，而这些库在系统内没有安装，或者安装的位置不在 Python 安装脚本默认搜索的范围内。 解决办法：使用 yum 一口气安装就好了。 具体：执行下列 yum 命令。 1$ yum install -y ncurses-libs zlib-devel mysql-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel 安装完成后 pip 提示没有可用的 SSL，以至于无法访问 https 协议的源原因：Python 编译时没有将 SSL 编译进去。 解决办法：安装符合要求的 OpenSSL 版本，并在 ./configure 时添加 --with-ssl 参数。 具体：执行下列命令。 1234567$ cd /path/to/downloads$ wget https://www.openssl.org/source/openssl-1.1.1b.tar.gz$ tar zvxf openssl-1.1.1b.tar.gz$ cd openssl-1.1.1b$ ./config -fPIC --prefix=/usr/ --openssldir=/usr/openssl enable-shared shared zlib$ make -j24$ make install 注意：必须安装 1.0.2 以上版本的 OpenSSL，故而 yum 源当中的 1.0.1 版本不可用。 依赖 SSL 之后提示 UUID 编译失败原因：Python 的 UUID 相关扩展的代码有 bug；无法正确载入 uuid.h 头文件或者载入了两个版本的头文件。 解决办法：修改相应头文件。 具体：在 Python 源码根目录，编辑 ./Modules/_uuidmodule.c 文件，修改头部 #include 部分的代码如下： 12345678#define PY_SSIZE_T_CLEAN#include "Python.h"#ifdef HAVE_UUID_UUID_H#include &lt;uuid/uuid.h&gt;#else#include &lt;uuid.h&gt;#endif 总结总结一下编译安装 Python 3.7.2 时用到的命令。 123456789101112131415161718192021222324252627yum install -y ncurses-libs zlib-devel mysql-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel uuid-devel libuuid-develcd /path/to/downloadswget https://www.openssl.org/source/openssl-1.1.1b.tar.gztar zvxf openssl-1.1.1b.tar.gzcd openssl-1.1.1b./config -fPIC --prefix=/usr/ --openssldir=/usr/openssl enable-shared shared zlibmake -j24make installcd /path/to/downloadswget https://www.python.org/ftp/python/3.7.2/Python-3.7.2.tgztar zvxf Python-3.7.2.tgzcd Python-3.7.2sed -i "6s/endif/else/" ./Modules/_uuidmodule.csed -i "7d" ./Modules/_uuidmodule.c./configure --prefix=/usr/local/python3.7.2 --enable-optimizations --enable-shared --enable-profiling --with-sslmake -j24make installcd /usr/binfor fname in $(ls /usr/local/python3.7.2/bin/); do ln -sf /usr/local/python3.7.2/bin/$&#123;fname&#125; ./$&#123;fname&#125;; doneln -sf pydoc3 pydocln -sf python3 pythonln -sf python3-config python-configln -sf pip3 pip]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>OpenSSL</tag>
        <tag>UUID</tag>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[到底什么是「内容与样式分离」]]></title>
    <url>%2F2019%2F03%2F18%2Fseparation-of-content-and-presentation%2F</url>
    <content type="text"><![CDATA[写这篇文章的原因有两个。 时至今日仍然有很多人在按「这一行要缩进两个字符、加粗」的方式来使用 LaTeX； 市面上关于 LaTeX 的资料大都宣称「LaTeX 是内容与样式分离的」，却不对此做进一步解释，含混而过。 我认为有必要对此稍作解释（或者是重新解释），形成一篇短文，填上这一空白。 介绍内容与样式分离在英文环境中，更多地被称作：内容与表现分离（separation of content and presentation）。这里的「表现」指的是内容呈现出来的状态，即英文：「the state of being presented」。这一原则的本意是一篇文档的实际内容和逻辑结构与这篇文档呈现给读者看到的样式是相互独立的。举个栗子。em 是 emphasis 的缩写。于是 HTML 语法中的 &lt;em&gt; 标签和 LaTeX 语法中的 \emph{} 命令，都是用来强调文档中的一部分内容使用的。通常，被强调的内容的样式是「倾斜体」。但请注意，「被强调的内容」与「倾斜体」之间的关系，既不充分也不必要。这也就是说，被强调的内容既可以是倾斜体，也可以不是倾斜体——例如可以用增加下划线或者用更高的字重（即用粗体）；另一方面，倾斜体也不一定是被强调的内容——排版诗歌时，一般就会用到倾斜体。 由此也可见得，「内容与样式分离」这一原则并非只属于 LaTeX。它是一种通用的原则，并非 LaTeX 家专属。 思维流基于这些对「内容与样式分离」的理解，我们可以看看在内容与样式分离这一原则之下，写作时的思维流应该是怎样的。思维流是我自创的概念；在我的理解中 $$ \text{思维流} = \text{思考方式} + \text{思考的内容}. $$ 这里我们以下面的内容为例，看一看思维流是怎样的。 定理 1 (勾股定理). 设直角三角形的三条边长分别是 $a$, $b$ 和 $c$，其中 $c$ 是斜边边长，则有 $a^2 + b^2 = c^2$ 成立. 内容与样式不分离对于内容与样式不分离的思维流，书写这段文字的时候大概是这样的： 加粗 定理 空格 数字 1 左括号 ( 勾股定理 右括号 ) 句点 . 空格 结束加粗 倾斜体 设直角三角形的三条边长分别是 $a$, $b$ 和 $c$，其中 $c$ 是斜边边长，则有 $a^2 + b^2 = c^2$ 成立. 结束倾斜 翻译成 LaTeX 代码大概会是这样： 1\textbf&#123;定理 1 (勾股定理).&#125; \textsl&#123;设直角三角形的三条边长分别是 $a$, $b$ 和 $c$，其中 $c$ 是斜边边长，则有 $a^2 + b^2 = c^2$ 成立.&#125; 不遵守内容与样式分离的原则时，作者的思维是非结构化的。作者思考的是「这一小块内容应该是加粗还是倾斜，是多大字号」这些问题。然后，作者在书写内容时，不得不边写边调整格式。 内容与样式分离对于内容与样式分离的思维流，书写这段文字的时候大概是这样： 这是一个 定理 它的编号是 1 它的名字是 勾股定理 它的内容是 设直角三角形的三条边长分别是 $a$, $b$ 和 $c$，其中 $c$ 是斜边边长，则有 $a^2 + b^2 = c^2$ 成立. 把它们分别放在恰当的标记中（在 LaTeX 中是定理环境） 翻译成 LaTeX 代码大概会是这样： 123\begin&#123;theorem&#125;[勾股定理]设直角三角形的三条边长分别是 $a$, $b$ 和 $c$，其中 $c$ 是斜边边长，则有 $a^2 + b^2 = c^2$ 成立.\end&#123;theorem&#125; 在内容与样式分离的原则下，作者的思维流是结构化的。具体来说，作者会思考：「这一小块内容起到了什么作用，属于什么结构」，然后相应地标记（在 LaTeX 中是命令或者控制序列）这些内容。例如，在这个例子中，作者用 theorem 环境把定理的各个方面标记起来。这种情况下，作者无需边写边调整格式，只需在撰写文档开始前或者结束后，统一定义各个标记的具体样式即可。 一个问答很多人使用 LaTeX 时往往会有这种疑惑：不是说 LaTeX 是内容与样式分离的吗？为什么为用 LaTeX 写文章的时候，还要不停去调整格式？ 对此，我的回答如下： LaTeX 是按照「内容与样式分离」的原则设计的没错，但是具体能不能遵循这一原则，还要看具体使用的人。事实上，从 Office 2003 开始，Microsoft Word 也引入了样式的功能，可以在这一原则下写作。这一点与 LaTeX 是一样的。但是有多少人会「正确地使用 Word」呢？ 如果写作的过程中会需要你不停调整格式，说明你没有完全遵循内容与样式分离的思维流。你需要做的事情是切换思维流： 遇到一段内容，比如 foo bar baz，你打算将其加粗并将字体放大。比如使用 \textbf{\LARGE foo bar baz}； 你需要做的是停下，然后去思考这一段内容究竟起到什么作用？属于什么结构？比如，你发现它是练习题的名字，接下来还会有练习题的内容。 那么你需要在导言区定义一个命令或者环境，用于标记练习题。比如定义一个带有一个参数的环境 MyExercise。此时你可以不去设计这个环境的具体格式，只需要有一个框架即可。 然后，你应该在恰当的位置使用该环境。 最后，当你文章写完之后，如果还有尚未确定样式的命令或环境，再去慢慢设计就好了。 12345678910% ...\newenvironment&#123;MyExercise&#125;[1]&#123;#1\par&#125;&#123;\par&#125;% ...\begin&#123;document&#125;% ...\begin&#123;MyExercise&#125;&#123;foo bar baz&#125;% ...\end&#123;MyExercise&#125;% ...\end&#123;document&#125;]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Content</tag>
        <tag>Presentation</tag>
        <tag>Style</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Tmux 创建 window 或 pane 之后执行命令]]></title>
    <url>%2F2019%2F03%2F07%2Fexecute-command-after-create-new-window-or-pane-in-Tmux%2F</url>
    <content type="text"><![CDATA[这是一篇简单的记录。 最近在服务器上安装 Tmux，但每次新建 window 或 pane 之后，不会加载 .bashrc 中的内容。这大概与机器上默认的 login shell 的配置有关。一瞬间，脑海里想到的有两种解法。 修改 Tmux 默认启动的 shell； 在 Tmux 创建 window 或 pane 之后执行命令，source ~/.bashrc。 前一种解法不难，但只有这单一的用处。修改 ~/.tmux.conf： 1set-option -g default-shell "/bin/bash" 后一种解法就灵活多了。具体就是在 split-window 或者 new-window 之后向 shell 发送命令。修改 ~/.tmux.conf： 123bind c new-window \; send-keys "source ~/.bashrc; clear" Enterbind - splitw -v \; send-keys "source ~/.bashrc; clear" Enterbind | splitw -h \; send-keys "source ~/.bashrc; clear" Enter 此处我将 prefix + c 绑定为产生新 window 的快捷键，而后向 shell 发送 source ~/.bashrc; clear 的命令并回车。prefix + - 和 prefox + | 则分别被设置为纵向和横向分割 window 产生新的 pane，同样会发送相关命令到 shell。如此一来，前述问题就解决了。]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Tmux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[古诗词文赏析：鹊桥仙·纤云弄巧]]></title>
    <url>%2F2019%2F03%2F03%2FQueqiaoxian-Xianyunnongqiao%2F</url>
    <content type="text"><![CDATA[作为一个纯正的理工科学生，虽然在读书时代语文成绩不好，却在这些年随着阅历的增长，慢慢地能够感受到古诗词文传递的情绪、情感、力量甚至中国古代士子的精神追求。每次读到横渠四句，也会忍不住想要「为天地立心，为生民立命，为往圣继绝学，为万世开太平」。这大概是与中国人的文化血脉分不开的什么东西——说不清道不明，但又确实存在。于是，就这么带着不少冲动，决定开启古诗词文赏析这个系列的大坑，试着要去填一填。——哪怕填不好，哪怕会贻笑大方。但我写的是我自己的理解，希望能带给读者一些以前未有过的感受。 此篇谈谈秦观的佳作：鹊桥仙·纤云弄巧。 纤云弄巧，飞星传恨，银汉迢迢暗渡。金风玉露一相逢，便胜却人间无数。柔情似水，佳期如梦，忍顾鹊桥归路。两情若是久长时，又岂在朝朝暮暮？ 背景这首鹊桥仙的背景，作为中国人大概再熟悉不过了。这是一首七夕词，说的是牛郎和织女的故事。 作为中国最著名的爱情故事——可能没有之一，牛郎和织女的故事不一定是一个悲剧，但一定是充满了遗憾色彩的故事。而遗憾，正是男女情感之间，最令人感怀的一种情绪。正因如此，在中国古代，有不少诗词曲以七夕和牛郎织女的故事为题，寄托诗词作者自己的情感。其中传唱最久远的，大概是汉乐府的一首古诗： 汉乐府·古诗十九首之一迢迢牵牛星，皎皎河汉女。纤纤擢素手，札札弄机杼。终日不成章，泣涕零如雨。河汉清且浅，相去复几许。盈盈一水间，脉脉不得语。 也许是因为牛郎织女故事中的遗憾，七夕诗词曲大多逃不开「痴男怨女」的基调。例如此处汉乐府的古诗就细致地描写了织女因相似而不成章、泣涕如雨的样子，又讲银河就那么清浅，却与情郎不得相见叙说的苦闷。 秦观的鹊桥仙却别出机杼，堪称七夕诗词之最。 赏析 纤云弄巧，飞星传恨，银汉迢迢暗渡。 上阙开头的第一句极其巧妙。 首先，牛郎织女是两颗星星。于是讲七夕的故事，肯定是晚上天空里的事情。写「纤云弄巧」，描写天上云彩的变化，就必须要「抬头看天」；写「飞星传恨」，描写一闪而逝的流行，就暗示了「夜晚」的场景。其次，牛郎织女一年一会，分开之后相会之前，肯定有数不尽的思绪要说，说不出来就变成恨。思绪万千就如同天上的云朵变换，思绪不得传达，就恨不得能如流星那样快点传达给对方。最后，「迢迢」和「暗渡」又体现了爱人相见之前的情绪。迢迢是「悄悄地」的意思：爱人相会自然是悄悄地私会，又要避开「王母」。暗渡中的「暗」字承接了「迢迢」悄悄的义项，「渡」字又承接「弄巧」、「传恨」，透出急迫的心情。 不过，上阙第一句巧妙有余，但其余不足。第一句仅仅是叙事，传达出的作者的情感态度却很少。若凭此就能成为七夕词之最，未免名不副实。我们接下来看第二句。 金风玉露一相逢，便胜却人间无数。 上阙第二句乃是一绝。这句没有七夕之哀愁，化恨为惜、化恨为喜。秋风秋露原本是平平一见的事物，但到了七夕这一天，在牛郎织女的眼里，那便是金风玉露。足以衬托出牛郎织女相见的不易。爱人之间，一年才能见一次，见到了难道不珍惜？悲了一年，难道不喜？如此难道不胜过人间万事？ 柔情似水，佳期如梦，忍顾鹊桥归路。 下阙第一句写两人相见时互诉情深，其柔情似水，又写这短暂相会的「假期」如梦一样短暂，离开时不敢看鹊桥。这似乎又回到了悲恨交织的轨道了，看起来大煞风景。要知道，描写这种情绪，再怎么也妙不过「盈盈一水间，脉脉不得语」的画面感。但是，秦观在下一句却峰回路转、神来之笔，传唱天下。 两情若是久长时，尤其在朝朝暮暮？ 人人都知道牛郎织女感情深，但这么多七夕诗词却摆脱不了怨憎的窠臼。整首词写牛郎织女：见前恨，见时喜，离别悲。而后在最后一句又看破离别苦恨难分难舍，讲「有情人不怕千山万水之隔」。这句饱含的感情至真至善，一举超越千万七夕诗词，传唱天下。]]></content>
      <categories>
        <category>Literature and Social Sciences</category>
      </categories>
      <tags>
        <tag>Poetry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[赏析谭晶在歌手 2018 上演唱的九儿]]></title>
    <url>%2F2019%2F02%2F26%2Fappreciate-and-analyze-Tan-Jing-s-Jiuer-on-Singers%2F</url>
    <content type="text"><![CDATA[动不了笔，让我再多循环几遍再说……https://www.bilibili.com/video/av21583288/]]></content>
      <categories>
        <category>Music</category>
      </categories>
      <tags>
        <tag>Tan Jing</tag>
        <tag>Jiuer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[像递归一样的函数模板调用]]></title>
    <url>%2F2019%2F02%2F19%2Frecursive-like-function-template-calling%2F</url>
    <content type="text"><![CDATA[遇到一个蛮奇葩的问题：在 C++ 中如何不用循环和递归，打印从 1 至 N 的自然数？ 想了想，用模板元编程可以解决——让编译器在编译期把该打印的东西都展开就好了。 直接上代码好了…… 123456789101112131415161718#include &lt;iostream&gt;template &lt;int N&gt;void counting(std::ostream&amp; os) &#123; counting&lt;N - 1&gt;(os); // * os &lt;&lt; N &lt;&lt; std::endl;&#125;template &lt;&gt;void counting&lt;1&gt;(std::ostream&amp; os) &#123; os &lt;&lt; 1 &lt;&lt; std::endl;&#125;int main() &#123; const int N = 10; counting&lt;N&gt;(std::cout); return 0;&#125; 这里，(*) 处有类似递归的调用。但由于 counting 是函数模板，所以 counting&lt;N&gt; 调用的 counting&lt;N - 1&gt; 并非自身，因此不是递归。 编译器在实例化 counting&lt;N&gt; 的时候，由于它调用了 counting&lt;N - 1&gt;，所以在编译期会递归地实例化下去——直到遇见全特化的 counting&lt;1&gt; 为止。这段代码利用了编译器在编译期的递归替代运行期的递归，巧妙地绕过了原始问题的限制。 类似的手段也可以运用在类模板上。在 YTL 的 traits 库当中就有这样的运用。 不过要注意，既然是递归，就有可能爆栈。编译器递归实例化的深度是有限制的。clang 3.4 的默认限制是 256 层而 gcc 8.2 的默认限制是 900 层。超过这一限制会引发编译器 Fatal error 而编译失败。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Template</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寻找不小于给定整数的最小的 2 的幂方]]></title>
    <url>%2F2019%2F02%2F14%2Ffind-smallest-power-of-2-that-is-not-less-than-a-given-integer%2F</url>
    <content type="text"><![CDATA[这是一篇简单的记录。 最近在写 YTL 的过程中遇到这样一个子问题：需要定义一个函数 uint32_t func(uint32_t num)，返回不小于 num 的最小的 2 的幂方。例如 123451 == func(1);2 == func(2);4 == func(3);4 == func(4);// …… 一开始我想了个用位运算的奇技淫巧，自我感觉还不错： 1234567uint32_t func(uint32_t num) &#123; uint32_t res = 1; while (res &lt; num) &#123; res &lt;&lt;= 1; &#125; return res;&#125; 后来一想，「不要在编译器面前装屄」，于是发现老实用 std::log2 来计算的话，效率要高出五倍多： 1234// #include &lt;cmath&gt;uint32_t func(uint32_t num) &#123; return 1 &lt;&lt; static_cast&lt;int&gt;(std::ceil(std::log2(num)));&#125; 再一想，std::ceil 本来就快，std::log2 有快速解法。那么如果把 1 &lt;&lt; foo 换成 std::pow(2.0, foo) 会怎样呢？结果发现，大概是由于 std::pow 是为浮点数运算设计的，所以没为 2 的幂方做优化，所以效率还不如位运算： 1234// #include &lt;cmath&gt;uint32_t func(uint32_t num) &#123; return std::pow(2.0, std::ceil(std::log2(num)));&#125; 以上。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为 XeLaTeX 所调用时 xDVIPDFMx 的默认参数]]></title>
    <url>%2F2019%2F02%2F12%2Fdefault-flags-for-xDVIPDFMx%2F</url>
    <content type="text"><![CDATA[去年，有人在群里提及： 在 macOS 上，同样是使用 STFangSong 字体，使用 LaTeXmk 编译出来的文档在 Windows 上查看会乱码，但使用 XeLaTeX 直接编译则正常。MWE 是：12345\documentclass&#123;ctexbook&#125;\begin&#123;document&#125;\fangsong中文\end&#123;document&#125; 具体的编译命令分别是：12latexmk -cd -f -xelatex -interaction=nonstopmode -synctex=1 --output-directory=output foo.texxelatex -interaction=nonstopmode -synctex=1 --output-directory=output foo.tex 这个问题直至近期查看了 XeLaTeX 的源码才得到了完整答案。 字体嵌入根据 Ao Zhang 的检查，latexmk-mac.pdf 当中没有如 xelatex-mac.pdf 那样嵌入字体。 由于找不到相应字体，Windows 上查看文档时，就乱码了。 驱动 xDVIPDFMxXeLaTeX 输出的文件格式是扩展 DVI（eXtended DVI, .xdv）。不过，XeLaTeX 在执行到最后时会调用驱动，将 .xdv 文件转为 .pdf 格式，并将 .xdv 文件删除。默认的驱动是 xDVIPDFMx，它与 DVIPDFMx 系出同源。 使用 LaTeXmk 编译的文档没有嵌入字体，显然与 xDVIPDFMx 有关。经检查，LaTeXmk 考虑到多次编译时，只有最后一次编译需要真正输出 PDF 文件，故而在调用 XeLaTeX 时加上了 -no-pdf 选项，同时在最后一次调用 XeLaTeX 之后去调用 xDVIPDFMx。大致可以理解为 LaTeXmk 会按如下方式执行命令： 123456xelatex -no-pdf [other-options] foo.texbibtex foomakeindex fooxelatex -no-pdf [other-options] foo.texxelatex -no-pdf [other-options] foo.texxdvipdfmx foo 问题出在最后调用 xDVIPDFMx 的时候。若要嵌入字体，应当加上 -E 选项。但是默认情况下，LaTeXmk 没加上这一选项。所以，默认情况下，由 LaTeXmk 编译出来的 PDF 文档不会嵌入字体。具体到我们的例子中，latexmk-mac.pdf 在 Windows 上显示为乱码。 XeLaTeX 调用 xDVIPDFMx 时的默认参数至此，「在 macOS 上使用 LaTeXmk 编译的文档在 Windows 上乱码」这一问题已经可以解释。但是问题的另一半，即「为什么在 macOS 上使用 XeLaTeX 编译的文档在 Windows 上不会乱码」这一问题还没回答。显然，这仍与 xDVIPDFMx 的调用参数有关。 经查，XeLaTeX 在指定输出驱动为 xDVIPDFMx 时的 C 代码为： 1const char *outputdriver = "xdvipdfmx -q -E"; /* default to portable xdvipdfmx driver */ 可见，调用时添加了 -q 和 -E 两个参数。其中 -q 表示静默模式，即 xDVIPDFMx 不会输出任何回显信息；-E 表示忽略字体版权标记而总是将字体嵌入输出文件。 如此一来，问题的另一半也得到了合理解释。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Drivers</tag>
        <tag>xDVIPDFMx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTeX 插图时对文件扩展名的处理]]></title>
    <url>%2F2019%2F01%2F27%2Fkeep-single-dot-in-image-filename-for-LaTeX%2F</url>
    <content type="text"><![CDATA[这是一篇简单的记录，缘起于有人在 XeLaTeX 中插入 .png 格式的图片，但提示 no boundingbox。这与我的认知不同：这一错误通常只在 LaTeX 方式编译时才会出现，而且加上 bmpsize 宏包结合 DVIPDFMx 驱动就能解决。但这次问题出现在 XeLaTeX 下，我感到很奇怪，也引起了我的兴趣。 MWE最小工作示例如下： test.tex123456% compile with XeLaTeX\documentclass&#123;article&#125;\usepackage&#123;graphicx&#125;\begin&#123;document&#125; \includegraphics&#123;foo.bar.png&#125; % reports error (no boundingbox)\end&#123;document&#125; 报错如下： 12345678910! LaTeX Error: Cannot determine size of graphic in foo.bar.png (no BoundingBox).See the LaTeX manual or LaTeX Companion for explanation.Type H &lt;return&gt; for immediate help. ...l.5 \includegraphics&#123;foo.bar.png&#125; % reports error (no boundingbox)? 分析如前所述，这就很奇怪了。我第一反应是图片本身有什么问题。但多方检查都没发现有什么问题。考虑到同样的代码在 pdfLaTeX 下编译理应也能通过并顺利输出，故执行命令 pdflatex test.tex，并观察现象。 123456789! LaTeX Error: Unknown graphics extension: .bar.png.See the LaTeX manual or LaTeX Companion for explanation.Type H &lt;return&gt; for immediate help. ...l.5 \includegraphics&#123;foo.bar.png&#125; % reports error (no boundingbox)? 出乎意料，本该顺利通过的代码，在 pdfLaTeX 下也报错了。不过，这次报错的问题和使用 XeLaTeX 时还不太一样。pdfLaTeX 提示说不认识名为 .bar.png 的图片扩展名。 这给了我新的提示。显然 pdfLaTeX 在处理图片时，以第一个 . 作为分割，之后的部分都是扩展名；而后根据图片文件的扩展名去处理。推测 XeLaTeX 也会做类似的操作，只是细节上有所不同，XeLaTeX 没有在遇见 .bar.png 这个扩展名的第一时间报错，而是延迟到了计算边界框尺寸时发现没有匹配该扩展名（.bar.png）时才报错。如果确实如此，那么在 graphicx.sty 当中应该有所体现。追溯到 graphicx.sty 依赖的 graphics.sty 当中： 123456\def\Ginclude@graphics#1&#123;% \begingroup \let\input@path\Ginput@path \filename@parse&#123;#1&#125;% \ifx\filename@ext\relax% ... 显然，\filename@parse 是在解析图片文件的文件名。这是一个定义在 LaTeX2e 中的底层命令，根据其文档，它会将解析结果保存在 \filename@area, \filename@base, \filename@ext 三个宏当中。在 \filename@parse 的定义中，解析扩展名是通过利用 TeX 的宏定义式的技巧来实现的： 1\def\filename@simple#1.#2 在调用 \filename@simple 时，会将遇到的第一个 . 之前的内容当做 #1 而把 . 之后的内容当做 #2。这个 #2 最后被保存在了 \filename@ext 当中，作为文件扩展名。 解决办法了解了问题的根源，解决起来就容易了。 最简单的绕过办法，是保持图片文件的文件名当中只有一个句点，用于区分文件名及其扩展名。这样 TeX 就不会被误导了。例如，将 MWE 中的文件名从 foo.bar.png 改为 foo_bar.png，再尝试于 LaTeX 当中插入。 如果不想修改文件名，那么可以利用 TeX 的分组，将真实的文件名包裹在一对分组花括号当中。也就是写成形如这样的代码 {foo.bar}.png。这样，在 \filename@simple 处理参数的过程中，由于 foo.bar 被放在一个分组当中，整个被当成是一个 token，因而不会被打散，也因而能解析到正确的扩展名 png。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Graphicx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 C++ 中移除序列中连续重复的特定值]]></title>
    <url>%2F2019%2F01%2F27%2Fremove-consecutive-duplicates-in-Cxx%2F</url>
    <content type="text"><![CDATA[最近在写 YTL 中的字符串相关辅助函数。实现到 split 函数时，希望能够实现类似 Python 当中的 str.split 方法的功能。 If sep is not specified or is None, a different splitting algorithm is applied: runs of consecutive whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the string has leading or trailing whitespace.——https://docs.python.org/3/library/stdtypes.html#str.split 也就是说，在最基本的 split 的基础上，要添加两个功能： 删除输入字符串首尾的空白； 将字符串中的连续分隔符当成一个分隔符看待。 前一个功能很好实现。将空白符保存在 const char* trim_chars = &quot; \t\n\r\v\f&quot; 当中，然后使用 std::string::find_first_not_of 以及 std::string::find_last_not_of 即可找到有效内容的起止位置，最后再 std::string::erase 一下就好了。 后一个功能也不复杂。但要写得优雅——最好是能利用上标准库的设施——就不那么容易了。 std::unique 的基本用法std::unique 是定义在 algorithm 头文件内的容器算法。它有两种基本形式： 1234template&lt; class ForwardIt &gt;ForwardIt unique( ForwardIt first, ForwardIt last );template&lt; class ForwardIt, class BinaryPredicate &gt;ForwardIt unique( ForwardIt first, ForwardIt last, BinaryPredicate p ); 其中，第一种形式是第二种形式的特例，它等价于 BinaryPredicate p 为连续两元素相等性判断时的第二种形式： 12345678template&lt; class ForwardIt, class BinaryPredicate = std::function&lt;bool(const typename std::iterator_traits&lt;ForwardIt&gt;::value_type&amp;, const typename std::iterator_traits&lt;ForwardIt&gt;::value_type&amp;)&gt;ForwardIt unique( ForwardIt first, ForwardIt last, BinaryPredicate p = [](const typename std::iterator_traits&lt;ForwardIt&gt;::value_type&amp; lhs, const typename std::iterator_traits&lt;ForwardIt&gt;::value_type&amp; rhs) &#123; return lhs == rhs; &#125;); 这也就是说，第一种形式的 std::unique 会找到每个连续重复的区间，而后保留这些区间的首个元素，最后返回新序列逻辑上的尾后迭代器。例如，aabbccaa 经过 std::unique 处理之后得到： 12abca???? ↑ 这里用箭头标出的位置，即是 std::unique 的返回值所指向的位置。需要注意的是，经过 std::unique 处理之后，容器的实际大小没有发生改变，甚至逻辑尾后迭代器到容器实际尾后迭代器之间的左闭右开区间内的迭代器仍然是可解引用的（dereferenceable）。但这部分区间内的元素的值是不确定的。因此，在使用 std::unqiue 之后，往往会调用容器的 erase 函数成员，删除逻辑尾后迭代器开始的所有元素。例如： 12345// #include &lt;string&gt;// #include &lt;algorithm&gt;std::string source("aabbccaa");source.erase(std::unique(source.begin(), source.end()), source.end());std::cout &lt;&lt; source &lt;&lt; std::endl; // expect result: abca 只对特定内容进行 std::unique 操作回到最开始的问题。我们需要的功能，是针对分隔符 sep 进行操作，将连续出现的 sep 压缩成一个。std::unique 的默认行为则不然，它会将所有连续出现的元素都压缩成一个——不光是 sep。为此，我们需要实现自己的 BinaryPredicate。首先，由于我们要指定具体需要被 std::unique 压缩的元素，我们必然要将其作为函数参数传入函数。于是我们有以下实现： 12345// #include &lt;functional&gt;template &lt;typename T&gt;bool AreConsecutiveElements(const T&amp; target, const T&amp; lhs, const T&amp; rhs) &#123; return (lhs == rhs) and (lhs == target);&#125; std::unique 要求一个二元谓词（BinaryPredicate），但此处我们实现的是三元谓词。于是，好在 target 总是应当预先给出的，所以我们可以利用 std::bind 将 target 绑定在 AreConsecutiveElements 的第一个参数上，产生一个二元谓词。 123456789// #include &lt;functional&gt;// using namespace std::placeholders;// #include &lt;string&gt;// #include &lt;algorithm&gt;const char target = 'b'auto binp = std::bind(AreConsecutiveElements, target, _1, _2);std::string source("aabbccaa");source.erase(std::unique(source.begin(), source.end(), binp), source.end());std::cout &lt;&lt; source &lt;&lt; std::endl; // expect result: aabccaa 这里，我们将 &#39;b&#39; 作为压缩目标，并将其与 AreConsecutiveElements 绑定在一起，产生一个新的二元谓词。最终输出期待的结果。 附：std::unique 的一个可能实现1234567891011121314template&lt;class ForwardIt, class BinaryPredicate&gt;ForwardIt unique(ForwardIt first, ForwardIt last, BinaryPredicate p) &#123; if (first == last) &#123; return last; &#125; ForwardIt result = first; while (++first != last) &#123; if (!p(*result, *first) &amp;&amp; ++result != first) &#123; *result = std::move(*first); &#125; &#125; return ++result;&#125;]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Consecutive</tag>
        <tag>Duplicate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 LaTeX 中实现缩印效果]]></title>
    <url>%2F2019%2F01%2F25%2Freduced-print-in-LaTeX%2F</url>
    <content type="text"><![CDATA[近日大概重拾了一点对 LaTeX 的兴趣，遇见这样一个问题：如何在 LaTeX 中实现缩印效果（即，将两页或更多页排版在一页纸上），并且实现水印效果的页码？ 缩印以朴素的办法实现缩印效果并不困难。例如，可以先以 LaTeX 正常输出文档，再以 pdfpages 宏包将生成的文档载入进来排版。不过，这样的做法扩展性太差，并且需要至少编译两份文档——一份是原始文档，一份是缩印框架文档。 更有技巧的办法，需要深入到 TeX 构建页面输出的过程中去。基本上来说，我们需要让 TeX 按往常一样去构建页面，但是在 TeX 准备将页面输出（shipout）时我们需要插入一个钩子。这个钩子做两件事情： 打断输出过程； 将整个页面内容保存在一个盒子中备用。 我们将保存在盒子里的页面称为逻辑页面（logic pages）。而后，当保存的页面足够多时，或没有更多页面需要保存时，将这些盒子的内容成比例缩小并列印在页面上。我们将最终输出的页面称之为物理页面。 pgfpages 就是这样做的。它是 PGF 宏集的一部分，因而使用 texdoc pgf 可以看到它的文档（Section 89）。 首先我们从一个简单的例子开始，其效果见这里。 demo-2on1-landscape.tex12345678\documentclass&#123;article&#125;\usepackage&#123;pgfpages&#125;\pgfpagesuselayout&#123;2 on 1&#125;[a4paper, landscape, border shrink = 5mm]\begin&#123;document&#125;This text is shown on the left.\clearpageThis text is shown on the right.\end&#123;document&#125; 这里，\pgfpagesuselayout 命令是实现缩印效果的核心命令。参数 2 on 1 的含义不言自明。其后的可选参数：a4paper 表示物理页的尺寸是标准 A4 纸；landscape 表示要将物理页横过来——毕竟是二合一缩印，这很合理；border shink = 5mm 表示被缩印的逻辑页会被继续缩小，并在每个逻辑页的上下左右四周保留宽度为 5mm 的边框。 类似地，你也可以缩印 beamer 幻灯片。不过，由于 beamer 幻灯片的逻辑页本就是横着的，所以此处不需要在加 landscape 参数了。 相应的，4 on 1 需要加，6 on 1 和 8 on 1 不需要加，以及 16 on 1 又需要加。——32 on 1 是不存在的…… demo-2on1.tex1234567891011\documentclass&#123;beamer&#125;\usepackage&#123;pgfpages&#125;\pgfpagesuselayout&#123;2 on 1&#125;[a4paper, border shrink=5mm]\begin&#123;document&#125;\begin&#123;frame&#125;This text is shown at the top.\end&#123;frame&#125;\begin&#123;frame&#125;This text is shown at the bottom.\end&#123;frame&#125;\end&#123;document&#125; 页码在当前问题中，TeX 默认的页码机制实际上是作用在各个逻辑页上的。但显然，我们可能会想要为物理页编上页码。这里有两个问题需要解决： 物理页的页码如何确定？ 缩印排版，有效内容字体很小且密集，如何保证物理页页码可见且不影响有效内容的阅读？ 对于第一个问题，有两种思路。 一是读取逻辑页页码 page 计数器，然后按 x on 1 的比例做除法，得出物理页的页码。不过，这种方式是有前提的。具体来说，它要求 TeX 的逻辑页页码功能不在缩印的情况下失效，并且它要求 TeX 能正确计算整数除法（向上取整）。总得来说，这是一种快而脏的解法，不推荐。 如果十年以后，你以快而脏的方式做什么事的时候，能想象我在你的肩后看着，然后对自己说：「Dijkstra 不会希望这样的。」那么对我来说，这就和永生一样了。—— Edsger Wybe Dijkstra 另一种思路则更加直接。既然页码本质是由计数器实现的，这一计数器随页面输出而自增，而 pgfpages 影响的正是 TeX 页面输出的逻辑，那么 pgfpages 内必然有什么地方可以下钩子来自增该计数器。 123456789\newcommand\pgfshipoutphysicalpage&#123;% \ifnum\pgf@logicalpages&gt;0\relax% \pgfpages@buildshipoutbox% \pgfpages@shipoutshipoutbox% \pgfpages@performcopying% \global\pgfphysicalpageemptytrue% \global\pgf@holdingphysicalpagefalse% \fi%&#125; 通过翻阅 pgfpages.sty 的源码，我们不难发现有以上代码和物理页输出有关。可以说，PGF 宏集的代码风格相当好，一眼就能看明白代码在做什么。显然，\pgfpages@shipoutshipoutbox 是在输出物理页，而它之前的 \pgfpages@buildshipoutbox 就是将逻辑页构建成物理页的过程了。因此，我们需要在 \pgfpages@buildshipoutbox 当中下钩子；此时我们又要用到老朋友 etoolbox 当中的 \patchcmd 了。 1234567891011% require packages: pgfpages, etoolbox\newcounter&#123;physicalpage&#125;\makeatletter\patchcmd&#123;\pgfpages@buildshipoutbox&#125;&#123;% \pgfsys@beginpicture&#125;&#123;% \pgfsys@beginpicture \stepcounter&#123;physicalpage&#125;%&#125;&#123;&#125;&#123;&#125;\makeatother 第二个问题可能有多种解决思路。我偏好于在页面中央以水印的形式加一个大大的页码。四年多以前，我利用 TikZ 实现了水印功能。TikZ 也是 PGF 宏集的一部分，用在这里正好。于是，我们的代码变为 1234567891011121314151617181920212223% require packages: pgfpages, etoolbox, xcolor, tikz\newcommand&#123;\boxedcontent&#125;[5]&#123;\parbox[b][\paperheight]&#123;\paperwidth&#125;&#123;% \vfill% \centering% \tikz[remember picture, overlay]% \node [rotate = #1, scale = #2] at (#3)% &#123;\textcolor&#123;#4&#125;&#123;#5&#125;&#125;; \vfill&#125;&#125;\newcounter&#123;physicalpage&#125;\makeatletter\patchcmd&#123;\pgfpages@buildshipoutbox&#125;&#123;% \pgfsys@beginpicture&#125;&#123;% \pgfsys@beginpicture \stepcounter&#123;physicalpage&#125;% \setbox0\vbox&#123;\makebox[0pt][c]&#123;\boxedcontent&#123;0&#125;&#123;30&#125;&#123;current page.center&#125;&#123;gray!80!cyan!30&#125;&#123;\arabic&#123;physicalpage&#125;&#125;&#125;&#125;% \pgfsys@beginscope \pgflowlevel&#123;\pgftransformshift&#123;\pgfpoint&#123;0\pgfphysicalwidth&#125;&#123;0\pgfphysicalheight&#125;&#125;&#125;% \pgfsys@hbox0% \pgfsys@endscope&#125;&#123;&#125;&#123;&#125;\makeatother 实际效果将以上代码综合起来，我做了一个简单的 demo。 demo-reduced-print.tex1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950\documentclass[12pt]&#123;article&#125;\usepackage&#123;mwe&#125;\pagestyle&#123;empty&#125;\usepackage&#123;multicol&#125;\setlength&#123;\columnseprule&#125;&#123;0.4pt&#125;\usepackage&#123;geometry&#125;\geometry&#123;a4paper, scale = 1, includeall, margin = 0pt, marginparwidth = 0pt, marginparsep = 0pt, headheight = 0pt, headsep = 0pt, footskip = 0pt&#125;\usepackage&#123;pgfpages&#125;\pgfpagesuselayout&#123;4 on 1&#125;[a4paper, border shrink = 1.5mm]\usepackage&#123;tikz&#125;\usepackage&#123;xcolor&#125;\usepackage&#123;eso-pic&#125;\usepackage&#123;etoolbox&#125;\newcommand&#123;\boxedcontent&#125;[5]&#123;\parbox[b][\paperheight]&#123;\paperwidth&#125;&#123;% \vfill% \centering% \tikz[remember picture, overlay]% \node [rotate = #1, scale = #2] at (#3)% &#123;\textcolor&#123;#4&#125;&#123;#5&#125;&#125;; \vfill&#125;&#125;\newcommand&#123;\watermark&#125;[3]&#123;\AddToShipoutPictureBG&#123;% \boxedcontent&#123;#1&#125;&#123;#2&#125;&#123;current page.center&#125;&#123;gray!80!cyan!30&#125;&#123;#3&#125;&#125;&#125;\newcounter&#123;physicalpage&#125;\makeatletter\patchcmd&#123;\pgfpages@buildshipoutbox&#125;&#123;% \pgfsys@beginpicture&#125;&#123;% \pgfsys@beginpicture \stepcounter&#123;physicalpage&#125;% \setbox0\vbox&#123;\makebox[0pt][c]&#123;\boxedcontent&#123;0&#125;&#123;30&#125;&#123;current page.center&#125;&#123;gray!80!cyan!30&#125;&#123;\arabic&#123;physicalpage&#125;&#125;&#125;&#125;% \pgfsys@beginscope \pgflowlevel&#123;\pgftransformshift&#123;\pgfpoint&#123;0\pgfphysicalwidth&#125;&#123;0\pgfphysicalheight&#125;&#125;&#125;% \pgfsys@hbox0% \pgfsys@endscope&#125;&#123;&#125;&#123;&#125;\makeatother\begin&#123;document&#125;\begin&#123;multicols&#125;&#123;3&#125; \lipsum[1-79]\end&#123;multicols&#125;\end&#123;document&#125;]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>PGF</tag>
        <tag>Reduce Print</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决升级 Mojave 后 g++ 找不到头文件的问题]]></title>
    <url>%2F2019%2F01%2F18%2Ffix-missing-headers-fatal-errors-after-upgraded-to-Mojave%2F</url>
    <content type="text"><![CDATA[Mac 升级 Mojave (10.14) 之后，尝试编译以前编译通过的 C++ 项目，g++-6 提示找不到各种头文件。例如有如下报错。 1234./third_party/catch.hpp:69:33: fatal error: TargetConditionals.h: No such file or directory # include &lt;TargetConditionals.h&gt; ^compilation terminated. 经查，这是因为 macOS 在升级过程中，移除了过时的开发者工具。（不得不说这种无声移除的设计非常傻屄）解决的办法也很简单，重新安装 Command Line Tools 及其头文件包即可。 12xcode-select --installopen /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg 参考：https://forums.developer.apple.com/thread/104296]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>macOS</tag>
        <tag>Mojave</tag>
        <tag>XCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经济机器是如何运行的]]></title>
    <url>%2F2019%2F01%2F17%2Fhow-does-economic-machine-work%2F</url>
    <content type="text"><![CDATA[本文是对经济机器是怎样运行的的整理和再创作。感谢原作者 Ray Dalio。 经济虽然可能看起来复杂，但是其实是以简单和机械的方式运行的。经济有几个简单的零部件和无数次重复的简单交易组成，这些交易首先是由人的天性所驱动，因而形成三股主要的经济动力：一，生产率的提高；二，短期债务周期；三，长期债务周期。 下面我们谈一下这三股动力，并介绍如何把它们组合在一起，得出一个良好的模型，便于我们跟踪经济走势并理解当前正在发生的事情。 交易我们先来说经济中最简单的部分：交易！ 经济不过是无数交易的总和，而交易是一件非常简单的事情。交易时刻都在发生，你每次买东西都是进行一笔交易。在每次交易中，买方使用货币或信用向卖方交换商品服务或金融资产。信用在使用时和货币一样，因此把花费的货币和信用加在一起，就可以得出支出总额。支出总额是经济的驱动力。如果用支出金额除以销量就得出价格。就是这么简单，这就是交易。交易是经济机器的最基本零件，所有的经济周期和动力都是交易造成的。所以理解了交易就理解了整个经济。 一个市场由买卖同一种商品的所有买方和卖方组成；例如小麦市场，汽车市场股票市场和千百万种其他市场。经济，就是由所有市场内的全部交易构成。把全部市场的总支出和销量加在一起，就得到了了解经济运行所需要的全部信息。就这么简单。 个人、企业、银行和政府都在以上述方式从事交易，用货币和信用交换商品服务和金融资产。政府是最大的买方和卖方，而政府由两个组成部分：收税和花钱的中央政府和中央银行。央行控制的经济中的货币和信贷数量，因此不同于其他买方和卖方。央行通过影响利率和发行更多货币来实行这种控制。我们在下面会看到，正因如此，央行在信贷流通当中发挥着重要作用。 信贷请诸位注意信贷。信贷是经济中最重要的组成部分，但也许是人们最不了解的部分。它之所以最重要，是因为它是经济中最大且最为变幻莫测的一部分。 贷款人和借款人已在市场中进行交易的买方和卖方没有两样。通常贷款人希望自己的钱生出更多的钱，而借款人则想购买当前无法负担的某种东西——比如房子汽车或是进行投资，例如开办企业。借贷可以同时满足贷款人和借款人的需要。 借款人保证偿还借款，成为本金并支付额外的款额成为利息。利率高时借贷就会减少，因为贷款变得昂贵；当利率低时借贷就会增加，因为贷款变的便宜。如果借款人保证偿还债务，而且贷款人相信这一承诺，信贷就产生了。任何两个人都可以通过协定凭空创造出信贷。信贷看似简单实则复杂，因为信贷还有其他名称。信贷一旦产生，立即成为债务。债务是贷款人的资产，同时是借款人的负债。等到借款人今后偿还了贷款并支付了利息，这些资产和负债将消失，交易得以完成。 那么为什么信贷如此重要？这是因为借款人一旦获得信贷，便可以增加自己的支出。不要忘记支出是经济的驱动力——这是因为一个人的支出，是另一个人的收入。想想看，你每花一块钱另一个人就挣了一块钱，而你每挣一块钱必定有别人花了一块钱，所以你花的越多别人挣得就越多！如果某人的收入增加，其信用度就会提高，贷款人就更愿意把钱借给他。信用良好的借款人具备两个条件，偿还能力和抵押物收入。债务比率高，借款人就具备偿还能力。如果无法偿还，借款人还可以用有价值可以出售的资产作为抵押物，这样贷款人可以放心的把钱借给他们。所以收入增加使得借贷也增加，从而能够增加支出。由于一个人的支出是另一个人的收入，这将导致借贷进一步增加，并不断循环。这一自我驱动的模式导致经济增长，也正是因为如此，才产生了经济周期。 经济周期在一项交易中，为了获得某样东西，你必须付出另一样东西，长期来看你得到多少，取决于你生产多少。我们的知识随时间而逐渐增多，知识的积累会提高我们的生活水平，我们将此称为生产率的提高。一个善于创新和勤奋的人将比那些自满和懒惰的人更快地提高生产率和生活水平，但在短期内不一定体现出来！生产率在长期内最关键，但信贷在短期内最重要。这是因为生产率的提高不会剧烈波动，因此不是经济起伏的一个重要动力。但是债务是这种动力，因为我们能够通过借债让消费超过产出！但是在还债时，人们不得不让消费低于产出。债务量的波动有两大周期，其中一个周期持续大约五年至八年，另一个持续大约 75 年至 100 年。大部分人虽然能够感受到波动，但由于离波动太近，每天每周都身临其境，通常并不认为这是周期。我们将考查这三股主要动力，并观察它们如何相互作用，以及它们在日常经济中的表现。 周期的产生如上所述，经济的上下起伏不是取决于人们多么善于创新或勤奋工作，而是主要看信贷的总量。我们先想象一个没有信贷的经济运行，在这样的经济运行中，增加支出的唯一办法是增加收入，因此需要提高生产率和工作量。提高生产率是经济增长的唯一途径。由于我的支出是另一个人的收入，当我或者另一个人提高生产率的时候，经济就会增长。我们如果观察各种交易加以总结，就会发现一条类似于生产力增长轨迹的渐进线。 但是由于我们借债，于是产生了周期，原因并不是任何法规，而是人的天性和信贷的运作方式！借债不过是提前消费，为了购买现在买不起的东西，你的支出必然超过收入。因此你需要借钱，实质上是向未来的自己借钱。你给自己设定了一个未来的时间，到那个时候你的支出必须少于收入，以便偿还债务。 这样马上就形成了一个周期。通常一旦你借钱就制造了一个周期。对于个人是这样，对于整个经济运行也是这样。这就是为什么必须理解信贷，因为信贷触发了一系列机械和可以预料的将在未来发生的事件，这就是信贷不同于货币的地方！完成交易需要使用货币，当你在酒吧用现金买一瓶啤酒时，交易立即完成。但是如果你用信用来买一瓶啤酒，比如赊账，你相当于承诺今后为这瓶啤酒付钱！你和酒吧一起创造了一笔资产和一笔负债，你们凭空制造出了信贷，只有在你今后清偿了这笔赊账之后，上述资产和负债才会消失，债务才会还清，交易才会了结。 现实生活中大部分所谓的钱实际上是信贷。美国国内的信贷总额大约为 50 万亿美元，而货币总额只有大约 3 万亿美元，不要忘记在没有信贷的经济运行中，增加支出的唯一办法是增加生产。但是在有信贷的经济运行中，还可以通过借债来增加支出。因此有信贷的经济运行能增加支出，使得收入的增长速度在短期内超过生产率的增长，但在长期内并非如此。但是请不要误解我的意思，信贷不一定是坏事，只是会导致周期性变化。信贷如果造成超过偿还能力的过度消费就是不良信贷;但是现在如果高效率地分配资源和产生收入，让你能偿还债务就是良性信贷。例如如果你借钱买一台大彩电，电视机不会带来任何收入，但是需要你偿还债务；但是你如果借钱买一台拖拉机，用它来收获更多的庄稼，赚更多的钱，你就能够偿还债务，提高生活水平。 在有现代的经济运行中，我们可以跟踪各种交易，观察信贷如何带来经济增长。我举一个例子，假设你每年挣 10 万美元，没有任何债务，你有不错的信用可以借 1 万美元。例如用信用卡借。因此你每年可以花 11 万美元，即使你的收入只有 10 万美元。由于你的支出是别人的收入，另一个人因此挣了 11 万美元。这个挣了 11 万美元的人，如果没有任何债务，可以借 1.1 万美元。他可以消费 12.1 万美元，即使他的年收入只有 11 万美元。由于他的支出是另一个人的收入，而我们通过跟踪各种交易，可以看到这个过程，不断自我强化。 短期债务周期但不要忘记借债形成周期，周期会上升，最终也会下降。下面我们谈谈短期债务周期。随着经济活动的增加，出现了扩张，这是短期债务周期的第一阶段。支出继续增加，价格开始上涨，这里导致支出增加的是信贷，而信贷可以即刻凭空产生。如果支出和收入的增长速度超过所出售的商品的生产速度，价格就会上涨。我们把价格的上涨称为通货膨胀。央行不希望通货膨胀过高，因为这会导致许多问题。央行在看到价格上涨时就会提高利率。随着利率的上升，有能力借钱的人会减少，同时现有的债务成本也会上升，就等于你每个月的信用卡还款额会增加。由于人们减少借债、还款额度增长，剩下来用于支出的资金将减少，因此支出速度放慢。而由于一个人的支出是另一个人的收入，环环相扣，人们的收入将下降。由于支出减少，价格将下跌，我们称之为通货紧缩。经济活动减少，经济便进入衰退。如果衰退过于严重，而且通货膨胀不再成为问题，央行将降低利率，使经济活动重新加速。随着利率降低，偿债成本下降，借债和支出增加，出现另一次经济扩张，可见经济像一部机器一样运行。在短期债务周期中限制支出的唯一因素是贷款人和借款人的贷款和借款意愿。 长期债务周期如果信贷易于获得，经济就会扩张。如果信贷不易获得，经济就会衰退。请注意这个周期主要由央行控制。短期债务周期通常持续 5-8 年，在几十年里不断重复。但是请注意在每个周期的低谷和高峰后，经济增长和债务都超过前一个周期。为什么会这样？这是人促成的。人具有借更多钱和花更多钱的倾向，而不喜欢偿还债务。这是人的天性。因此在长期内债务增加的速度超过收入，从而形成长期债务周期。尽管人们的债务增加，但贷款人会提供更宽松的信贷条件。 这是为什么？这是因为大家都以为形势一片大好，人们仅注意最近出现的情况。最近的情况是什么？收入一直在增加，资产价值不断上升，股票市场欣欣向荣，现在是繁荣时期——用借来的钱购买商品服务和金融资产很划算。当人们过度借贷消费使泡沫便产生了。因此尽管债务一直增加，但收入也以相进的速度增加，从而抵消了债务！我们把债务与收入比率称为债务负担。只要收入继续上升，债务负担就可以承受。与此同时，资产价值迅猛上升，人们大量借钱来购买资产，因为投资促使资产价格日益升高，人们感觉自己很富有。因此尽管积累了大量债务，收入和资产价值的上升，帮助借贷人在长期内保持良好的信用度。但是这种情况显然无法永久持续下去，也确实没有持续下去。几十年来债务负担缓慢增加，使偿贷成本越来越高，到了一定的时候，偿债成本的增加速度超过收入，迫使人们削减支出。由于一个人的支出是另一个人的收入，收入开始下降。人们的信用因此降低，致使借贷减少，偿债成本继续增加，使得支出进一步减少，周期开始逆转，这时到达长期债务的顶峰，债务负担变得过重。 美国欧洲和世界上很多其他地区在 2008 年即发生了这一情况，日本在 1989 年和美国在 1929 年因同样原因发生了这一情况。现在经济进入去杠杆化时期，在去杠杆化过程中，人们削减支出、收入下降、信贷消失、资产价格下跌、银行发生挤兑、股票市场暴跌、社会紧张加剧，整个过程开始下滑并形成恶性循环。随着收入下降和偿债成本增加，借款人倍感拮据。随着信用消失信贷枯竭，借款人再也无法借到足够的钱来偿还债务。借款人竭力填补这个窟窿，不得不在支出下降的同时出售资产。出售热潮使市场充斥待售资产，这时股票市场暴跌，不动产市场一蹶不振，银行陷入困境。随着资产价格下跌，借款人能够提供抵押物的价值下降，这进一步降低了借款人的信用，人们觉得自己很穷。信贷迅速消失，支出减少，收入减少，财富减少，信贷减少借债等等随之减少，这是一个恶性循环。 它看起来与衰退相似，但不同之处是无法通过降低利率来挽回局面。在衰退中可以通过降低利率来刺激借贷，但是在去杠杆化过程中，由于利率已经很低接近零，从而丧失刺激功能，因此降低利率不起作用。美国国内的利率在 1930 年代的去杠杆化期间下降到零，在 2008 年也是如此。衰退与去杠杆化之间的差别在于，在去杠杆化过程中，借款人的债务负担变得过重，无法通过降低利率来减轻。贷款人意识到债务过于庞大，根本无法足额偿还。借款人失去了偿债能力，其抵押物失去价值，他们觉得受到债务的极大伤害，不想再借入更多债务。贷款人停止放贷，借款人停止借贷，整个经济体与个人一样都失去了信用度。 去杠杆化的手段那么应该怎样应对去杠杆化？问题在于债务负担过重，必须减轻。为此可以采用四种办法：一，个人企业和政府削减支出；二，通过债务违约和重组来减少债务；三，财富再分配，将财富从富人转给穷人；四，最后央行发行更多货币。这四种办法被用于现代历史上的每一个去杠杆化过程。 削减支出，共克时艰通常第一个措施是削减支出，我们刚才看到个人企业银行和政府都勒紧裤带削减支出，从而能够减少债务。我们经常把这称为紧缩。当借款人不再借入新的债务，并开始减少旧债务的时候，你会以为债务负担会减轻。但情况正好相反，支出减少了，而一个人的支出是另一个人的收入，这就导致收入下降，收入下降速度超过还债的速度，因此债务负担实际上更为沉重。我们已经看到这种削减支出的做法引起通货紧缩，令人痛苦，企业不得不削减成本，这意味着工作机会减少，失业率上升，这导致下一个步骤：必须减少债务。 很多借款人无法偿还贷款，而借款人的债务是贷款人的资产。如果借款人不偿还银行贷款，人们会担心银行无法返还其存款，因此纷纷从银行取出存款，银行受到挤兑，而个人企业和银行出现债务违约。这种严重的经济收缩就是萧条。萧条的一个主要特征是人们发现他们原来以为属于自己的财富中有很大一部分实际上并不存在。我们再次以酒吧为例，当你用赊账的办法买一瓶啤酒时，是在承诺今后偿还酒吧的赊账，你的承诺成为酒吧的一项资产。但是如果你不兑现承诺，不偿还酒吧的赊账，实际上是债务违约，那么酒吧的这项资产实际上一钱不值，它实际上是消失了。 债务重组很多贷款人不希望自己的资产消失，同意债务重组。债务重组意味着贷款人得到的还款减少或偿还期延长，或利率低于当初商定的水平。无论如何合约被破坏，结果是债务减少，贷款人希望多少收回一些贷款，这强过血本无归。债务重组让债务消失，但由于它导致收入和资产价值以更快的速度消失，债务负担继续日趋沉重。削减债务与减少支出一样，令人痛苦和导致通货紧缩。所有这些都对中央政府产生影响。因为收入降低和就业减少意味着政府的税收减少。 财富再分配与此同时由于失业率上升，中央政府需要增加支出：很多失业者储蓄不足，需要政府的财务支持；此外政府制定刺激计划和增加支出，以弥补经济活动的减少。在去杠杆化过程中，政府的预算赤字飙升，原因是政府的支出超过税收。你在新闻中所听到的预算赤字正是这种情况。政府必须加税或者举债，以填补赤字。但是在收入下降和很多人失业的时候，应该向谁融资呢？由于政府需要更多的钱，而且大量财富集中在少数人手中，政府自然而然地增加对富人的征税，以帮助经济中的财富再分配，把财富从富人那里，转给穷人。 发行货币，量化宽松正在困苦当中的穷人开始怨恨富人，承受经济疲弱资产贬值和增税压力的富人开始怨恨穷人。如果萧条继续下去就会爆发社会动荡！不仅国家内部的紧张加剧，而且国家之间也会这样，债务国和债权国之间尤其如此。这种局势可以导致政治变革，有时是极端的变革，1930 年代这种局势导致希特勒掌权，欧洲爆发战争和美国的大萧条。要求采取行动来结束萧条的压力越来越大，不要忘记人们心目中的货币，实际上大部分是信贷！因此信贷一旦消失，人们的钱会不够花，人们迫切需要钱，而你一定记得谁可以发行货币，中央银行可以。 央行已经把利率降到接近零的水平，现在不得不发行更多货币。发行货币与削减支出、减少债务和财富再分配不同，会引起通货膨胀和刺激经济。中央银行不可避免的凭空发行更多货币，并使用这些货币来购买金融资产和政府债券。这种情况发生在美国大萧条期间，并于 2008 年再次爆发。当时美国的中央银行及联邦储备委员会增加发行了 2 万多亿美元，世界各地能够这样做的其他央行也增发了很多货币。央行通过用这些货币购买金融资产，帮助推升了资产价格，从而提高了人们的信用。但是这仅仅有助于那些拥有金融资产的人。你看央行可以发行货币，但是只能购买金融资产。而另一方面，中央政府可以购买商品和服务，可以向人民送钱，但是无法印钞票。因此为了刺激经济，央行和政府必须合作。央行通过购买政府债券，其实是把钱借给政府，使其能够运行赤字预算，并通过刺激计划和失业救济金来增加购买商品和服务的支出。这增加了人们的收入，也增加了政府的债务。但是这个办法将降低经济中的总债务负担，这是一个风险很大的时刻。 有人问发行货币是否会加剧通货膨胀，如果增发的货币抵消信贷的降幅，就不会引发通货膨胀。不要忘记重要的是支出，每一块钱的支出，无论支付的是货币还是信用，对价格的影响都是一样的。央行可以通过增加货币发行量来弥补消失的信贷。央行为了扭转局面，不仅需要推动收入的增长，而且需要让收入的增长率超过所积累债务的利率，这是什么意思？主要的意思是收入一定要比债务增长的快。例如我们假设有个国家正在经历去杠杆化，其债务收入比率是100%，这意味着债务量相当于整个国家一年的收入。假设这些债务的利率是2%，如果债务以2%的利率速度增加，而收入的增长率仅有大约1%，那么债务负担永远不会减轻，必须发行更多货币，使收入增长率超过利率。然而发行货币太容易了，而且比其他办法受欢迎，因此这个办法可能易于被滥用。关键是避免像1920年代去杠杆化的德国那样发行过多的货币，从而导致恶性通货膨胀。 小结决策者需要平衡考虑降低债务负担的四种办法，必须平衡兼顾通货紧缩的办法和通货膨胀的办法，以便保持稳定。如果取成适当的平衡，就可以带来和谐的去杠杆化。所以说去杠杆化可以是痛苦的，也可以是和谐的！怎样才能实现和谐的去杠杆化？尽管去杠杆化是艰难的，但以尽可能好的办法来处理艰难的局势却是一件好事，这比杠杆化阶段大量举债产生过度失衡现象要好得多。在和谐的去杠杆化过程中，债务收入比率下降，经济实际上是正增长；同时通货膨胀并不是一个问题，这是通过适当的平衡所取得的。为了取得适当的平衡，需要结合削减支出、减少债务转移财富和发行货币的办法，以保持经济和社会稳定。 如果决策层取得适当的平衡，去杠杆化过程就不会那样激烈，经济增长速度缓慢，但债务负担会下降，这就是和谐的去杠杆化，当收入上升的时候，借款人的信用度提高，借款人一旦显得更有信用，贷款人就会开始恢复贷款，债务负担终于开始下降，人们可以借到钱就可以增加消费经济终于开始恢复增长长期债务周期，从而进入通货再膨胀阶段去杠杆化过程如果处理不当会非常可怕，但如果处理得当，最终将解决问题！为了使债务负担下降和经济活动恢复正常，大约需要十年或更长的时间，因此有失去的十年这种说法。综上所述，经济当然要比这个模式复杂一点。然而把短期债务周期长期债务周期和生产率增长轨迹结合起来分析，我们会得到一个不错的模式，可以看清我们在过去和当前的处境，以及未来可能的发展方向。 忠告最后我希望大家学到三条经验法则。第一，不要让债务的增长速度超过收入，因为债务负担最终将把你压垮。第二，不要让收入的增长速度超过生产率，因为这最终将使你失去竞争力。第三，尽一切努力提高生产率，因为生产率在长期内起着最关键的作用。这就是我给大家，也是给决策者们的简单的建议。大家也许会吃惊地发现，大多数人包括大多数决策者都没有对此予以足够的重视。这个模式对我很有用，希望他也将对你们有用。谢谢大家。]]></content>
      <categories>
        <category>Economics and Investment</category>
      </categories>
      <tags>
        <tag>Ray Dalio</tag>
        <tag>Economics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[管理 macOS 系统上的启动项]]></title>
    <url>%2F2019%2F01%2F16%2Fmanage-daemons-and-agents-on-macOS%2F</url>
    <content type="text"><![CDATA[最近在 Mac 上安装了一些软件。重启后发现这些软件会随开机启动。我不喜欢这样，所以想禁止这些启动项。 在中文网络搜索，大多数内容都是在系统偏好设置中，在账户和群组里管理「登录项」。但是目标软件没有出现在登录项的列表中。为此，我不得不在英文网络上搜索，找到了 Apple 关于开发者的一些文档，最终解决了问题。 这篇记录一下如何管理 macOS 系统上的启动项。 守护进程与用户代理启动项的专业称呼是守护进程（Daemon）。守护进程是计算机系统中，运行在后台的程序。在 *nix 系统中，守护进程通常没有父进程（让自己成为孤儿进程，前作中有相关讨论）。一般来说，守护进程完成监听而后作出响应的任务。举例来说，杀毒软件的守护进程监听到有新下载的文件，就给出响应——启动杀毒软件对新下载的文件进行安全扫描。 通常来说，守护进程是系统启动及内核运行后在系统初始化阶段启动的进程。对于 macOS 来说，还有名为用户代理（User Agent）的守护进程类似物。与守护进程相同，用户代理也能实现上述监听而后作出响应的功能。不过，与守护进程不同的是，用户代理是在用户登录系统时启动的，而不是在系统初始化阶段启动的。不过，就本文而言，守护进程与用户代理是一回事，因此除有特殊注明外，一律以守护进程指代，不做区分。 launchd在 macOS 上，Apple 推荐用 launchd 来启动守护进程与用户代理。具体来说，launchd 在系统启动及内和运行后，在系统初始化阶段启动守护进程，而在用户登录是启动用户代理。流程大致如下： 读入属性列表文件（property list files） 注册守护进程所需的套接字（sockets）和文件描述符（file descriptors） 启动要求在任何情况下持续运行的守护进程 对于按需启动的守护进程，在 launchd 收到相应请求时，启动对应的守护进程 当关机（对于守护进程）或用户登出（对于用户代理）时，launchd 对这些守护进程发出 SIGTERM 信号 其中，对于守护进程，其属性列表文件在以下目录中： /System/Library/LaunchDaemons/ /Library/LaunchDaemons/ 对于用户代理，其属性列表文件在以下目录中： /System/Library/LaunchAgents /Library/LaunchAgents ~/Library/LaunchAgents 这里，由于 launchd 提前为所有守护进程注册好了套接字及文件描述符，因而守护进程可以在任何时候按需启动。如果 launchd 监听到系统中有其他进程向某一守护进程发出请求，但该守护进程尚未启动；则发出请求的进程会被暂停，直到 luanchd 启动相应的守护进程并对请求作出响应为止。此外，若在一段时间内守护进程没有收到任何请求，则守护进程可以自行退出。launchd 会记录这种退出，并在将来有请求到来时再启动相应的守护进程。 属性列表文件（property list files）上一节提到，launchd 会去相应目录读取属性列表文件，然后根据属性列表文件中的参数，注册套接字和文件描述符等资源，以及控制守护进程的运行策略。因此，接下来的关键就是这类属性列表文件。 属性列表文件的英文是 Property List files，对应的文件名后缀是 .plist。说是属性列表文件，其实本质上就是 XML 文件。以下是一个示例文件。 123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;&lt;plist version="1.0"&gt;&lt;dict&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;com.example.hello&lt;/string&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;hello&lt;/string&gt; &lt;string&gt;world&lt;/string&gt; &lt;/array&gt; &lt;key&gt;KeepAlive&lt;/key&gt; &lt;true/&gt;&lt;/dict&gt;&lt;/plist&gt; Apple 在文档里给出了守护进程属性列表文件必选和推荐的字段，这里翻译如下。 关键字 说明 Label 必填；包含用于 launchd 识别守护进程的唯一字符串标识符。 ProgramArguments 必填；包含用于 launchd 启动守护进程时使用的参数。 inetdCompatibility 表示该守护进程对于每个传入的连接启用相互独立的实例。该关键字会让 launchd 像 inetd 那样运作；具体来说，launchd 会将与每个传入连接的客户端建立好的套接字传给相互独立的守护进程实例。 KeepAlive 该关键字用于指定相应的守护进程是按需启动还是要一直启动着。Apple 推荐实现按需启动的守护进程。 此外，Apple 在技术笔记中还提及了其他两个关键字，这两个关键字也可能影响守护进程的运行策略（当然还有其他一些关键字可能影响，但主要还有这两个）： RunAtLoad：在属性列表文件加载时启动守护进程； SuccessfulExit：与 KeepAlive 联合使用。当 SuccessfulExit = true 时表示若进程正常退出（Exit at 0），则 launchd 应当尝试将其重启；当 SuccessfulExit = false 时表示若进程异常退出，则 launchd 应当尝试将其重启。 因此我们可以构建一些场景： 预期的行为 相应的属性配置 完全地按需启动 KeepAlive = false; RunAtLoad = false 在属性列表文件加载时启动，而后按需启动 KeepAlive = false; RunAtLoad = true 在守护进程异常退出之前，按需启动 KeepAlive = { SuccessfulExit = false }; RunAtLoad = false 在守护进程正常退出之前，按需启动 KeepAlive = { SuccessfulExit = true }; RunAtLoad = false 管理启动项有了这些知识，管理 macOS 上的启动项就很容易了。你需要做的就是在上述 5 个目录下，找到相应程序的属性列表文件，而后按你的意图修改即可。当然，有些属性列表文件需要使用 root 权限来修改。有必要的话，你需要在终端（Terminal.app）当中使用 sudo vim /path/to/your.plist 来修改目标文件。 唯有一点需要注意，在做任何修改之前做好备份。]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>macOS</tag>
        <tag>Daemons</tag>
        <tag>Agents</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 中虚函数的声明与定义]]></title>
    <url>%2F2019%2F01%2F13%2Fvirtual-member-function-declaration-and-definition-in-Cxx%2F</url>
    <content type="text"><![CDATA[多态（Polymorphism）是面向对象程序设计最重要的特性之一。C++ 通过结合虚函数和指针（引用）来实现多态。作为 C++ 用户，你当然知道如何将虚函数和指针（引用）结合起来以实现多态。但在这些概念之间，可能还存在些许模糊地带。例如说，你有思考过下面这个问题吗？ 纯虚函数能有实现吗？ 此篇讨论 C++ 中虚函数的声明与定义。 直接回答问题能！纯虚函数可以有定义，并且有时我们必须给出纯虚函数的定义。不过有一点需要注意：和其它成员函数不同，纯虚函数的定义必须实现在类定义之外。（见下例） 12345678910111213141516171819struct Abstract &#123; virtual void f() = 0; // pure virtual ~Abstract() &#123; // f(); // undefined behavior Abstract::f(); // OK: non-virtual call &#125;&#125;;// definition of the pure virtual functionvoid Abstract::f() &#123; std::cout &lt;&lt; "A::f()\n"; &#125;struct Concrete : Abstract &#123; void f() override &#123; Abstract::f(); // OK: calls pure virtual function &#125; ~Concrete() &#123; f(); // OK: calls Concrete::f() &#125;&#125;; 虚成员函数我们首先来看看关于虚成员函数生命和定义的一些规则。根据 C++ 标准，虚成员函数应在类定义中生命，且必须有定义（实现）。注意，在类定义外实现虚成员函数时，不能再加 virtual 关键字。 12345678910111213struct Foo &#123; virtual void foo() &#123; // declare and define at the same time, inside the class definition. std::cout &lt;&lt; "Foo::foo()" &lt;&lt; std::endl; &#125;&#125;;struct Bar &#123; virtual void bar();&#125;;void Bar::bar() &#123; std::cout &lt;&lt; "Bar::bar()" &lt;&lt; std::endl;&#125; 不过，C++ 标准没有要求必须在编译期对这条规则进行诊断。也就是说，如果没有给出虚成员函数的实现，编译器可能不会报错。不过，链接器可能会提示引用了未定义的符号这样的错误。 纯虚成员函数纯虚函数使类成为「抽象类」。具体来说，我们不能创建抽象类类型的对象，也不能将其作为函数的参数类型、返回类型，也不能作为显式类型转换的目标类型。 因此，我们永远不会有机会调用抽象类中的徐成员函数。另一方面，纯虚函数必然会在派生类中被复写。因此，在大多数情况下，纯虚函数的实现是没什么用处的。也因此，我们可以将一个成员函数声明为纯虚的，但是不给它的定义。 也就是说，对于纯虚函数，我们可以： 在类定义中声明纯虚函数，并且不给实现； 在类定义中声明纯虚函数，并且在类定义之外给出实现。 不过，这里有两处例外： 对于纯虚析构函数，必须提供实现。 派生类中的成员函数可以调用抽象类中的纯虚函数，但必须加上抽象类的限定符（Base::some_pure_virtual_function()）。 在这两种情况下，提供纯虚函数的定义是有意义的——也必须提供。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Virtual Member Function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 个税新法计征算法及 Excel 个税计算器]]></title>
    <url>%2F2019%2F01%2F04%2FExcel-Personal-Income-Tax-Calculator%2F</url>
    <content type="text"><![CDATA[2018 年颁布的个税新法于 2019 年 1 月 1 日起施行。个税新法的个税计征办法，相较个税旧法的改变主要有以下几个： 计征周期发生变化：旧法按月计征工资和薪金的个税；新法按年计征工资和薪金的个税，按月预缴。 起征点发生变化：旧法按月计征个税的起征点是 ¥3,500.00；新法按月预缴个税的起征点是 ¥5,000.00。 计算应纳税所得额时，增加专项附加扣除：新法在子女教育、继续教育、大病医疗、（首套）住房贷款利息、住房租金、赡养老人等六个方面新增了专项附加扣除。 此外，按个税新法，个税旧法中全年一次性奖金收入（年终奖即属此类）的优惠将被取消，全年一次性奖金收入也将纳入全年累计收入进行个税计征。不过，按财政部税务总局发布的通知（关于个人所得税法修改后有关优惠政策衔接问题的通知，财税（2018）164 号），个税旧法中的优惠政策将在一定程度上延续至 2022 年 1 月 1 日。 对于我等升斗小民，赚点钱真的不容易。个税改革的细节又很多，想想就脑壳疼。为此，我将个税新法的计征办法归纳总结了一下，形成此文。此外，我制作了一个 Excel 表格（后附），大家可据此自行计算。若有不正确的地方，欢迎指正。 月收入应纳税所得额计征个税的第一步，是计算当月应纳税所得额。它的公式如下： $$\text{月应纳税所得额} = \text{当月税前收入} - \text{起征点} - \text{三险一金（五险一金个人缴存部分）减除} - \text{专项附加扣除}.$$ 举例来说，某人某月的税前收入是 ¥30,000.00，三险一金减除额是 ¥4,500.00，个税新法下专项附加扣除总额是 ¥2,000.00，则其该月应纳税所得额是 $$ \begin{aligned} \text{月应纳税所得额} &amp;{}= \text{当月税前收入} - \text{起征点} - \text{三险一金（五险一金个人缴存部分）减除} - \text{专项附加扣除}\\ &amp;{} = ¥30,000.00 - ¥5,000.00 - ¥4,500.00 - ¥2,000.00 \\ &amp;{} = ¥18,500.00 \end{aligned} $$ 当年累计应纳税所得额计征个税的第二步，是计算当年累计应纳税所得额。它的公式如下： $$ \text{当年累计应纳税所得额}_k = \sum_{i = 1}^{k} \text{月应纳税所得额}_i. $$ 续上例。当年一月、二月，该人税前月收入是 ¥30,000.00，三月起，他的税前月收入增长到 ¥35,000.00。则其一月、二月的月应纳税所得额是 ¥18,500.00，三月起的月应纳税所得额是 ¥23,500.00。于是，截至四月，他当年的累计应纳税所得额是 $$ \begin{aligned} \text{当年累计应纳税所得额}_4 &amp;{}= \sum_{i = 1}^{4} \text{月应纳税所得额}_i \\ &amp;{}= ¥18,500.00 + ¥18,500.00 + ¥23,500.00 + ¥23,500.00 \\ &amp;{}= ¥84,000.00 \end{aligned} $$ 当年累计应预缴税额计征个税的第三步，是计算当年累计应预缴税额。它的公式如下： $$ \text{当年累计应预缴税额}_k = \text{当年累计应纳税所得额}_k * \text{适用税率} - \text{适用速算扣除数}. $$ 其中，适用税率和适用速算扣除数取决于当年累计应纳税所得额。对应关系如下表。 级数 累计预扣预缴应纳税所得额 预扣率（%） 速算扣除数 1 不超过 36000 元的部分 3 0 2 超过 36000 元至 144000 元的部分 10 2520 3 超过 144000 元至 300000 元的部分 20 16920 4 超过 300000 元至 420000 元的部分 25 31920 5 超过 420000 元至 660000 元的部分 30 52920 6 超过 660000 元至 960000 元的部分 35 85920 7 超过 960000 元的部分 45 181920 续上例。截至四月，他当年的累计应预缴税额是： $$ \begin{aligned} \text{当年累计应预缴税额}_4 &amp;{}= \text{当年累计应纳税所得额}_4 * \text{适用税率} - \text{适用速算扣除数} \\ &amp;{}= ¥84,000.00 * 10\% - ¥2,520.00 \\ &amp;{}= ¥8,230.00 \end{aligned} $$ 当月应预缴税额计征个税的第四步，是计算当月应预缴税额。它的公式如下： $$ \text{月应预缴税额}_k = \text{当年累计应预缴税额}_k - \text{当年累计实际已预缴税额}_{k - 1}. $$ 因此，续上例，该人前 4 个月每个月的应预缴税额如下表。 月份 当年累计应预缴税额 当年累计实际已预缴税额 当月应预缴税额 一月 ¥555.00 ¥0 ¥555.00 二月 ¥1,180.00 ¥555.00 ¥625.00 三月 ¥3,530.00 ¥1,180.00 ¥2,350.00 四月 ¥5,880.00 ¥3,530.00 ¥2,350.00 由此可见，在年应纳税收入累计升高到新的级数时，从该月开始，月应预缴税额会相应升高。 当月税后收入计征个税完成后，我们就能计算实际税后收入了。它的公式如下： $$ \text{月税后收入}_k = \text{月税前收入}_k - \text{三险一金（五险一金个人缴存部分）}_k - \text{月应预缴税额}_k. $$ 因此，续上例，该人前 4 个月每个月的税后收入如下表。 月份 税前收入 三险一金（五险一金个人缴存部分） 月应预缴税额 月税后收入 一月 ¥30,000.00 ¥4,500.00 ¥555.00 ¥24,945.00 二月 ¥30,000.00 ¥4,500.00 ¥625.00 ¥24,875.00 三月 ¥35,000.00 ¥4,500.00 ¥2,350.00 ¥23,150.00 四月 ¥35,000.00 ¥4,500.00 ¥2,350.00 ¥23,150.00 由此可见，在年应纳税收入累计升高到新的级数时，从该月开始，由于月应预缴税额会相应升高，实际月税后收入会相应下降。 全年一次性奖金按上述「通知」 居民个人取得全年一次性奖金，符合《国家税务总局关于调整个人取得全年一次性奖金等计算征收个人所得税方法问题的通知》（国税发〔2005〕9号）规定的，在2021年12月31日前，不并入当年综合所得，以全年一次性奖金收入除以12个月得到的数额，按照本通知所附按月换算后的综合所得税率表（以下简称月度税率表），确定适用税率和速算扣除数，单独计算纳税。$$ \text{应纳税额}_k = \text{全年一次性奖金收入} * \text{适用税率} - \text{速算扣除数}. $$ 其中月度税率表如下。 级数 全月应纳税所得额 税率（%） 速算扣除数 1 不超过 3000 元的 3 0 2 超过 3000 元至 12000 元的部分 10 210 3 超过 12000 元至 25000 元的部分 20 1410 4 超过 25000 元至 35000 元的部分 25 2660 5 超过 35000 元至 55000 元的部分 30 4410 6 超过 55000 元至 80000 元的部分 35 7160 7 超过 80000 元的部分 45 1516 举例来说，某人获得全年一次性奖金 ¥30,000.00，则其适用税率 3% 和速算扣除数 ¥0.00。因此，它的全年一次性奖金应纳税额是 ¥900.00，税后奖金收入 ¥29,100.00。 Excel 版个税计算器按上述个税计征逻辑，我制作了一个 Excel 版个税计算器。你可以在这里下载。 由于每个人的税前收入和专项附加扣除不一致，因此这两列需要按实际情况填写。此外，每个人缴存的三险一金基数及缴存比例也不一样，因此这一列也需要按实际情况填写。填写完成后，Excel 表格会自动计算出每个月应预缴的个人所得税额及实际税后收入。]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Tax</tag>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决 Windows 7 上的图标异常]]></title>
    <url>%2F2018%2F12%2F28%2Ffixing-icon-missing-on-Windows-7%2F</url>
    <content type="text"><![CDATA[话说 Windows 的小毛病是真的多。配置电脑一段时间之后，Micorsoft Word 的图标就变成了白板（如下图）。这篇文章解释这个现象是哪里出了问题，以及要如何解决。 上图即是又遇见的奇怪的图标——咦，为什么要说又。看见它就很不爽对吧？ Windows 对不同文件类型/文件的图标是有一个图标缓存的。这个缓存的文件名叫做 IconCache.db。如果缓存中存在这个文件类型/文件的图标，就会以缓存中的图标来标示文件类型/文件；如果缓存中不存在，则从原始路径去读取图标资源。 问题就处在这个 IconCache.db 上。它可能被各种奇怪的操作修改、破坏。如果它被修改破坏了，那么我们看到的图标就会有异常。 解决问题的办法也很简单——删掉缓存，让 Windows 重建缓存即可。以下是解决这一问题的批处理文件内容。你可以将它保存为 refresh_thumbnail_cache.bat 或者直接从这里下载，而后双击执行。执行时，Windows 资源管理器会被杀死，而后重启。因此，你可能会观察到计算机会「闪」几下。这是正常现象，无需担心。 123456@echo offtaskkill /f /im explorer.execd /d %userprofile%\AppData\Localdel IconCache.db /astart explorer.exeecho done.]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Windows 7</tag>
        <tag>Windows</tag>
        <tag>BAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[禁止 Tmux 自动修改 window 的名字]]></title>
    <url>%2F2018%2F12%2F13%2Fdisallow-tmux-to-rename-window%2F</url>
    <content type="text"><![CDATA[使用 Tmux 也有很长时间了，基础配置一直没动，用起来也很顺手。今天在新的服务器上编译安装 Tmux 之后，使用了一段时间发现 Tmux 的 window 名字一直随着执行命令而不断变化。哪怕是强行设置了 window name 也不管用。经过一番搜索，找到解决方案。 只需将如下代码，贴近 ~/.tmux.conf 即可。 1set-option -g allow-rename off]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Tmux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈代码的模块化]]></title>
    <url>%2F2018%2F12%2F12%2Fwriting-modular-codes%2F</url>
    <content type="text"><![CDATA[我们总是说要写模块化的代码。但是到底什么是模块化的代码？怎样写模块化的代码？这两个问题不解决，模块化就不接地气、无法落地。 这篇谈谈我对代码模块化的一些思考。 模块化是什么?代码分割可能在很多人的理解中，要「模块化」就要分割代码。于是他们会把项目分成很多个文件，甚至分割成很多个版本仓库（repository）。但实际上，这种分割只是手段，而不是目的。如果把这种手段错误地当做是目的，那可能不会带来什么好处，反而会带来很多麻烦。 例如说，我曾经参与过一个项目的开发。对于运行在网络通信框架上的业务逻辑插件，人们为之写了一个基类，命名为 PluginBase。而后，人们把它单独拉出去，作为一个单独的版本仓库。在实际编写插件时，再通过二进制依赖的方式，将 PluginBase 的共享对象（.so）动态链接到进程中去。这种做法其实完全没必要，就属于典型的错把手段当目的。PluginBase 与 PluginFooBar 在逻辑上的结合是很紧密的——基类和派生类，因此将它们分开不合适。打个比方，在开发 PluginFooBar 时，我们可能发现之前在设计 PluginBase 时不够完善，需要再添加一个接口。此时，我们就需要： 修改 PluginBase 的代码； 编译之后发版； 在 PluginFooBar 的版本仓库中修改依赖配置； 编译 PluginFooBar； 将新版本的 libPluginBase.so 和 libPluginFooBar.so 都拷贝到执行环境。 而如果我们能发现 PluginBase 和 PluginFooBar 在逻辑上结合很紧密，而不把它们分开在两个版本仓库中，这样的修改就简单多了： 修改 PluginBase 的代码； 编译； 将新版本的 libPlugins.so 拷贝到执行环境。 按逻辑分块如此我们可以发现，所谓模块化，分割是手段而非目的。那么究竟要怎么模块化呢？上面的讨论已经提到了一点——跟逻辑相关。这里继续讨论。 要搞清楚模块化，首先要搞清楚什么是模块。模块其实是一个逻辑层面的定义。它是说：如果一个东西，它有定义良好的输入和输出，那么它就是一个模块。再详细说一点，这里所谓的「定义良好」有两个方面需要定义：一方面指输入和输出的格式，一方面指输入和输出的含义。 因此，只要一个东西的行为，在逻辑上满足这个阐述，那么它就是一个模块。例如一块电路板是一个模块；因为它接受固定格式的输入，根据固定逻辑产出输出。又例如一个定义良好的函数是一个模块；因为它接受固定格式的输入（函数参数），根据固定逻辑产出输出。 回到上一小节举的例子。PluginBase 在逻辑上并没有良好的输入和输出——它是基类，通常实际功能由子类完成。因此，强行把它提出去单独管理是不合适的。 怎样写模块化的代码？具体到写代码时，模块化这个命题主要就落在如何设计函数上了——毕竟，在代码的世界里，函数是最小的模块单元。这里提炼一些实践中的经验。 单一职责设计函数时，最好让函数的职责足够简单，只有一个。 为什么这么说呢？我们可以考虑一下，如果一个函数既可以做这个，又可以做那个，这种函数需要怎样设计？显然，函数需要根据某些变量的值，或者某种条件，来选择走哪个逻辑分支。比如可能有如下代码： 1234567891011// bool flag;void foo() &#123; if (flag == true) &#123; bar_a(); baz_a(); &#125; else &#123; bar_b(); baz_b(); &#125; qux();&#125; 变量 flag 用来表示影响函数行为的外部因素。函数 foo 内，根据 flag 取值的不同，会走不同的分支。这种设计看起来不错。比如，有人可能会认为它节省了代码行数，写起来爽快。但是实际上这个函数的行为某种程度上就不是良定义的了——它取决于一个外部变量。试想，一个刚接手这段代码的人，调用 foo 函数，TA 就必须不断去追踪 flag 变量代表的外部环境。如果你觉得追踪某个变量还算好的话，可以试想一下如果这个变量代表「打印机有没有连上」这种在代码中完全不可控的外部因素会怎样。 对于这种代码，就不如把两种不同情形分开，写成这样： 1234567891011121314151617181920// bool flag;void foo_a() &#123; bar_a(); baz_a(); quz();&#125;void foo_b() &#123; bar_b(); baz_b(); quz();&#125;/*if (flag == true) &#123; foo_a();&#125; else &#123; foo_b();&#125;*/ 如此一来，foo_a 和 foo_b 的职责都很明确，接手维护的人再也不会疑惑函数的行为了。 输入决定（input dominated）设计函数时，尽可能使函数的行为完全由其输入参数决定。特别地，尽可能不要让函数的行为受到全局变量、类的成员变量的取值影响。某种意义上，这和「可重入」的概念比较像。 这一点应该比较好理解。如果一个函数的行为取决于入参之外的因素，那么相当于这个函数在参数之外还有其他输入。显然，这和「输入良定义」是矛盾的。特别地，如果一个类的成员函数的行为依赖类的成员变量的取值，那么使用这个成员函数时，我们就不得不胆战心惊，逐个推演其他的成员函数有可能在某些情况下修改这些成员变量的值。 自我限制这部分完全是经验之谈。 写代码的时候，可以做一些自我限制。例如说：不写超过 50 行的代码；不超过 5 行的通用功能也要拉出去做工具函数。 人总是爱偷懒的。因此，写代码写 high 的时候，往往就会忘记很多最佳实践。因此，给自己做一些自我限制，有一些强迫症还是很有必要的。据我自己的经验，超过 50 行的代码，往往就会把逻辑写得像面条一样，同时输入和输出的定义就不那么明朗了。因此 50 行虽然没有什么别的意义，但是仅仅将它作为是一个强迫症式的自我限制也是不错的。当然，你可以根据你的习惯，调整这个限制的大小。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Modular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTeXUG 的 LOGO]]></title>
    <url>%2F2018%2F12%2F11%2Flogo-of-CTeXUG%2F</url>
    <content type="text"><![CDATA[手残党设计的 LOGO。XD CTeXUG 用到的的字体是「Quicksand」，OVERFLOW 用到的的字体是「Coda」。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>LOGO</tag>
        <tag>CTeXUG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 中的 mklink 命令]]></title>
    <url>%2F2018%2F12%2F10%2Fmklink-in-Windows%2F</url>
    <content type="text"><![CDATA[日常使用 Linux 的用户，想必对 ln 命令不会陌生。使用该命令，可以在 Linux 系统上创建针对文件或目录的符号链接，实现一个文件（目录）两个名字的功能。 Windows 上也有一个类似功能的命令，它是 mklink。不过它的行为和 ln 不太一样。此外，Windows 上还有「快捷方式」这种东西，也能实现一个文件（目录）两个名字的功能。但它和 mklink 建立的符号链接不一样，它是 Windows 上特有的一种文件格式，专门用来指向其它文件（目录）。 此篇讲讲 Windows 上的 mklink 命令。 速查表 不带参数 /D 参数 /H 参数 J 参数 中文名称 符号链接 符号链接 硬链接 联接 英文名称 Symbolic Link Symbolic Link Hard Link Junction 作用对象 文件 目录 文件 目录 是否一定指向路径 否 否 否 是 dir 类型 SYMLINK SYMLINK 无特殊显示 JUNCTION 资源管理器类型 .symlink 文件夹 无特殊显示 文件夹 资源管理器图标 快捷方式 文件夹快捷方式 无特殊显示 文件夹快捷方式 修改同步 是 是 是 是 删除同步 否 否 否 否 彻底删除源 删除源路径 删除源路径 删除所有硬链接 删除源路径 引用错误报错 无 引用了一个不可用的位置 - 引用了一个不可用的位置 详细说明mklink 命令需要使用管理员权限，在 cmd.exe 中运行。在 Windows 7 中，可以在开始菜单中搜索 cmd，而后右键搜索结果，选择「以管理员身份运行」。 执行 mklink 命令，不带任何 flags 及 arguments，可以查看它的语法说明（官方网页版说明）。 123456789101112D:\test&gt;mklink创建符号链接。MKLINK [[/D] | [/H] | [/J]] Link Target /D 创建目录符号链接。默认为文件 符号链接。 /H 创建硬链接，而不是符号链接。 /J 创建目录联接。 Link 指定新的符号链接名称。 Target 指定新链接引用的路径 (相对或绝对)。 不带参数不带参数的 mklink 命令可以为文件创建符号链接。当源路径是目录时，不带参数的 mklink 不会报错，但是实际产生的符号链接不可用。在 cmd 中使用 dir 列出当前目录的文件列表时，符号链接显示为 SYMLINK，同时在文件名后以方括号表示链接的源地址。 1234567891011121314151617181920D:\test&gt;mklink source_link.txt source.txt为 source_link.txt &lt;&lt;===&gt;&gt; source.txt 创建的符号链接D:\test&gt;mklink source_link source为 source_link &lt;&lt;===&gt;&gt; source 创建的符号链接D:\test&gt;dir 驱动器 D 中的卷是 Data 卷的序列号是 22FA-F6AC D:\test 的目录2018/12/10 16:18 &lt;DIR&gt; .2018/12/10 16:18 &lt;DIR&gt; ..2018/12/10 16:17 &lt;DIR&gt; source2018/12/10 16:17 0 source.txt2018/12/10 16:18 &lt;SYMLINK&gt; source_link [source]2018/12/10 16:18 &lt;SYMLINK&gt; source_link.txt [source.txt] 3 个文件 0 字节 3 个目录 241,024,643,072 可用字节 不带参数的 mklink 创建的符号链接，展现在 Windows 资源管理器中的样式与普通的快捷方式没有两样——在图标的左下角有一个小箭头。不过，在资源管理器中，符号链接的文件类型是 .symlink。对于源路径是目录的情况，图标显示为一块白板。 删除不带参数的 mklink 创建的符号链接，不会影响源路径指向的文件。删除不带参数的 mklink 创建的符号链接指向的源文件，访问符号链接时无法访问。 参数 /D参数 /D 版本的 mklink 命令可以为目录创建符号链接。当源路径是文件时，不带参数的 mklink 不会报错，但是实际产生的符号链接不可用；访问时会提示「目录名称无效」。在 cmd 中使用 dir 列出当前目录的文件列表时，符号链接显示为 SYMLINK，同时在文件名后以方括号表示链接的源地址。 1234567891011121314151617181920D:\test&gt;mklink /D source_link source为 source_link &lt;&lt;===&gt;&gt; source 创建的符号链接D:\test&gt;mklink /D source_link.txt source.txt为 source_link.txt &lt;&lt;===&gt;&gt; source.txt 创建的符号链接D:\test&gt;dir 驱动器 D 中的卷是 Data 卷的序列号是 22FA-F6AC D:\test 的目录2018/12/10 16:27 &lt;DIR&gt; .2018/12/10 16:27 &lt;DIR&gt; ..2018/12/10 16:17 &lt;DIR&gt; source2018/12/10 16:17 0 source.txt2018/12/10 16:27 &lt;SYMLINKD&gt; source_link [source]2018/12/10 16:27 &lt;SYMLINKD&gt; source_link.txt [source.txt] 1 个文件 0 字节 5 个目录 241,024,618,496 可用字节 参数 /D 版本的 mklink 命令创建的符号链接，展现在 Windows 资源管理器中的样式与普通的快捷方式没有两样——在图标的左下角有一个小箭头。不过，在资源管理器中，符号链接的文件类型是「文件夹」。对于源路径是文件的情况，图标显示为空目录的样式。 删除参数 /D 版本的 mklink 命令创建的符号链接，不会影响源路径指向的文件。删除参数 /D 版本的 mklink 命令创建的符号链接指向的源文件，访问符号链接时无法访问；提示「引用了一个不可用的位置」。 参数 /H参数 /H 版本的 mklink 命令可以为文件创建硬链接。当源路径是目录时，不带参数的 mklink 会报错「拒绝访问」。在 cmd 中使用 dir 列出当前目录的文件列表时，硬链接的样式与正常文件没什么不同。 12345678910111213141516171819D:\test&gt;mklink /H source_link.txt source.txt为 source_link.txt &lt;&lt;===&gt;&gt; source.txt 创建了硬链接D:\test&gt;mklink /H source_link source拒绝访问。D:\test&gt;dir 驱动器 D 中的卷是 Data 卷的序列号是 22FA-F6AC D:\test 的目录2018/12/10 16:38 &lt;DIR&gt; .2018/12/10 16:38 &lt;DIR&gt; ..2018/12/10 16:35 &lt;DIR&gt; source2018/12/10 16:17 0 source.txt2018/12/10 16:17 0 source_link.txt 2 个文件 0 字节 3 个目录 241,024,421,888 可用字节 参数 /H 版本的 mklink 命令创建的硬链接，展现在 Windows 资源管理器中的样式与源文件一致。 删除参数 /H 版本的 mklink 命令创建的硬链接，不会影响源路径指向的文件。删除参数 /H 版本的 mklink 命令创建的硬链接指向的源文件，也不会影响硬链接。只有当一个文件的所有硬链接都被删除时，文件才被真正删除。 参数 /J参数 /J 版本的 mklink 命令可以为目录创建联接。当源路径是文件时，不带参数的 mklink 不会报错，但是实际产生的联接不可用；访问时会提示「目录名称无效」。在 cmd 中使用 dir 列出当前目录的文件列表时，联接显示为 JUNCTION，同时在文件名后以方括号表示链接的源地址的绝对路径。 1234567891011121314151617181920D:\test&gt;mklink /J source_link.txt source.txt为 source_link.txt &lt;&lt;===&gt;&gt; source.txt 创建的联接D:\test&gt;mklink /J source_link source为 source_link &lt;&lt;===&gt;&gt; source 创建的联接D:\test&gt;dir 驱动器 D 中的卷是 Data 卷的序列号是 22FA-F6AC D:\test 的目录2018/12/10 16:43 &lt;DIR&gt; .2018/12/10 16:43 &lt;DIR&gt; ..2018/12/10 16:35 &lt;DIR&gt; source2018/12/10 16:41 2 source.txt2018/12/10 16:43 &lt;JUNCTION&gt; source_link [D:\test\source]2018/12/10 16:43 &lt;JUNCTION&gt; source_link.txt [D:\test\source.txt] 1 个文件 2 字节 5 个目录 241,024,319,488 可用字节 参数 /J 版本的 mklink 命令创建的联接，展现在 Windows 资源管理器中的样式与普通的快捷方式没有两样——在图标的左下角有一个小箭头。不过，在资源管理器中，联接的文件类型是「文件夹」。对于源路径是文件的情况，图标显示为空目录的样式。 删除参数 /J 版本的 mklink 命令创建的联接，不会影响源路径指向的文件。删除参数 /J 版本的 mklink 命令创建的联接指向的源文件，访问联接时无法访问；提示「引用了一个不可用的位置」。]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Symbolic Link</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTeX 黑魔法（七）：TeX 中作为参数的 dimen 和 skip]]></title>
    <url>%2F2018%2F12%2F10%2Fdimen-and-skip-as-argument-in-TeX%2F</url>
    <content type="text"><![CDATA[接触 TeX 稍久的用户，应该多少都接触过 \kern 和 \hskip 两个命令。那么不知你是否会好奇，TeX 是如何获取它们的参数的呢？要知道，像 I\kern37ptlike\hskip100ptcake 这种看上去奇奇怪怪的写法，能正常工作，但 \hskip 2pt minuscule chances of error 这种看起来正常的写法却会报错。 此篇介绍一下 TeX 中作为参数的 dimen 和 skip。 作为参数的 dimen命令 \kern 的参数是 ⟨dimen⟩，因此我们以它为例。具体来说，TeX 在读入 \kern 这个 token 之后，会先去寻找一个十进制分数（⟨decimal number⟩），而后寻找合法的单位（⟨unit of measure⟩）。在十进制分数和单位之间的空格都会被忽略。在单位之后，则有一个可选空格。 这里，十进制分数可以是： 任意在 TeX 中合法的整数； 任意合法的十进制分数（以句点或逗号作为整数与小数部分的分隔）。 特别说明一下以逗号作为整数与小数部分的分隔的问题。在中国，大多数时候，我们都以句点作为小数点，来分隔十进制分数的整数与小数部分；例如 1.25。同时，逗号通常用于大数记录时的千分标记；例如 1, 000.25。但是，在部分国家（例如法国和德国），在表示十进制分数时，句点和逗号的用法正好颠倒。因此，1, 000.25 在法国和德国记作 1. 000,25。有趣的是，\kern , pt 是一个合法的铅空。它会产生一个宽度为 0pt 的铅空。这是因为，逗号在此被当做是小数点。而小数点前后的数字是零时，是可以省略的。 这里的单位，指得是 TeX 接受的，以两个字符表达的长度单位。包括：pt, cm, mm, in, dd, pc, cc, bp, sp, em, ex。对于 pdfTeX 来说，还包括 px。如果 TeX 在读入一个合法的十进制分数之后，没有找到合法的单位，则会报错： 1! Illegal unit of measure (pt inserted). 因此，\kern37ptlike 是合法的。它与 \kern 37 pt like 等价。 作为参数的 skip命令 \hskip 的参数是 ⟨skip⟩，因此我们以它为例。具体来说，TeX 在读入 \hskip 这个 token 之后，会先和上述步骤一样，寻找一个 ⟨dimen⟩，作为 ⟨skip⟩ 的自然长度。而后，TeX 会在展开得到的 token list 当中继续寻找 plus。如果 TeX 找到了 plus，则 TeX 又会去寻找一个 ⟨dimen⟩。不过，此时十进制分数之后，除了长度单位，还可以是 fil, fill 或者 filll。其中 fil(|l|ll) 之后的可选空格会被忽略。特别地，如果没有找到 plus，TeX 也会继续寻找 minus。找到 minus 之后的规则，就跟 plus 的情况一样了。 因此，在 \hskip 2pt minuscule chances of errors 这个例子中，TeX 读入 2pt 作为 \hskip 的自然长度。而后，尽管没有找到 plus，但找到了 minus——它藏在 minuscule 这个单词中。很不幸，此时在 minus 之后没有一个合法的 ⟨dimen⟩，于是 TeX 会报错。如果你不了解 TeX 读入 ⟨skip⟩ 的规则，那这种报错还是蛮令人挠头的。 为了避免这些问题，在 ⟨skip⟩ 之后，果断地加一个 \relax 总归是个好主意。 bonus! 奇怪的 fil(|l|ll)首先我们来看一个例子。你认为下面的写法是合法的吗？ 1\hskip 0pt plus 1 fil L l minus 2 fiLL 答案是合法的…… 事实上，fill 和 filll 并不是 TeX 的关键字。真实情况是，fil 和 l 是 TeX 关键字。而 TeX 在读入 fil 之后，会尝试继续寻找 l 这个关键字。如果找到了，就拼在一起，作为弹力更大的弹簧。此外，TeX 的关键字是不区分大小写的。 因此，fil L l 就相当于 filll；而 fiLL 就相当于是 fill。也因此，如果你不了解这一点，下面的例子可能会让你很伤脑筋——Let&#39;s Go 当中的 L 怎么不输出了？ 1\hskip 0pt plus 1fil Let's go 通常，我们（雾）把这种情况称之为「神秘的 L」。←_←]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Arguments</tag>
        <tag>TeX-core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈由异常输入导致的 ReLU 神经元死亡的问题]]></title>
    <url>%2F2018%2F11%2F30%2Fvanishing-gradient-of-ReLU-due-to-unusual-input%2F</url>
    <content type="text"><![CDATA[最近在阅读 Airbnb 的论文 Applying Deep Learning to Airbnb Search。阅读的过程中，我发现作者在谈及特征归一化的必要性时，有如下表述： Feeding values that are outside the usual range of features can cause large gradients to back propagate. This can permanently shut of activation functions like ReLU due to vanishing gradients. 翻译成中文： 神经网络接受异于常值范围的输入时，在反向传播过程中会产生大的梯度。这种大的梯度，会因梯度消失而永久关闭诸如 ReLU 的激活函数。 我感到有些疑惑。ReLU 正是为了解决梯度消失问题而设计的。为什么这里会提到「因梯度消失而永久关闭诸如 ReLU 的激活函数」呢？ 此篇来讨论这个问题。 ReLU 函数ReLU 的全称是 Rectified Linear Unit，即：线性整流单元。对于输入 $x$，它有输出 $$y = \max(0, x).$$ 相应地，有导数 $$y&#39; = \begin{cases}1 &amp; x &gt; 0, \\ 0 &amp; x &lt; 0.\end{cases}$$ 由于 ReLU 在 $x &gt; 0$ 时，导数恒为 1。因此在反向传播的过程中，不会因为导数连乘，而使得梯度特别小，以至于参数无法更新。在这个意义上，ReLU 确实避免了梯度消失问题。 异常输入杀死神经元 上图是一个典型的神经元。 现在假设，这个神经元已经经过若干次迭代，其参数 $(\vec w, b)$ 已经迭代得趋于稳定。现在，神经元接收到了一个异常的输入 $\vec x$。比方说，它的某一维特征 $x_i$ 与对应的权重 $w_i$ 的乘积 $w_ix_i$ 非常大。一般来说，这意味着 $x_i$ 的绝对值非常大。于是，ReLU 的输入就会很大，对应 ReLU 的输出 $y$ 也就会很大。好了，假设这个 ReLU 神经元期望的输出（ground truth）是 $\hat y$，这个时候损失就会很大——损失一般是 $\lvert y - \hat y\rvert$ 的增函数，记为 $f\bigl(\lvert y - \hat y\rvert\bigr)$。 于是，在反向传播过程中，传递到 ReLU 的输入时的梯度就是 $g = f\bigl(\lvert y - \hat y\rvert\bigr)$。考虑对于偏置 $b$ 有更新 $$b \gets b - g\eta.$$ 考虑到 $g$ 是一个很大的正数，于是 $b$ 可能被更新为一个很小的负数。此后，对于常规输入来说，ReLU 的输入大概率是个负数。这也就是说，ReLU 大概率是关闭的。这时，梯度无法经 ReLU 反向传播至 ReLU 的输入函数。也就是说，这个神经元的参数再也不会更新了。这就是所谓的「神经元死亡」。 如此看来，尽管 ReLU 解决了因激活函数导数的绝对值小于 1，在反向传播连乘的过程中迅速变小消失至 0 的问题，但由于它在输入为负的区段导数恒为零，而使得它对异常值特别敏感。这种异常值可能会使 ReLU 永久关闭，而杀死神经元。 梯度消失？梯度消失（gradient vanishing）是深度神经网络中的一种现象。导致它的原因有很多。由于激活函数导数连乘导致的梯度消失问题最为出名。因此，在很多人心里（包括我过去也是），梯度消失指得就是这种现象。故而对原文的表述有困惑。这种理解实际上是一种不完全的、很偷懒的做法。因此，对概念的理解要着重深入到实际情况中去，而不能囫囵吞枣。 共勉。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>ReLU</tag>
        <tag>Dead</tag>
        <tag>Gradient</tag>
        <tag>Vanishing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TeX 引擎、格式、发行版之介绍]]></title>
    <url>%2F2018%2F11%2F26%2Fintroduction-to-TeX-engine-format-and-distribution%2F</url>
    <content type="text"><![CDATA[近日被邀请在知乎上回答问题。鉴于这个问题已经被答烂了，所以将其存档在博客，以供后享。 问题：新手学习 TeX，推荐用什么编译器，是 LaTeX 还是 CTeX？或者说别的什么？原回答：https://www.zhihu.com/question/55137880/answer/539242148 十秒版本： 安装 TeX Live：TeX Live 下载及安装说明 开始菜单中找到随附 TeX Live 安装的 TeXworks，打开。这是一个「TeX 编辑器」。 阅读入门教程：一份其实很短的 LaTeX 入门文档 引擎与通常用的编程语言的编译器相对应——如 C++ 的 gcc/icc/cl、Java 的 javac——TeX 的「编译器」的真名叫做「TeX 引擎」。TeX 引擎大概有如下一些选择： Knuth TeX e-TeX pdfTeX LuaTeX XeTeX pTeX upTeX e-upTeX pTeX-ng 其中，Knuth TeX 是高德纳的原版 TeX，现在你基本已经找不到它了。 e-TeX 是目前事实上的「标准」TeX。尽管它名字中的「e」表示的是「extended」。几乎所有的后续的 TeX 编译器都是在 e-TeX 基础上开发的。 pdfTeX 是西文世界最常用的 TeX 编译器。通常来说，西文期刊的模板，用 pdfTeX 作为编译器编译不会错。 LuaTeX 则是作为 pdfTeX 正统后继者出现的。它给 TeX 加入了 Lua 脚本的支持，同时原生支持 Unicode。它可以通过 Lua 回调加入编译器级别的 CJK 字符支持；虽然这样子处理，编译起来效率很低速度很慢。 XeTeX 是 e-TeX 的另一个分支扩展。它也原生支持 Unicode，并且和 LuaTeX 一样，支持直接调用系统里的字体。目前推荐的中文支持办法，是在 XeTeX 引擎上，使用宏的方式解决的。（xeCJK宏包） pTeX 及后续的 TeX 引擎，我们习惯称之为「pTeX 系引擎」。这里的「p」是「publish」的缩写。看得出来，pTeX 的日本作者们「野心」很大的，想要做成一个出版工业级的引擎。pTeX 系引擎里，目前用得最广泛的是 e-upTeX。它可以较好地支持 CJK 字符。不过由于是日本人开发的，所以对日语支持是最好的。用来撰写中文文档，跟我们的习惯有些出入，需要有丰富的经验才能驾驭。pTeX-ng 则是 pTeX 系引擎的新贵，它是由国人Clerk Ma 开发的引擎。其中「ng」是「next generation」的缩写。从命名来看，果然还是要「秒杀」一下我们的邻居的。pTeX-ng 已经相对成熟，不过我用得很少，故不展开。关于 pTeX 系引擎，我有翻译过一系列文章（在此）。 小结一下。Knuth TeX 是祖宗，目前已被供起来，不太会被用到。e-TeX 开创了新世纪，不过裸用 e-TeX 也很少。pdfTeX 在西文世界里被广泛使用，也很稳定。LuaTeX 是 pdfTeX 的「正统」继承者，不过编译起来慢慢慢。用 XeTeX 来支持中文比较成熟，在中文世界里被推荐使用。pTeX 系引擎源自日本，感兴趣的可以玩一玩。 格式TeX 是一个「宏语言」。当你制作了一些特别基础的宏，那么你可以将其发布为一个「格式」（format）。建立在 TeX 之上，有常用的格式： plain TeX：这是 Knuth 搞出来的格式，最为基础。 LaTeX：这是兰伯特搞出来的格式，使用最为广泛。 ConTeXt：这也是一个格式。不过我基本没用过。 你在某个格式之上写作文档（manuscript）时，你需要先告诉 TeX 引擎你要载入哪个格式。因为格式使用得太频繁了，所以人们倾向于把格式和引擎打包在一起。这样，就不用每次都告诉 TeX 引擎这件事情了。以 LaTeX 为例，将它与上述引擎打包在一起之后，我们有了： e-TeX -&gt; LaTeX pdfTeX -&gt; pdfLaTeX LuaTeX -&gt; LuaLaTeX XeTeX -&gt; XeLaTeX pTeX -&gt; pLaTeX upTeX -&gt; upLaTeX e-upTeX -&gt; e-upLaTeX pTeX-ng -&gt; pLaTeX-ng 尽管真正的「编译器」应该是「TeX 引擎」这一概念。但实际上，在日常沟通中，我们说的「怎么编译」，应当指的是这些「格式与引擎相结合」的产物。 于是，再小结一下： 西文文档：pdfLaTeX、XeLaTeX 中文文档：XeLaTeX 考古者：LaTeX 好奇心者：LuaLaTeX、pLaTeX-ng 好奇心爆棚者：pLaTeX、upLaTeX、e-upLaTeX 发行版回到「宏」的问题上来。当你写了一些具有特定功能的宏，你会考虑将其发布为宏包（style package）或者文档类（document class）。也因此，当你想要用某些特定功能，你会倾向于去寻找宏包或者文档类，而不是自己造轮子。若是你每次寻找宏包，都要去互联网上爬文、下载、安装、调试、使用。那么多试几次，你一定会崩溃。 这引出了「TeX 发行版（distribution）」或者「TeX 系统（system）」或者「TeX 套装（suite）」的概念，表示上述所有引擎、格式、宏包，还有一些为了简便未在此处介绍的驱动、辅助工具，的集合。一般来说 TeX 发行版是用户真正需要安装的东西。也就是说，讨论「新手应该安装什么」的时候，我们实际上讨论的是「新手应该安装什么 TeX 发行版」。 对于任何阶段的 TeX 用户，这里都推荐安装 TeX Live 这一发行版。若你使用 macOS，则推荐安装基于 TeX Live 开发的 macTeX 这一发行版。 注意：不推荐 CTeX 发行版。没有理由，不听解释。 注意：名为 CTeX 的，除了发行版，还有一个宏集（多个宏包组成的集合）。它们不是一个东西。尽管我们不推荐 CTeX 发行版，但我们强烈推荐使用 CTeX 宏集解决中文支持和版式设定的问题。 最后，对于新人：一份其实很短的 LaTeX 入门文档。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Format</tag>
        <tag>System</tag>
        <tag>Engine</tag>
        <tag>Distribution</tag>
        <tag>Compiler</tag>
        <tag>Suite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈二分搜索及其变体]]></title>
    <url>%2F2018%2F11%2F23%2Fbinary-search-and-its-variants%2F</url>
    <content type="text"><![CDATA[在前作讨论基于比较的排序算法的复杂度下界时，我们提及了二分搜索算法。 二分搜索是一个效率很高的算法。一个良好实现的二分搜索算法，其时间复杂度可以达到 $\Theta(\log n)$，而空间复杂度只有 $O(1)$。特别地，二分搜索算法的描述十分简洁。作为程序员，总是喜欢 clean and powerful 的东西。因此，二分搜索无疑对程序员有巨大的吸引力。 按照 Knuth 的说法，「尽管第一个二分搜索算法早在1946年就被发表，但第一个没有bug的二分搜索算法却是在12年后才被发表出来」。 此篇我们讨论二分搜索算法的原理及其各种变体的实现。 算法描述二分搜索是针对支持随机访问的有序数据集进行查找操作的算法。最基本的二分搜索，查找的是等于目标元素的元素在数据集中的位置。它的描述十分简单： 折半取中，判断元素与目标元素的大小关系 小于——往前继续折半 大于——往后继续折半 等于——返回 此处要注意二分搜索的适用场景： 依赖顺序表结构 数据本身必须有序 数据量相对比较元素的开销要足够大——不然遍历即可 数据量相对内存空间不能太大——不然顺序表装不下 二分搜索的实现123456789101112131415161718192021222324#include &lt;iterator&gt;#include &lt;functional&gt;template &lt;typename IterT, typename ValueT = typename std::iterator_traits&lt;IterT&gt;::value_type, typename Compare = std::less&lt;ValueT&gt;&gt;IterT bsearch(IterT first, IterT last, ValueT target, Compare comp = Compare()) &#123; IterT result = last; while (std::distance(first, last) &gt; 0) &#123; IterT mid = first + std::distance(first, last) / 2; if (comp(*mid, target)) &#123; first = mid + 1; &#125; else if (comp(target, *mid)) &#123; last = mid; &#125; else &#123; // equal result = mid; break; &#125; &#125; return result;&#125; 这一实现有一些技巧值得说一说。 首先，搜索范围是由 first 和 last 构成的左闭右开区间。在编程中，坚持使用左闭右开区间，能够避免大多数索引越界的问题。这是个好习惯，值得一说。 其次，这一实现以 mid = low + (high - low) / 2 的方式来确定折半点。与之相对，还有一种写法是 mid = (low + high) / 2。在数学的角度，这两种写法完全相同。但是在计算机的角度，后者可能涉及到整数的溢出。因此，为了避免溢出，我们应当优先采用实现当中的写法。 最后，这一实现以 while 循环替代递归，节省了函数的递归调用带来的开销。与之搭配，在未能找到目标时，通过调整区间首尾实现折半动作。这种实现方式是处于效率的考量。 二分搜索的变体单就查找等于目标的元素来说，这一任务还有哈希表和查找树等数据结构能高效地完成。相较二分搜索，它们的限制更少——不需要数据集本身有序，也不需要分配连续的大块内存。如此看来，二分搜索似乎只是看起来美好，实际用途应该不广。 但事实上，二分搜索还有若干变体。这些变体实现的功能，上述这些数据结构通常很难以较低的时间复杂度完成。这些变体才是最能体现二分搜索威力的场景。这里介绍常见的四个变体： 查找支持随机访问的有序数据集中，第一个等于给定值的元素 查找支持随机访问的有序数据集中，最后一个等于给定值的元素 查找支持随机访问的有序数据集中，第一个不小于给定值的元素 查找支持随机访问的有序数据集中，最后一个不大于给定值的元素 这些变体的实现也不难。在上述标准二分搜索的基础上，只需要稍加改造即可。需要关注的核心点，就是在不同条件下，区间的首尾应该如何变化。以下是我以 C++ 实现的这些变体。这份实现里值得一提的地方，在基础款的二分搜索实现中已经提过，便不再赘述。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iterator&gt;#include &lt;functional&gt;enum class BsearchPolicy &#123; UNSPECIFIED, FIRST, LAST, FIRST_NOT_LESS, LAST_NOT_GREATER &#125;;template &lt;typename IterT, typename ValueT = typename std::iterator_traits&lt;IterT&gt;::value_type, typename Compare&gt;IterT bsearch(IterT first, IterT last, ValueT target, Compare comp, BsearchPolicy policy = BsearchPolicy::UNSPECIFIED) &#123; IterT result = last; while (std::distance(first, last) &gt; 0) &#123; IterT mid = first + std::distance(first, last) / 2; if (policy == BsearchPolicy::FIRST_NOT_LESS) &#123; if (!comp(*mid, target)) &#123; if (mid == first or comp(*(mid - 1), target)) &#123; result = mid; break; &#125; else &#123; last = mid; &#125; &#125; else &#123; first = mid + 1; &#125; &#125; else if (policy == BsearchPolicy::LAST_NOT_GREATER) &#123; if (comp(target, *mid)) &#123; last = mid; &#125; else &#123; if (std::distance(mid, last) == 1 or comp(target, *(mid + 1))) &#123; result = mid; break; &#125; else &#123; first = mid + 1; &#125; &#125; &#125; else &#123; // policy == UNSPECIFIED or FIRST or LAST if (comp(*mid, target)) &#123; first = mid + 1; &#125; else if (comp(target, *mid)) &#123; last = mid; &#125; else &#123; // equal if (policy == BsearchPolicy::FIRST) &#123; if (mid == first or comp(*(mid - 1), *mid)) &#123; result = mid; break; &#125; else &#123; last = mid; &#125; &#125; else if (policy == BsearchPolicy::LAST) &#123; if (std::distance(mid, last) == 1 or comp(*mid, *(mid + 1))) &#123; result = mid; break; &#125; else &#123; first = mid + 1; &#125; &#125; else &#123; result = mid; break; &#125; &#125; &#125; &#125; return result;&#125;template &lt;typename IterT, typename ValueT = typename std::iterator_traits&lt;IterT&gt;::value_type, typename Compare = std::less&lt;ValueT&gt;&gt;IterT bsearch(IterT first, IterT last, ValueT target, BsearchPolicy policy = BsearchPolicy::UNSPECIFIED) &#123; return bsearch(first, last, target, Compare(), policy);&#125;]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 上的 GIF 动画录像机和浏览器]]></title>
    <url>%2F2018%2F11%2F23%2FGIF-aminate-recoder-and-viewer-on-Windows%2F</url>
    <content type="text"><![CDATA[继续配置电脑的旅程。 此篇推荐两个小工具。它们的大小都不足 1MiB，但是都非常好用。一个是 GIF 录屏工具，一个是 GIF 查看器。 LICECapLICECap 是一款小巧的 GIF 录屏工具，其安装包大小只有 282KiB。它的下载地址是：https://licecap.en.softonic.com/?ex=BB-682.0。 GIF Viewer从 Windows Vista 开始，系统自带的图片查看器不支持查看 GIF 动画。因此在 Windows 上打开 GIF 动画，系统会自动打开臃肿的 Internet Explorer。这实在不能忍。 在国外论坛上找到了名为 GIF Viewer 的小工具。它的安装包大小只有 134KiB，下载地址是：https://sourceforge.net/projects/gifviewer/。]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>GIF</tag>
        <tag>Recoder</tag>
        <tag>Viewer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Windows 7 的锁屏界面上执行命令/程序]]></title>
    <url>%2F2018%2F11%2F22%2Fexecute-command-or-executables-on-Windows-login-page%2F</url>
    <content type="text"><![CDATA[前作提到了如何在 Windows 7 上更换锁屏界面的背景图片。这就给我创造了一个新的需求——如何为锁屏界面截图？ 此篇以此为例，讲讲如何在锁屏界面上执行命令/程序。 实现思路在锁屏界面截图需要解决的主要问题是： 如何在用户没有登录的情况下，执行命令； 有什么可用的截图工具能够在锁屏界面进行截图？ 在锁屏界面执行命令PsExecPsExec 是 M$ 提供的一款在远程机器上执行命令的小工具。正如 Linux 上常用的 SSH 可以将本机作为「远程机器」登录一样，PsExec 也能完成这个任务。此外，PsExec 的 -x 选项，能够在 Windows 登录页面显示 UI。这样一来，我们就能利用 PsExec 在锁屏界面执行命令了。 具体操作路径如下： 下载：https://download.sysinternals.com/files/PSTools.zip 安装：打开 .zip 包，将 PsExec.exe 复制到 C:\Windows\System32 当中 在开始菜单中搜索 cmd，右键「以管理员身份运行」 执行命令 psexec -sx cmd.exe；其中 -s 表示以系统权限运行，-x 表示在锁屏界面显示 UR 按 Win + L 锁屏 按 Alt + Tab 切换到 cmd.exe 的 UI 轻松访问事实上，Windows 的轻松访问有各种 bug。利用它可以实现很多 hacky 的功能。此次我们也来利用这一小漏洞。 直接替换可执行文件默认的轻松访问可执行文件位于 C:\Windows\System32\Utilman.exe。我们可以备份它，然后将其替换为其它可执行文件。如此一来，在锁屏界面点击轻松访问按钮，就能执行被替换的可执行文件了。 修改注册表我们也可以通过修改注册表，将轻松访问的可执行文件路径，指向其它可执行文件。 在开始菜单中搜索 regedit，回车执行 导航路径 HKEY_LOCAL_MACHINE SOFTWARE Micorsoft Windows NT CurrentVersion Image File Execution Options 右键，新建名为 Utilman.exe 的项 在右侧新建名为 Debugger 的字符串值 右键双击 Debugger 字符串值，将其值设置为目标可执行文件的完整路径 实际截图试试看这里，我使用 Win 7 Logon Screen Capture 这个小工具来截图。我将其下载解压到了 E:\Tools\Login Screen Capture.exe 位置。而后，我们只需要通过上述两种方式之任一，在锁屏界面执行截图工具即可。 以下即是我截图的结果。]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Screenshot</tag>
        <tag>PsExec</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更换 Windows 7 锁屏界面的背景]]></title>
    <url>%2F2018%2F11%2F21%2Freplace-the-background-of-login-page%2F</url>
    <content type="text"><![CDATA[Windows 7 在登录时默认的背景图片是一片蓝色。作为一个程序员，我会倾向于认为，这片蓝色是一张图片资源。因此，它是可以被更换的。 这篇介绍如何更换 Windows 7 锁屏界面的背景。 允许自定义经过一番搜索，我并没能找到那一片蓝的资源图。不过，爬文过程中，我发现 OEM 厂往往会将锁屏界面替换为 OME 自定义的图片。而这个开关需要在注册表中打开。具体来说： 开始菜单 -&gt; 搜索 -&gt; Regedit.exe -&gt; 导航至 HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows/CurrentVersion/Authentication/LogonUI/Background -&gt; 修改 OEMBackground 的值为 1。 设置 OEM 锁屏背景图片资源新建目录 C:\Windows\System32\oobe\info\backgrounds，而后将资源图片保存为 .jpg 格式，并重命名为 backgroundDefault.jpg。特别地，要注意它的体积不能超过 256KiB。 锁屏查看效果]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Background</tag>
        <tag>Windows 7</tag>
        <tag>Login</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彻底关闭 ThinkPad 的触控板]]></title>
    <url>%2F2018%2F11%2F20%2Fturn-off-touchpad-of-ThinkPad%2F</url>
    <content type="text"><![CDATA[这是一篇简单的记录。 新电脑是 ThinkPad。众所周知，TP 的小红点（TrackPoint）很好用。相应的，TP 的触控板就不怎么好用了。特别地，TP 的触控板在打字的时候，经常会误触导致光标漂移。 因此，我需要关闭触控板。 网上爬文，大多数结果都告诉要安装 UltraNav 的驱动。从联想官网上下载安装驱动后，TP 提示说找不到相关设备。看起来是驱动与硬件不匹配导致的。遂删除驱动。 最后想到，BIOS 能控制各种输入输出设备。遂在重启时进入 BIOS 设置（Enter 键），找到触控板（TouchPad）设置，将其设置为 disabled。完成！ 123RebootHold &apos;Enter&apos;BIOS -&gt; config -&gt; keyboard/mouse -&gt; TouchPad (disabled)]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>ThinkPad</tag>
        <tag>TouchPad</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博弈论通俗演义：美女的硬币游戏与为啥你炒股总亏]]></title>
    <url>%2F2018%2F11%2F14%2Fgame-of-beauty-and-stock-market%2F</url>
    <content type="text"><![CDATA[这是博弈论通俗演义的第二篇。我们首先分析经典的「美女的硬币游戏」，而后挖掘它背后的模型，再引出「为啥你炒股总亏」的问题。 美女的硬币游戏问题描述美女的硬币游戏描述如下： 美女提议与你进行一个游戏，规则如下： 双方各持一枚硬币，同时亮出。 若双方均为正面，则美女给你 3 元奖励； 若双方均为反面，则美女给你 1 元奖励； 若双方正反不一致，则你输给美女 2 元。 那么现在的问题是： 如果美女不怀好意，想要在你这里赚钱，她应该怎么做？ 你是否有必胜的策略，能在这个游戏中赚到美女的奖励？ 看似公平我们可以用一张表格表示这个游戏可能出现的各种情况下，你的收益。 ↓美女·你→ 正 反 正 3 -2 反 -2 1 乍看起来，总共有 4 中情况，每种情况出现的概率都是 $\frac{1}{4}$。于是这个游戏是公平的，不管怎样，一直玩下去你也不会亏钱。对于广大单身男同胞，可能还获得了一个与美女搭讪的机会。看上去不亏。但事实真是这样吗？ 藏在概率里的陷阱游戏是公平的，这个推论建立在上述 4 种情况出现的概率均等的前提下。某种程度上，这受到了各种「抛硬币实验」的影响。——大家可能默认硬币出现正反面的概率是均等的，都为 $\frac{1}{2}$。但是这个前提在当前问题中不成立。 实际上，参与游戏的双方，可以选择以一定的概率亮出正面或反面。我们假设美女亮出正面的概率是 $p$，而你亮出正面的概率是 $q$。于是，对于你来说，参与游戏获得收益的期望是 $$\begin{aligned} E = {}&amp; 3pq - p(1 - q) - 2(1 - p)q + 2(1 - p)(1 - q) \\ = {}&amp; 8pq - 3p - 3q + 1. \end{aligned}$$ 显然，若 $p$, $q$ 不全为 $\frac{1}{2}$ 时，期望不一定为 0。它可能大于 0 也可能小于 0。 不怀好意的美女现在假设美女不怀好意。也就是说，她想从你手中赢钱。那么美女要怎样做呢？ 考虑 $E$ 是你收益的期望。那么，不怀好意的美女希望通过改变 $p$ 的值，使得 $E &lt; 0$。这即是 $$\begin{aligned} {}&amp;{} E &lt; 0 \\ \Leftrightarrow {}&amp;{} 8pq - 3p - 3q + 1 &lt; 0 \\ \Leftrightarrow {}&amp;{} p(8q - 3) &lt; 3q - 1. \end{aligned}$$ 考虑当 $8q - 3 &gt; 0$，即 $q &gt; \frac{3}{8}$ 时，原式等价于 $$p &lt; \frac{3q - 1}{8q - 3}.$$ 由于 $f(q) = \frac{3q - 1}{8q - 3}$ 在 $\bigl(\frac{3}{8}, 1\bigr]$ 上是 $q$ 的减函数。因此当 $p &lt; f(1) = \frac{2}{5}$ 时，原式成立。 再考虑当 $8q - 3 &lt; 0$，即 $q &lt; \frac{3}{8}$ 时，原式等价于 $$p &gt; \frac{3q - 1}{8q - 3}.$$ 由于 $f(q) = \frac{3q - 1}{8q - 3}$ 在 $\bigl[0, \frac{3}{8}\bigr)$ 上是 $q$ 的减函数。因此当 $p &gt; f(0) = \frac{1}{3}$ 时，原式成立。 再考虑当 $8q - 3 = 0$，即 $q = \frac{3}{8}$ 时，对任意的 $p \in [0, 1]$ 成立 $$E = p(8q - 3) - 3q + 1 = -\frac{1}{8}.$$ 综上所述，当 $p \in \bigl(\frac{1}{3}, \frac{2}{5}\bigr)$ 时，无论 $q$ 如何取值，美女都能从你手中赢钱。 苦苦挣扎的你从上一节中，我们已经可以看出，事实上美女是有必胜的策略的。因此原题第二个问题的答案就显而易见了——你没有必胜的策略。不过不死心的你，可能还想要从你的角度来分析一下。 我们考虑一种极端情况，即「你」的收益最大化的情况，你亮出正面的概率 $q$ 应当满足什么条件。为了让美女无机可乘，你应当调整概率 $q$，使得无论美女亮出正面还是反面，你的收益的期望相等。因为，若不然，美女就可以通过调整概率 $p$，使得正面或反面出现的次数更多，来降低你的总收益。——这与「你的收益最大化」的假设矛盾。 首先，我们列出当美女亮出正面或反面时，你的收益的期望： $$\begin{cases} E_{+} = 3q - 2(1 - q), \\ E_{-} = -2q + (1 - q). \end{cases}$$ 现在，令 $E_{+} = E_{-}$，则有一元一次方程的解 $q = \frac{3}{8}$。这就是说，当你亮出正面的概率是 $\frac{3}{8}$ 时，你的收益最大。而最大的收益是多少呢？——我们在上一节已经计算过了 $$E\Bigl(q = \frac{3}{8}\Bigr) = -\frac{1}{8}.$$ 这也就是说，最好的情况，你平均每一局游戏也得亏 $-\frac{1}{8}$ 元钱。因此，你是没有必胜策略的（相反美女是有的）。 美女硬币游戏的要义和模型美女硬币游戏的要义，其实就是她的「提议」。她的提议看起来是一个公平的游戏，但实际上是她占据了话语权。具体到游戏中，就是占据了游戏规则的制定权。那么，美女硬币游戏中的美女，事实上就具有了[前作]中提及的先发优势。 更抽象的问题我们说，假设越强，结论就越弱；反过来，假设越弱，结论就越强。现在我们削弱美女硬币游戏的假设，让它变得更抽象，从而加强我们已有的结论。 考虑到硬币的正反面地位等同。我们不妨设「正正」的情况，收益为 $a$；而「反反」的情况，收益为 $b$。为了让游戏「看起来公平」，我们需要保证「正反」和「反正」的情况，收益为 $-\frac{a + b}{2}$。 ↓·→ 正 反 正 $a$ $-\frac{a + b}{2}$ 反 $-\frac{a + b}{2}$ $b$ 这种情况下，对手收益的期望是 $$\begin{aligned} E = {}&amp; apq - \frac{a + b}{2}p(1 - q) - \frac{a + b}{2}(1 - p)q + b(1 - p)(1 - q) \\ = {}&amp; 2(a + b)pq - \frac{a + 3b}{2}p - \frac{a + 3b}{2}q + b. \end{aligned}$$ 因此，你收益最大时应满足 $$q = \frac{a + 3b}{4(a + b)}.$$ 此时，你收益的期望是 $$E = -\frac{(a - b)^{2}}{8(a + b)}.$$ 考虑到 $(a - b)^{2} &gt; 0$ 对任意的 $a \neq b$ 总是成立。于是，我们得到了一个假设很弱的结论： 若你的对手巧妙地设置 $a$ 和 $b$ 的值，使得 $a \neq b$ 及 $a + b &gt; 0$，那么你就总是会输。 从这里，我们也能看出，所谓的「先发优势」是何等巨大。先发者只需要稍微设置一下游戏规则，你就只能输输输了。 炒股还是不炒股？这不是个问题。现在我们回到炒股的问题上来。在股市中，有如下对应关系。 美女的硬币 股市 美女 庄家 亮正面 做多 亮反面 做空 收益 收益 如此一来，结论就显而易见了。在一个由庄家控盘的股票上，不论你怎么买入卖出，庄家都很容易通过一定的策略让你（和其他散户）的收益期望最大值为负。如此一来，结论就是：庄家总是能赚钱，而散户长远看总是亏钱。 因此，炒股还是不炒股？这不是个问题。珍爱资产，远离股市——特别是庄家多的题材股。如果你一定要炒股，那么，请在合适的时机投资你了解、看好的基本面良好的股票。]]></content>
      <categories>
        <category>Mathematics and Natural Sciences</category>
      </categories>
      <tags>
        <tag>Game Theory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTeX 黑魔法（六）：使用比逼格更逼格的定界符]]></title>
    <url>%2F2018%2F11%2F09%2Fthe-bigger-than-bigger-delimiter-in-LaTeX%2F</url>
    <content type="text"><![CDATA[通常，我们建议在 LaTeX 中使用 LaTeX 提供的 \big, \Big, \bigg, \Bigg 一系列命令，代替 TeX 默认的 \left 和 \right 来调整定界符的大小。然而，尽管最大提供了 \Bigg 的命令，但有时候仍然不够用。 此篇介绍如何定义 \biggg, \Biggg, \bigggg 和 \Bigggg 系列命令。我们的口号是「比逼格更逼格」（bigger than bigger）！ 挖掘代码\big 系列命令要定义更大的定界符修饰，就必须搞清楚 \big 系列命令是如何定义的。首先，我们使用 kpsewhich amsmath.sty 找到 amsmath.sty 在系统中的路径。而后打开样式文件，搜寻 \big 的定义。 1234\renewcommand&#123;\big&#125;&#123;\bBigg@\@ne&#125;\renewcommand&#123;\Big&#125;&#123;\bBigg@&#123;1.5&#125;&#125;\renewcommand&#123;\bigg&#125;&#123;\bBigg@\tw@&#125;\renewcommand&#123;\Bigg&#125;&#123;\bBigg@&#123;2.5&#125;&#125; \bBigg@ 命令显而易见，核心是 \bBigg@ 这个命令。它可以根据其后第一个 token 决定定界符的放大程度。注意，这里 \@ne 表示 {1}，而 \tw@ 表示 {2}——这是令人讨厌的 LaTeX 内核编程 trick。于是我们继续去寻找 \bBigg@ 的定义。 1234\def\bBigg@#1#2&#123;% &#123;\@mathmeasure\z@&#123;\nulldelimiterspace\z@&#125;% &#123;\left#2\vcenter to#1\big@size&#123;&#125;\right.&#125;% \box\z@&#125;&#125; 很显然，\bBigg@ 命令内部也是通过 TeX 原始的 \left 和 \right 命令来调整定界符（#2）的大小的。不过，它还额外处理了左右的空距。这里我们知道就行了，不去深究。 \bigl 和 \bigr 系列命令接下来我们继续挖掘 \bigl 和 \bigr 系列命令的定义。它们定义在 LaTeX2e 内核当中，因此我们通过执行 texdoc source2e 就能看到它们的定义了。 123456789101112\def\bigl&#123;\mathopen\big&#125;\def\bigm&#123;\mathrel\big&#125;\def\bigr&#123;\mathclose\big&#125;\def\Bigl&#123;\mathopen\Big&#125;\def\Bigm&#123;\mathrel\Big&#125;\def\Bigr&#123;\mathclose\Big&#125;\def\biggl&#123;\mathopen\bigg&#125;\def\biggm&#123;\mathrel\bigg&#125;\def\biggr&#123;\mathclose\bigg&#125;\def\Biggl&#123;\mathopen\Bigg&#125;\def\Biggm&#123;\mathrel\Bigg&#125;\def\Biggr&#123;\mathclose\Bigg&#125; 很显然，它们就只是用 \mathopen, \mathrel 和 \mathclose 宏来修饰了一下对应的定界符修饰命令。 改造据此，我们可以定义更有逼格的定界符修饰命令了。 123456789101112131415161718% \RequirePackage&#123;amsmath&#125;\newcommand&#123;\biggg&#125;&#123;\bBigg@&#123;3&#125;&#125;\def\bigggl&#123;\mathopen\biggg&#125;\def\bigggm&#123;\mathrel\biggg&#125;\def\bigggr&#123;\mathclose\biggg&#125;\newcommand&#123;\Biggg&#125;&#123;\bBigg@&#123;3.5&#125;&#125;\def\Bigggl&#123;\mathopen\Biggg&#125;\def\Bigggm&#123;\mathrel\Biggg&#125;\def\Bigggr&#123;\mathclose\Biggg&#125;\newcommand&#123;\bigggg&#125;&#123;\bBigg@&#123;4&#125;&#125;\def\biggggl&#123;\mathopen\bigggg&#125;\def\biggggm&#123;\mathrel\bigggg&#125;\def\biggggr&#123;\mathclose\bigggg&#125;\newcommand&#123;\Bigggg&#125;&#123;\bBigg@&#123;4.5&#125;&#125;\def\Biggggl&#123;\mathopen\Bigggg&#125;\def\Biggggm&#123;\mathrel\Bigggg&#125;\def\Biggggr&#123;\mathclose\Bigggg&#125; 注意，这段代码在普通的 LaTeX 文档中，需要使用 \makeatletter 和 \makeatother 来改变 @ 字符的分类码，以便正确定义命令。 接下来我们实际使用看看。 123456789101112131415161718192021222324252627282930\documentclass&#123;article&#125;\usepackage&#123;amsmath&#125;\makeatletter\newcommand&#123;\biggg&#125;&#123;\bBigg@&#123;3&#125;&#125;\def\bigggl&#123;\mathopen\biggg&#125;\def\bigggm&#123;\mathrel\biggg&#125;\def\bigggr&#123;\mathclose\biggg&#125;\newcommand&#123;\Biggg&#125;&#123;\bBigg@&#123;3.5&#125;&#125;\def\Bigggl&#123;\mathopen\Biggg&#125;\def\Bigggm&#123;\mathrel\Biggg&#125;\def\Bigggr&#123;\mathclose\Biggg&#125;\newcommand&#123;\bigggg&#125;&#123;\bBigg@&#123;4&#125;&#125;\def\biggggl&#123;\mathopen\bigggg&#125;\def\biggggm&#123;\mathrel\bigggg&#125;\def\biggggr&#123;\mathclose\bigggg&#125;\newcommand&#123;\Bigggg&#125;&#123;\bBigg@&#123;4.5&#125;&#125;\def\Biggggl&#123;\mathopen\Bigggg&#125;\def\Biggggm&#123;\mathrel\Bigggg&#125;\def\Biggggr&#123;\mathclose\Bigggg&#125;\makeatother\begin&#123;document&#125;\[ \Biggggl[\biggggl[\Bigggl[\bigggl[\Biggl[\biggl[\Bigl[\bigl[[ x ]\bigr]\Bigr]\biggr]\Biggr]\bigggr]\Bigggr]\biggggr]\Biggggr]\]\end&#123;document&#125;]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Delimiter</tag>
        <tag>amsmath</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈期望最大算法]]></title>
    <url>%2F2018%2F11%2F08%2FExpectation-Maximization-Algorithm%2F</url>
    <content type="text"><![CDATA[本篇讨论期望最大算法算法（Expecation Maximization Algorithm，EM 算法）。 从极大似然估计到 EM 算法EM 算法和极大似然有着很深的联系。因此在讨论 EM 算法之前，我们首先通过一个例子来回顾极大似然算法。 极大似然问题描述假设有一枚硬币 A；投掷硬币 A 后结果为正面的概率记为 $p$。我们将投掷硬币结果为正面的实验记作 $1$，反面的实验记作 $0$。独立重复 $n = 10$ 次实验，观测结果如下： $$1, 1, 0, 1, 0, 0, 1, 0, 1, 1.$$ 现在的问题是要估计投掷硬币 A 后结果为正面的概率 $p$。 整理似然函数和对数似然函数显而易见，投掷硬币 A 后的结果应当服从二项分布。于是我们可以整理似然函数： $$L(\theta) = L(x_1, x_2, \ldots, x_{10} \mid \theta) = \prod_{i = 1}^{10} p(x_i\mid \theta) = p^{6}(1 - p)^{4}.$$ 由于连乘不方便分析和优化，因此我们对似然函数取对数，构造对数似然函数，将连乘转换为连加。 $$H(\theta) = \ln L(\theta) = \sum_{i = 1}^{10}\ln p(x_i \mid \theta) = (\ln p)^{6}\cdot\bigl(\ln (1 - p)\bigr)^{4}.$$ 求解极大化问题根据似然函数或者对数似然函数，构造极大化问题。此处以似然函数为例： $$\hat \theta = \underset{\theta}{\arg\,\max} L(\theta).$$ 对于这类简单的似然函数，我们可以对它求导，令导数为 $0$，而后得到参数值；对于复杂的似然函数极大化问题，我们可以用牛顿法、拟牛顿法、梯度上升法等方法求解。此处 $$\frac{\mathop{}\!\mathrm{d}L(\theta)}{\mathop{}\!\mathrm{d}\theta} = \frac{\mathop{}\!\mathrm{d}L}{\mathop{}\!\mathrm{d}p} = 2p^{5}(1 - p)^{3}(3 - 5p).$$ 令导函数为 $0$，得到似然方程 $$2p^{5}(1 - p)^{3}(3 - 5p) = 0$$ 对似然方程的三个不重复解代入原函数依次验证，可知当 $p = \frac{3}{5}$ 时原函数取得极大值。此即为所求。 总结极大似然估计的一般方法可以记录如下： 极大似然估计，估计的目标是随机变量服从分布的参数；因此在使用极大似然估计法之前，必须假定数据服从的分布。 根据分布和实验结果，列出似然函数或者对数似然函数； 求解似然函数或者对数似然函数的极大化问题； 对于不同的（对数）似然函数，采取不同的求解方法——例如可以采用牛顿法、拟牛顿法、梯度上升法等方法，也可以求导直接求解。 EM 算法问题描述我们考虑一个复杂一些的问题。 现在假设我们有 A, B, C 三枚硬币；三枚硬币投掷后结果为正面的概率分别记为 $\pi$, $p$, $q$。现在我们规定这样一种实验：先抛 A 硬币，若 A 硬币为正面，则继续抛 B 硬币并记录结果；若 A 硬币为反面，则继续抛 C 硬币并记录结果。独立重复 $n = 10$ 次实验，观测结果如下： $$1, 1, 0, 1, 0, 0, 1, 0, 1, 1.$$ 现在的问题是要估计三枚硬币投掷后结果为正面的概率 $\pi$, $p$, $q$。 问题分析、生成模型与似然函数参考上一节关于极大似然估计法的讨论。如果我们能知道 10 次独立重复实验中，哪一些是由 B 硬币确定的最终结果，哪一些是由 C 硬币确定的最终结果；那么我们就可以对他们分别采用极大似然估计，确定 B、C 两枚硬币的二项分布参数。但是由于硬币 A 的分布参数不确定，反过来我们又必须先知道 B、C 两枚硬币取得正面的分布参数，才能说某一个结果更可能来自 B 硬币还是 C 硬币。 这是一个鸡生蛋蛋生鸡的问题，看起来不好解决。脑壳疼啊脑壳疼。以下我们用概率的语言来表述这个问题。 我们引入两个随机变量 $y$ 和 $z$。此处 $y$ 表示一次投币实验的结果，而 $z$ 表示一次投币实验中间硬币 A 的结果。于是，三硬币问题的生成模型是 $$\begin{aligned} p(y \mid \theta) = {}&amp; \sum_{z} p(y, z\mid \theta) \\ = {}&amp; \sum_{z} p(z \mid \theta)p(y \mid z, \theta) \\ = {}&amp; \pi p^{y} (1 - p)^{1 - y} + (1 - \pi)q^{y}(1 - q)^{1 - y}. \end{aligned}\tag{*}\label{star}$$ 如此有似然函数 $$\begin{aligned} L(\theta) = {}&amp; p(Y\mid\theta) \\ = {}&amp; \prod_{i = 1}^{n} \pi p^{y_i} (1 - p)^{1 - y_i} + (1 - \pi)q^{y_i}(1 - q)^{1 - y_i}. \end{aligned}$$ 考虑求模型参数 $\theta = (\pi, p, q)$ 的极大似然估计 $$\hat \theta = \underset{\theta}{\arg\,\max} \ln L(\theta).$$ 这种「鸡生蛋蛋生鸡」的问题，$(\pi, p, q)$ 参数之间互相制约，因此这个优化问题很难求得解析解。因此，针对极大似然估计法的常用解法在这里都会失效，而只能用迭代的方式求解。EM 算法是其中一种迭代算法。 EM 迭代我们刚才说，如果能确定三硬币模型的参数，那么我们就能知道观测数据 $y_i$ 来自硬币 B 或 C 的概率。知道了这个概率，我们又可以反过来去推算三硬币模型的参数。这种鸡生蛋蛋生鸡的问题，总得有个头啊。因此，在 EM 算法迭代过程中，我们需要为模型参数设置一个初始值，而后不断循环迭代。以下是以三硬币模型为例，表述 EM 算法的迭代过程。 选取参数的初始值，记为 $\theta^{(0)} = (\pi^{(0)}, p^{(0)}, q^{(0)})$； 迭代至参数值变化不大为止 E 步，根据第 $i - 1$ 轮的参数，计算隐变量 $z$ 的概率 $\mu^{(i)}_j = p\bigl(z_j\mid \theta^{(i - 1)}\bigr)$（即 $y_{j}$ 来自硬币 B 的概率）； M 步，根据隐变量的概率，计算模型参数新的估计值 $$\begin{aligned} \pi^{(i)} = {}&amp; \frac{1}{n} \sum_{j = 1}^{n}\mu_j^{(i)}; \\ p^{(i)} = {}&amp; \frac{\sum_{j = 1}^{n}\mu_j^{(i)}y_j}{\sum_{j = 1}^{n}\mu_j^{(i)}}; \\ q^{(i)} = {}&amp; \frac{\sum_{j = 1}^{n}\bigl(1 - \mu_j^{(i)}\bigr)y_j}{\sum_{j = 1}^{n}\bigl(1 - \mu_j^{(i)}\bigr)}. \end{aligned}$$ 实际计算看看我们假定初值 $\theta^{(0)} = (\pi^{(0)} = 0.5, p^{(0)} = 0.5, q^{(0)} = 0.5)$。 第一轮迭代： E 步：$\mu^{(1)_j} = p\bigl(z_j\mid \theta^{(0)}\bigr) = \frac{\pi^{(0)} \bigl(p^{(0)}\bigr)^{y_j}\bigl(1-p^{(0)}\bigr)^{1 - y_j}}{\pi^{(0)}\bigl(p^{(0)}\bigr)^{y_j}\bigl(1 - p^{(0)}\bigr)^{1 - y_j} + \bigl(1 - \pi^{(0)}\bigr)\bigl(q^{(0)}\bigr)^{y_j}\bigl(1 - q^{(0)}\bigr)^{1 - y_j}} = 0.5$ M 步：$$\begin{aligned} \pi^{(1)} = {}&amp; \frac{1}{n} \sum_{j = 1}^{n}\mu_j^{(1)} = 0.5; \\ p^{(1)} = {}&amp; \frac{\sum_{j = 1}^{n}\mu_j^{(1)}y_j}{\sum_{j = 1}^{n}\mu_j^{(1)}} = 0.6; \\ q^{(1)} = {}&amp; \frac{\sum_{j = 1}^{n}\bigl(1 - \mu_j^{(1)}\bigr)y_j}{\sum_{j = 1}^{n}\bigl(1 - \mu_j^{(1)}\bigr)} = 0.6. \end{aligned}$$ 第二轮迭代： E 步：$\mu^{(2)_j} = p\bigl(z_j\mid \theta^{(1)}\bigr) = \frac{\pi^{(1)} \bigl(p^{(1)}\bigr)^{y_j}\bigl(1-p^{(1)}\bigr)^{1 - y_j}}{\pi^{(1)}\bigl(p^{(1)}\bigr)^{y_j}\bigl(1 - p^{(1)}\bigr)^{1 - y_j} + \bigl(1 - \pi^{(1)}\bigr)\bigl(q^{(1)}\bigr)^{y_j}\bigl(1 - q^{(1)}\bigr)^{1 - y_j}} = 0.5$ M 步：$$\begin{aligned} \pi^{(2)} = {}&amp; \frac{1}{n} \sum_{j = 1}^{n}\mu_j^{(2)} = 0.5; \\ p^{(2)} = {}&amp; \frac{\sum_{j = 1}^{n}\mu_j^{(2)}y_j}{\sum_{j = 1}^{n}\mu_j^{(2)}} = 0.6; \\ q^{(2)} = {}&amp; \frac{\sum_{j = 1}^{n}\bigl(1 - \mu_j^{(2)}\bigr)y_j}{\sum_{j = 1}^{n}\bigl(1 - \mu_j^{(2)}\bigr)} = 0.6. \end{aligned}$$ 考虑到 $\theta^{(1)} = \theta^{(2)} = (\pi = 0.5, p = 0.6, q = 0.6)$，参数已趋于稳定，故而迭代结束。 注意，EM 算法迭代的结果是对初值敏感的。例如，对于三硬币模型，若初值取 $\theta^{(0)} = (\pi^{(0)} = 0.4, p^{(0)} = 0.6, q^{(0)} = 0.7)$，则迭代结果为 $\hat\theta = \bigl(\hat{\pi}=0.4064, \hat{p}=0.5368, \hat{q} = 0.6432\bigr)$。 EM 算法的理论推导数学工具凸函数定义在实数域上的一元函数 $f(x)$，若对于定义域内的任意自变量都成立不等式 $f’’(x) \geqslant 0$，则称该函数是凸函数；若严格成立不等式 $f’’(x) &gt; 0$，则称该函数是严格凸函数。 定义在实数域上的多元函数 $f(x_1, x_2, \ldots, x_n)$，若对于定义域内的任意自变量其海森矩阵是半正定的，则称该函数是凸函数；若海森矩阵是正定的，则称该函数是严格凸函数。 期望对于连续随机变量 $X$，若其概率密度函数为 $f(x)$，则其期望定义为 $$E[X] = \int_{-\infty}^{+\infty} x\cdot f(x)\mathop{}\!\mathrm{d}x.$$ 设随机变量 $Y = g(X)$，则其期望是 $$E[Y] = \int_{-\infty}^{+\infty} g(x)\cdot f(x)\mathop{}\!\mathrm{d}x.$$ 琴生（Jensen）不等式假设 $\mu$ 是集合 $\Omega$ 的正测度，并且 $\mu(\Omega) = 1$。又设 $g$ 是勒贝格（Lebesgue）可积的实值函数，而 $\varphi$ 是定义在 $\mathbb{R}$ 上的凸函数，则成立琴生不等式 $$\varphi\Bigl(\int_{\Omega} g\mathop{}\!\mathrm{d}\mu\Bigr) \leqslant \int_{\Omega}\varphi\circ g\mathop{}\!\mathrm{d}\mu.$$ 以概率论的语言来说，$\mu$ 显然是个概率测度。此时，若 $g$ 表示随机变量 $X$，则在 $\Omega$ 上，随机变量相对概率测度的积分其实是期望。此时，琴生不等式转化为 $$\varphi\bigl(E[X]\bigr) \leqslant E\bigl(\varphi[X]\bigr).$$ 问题的数学表述对于 $m$ 个相互独立的样本 $x_1$, $x_2$, …, $x_m$，有观测数据 $y_1$, $y_2$, …, $y_m$，以及隐含数据 $z_1$, $z_2$, …, $z_m$。此时，$(y)$ 为不完全数据，而 $(y, z)$ 是完全数据。 面对不完全数据建立的概率模型（\ref{star} 式）会含有隐变量： $$\begin{aligned} H(\theta) = {}&amp; L(\theta) \\ = {}&amp; \ln p(Y \mid \theta) \\ = {}&amp; \ln \sum_{z} p(Y, Z\mid \theta) \\ = {}&amp; \ln \Bigl(\sum_{z} p(Z \mid \theta)p(Y \mid Z, \theta)\Bigr) \end{aligned}$$ 因此，极大化问题事实上变成了 $$\hat\theta, \hat z = \underset{\theta, z}{\arg\,\max}H(\theta, z).$$ 此时，若以极大似然估计的解法思路，对 $\theta$ 和 $z$ 求导，而后直接求解极大似然方程或者梯度上升，其表达式会非常复杂。因此，很难求得它的解析解。 构造似然函数下界我们的目的是极大化（对数）似然函数 $H(\theta)$。因此对于第 $i + 1$ 轮迭代，我们希望找到新的 $\theta$ 使得 $H\bigl(\theta\bigr) &gt; H\bigl(\theta^{(i)}\bigr)$。 因此，我们考虑（凹函数的）琴生不等式 $$\begin{aligned} H(\theta) = {}&amp; \ln \Bigl(\sum_{z} p(Z \mid \theta)p(Y \mid Z, \theta)\Bigr) \\ = {}&amp; \ln \biggl(\sum_{z}p(Z\mid Y, \theta^{(i)}) \cdot \frac{p(Z \mid \theta)p(Y \mid Z, \theta)}{p(Z\mid Y, \theta^{(i)})}\biggr) \\ \geqslant {}&amp; \sum_{z} p(Z\mid Y, \theta^{(i)}) \ln \biggl(\frac{p(Z \mid \theta)p(Y \mid Z, \theta)}{p(Z\mid Y, \theta^{(i)})}\biggr). \end{aligned}$$ 注意到 $\sum_{z} p(Z\mid Y, \theta^{(i)}) = 1$，于是考虑做差 $$\begin{aligned} H(\theta) - H(\theta^{(i)}) \geqslant {}&amp; \sum_{z} p(Z\mid Y, \theta^{(i)}) \ln \biggl(\frac{p(Z \mid \theta)p(Y \mid Z, \theta)}{p(Z\mid Y, \theta^{(i)})}\biggr) - \ln p(Y\mid \theta^{(i)}) \\ = {}&amp; \sum_{z} p(Z\mid Y, \theta^{(i)}) \ln \biggl(\frac{p(Z \mid \theta)p(Y \mid Z, \theta)}{p(Z\mid Y, \theta^{(i)}) p(Y\mid \theta^{(i)})}\biggr). \end{aligned}$$ 于是，令 $$B\bigl(\theta,\theta^{(i)}\bigr) \overset{\text{def}}{=} H(\theta^{(i)} + \sum_{z} p(Z\mid Y, \theta^{(i)}) \ln \biggl(\frac{p(Z \mid \theta)p(Y \mid Z, \theta)}{p(Z\mid Y, \theta^{(i)}) p(Y\mid \theta^{(i)})}\biggr),$$ 则有 $H(\theta) \geqslant B\bigl(\theta,\theta^{(i)}\bigr)$，并且有 $H\bigl(\theta^{(i)}\bigr) = B\bigl(\theta^{(i)},\theta^{(i)}\bigr)$。因此，实际上我们已经构造了 $H(\theta)$ 的一个下界 $B\bigl(\theta,\theta^{(i)}\bigr)$，即完成了 E 步。接下来，我们要想办法提升这个下界（M 步）。 优化目标考虑到提升 $B\bigl(\theta,\theta^{(i)}\bigr)$ 就能提升 $H(\theta)$。原始的优化问题转化为： $$\begin{aligned} \theta^{(i + 1)} = {}&amp; \underset{\theta}{\arg\,\max} B\bigl(\theta,\theta^{(i)}\bigr) \\ = {}&amp; \underset{\theta}{\arg\,\max} \Biggl[H\bigl(\theta^{(i)}\bigr) + \sum_{z} p(Z\mid Y, \theta^{(i)}) \ln \biggl(\frac{p(Z \mid \theta)p(Y \mid Z, \theta)}{p(Z\mid Y, \theta^{(i)}) p(Y\mid \theta^{(i)})}\biggr)\Biggr] \\ = {}&amp; \underset{\theta}{\arg\,\max} \Biggl[\sum_{z} p(Z\mid Y, \theta^{(i)}) \ln \bigl(p(Z \mid \theta)p(Y \mid Z, \theta)\bigr) + H\bigl(\theta^{(i)}\bigr) - \sum_{z} p(Z\mid Y, \theta^{(i)}) \ln \bigl(p(Z\mid Y, \theta^{(i)}) p(Y\mid \theta^{(i)})\bigr)\Biggr] \\ = {}&amp; \underset{\theta}{\arg\,\max} \Biggl[\sum_{z} p(Z\mid Y, \theta^{(i)}) \ln \bigl(p(Z \mid \theta)p(Y \mid Z, \theta)\bigr) \Biggr] \qquad\text{// 省略相对 $\theta$ 的常数项} \\ = {}&amp; \underset{\theta}{\arg\,\max} \Biggl[\sum_{z} p(Z\mid Y, \theta^{(i)}) \ln p(Y, Z \mid \theta) \Biggr] \end{aligned}$$ 于是，令 $$Q(\theta, \theta^{(i)}) \overset{\text{def}}{=} \sum_{z} p(Z\mid Y, \theta^{(i)}) \ln p(Y, Z \mid \theta).$$ 这即是在 M 步我们需要优化的目标。 EM 迭代算法 输入：观测变量数据 $Y$，隐变量数据 $Z$，给定参数 $\theta$ 时观测变量和隐变量的联合分布 $p(Y, Z\mid\theta)$，给定观测变量和参数 $\theta$ 时隐变量 $Z$ 的条件分布 $p(Z\mid Y, \theta)$。 输出：模型参数 $\theta$。 设置参数初值 $\theta^{(0)}$。 开始迭代，直至 $\theta$ 收敛： E 步，计算 $$Q(\theta, \theta^{(i)}) \overset{\text{def}}{=} \sum_{z} p(Z\mid Y, \theta^{(i)}) \ln p(Y, Z \mid \theta).$$ M 步，解最优化问题 $$\theta^{(i + 1)} = \underset{\theta}{\arg\,\max} Q(\theta, \theta^{(i)}).$$ 可见，在模型输入中包含联合分布和条件分布。这印证了我们之前说的：「EM 算法同极大似然法一样，需要预先假定分布」。 EM 算法的收敛性考虑 EM 算法在迭代过程中产生的参数估计序列 ${\theta^{(i)}}$，以及据此计算的对数似然函数序列 ${H(\theta^{(i)}) = \ln p(Y\mid\theta^{(i)} = B(\theta^{(i)}, \theta^{(i)})}$。 考虑到在 EM 迭代算法中有： $$B(\theta^{(i + 1)}, \theta^{(i + 1)}) \geqslant B(\theta^{(i + 1)}, \theta^{(i)}) \geqslant B(\theta^{(i)}, \theta^{(i)}).$$ 因此，上述对数似然函数序列是单调递增的。又考虑到似然函数是概率，故而上述对数似然函数序列有上界。根据单调有界原理，上述对数似然函数序列必然收敛。不过，这并不意味着参数的估计序列 ${\theta^{(i)}}$ 必然收敛。因此，在实际使用过程中，EM 算法的终止条件除了 $\bigl\lVert\theta^{(i + 1)} - \theta^{(i)}\bigr\rVert &lt; \varepsilon_1$ 之外，还应包含 $\bigl\lVert Q\bigl(\theta^{(i + 1)}, \theta^{(i)}\bigr) - Q\bigl(\theta^{(i)}, \theta^{(i)}\bigr)\bigr\rVert &lt; \varepsilon_2$。 此外，由于 EM 算法对初值敏感。故而，尽管 EM 算法能保证收敛，但不保证一定能收敛到全局最优解。因此，使用 EM 算法时，往往需要设置多个初值，估计多套模型参数。最后再将模型参数代入模型，比较模型的效果，选出其中最好的作为最终结果。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>EM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博弈论通俗演义：海盗分金问题与特朗普当选]]></title>
    <url>%2F2018%2F11%2F07%2Fpirates-and-golds-and-president-Trump%2F</url>
    <content type="text"><![CDATA[此篇开始，讲讲博弈论通俗演义。这是第一篇，谈谈海盗分金问题。 海盗分金问题描述海盗分金的问题描述如下： 三个聪明的海盗 A, B, C 分抢来的 100 枚金币。关于如何分赃，三人并未达成一致；于是三人按照「海盗之神」的指示，以这样的方式决定如何分赃： 按 A, B, C 的顺序，依次提出自己分赃的方案。 尚存活的人，对刚刚提出的方案进行表决 如若分赃方案得到过半（不包含一半）人的认可，则按方案执行，而后分赃结束； 否则，立即把提出方案的人丢到船下喂鲨鱼，剩下的人继续依次提出自己的方案。 海盗总是谨慎而贪婪的： 他们首先总是想要保全自己的性命； 他们总是想得到尽可能多的金币； 并且在得到金币数量相等的情况下希望干掉更多的对手（某种意义上，这是一种短视；因为干掉分赃的对手后，将来没有帮手再也抢不到金币了）。 那么现在的问题是：海盗 A 是否有办法保住自己的性命，并且获得尽可能多的金币？ 逆向推理乍看起来，不论 A 怎样提出建议，B 和 C 都有可能不满而否决 A 的提议，从而「票死」A。因此 A 是危险的。但是这个问题不能简单地凭感觉，而需要逆向去推理。 C首先我们假设，A 和 B 都因为提议不通过而被票死了。现在只剩下了 C。那么毫无疑问，C 是最后的赢家：他不仅独得 100 枚金币，而且干掉了所有的竞争对手。 B 和 C接下来我们假设 A 因为提议不通过而被票死了。现在剩下了 B 和 C。 考虑到 B 是聪明谨慎而贪婪的：他希望自己活下去，而不希望自己死掉 C 独得 100 枚金币。但是，不论 B 提出何等建议——哪怕 B 将金币全都分给 C——C 都会否决提议而票死 B。因此，B 如果想要活下去，就不能让 A 被票死。 A, B 和 C现在我们回到原始问题。 考虑到 A 是聪明谨慎而贪婪的，B 能分析得到的结果，A 也能分析得出。因此 A 明白，不论 A 提出何等苛刻的提议，B 为了保全自己，都必须同意——哪怕 A 不给 B 哪怕一枚金币。而有了 B 的支持，A 自己必然支持自己的提议，因此 A 不会被票死，同时能提出任何可能的提议从而确保自己的利益。 结论A 可以选择独吞 100 枚金币，B 出于保全自身的目的必然同意 A 的提议，此时 C 的选择不重要。结局是 A 不会死，并且可以独吞 100 枚金币。 扩展一下问题现在假设有一个新人 M 加入了分赃的行列，并且 M 在 A 之前提议。情况又会发生怎样的变化呢？ 我们同样从逆向推理。那么若 M 被票死，问题就回退到了原始问题。此时 A 独吞所有金币而 B 与 C 毫无所得。这个结局是 M, A, B 和 C 都能预见到的。因此出于自保，M 不希望自己被票死；出于贪婪，B 和 C 希望不要毫无所得。于是 M 可以提议给 B 和 C 各 1 枚金币——这至少比票死 M 而后什么都得不到要好——而后 M 自己得到剩下的 98 枚金币。在这种情况下，B 和 C 会支持 M 的提议，而 A 什么都得不到。 海盗分金的要义和模型海盗分金问题，实际上是建立在人性本恶基础上，对这个世界的黑暗进行的一次建模。海盗分金问题里，所有的要点在真实世界里都有东西与之对应。因此，海盗分金这个游戏本身，能说明真实世界的很多问题。 海盗分金 真实世界 提议顺序 话语权顺序 海盗之神 法律以及约定俗成的规约 金币 （各种形式的）利益 投票 （人人均等的）投票权 分赃 利益分配 分赃提议 利益分配的方式 提议顺序与投票致死 话语权不同的人有对等的投票权 先发优势不论是原始的海盗分金问题还是扩展后的海盗分金问题，最终的「大赢家」实际上都是首先提议的海盗。我们将这种现象称之为先发优势。具有先发优势的人，能尽可能多地权衡各个利益相关方的心思，从而决定对自己最有利的利益分配方式，从而最终获得最大的利益。 拉拢底层在扩展的海盗分金问题当中，M 不能像原始问题当中的 A 一样独吞所有金币。这是因为尽管话语权有大小，但是人人都有公平的投票权。这实际上形成了对先发优势的一种制衡。因此，M 为了保全自身，必须拉拢话语权最低的 B 和 C，获取他们的支持，以便在投票中获胜。 而另一方面，由于 B 和 C 的话语权最低，所以某种意义上说，他们是「最惨」的那一批。也因而，他们是最容易拉拢的（最短视的、最容易小富即安的）。 特朗普当选美国总统，用的就是这种策略。在「让美国再次强大」、「美国优先」和「降低失业率」等口号下，暗藏的其实是对基数庞大的底层人民的拉拢。于是，他其实只需要付出很少的利益给底层人民，就能获取大量的票数支持——甚至赢下了很多传统蓝州，从而最终赢得选举。 报团取暖在扩展的海盗分金问题当中，最尴尬的就是原本能独得 100 枚金币的 A 了。话语权的降低，让他丧失先发优势；话语权不够高，又让他失去了被拉拢的价值——因为拉拢他代价很大，但获得的票数很少。这种「不上不下」地位的人，在利益分配面前，往往是最尴尬的。也所以，创业艰难，共苦容易同甘难。 那么 A 是否有机会「翻身」呢？这就需要所谓的「报团取暖」了。但是抱团取暖的策略总是能生效吗？ ——关于这个问题以及更多关联相似问题分析讨论过于暗黑；因此留待读者自己分析。分析完成后，你也就能明白为什么这类人总是「战战兢兢」了。]]></content>
      <categories>
        <category>Mathematics and Natural Sciences</category>
      </categories>
      <tags>
        <tag>Game Theory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 C++ 中的 switch-case 语句中使用 C 风格字符串]]></title>
    <url>%2F2018%2F11%2F05%2Fapply-C-style-string-in-switch-case-clause%2F</url>
    <content type="text"><![CDATA[众所周知，C/C++ 语言中的 switch-case 语句只支持整型数字的逻辑分支。因此，当我们需要对整型数字之外的变量进行分支判断时，就只能依赖 if-else 语句了。例如： 1234567if (policy == "SINGLE") &#123; ; // do something&#125; else if (policy == "MULTIPLE") &#123; ; // do something&#125; else &#123; // UNSPECIFIED ; // do something&#125; 这种情况下，虽然我们用 if-else 语句实现了类似 switch-case 语句的功能。但一方面写起来未免麻烦，分支多了难以维护；另一方面如果分支很多，那么执行起来需要注意进行字符串相等性判断，效率很低。因此，这篇文章尝试通过一些取巧的方式来解决这个问题。 HASH无论如何，语言层面的 swtch-case 限制是绕不开的。因此，我们需要找到一个有效的办法，将字符串与整形数字对应起来。虽然不甚完美，但是 Hash 是一种解决办法。于是我们针对 C 风格的字符串定义 Hash 函数。 123456789101112131415using hash_t = size_t;constexpr hash_t prime = 0x100000001B3ull;constexpr hash_t basis = 0xCBF29CE484222325ull;hash_t hash_run_time(const char* str) &#123; hash_t ret = basis; while (*str) &#123; ret ^= *str; ret *= prime; str++; &#125; return ret;&#125; 如此，我们「似乎」便可以针对字符串使用 switch-case 语句了。 123456789101112131415void simple_switch(const char* str) &#123; switch (hash_run_time(str)) &#123; case hash_run_time("first"): std::cout &lt;&lt; "1st" &lt;&lt; std::endl; break; case hash_run_time("second"): std::cout &lt;&lt; "2nd" &lt;&lt; std::endl; break; case hash_run_time("third"): std::cout &lt;&lt; "3rd" &lt;&lt; std::endl; break; default: std::cout &lt;&lt; "Default..." &lt;&lt; std::endl; &#125;&#125; constexpr 函数然而，如果你编译这段代码，编译器就会提醒你在 case 处必须使用常量表达式。因此，对于 case 的分支选项，我们不仅要将他们转换为整型 hash_t，还必须保证它们在编译期就能运算完成，从而作为常量表达式。考虑到，在 C++11 中常量表达式函数必须只能有一个 return 语句（在 C++14 之后就没有这个限制了），因此我们需要借助 C++ 中的三元运算符 ?: 将 hash_run_time 函数改造为递归形式。 123constexpr hash_t hash_compile_time(const char* str, hash_t last_value = basis) &#123; return *str ? hash_compile_time(str + 1, (*str ^ last_value) * prime) : last_value;&#125; 同时，simple_switch 函数也需要改造一下： 123456789101112131415void simple_switch(const char* str) &#123; switch (hash_run_time(str)) &#123; case hash_compile_time("first"): std::cout &lt;&lt; "1st" &lt;&lt; std::endl; break; case hash_compile_time("second"): std::cout &lt;&lt; "2nd" &lt;&lt; std::endl; break; case hash_compile_time("third"): std::cout &lt;&lt; "3rd" &lt;&lt; std::endl; break; default: std::cout &lt;&lt; "Default..." &lt;&lt; std::endl; &#125;&#125; 此时，simple_switch 函数已可通过编译。 事实上，用于处理输入的 hash_run_time 也可以被 hash_compile_time 替代。 用户定义的字面值常量后缀尽管此时代码已经可以通过编译并使用，但在每个 case 处都写一个函数调用未免麻烦。于是我们需要引入用户定义的字面值常量后缀（User-defined suffix）简化代码。 123constexpr hash_t operator "" _hash(const char* p, size_t) &#123; return hash_compile_time(p);&#125; 于是，simple_switch 函数可被简化为： 123456789101112131415void simple_switch(const char* str) &#123; switch (hash_run_time(str)) &#123; case "first"_hash: std::cout &lt;&lt; "1st" &lt;&lt; std::endl; break; case "second"_hash: std::cout &lt;&lt; "2nd" &lt;&lt; std::endl; break; case "third"_hash: std::cout &lt;&lt; "3rd" &lt;&lt; std::endl; break; default: std::cout &lt;&lt; "Default..." &lt;&lt; std::endl; &#125;&#125; 完整的测试代码可见：https://gist.github.com/25dcb10e55b3cb2306931aa277355bbf。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>constexpr</tag>
        <tag>user-defined suffix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTeX 幻灯片模板：easy_slides]]></title>
    <url>%2F2018%2F10%2F29%2Feasy-slides-template%2F</url>
    <content type="text"><![CDATA[这是一篇非常图省事儿的模板发布文章。发布的内容如题，是我自用的一个简易的 LaTeX 幻灯片模板——easy_slides。由于我需要做演示的场景相对严肃、学术，所以我不会需要过多的效果。因此，模板基于标准模板类 article 简单修改而来。主要来说修改有二： 版面尺寸修改为适合幻灯片播放的 4:3 的样式； 利用以前实现过的水印功能，给幻灯片贴上了一个背景图。 由于我需要做演示的场景常与代码打交道，所以对 listings 提供的代码列印环境做了一些设置。 以上基本就是 easy_slides 的全部内容了。 本模板主要目的为自用，不接受任何批判、提问和特性请求；但欢迎使用、fork、改进。 GitHub 项目地址：https://github.com/Liam0205/easy_slides/ GitHub 最新发布：https://github.com/Liam0205/easy_slides/releases/latest]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Template</tag>
        <tag>Slides</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站改版之域名迁移的一些经验]]></title>
    <url>%2F2018%2F10%2F15%2Fwebsite-revise-domain-name%2F</url>
    <content type="text"><![CDATA[今天起，始终博客的域名从 liam0205.me 正式迁移至 liam.page。希望继续能为大家贡献高质量的技术文章。 以下是综合检索到的关于网站改版之域名迁移的一些经验。 保证资源可用：301 重定向虽然迁移域名，但是互联网上已经存在了很多指向老域名的外链。为了保证这些外链依旧可用，不会死链，我们需要为全站所有链接做 HTTP 301 永久重定向。 301 重定向的实现方法有很多，这里不做展开，请自行搜索。 保证搜索引擎收录和权重迁移作为个人技术博客，搜索引擎的自然搜索是一大流量来源。虽然不指望靠着博客流量挣钱，但是也不会希望因为网站域名切换导致流量大幅下降。因此，做好搜索引擎的收录和权重迁移工作还是很重要的。为此，你需要首先了解到哪些搜索引擎为你贡献了较大比例的流量。 对于始终博客来说，Google、Bing、Baidu、360 So 贡献了较大的流量。因此我们首先需要在这四个搜索引擎的站长平台上注册并验证新旧两套域名的所有权。而后，进行站点改版提交。 Google Webmaster - 站点迁移帮助 Bing - 站点工具 -&gt; 站点移动 Baidu - 优化与维护 -&gt; 网站改版 360 So - 优化与维护 -&gt; 改版收录保护 最后，我们需要在这些站长平台上，提交新的网站地图。如此，等待搜索引擎收录及权重迁移即可。这个过程可能持续长达数月，需要耐心等待。 其他资源迁移始终博客使用不蒜子进行网页计数。为了不使迁移后的计数只有可怜的个位数，也需要联系不蒜子的管理员进行修改。为此，需要加入不蒜子交流群（QQ 群：419260983）联系 Bruce 进行修改。 Time Line 2018-10-15：全站 301 重定向 2018-10-15：Google、Bing、Baidu、360 So 站点迁移完成 2018-10-15：不蒜子计数迁移完成]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Search Engine</tag>
        <tag>Domain Name</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈拉格朗日乘数法]]></title>
    <url>%2F2018%2F10%2F12%2FLagrange-Multiplier-Method%2F</url>
    <content type="text"><![CDATA[拉格朗日乘数法是约瑟夫·拉格朗日（Joseph-Louis Lagrange）提出的关于多元函数在有若干等式约束条件情况下求解最优化问题的解法。由于它在最大熵模型中有应用，所以在谈最大熵模型之前，首先要讲讲拉格朗日乘数法。 最简情形下的拉格朗日乘数法描述现在假设说有自变量 $x$ 和 $y$，以及关于它们的二元函数 $f(x, y)$，另有关于它们的等式约束条件 $g(x, y) = c$。现在的问题是，求解函数 $f$ 在约束条件 $g = c$ 下的最大值或最小值。显然，这是一个最优化问题，可简记为（以求最大值为例） $$ \begin{aligned} &amp;{}\max f(x, y), \\ &amp;{}\text{s.t. } g(x, y) = c. \end{aligned} $$ 拉格朗日乘数法是说，上述问题可转化为求解拉格朗日函数在无约束条件下的极值求解问题， $$ \mathcal{L}(x, y, \lambda) \overset{\text{def}}{=}f(x, y) + \lambda\cdot g(x, y). $$ 亦即求解拉格朗日函数驻点的问题 $$ \begin{cases} \frac{\partial \mathcal{L}}{\partial x} = 0, \\ \frac{\partial \mathcal{L}}{\partial y} = 0, \\ \frac{\partial \mathcal{L}}{\partial \lambda} = 0. \end{cases} $$ 这是关于 $x$, $y$ 和 $\lambda$ 的方程组，而它的解可能不止一个。拉格朗日乘数法说明，原优化问题的解必然处于该方程组的解集之中，只需对比解集中的点 $(x, y)$ 在原函数 $f(x, y)$ 中的值，即可得到原函数在等式约束条件下的最值。 证明拉格朗日乘数法的证明不难，简单（并不完全严格但足以说明问题）证明如下： 设二元函数 $f(x, y)$ 在点 $(x_0, y_0)$ 处有极值 $\kappa$，并且在点 $(x_0, y_0)$ 的领域内连续，则在点 $(x_0, y_0)$ 处有 $$f(x_0, y_0) = \kappa.$$ 另有一作为等式约束条件的常值函数 $g(x, y) = c$。显然，两个函数在点 $(x_0, y_0)$ 处的全微分有 $$ \begin{aligned} \mathrm{d}f =&amp;{} \frac{\partial f}{\partial x}\mathrm{d}x + \frac{\partial f}{\partial y}\mathrm{d}y = 0, \\ \mathrm{d}g =&amp;{} \frac{\partial g}{\partial x}\mathrm{d}x + \frac{\partial g}{\partial y}\mathrm{d}y = 0. \end{aligned} $$ 考虑微分 $\mathrm{d} x$ 和 $\mathrm{d}y$ 是任意的无穷小量，故两个方程关于两个微分的系数应当成比例。这就是说 \begin{equation} \begin{cases} \frac{\partial f}{\partial x} - \lambda\cdot\frac{\partial g}{\partial x} = 0, \\ \frac{\partial f}{\partial y} - \lambda\cdot\frac{\partial g}{\partial y} = 0. \end{cases}\tag{*}\label{star} \end{equation} 二式相加并积分即得拉格朗日函数 $$ \mathcal{L}(x, y, \lambda) \overset{\text{def}}{=}f(x, y) + \lambda\cdot g(x, y). $$ 这也就是说，原优化问题的解必然是拉格朗日函数的一个极值。 物理意义考虑函数 $f(x, y) = d$ 的图像。由于只有一个自由度，所以它是一条曲线。特别地，对于序列 $\bigl\{d_1, d_2, \ldots\bigr\}$ 来说，$f(x, y) = d_k$ 形成了一系列的曲线。若将 $d_k$ 理解为高度，则这一系列的曲线即是函数 $f(x, y)$ 的等高线组。同样，对于约束 $g(x, y) = c$ 来说它也是一条曲线，我们称之为约束曲线。 据此，可绘图如下（摘自英文 Wikipedia） 现在我们需要思考的是，等高线组和约束曲线满足什么条件时，我们可以说函数 $f$ 在条件 $g = c$ 的约束下取得极值。不难理解，等高线组中的一条等高线与约束曲线相切时，函数 $f$ 可能取得极值。反过来想想就很容易理解了，假设不相切时（即相交时）取得极值，例如说在图中 $f(x, y) = d_2$ 时取得极值。如此，从交点开始沿着约束曲线的两个方向滑动，都还能继续与其它等高线相交，这与 $f(x, y)$ 取得极值矛盾。因此 $f(x, y)$ 在约束下取得极值时，函数曲线必然与约束曲线相切。 函数曲线相切，意味着两个函数的法线在切点重合，也就是两个函数的法向量相差一个系数 $\lambda$，这也就是说两个函数在切点的梯度向量相差一个系数 $\lambda$，即 $\Bigl(\frac{\partial f}{\partial x}, \frac{\partial f}{\partial y}\Bigr) = \lambda\Bigl(\frac{\partial g}{\partial x}, \frac{\partial g}{\partial y}\Bigr)$。这恰好是上述证明过程中的 (\ref{star})-式的向量表示。 因此我们说，拉格朗日乘数法有很直观的物理意义。 推广到一般情形下的拉格朗日乘数法现在假设说有自变量向量 $x_1$, $x_2$, …, $x_n$，以及关于它们的 $n$ 元函数 $f(x_1, x_2, \ldots, x_n)$，另有关于它们的一组等式约束条件 $\bigl\{g_j(x_1, x_2, \ldots, x_n) = c_j\bigr\}_K$。现在的问题是，求解函数 $f$ 在约束条件组 $\bigl\{g_j = c_j\bigr\}_K$ 下的最大值或最小值。它可以转化为求解拉格朗日函数在无约束条件下的极值求解问题， $$ \mathcal{L}(x_1, x_2, \ldots, x_n, \lambda_1, \lambda_2, \ldots, \lambda_K) \overset{\text{def}}{=} f(x_1, x_2, \ldots, x_n) + \sum_{j = 1}^{K}\lambda_jg_j(x_1, x_2, \ldots, x_n). $$]]></content>
      <categories>
        <category>Mathematics and Natural Sciences</category>
      </categories>
      <tags>
        <tag>Mathematical Optimization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈逻辑回归模型]]></title>
    <url>%2F2018%2F10%2F10%2Flogistic-regression%2F</url>
    <content type="text"><![CDATA[逻辑回归（Logistic Regression）是最简单的分类算法之一，但是在很多领域中都被广泛应用。对于大多数人来说，逻辑回归（Logistic Regression）大概是入门机器学习时学习的第一个算法。然而，并不是每个人都能讲清这个算法。这便是本文的缘由。 Logistic 函数原函数Sigmoid 函数是所有函数图像为 S-形的函数的统称。Logistic 函数是形如下式定义的函数 $$\sigma(x;\alpha) = \frac{1}{1 + \exp(-\alpha\cdot x)}.$$ 此处 $\alpha$ 是函数的参数，它调整函数曲线的形状。当参数 $\alpha = 1$ 时，它的函数曲线如下图所示，因而它是一个 Sigmoid 函数。 当 $\alpha$ 增大时，函数曲线在 $x$ 轴方向压缩，函数曲线越接近阶梯函数。反之，当 $\alpha$ 减小时，函数曲线在 $x$ 轴方向拉伸。通常，我们可以直接使用 $\alpha = 1$ 的 Logistic 函数，即： $$\sigma(x) = \frac{1}{1 +\exp(-x)}.$$ 导函数Logistic 函数的导函数具有很好的形式，具体来说： $$\begin{aligned} \sigma’(x) ={}&amp; \biggl(\frac{1}{1 +\exp(-x)}\biggr)’ \\ ={}&amp; -\frac{1}{\bigl(1 +\exp(-x)\bigr)^2}\cdot\exp(-x)\cdot(-1) \\ ={}&amp; \frac{1}{1 +\exp(-x)}\cdot\frac{\exp(-x)}{1 +\exp(-x)} \\ ={}&amp; \sigma(x)\bigl(1 - \sigma(x)\bigr)\end{aligned}$$ 模拟概率由于 Logistic 函数的值域是 $(0, 1)$ 且便于求导，它在机器学习领域经常被用来模拟概率。 具体来说，假设二分类模型有判别函数 $z = f(\vec x;\vec w)$。其表意为：当输出值 $z$ 越大，则 $\vec x$ 代表的样本为正例的概率越大；当输出值 $z$ 越小，则 $\vec x$ 代表大样本为负例的概率越大。此时，考虑到 Logistic 函数的值域，我们可以用 $P(\vec x) = \sigma\Bigl(f(\vec x;\vec w)\Bigr)$ 来表示 $\vec x$ 代表的样本为正例的概率。同时，由于 Logistic 函数便于求导，只要我们选用了合适的损失函数（例如交叉熵损失函数），我们就可以方便地将梯度下降法运用在求解参数向量 $\vec w$ 之上。 二分类的逻辑回归模型线性判别函数在上一节讨论使用 Logistic 函数模拟概率时，我们没有限制判别函数 $f(\vec x;\vec w)$ 的形式。考虑到判别函数的形式取决于模型的结构，这也就是说，我们没有限制模型的结构。事实上，对于分类问题，我们可以用任意结构的模型得到的判别函数，代入 Logistic 函数得到对概率的模拟，再引入交叉熵损失函数进行优化求解。 在讨论逻辑回归模型时，我们一般假定模型是线性的，也就是判别函数是线性函数： $$f(\vec x;\vec w) = -\vec w\cdot\vec x.$$ 定义条件概率于是，我们可以定义条件概率： $$\begin{aligned} P(Y = 1\mid X = \vec x) ={}&amp; \sigma(-\vec w\cdot\vec x), \\ P(Y = 0\mid X = \vec x) ={}&amp; 1 - \sigma(-\vec w\cdot\vec x).\end{aligned}$$ 考虑正负例定义的对称性，我们也可以反过来将条件概率定义为： $$\begin{aligned} \pi(\vec x) \overset{\text{def}}{=} P(Y = 1\mid X = \vec x) ={}&amp; 1 - \sigma(-\vec w\cdot\vec x) = \frac{\exp(\vec w\cdot\vec x)}{1 + \exp(\vec w\cdot\vec x)}, \\ P(Y = 0\mid X = \vec x) ={}&amp; \sigma(-\vec w\cdot\vec x) = \frac{1}{1 + \exp(\vec w\cdot\vec x)}.\end{aligned}$$ 这即是经典的逻辑回归模型中条件概率的定义。 几率与对数几率事件的几率（odds）是该事件发生的概率与不发生的概率的比值。即，若假设事件发生的概率为 $p$，则其几率为 $$\text{odds} \overset{\text{def}}{=} \frac{p}{1 - p}.$$ 对于逻辑回归的条件概率 $P(Y = 1\mid X = \vec x)$ 来说，它的几率是 $$\text{odds}(Y = 1\mid X = \vec x) = \exp(\vec w\cdot\vec x).$$ 于是它的对数几率（logit）是 $$\text{logit}(Y = 1\mid X = \vec x) \overset{\text{def}}{=} \ln \text{odds}(Y = 1\mid X = \vec x) = \vec w\cdot \vec x = -f(\vec x).$$ 这就是说，在逻辑回归模型中，线性判别函数 $f$ 实际上是事件发生几率的相反数。 似然与对数似然条件概率确定之后，即可求模型在训练集上的似然。显然，这是一个二项分布的问题： $$L(\vec w) \overset{\text{def}}{=} \prod_i\bigl[\pi(\vec x_i)\bigr]^{y_i}\bigl[1 - \pi(\vec x_i)\bigr]^{1 - y_i}.$$ 对连乘进行最优化求解往往是困难的，因此我们可以在其上加上对数变换，将似然函数中的连乘转换为连加来求解。考虑到对数变换是单调的，它不会影响最优化求解结果的正确性。 $$\begin{aligned} \ln L(\vec w) \overset{\text{def}}{=}{}&amp; \sum_i y_i\ln\pi(\vec x_i) + (1 - y_i)\ln\bigl(1 - \pi(\vec x_i)\bigr), \\ ={}&amp; \sum_i y_i\ln\frac{\pi(\vec x_i)}{1 - \pi(\vec x_i)} + \ln\bigl(1 - \pi(\vec x_i)\bigr), \\ ={}&amp; \sum_i y_i\cdot\vec w\cdot\vec x_i - \ln\bigl(1 + \exp(\vec w\cdot\vec x_i)\bigr).\end{aligned}$$ 于是，逻辑回归模型的最优化问题就化归为： $$\vec{ w^{*}} = \underset{\vec w}{\arg\,\max} \ln L(\vec w).$$ 此处应用的是极大似然估计。极大似然估计法使用的前提是要知道或者假设数据总体的分布。此处显然数据服从二项分布。 最大似然与最小损失最大似然是站在统计学的角度求解模型。站在机器学习的角度，则应当用最小损失的办法求解优化问题。 考虑对样本 $(\vec x, y)$ 的交叉熵损失函数： $$\begin{aligned} \ell(\vec w) \overset{\text{def}}{=}{}&amp; -y\ln P(Y = y\mid X = \vec x) - (1 - y)\ln\bigl[1 - P(Y = y\mid X = \vec x)\bigr], \\ ={}&amp; -y\ln \pi(\vec x) - (1 - y)\ln\bigl[1 - \pi(\vec x)\bigr]\end{aligned}$$ 于是有在全部训练集上的损失： $$\begin{aligned} J(\vec w) \overset{\text{def}}{=}{}&amp; \sum_i -y_i\ln \pi(\vec x_i) - (1 - y_i)\ln\bigl[1 - \pi(\vec x_i)\bigr], \\ ={}&amp; \sum_i \ln\bigl(1 + \exp(\vec w\cdot\vec x_i)\bigr) - y_i\cdot\vec w\cdot\vec x_i, \\ ={}&amp; -\ln L(\vec w).\end{aligned}$$ 这也就是说，对于逻辑回归模型来说，最小化损失函数与最大化（对数）似然是等价的。 梯度下降求解至此，我们可以用梯度下降法求解模型。基本步骤如下： 求解梯度，选择下降方向 $\nabla J(\vec w_{(i - 1)})$； 线性搜索，选择步长 $\rho^*_{(i)} = \underset{\rho}{\arg\,\min} J\bigl(\vec w_{(i - 1)} - \rho\cdot\nabla J(\vec w_{(i - 1)})\bigr)$； 更新参数，使用学习率收缩步长 $\vec w_{(i)} = \vec w_{(i - 1)} - \eta\rho^{*}_{(i)}\cdot\nabla J(\vec w_{(i - 1)})$。 正则化当模型的参数很多时，往往需要加入正则项以防止过拟合。我们可以使用前文中提到的 $L_p$-正则项，于是我们有目标函数： $$ \text{Obj}(\vec w) \overset{\text{def}}{=} J(\vec w) + \lambda_p\cdot\lVert\vec w\rVert_p. $$ 多分类的逻辑回归模型将上述二分类的逻辑回归模型推广到多分类时，即得到所谓的 Softmax 模型。它将二分类的 Logistic 函数升级为 Softmax 函数。也就是说，条件概率的形式如下： $$ P(Y = i\mid X = x, \vec w) \overset{\text{def}}{=} \frac{\exp(\vec w_i\cdot \vec x)}{\sum_j^K \exp(\vec w_j\cdot \vec x)}. $$ 而后我们可以类似地得到损失函数，并套用梯度下降等方法求解。此处略去。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Logistic Regression</tag>
        <tag>Classification</tag>
        <tag>Likelihood</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈 STL 中的 std::sort]]></title>
    <url>%2F2018%2F09%2F18%2Fstd-sort-in-STL%2F</url>
    <content type="text"><![CDATA[前些天在 Bilibili 上看到一个视频（6 分钟演示 15 种排序算法）。好事者戏称：「在视频中，你能听到：冒泡咕噜声、飞机坠地声、暖瓶灌水声、猴子乱叫声等等」，实在搞笑得很。 C++ 的标准模板库有一个很霸气的解读：「标准模板库里的任意算法、数据结构，你找不到一个实现，在所有的情况下都优于标准模板库的实现；否则，它就应该进入标准模板库」。因此，对于排序问题来说，C++ 里的标准模板库中的 std::sort 可想而知是一个在绝大多数情况下都能达到极限性能的排序算法。 前文介绍的内省式排序算法正是 std::sort 采用的算法。但仅有一个理论上优秀的算法是不够的，std::sort 在内部也有很多技巧和权衡值得细细品味。这篇文章尝试来剖析 std::sort。 侯捷的《STL 源码剖析》选择了 SGI STL 2.91 版本来分析，理由是这个版本在技术层次、源代码组织、源代码可读性等方面的表现都非常好，并且这个版本代码较为稳定。本文也以这个版本为基础进行分析。 std::sort简便起见，我们分析默认版本的 std::sort，而不讨论传入仿函数 Compare 的版本。 1234567template &lt;class RandomAccessIterator&gt;inline void sort(RandomAccessIterator first, RandomAccessIterator last) &#123; if (first != last) &#123; __introsort_loop(first, last, value_type(first), __lg(last - first) * 2); __final_insertion_sort(first, last); &#125;&#125; 这是一个函数模板，接受两个随机访问迭代器 first 和 last。两个随机访问迭代器构成了待排序的左闭右开区间 [first, last)。注意，这里假设 last 不会先于 first。显然，此时区间的有效性等价于 first != last。 内部的 __introsort_loop 即是上一篇文章介绍的内省式排序的实现。__final_insertion_sort 则是插入排序，参照前文它在几乎有序的情况下效率很高。因此 std::sort 在内省式排序基本完成任务后调用插入排序以提升效率。 __introsort_loop1234567891011121314151617template &lt;class RandomAccessIterator, class T, class Size&gt;void __introsort_loop(RandomAccessIterator first, RandomAccessIterator last, T*, Size depth_limit) &#123; while (last - first &gt; __stl_threshold) &#123; if (depth_limit == 0) &#123; partial_sort(first, last, last); return; &#125; --depth_limit; RandomAccessIterator cut = __unguarded_partition (first, last, T(__median(*first, *(first + (last - first) / 2), *(last - 1)))); __introsort_loop(cut, last, value_type(first), depth_limit); last = cut; &#125;&#125; 这是内省式排序的实现，它接收 4 个参数：前两个参数对应 std::sort 的左闭右开区间，第三个参数利用 Type Traits 获取待排序区间元素的类型，第四个参数则是前文提到的递归深度限制。 __stl_threshold__stl_threshold 是一个预定义的宏，它对应前文提到的超参数。当左闭右开区间的长度不大于该超参数时，可以认为序列基本有序，于是退出内省式排序，转向插入排序。 if (depth_limit == 0) 与 --depth_limit这是内省式排序判断快排递归恶化的一步。每次 __introsort_loop 的递归，参数 depth_limit 都会自减一次；当该参数为 0 时，意味着递归深度已经很深，很可能快排掉入了陷阱，因此调用堆排，并退出递归。 12345678910111213141516template &lt;class RandomAccessIterator, class T, class Compare&gt;void __partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, T*, Compare comp) &#123; make_heap(first, middle, comp); for (RandomAccessIterator i = middle; i &lt; last; ++i) if (comp(*i, *first)) __pop_heap(first, middle, i, T(*i), comp, distance_type(first)); sort_heap(first, middle, comp);&#125;template &lt;class RandomAccessIterator, class Compare&gt;inline void partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, Compare comp) &#123; __partial_sort(first, middle, last, value_type(first), comp);&#125; 值得一提的是，在 std::sort 当中，内省式排序的 depth_limit 初始值是 __lg(last - first) * 2，即 $2\log_2{n}$。这与前文的分析是一致的。 递归结构处理过恶化情况后，理应是正常的快排算法的实现了。快排是一个典型的递归算法，写起来其实很简单： 1234qsort(first, last): cut = partition(first, last, pivot) // pivot is picked in [first, last) qsort(cut + 1, last) qsort(first, cut) 这无非是先分割，然后递归分别处理左右子序列。但是 std::sort 里的快排，生生写成了类似这样： 123456qsort(first, last): while (valid) &#123; cut = partition(first, last, pivot) qsort(cut + 1, last) last = cut &#125; 这里先分割，然后递归处理右子序列，左子序列则通过重新设置 last 的位置交由下一轮循环处理。这种处理方式节省了一半的递归调用开销；在待排序序列非常长的时候，无疑能提高不少效率。可谓「为了效率，无所不用其极」。 pivot 的选择前文提到，快排掉入陷阱的根本原因是主元选择得不好导致分割没有带来任何新的信息量。具体来说，就是主元选择了序列中最大或最小的元素。 1__median(*first, *(first + (last - first) / 2), *(last - 1)) 为了避免这种情况，std::sort 中的快排，主元选择了首元素、尾元素和中央位置元素三者中的中位数。这样一来，除非这三个元素都是最大值或最小值，不然三者的中位数不会是整个序列的最大值或最小值，从而不容易让快排掉入陷阱。 __unguarded_partition快排的核心是根据主元对序列进行分割。std::sort 当中使用了 __unguarded_partition 函数进行这一操作。 12345678910111213template &lt;class RandomAccessIterator, class T&gt;RandomAccessIterator __unguarded_partition(RandomAccessIterator first, RandomAccessIterator last, T pivot) &#123; while (true) &#123; while (*first &lt; pivot) ++first; // 1.2 --last; // 2.1 while (pivot &lt; *last) --last; // 2.2 if (!(first &lt; last)) return first; // 3. iter_swap(first, last); // 4. ++first; // 1.1 &#125;&#125; 函数接受 3 个参数，分别是左闭右开区间的迭代器和主元的值。 (1.1) 和 (1.2) 配合，将 first 迭代器后移，指向第一个不小于主元的元素。(2.1) 和 (2.2) 配合，将 last 迭代器前移，指向第一个不大于主元的元素。在 (3) 处的判断，若第一个不小于主元的元素不先序于第一个不大于主元的元素，则说明分割已经完毕，返回第一个不小于主元的元素的位置，即 first 的当前值；否则，在 (4) 处交换 first 和 last 指向元素的值。参考《STL 源码剖析》的图示： 对于该函数有两个地方值得一提： 函数没有进行任何边界判断而不会陷入死循环的原因是 pivot 是 [first, last) 内的元素，因此在循环中 first 和 last 必然会破坏先序关系（不一定是交错）。避免边界判断，又节省了不少比较开销。 不同于标准的 partition 返回主元的分割位置，__unguarded_partition 返回的是第一个不小于主元的元素位置。由于在 [first, last) 长度足够小时，函数会退出并交由插入排序实现，这种设计并不会影响算法的正确性。 __final_insertion_sort 在 __introsort_loop 将 [first, last) 调整为基本有序后，就会转而进入插入排序。 12345678910template &lt;class RandomAccessIterator&gt;void __final_insertion_sort(RandomAccessIterator first, RandomAccessIterator last) &#123; if (last - first &gt; __stl_threshold) &#123; __insertion_sort(first, first + __stl_threshold); __unguarded_insertion_sort(first + __stl_threshold, last); &#125; else &#123; __insertion_sort(first, last); &#125;&#125; 函数模板内有一个 if 分支。当区间长度较小时，直接调用 __insertion_sort；当区间长度较大时，对前 __stl_threshold 个元素调用 __insertion_sort，而对前 __stl_threshold 个元素之后的元素调用 __unguarded_insertion_sort。有了之前分析 __unguarded_partition 的经验，显然我们能猜到 __unguarded_insertion_sort 一定做了某种优化以提升性能。但我们有几个问题待解决： __insertion_sort 和 __unguarded_insertion_sort 分别是什么？它们与标准的插入排序有什么区别？各自的适用条件又是什么？ 在区间长度较长时，为什么要将前 __stl_threshold 个元素单独处理？ 为什么要对区间长度的大小进行划分？这与 __introsort_loop 中 while 循环的区间长度限制有什么联系？ 插入排序的实现标准的插入排序可以有这样的实现： 123456789101112template &lt;class RandomAccessIterator&gt;void insertion_sort(RandomAccessIterator first, RandomAccessIterator last) &#123; if (not(first &lt; last)) return; for (RandomAccessIterator i = first + 1; i != last; ++i) &#123; // 1. auto key = *i; RandomAccessIterator j; for (j = i - 1; first &lt;= j and key &lt; *j; --j) &#123; // 2. *(j + 1) = *j; // 3. &#125; *(j + 1) = key; // 4. &#125;&#125; 代码很简单。(1) 处从 first 之后的元素开始循环，假定 first 已经是排序完成的。(2) 处从目标位置 i 前一个元素向前循环，直到遇到区间头部或者遇到已排序元素小于目标元素时停止；在循环内的 (3) 处依次将大于目标元素的所有元素依次后移。(4) 处将目标元素放在目标位置。 接下来我们首先来看 __unguarded_linear_insert 的代码，它是 __insertion_sort 和 __unguarded_insertion_sort 共同依赖的内部函数。 1234567891011template &lt;class RandomAccessIterator, class T&gt;void __unguarded_linear_insert(RandomAccessIterator last, T value) &#123; RandomAccessIterator next = last; --next; while (value &lt; *next) &#123; *last = *next; last = next; --next; &#125; *last = value;&#125; __unguarded_linear_insert 函数模板的实现如其名称所展现的那样，它在对 next 迭代器的自减中，没有检查 next 迭代器是否向左超越边界。更有甚者，它根本无需输入左边界，而只需输入右边界迭代器和带插入元素的值即可；这也意味着，__unguarded_linear_insert 不是完整的插入排序的实现。事实上，它只完成了原版插入排序中 (2)(3)(4) 的部分功能。 显然，这种情况下，为了保证函数执行的正确性，函数必然有额外的前提假设。此处假设应当是：while 循环会在 next 迭代器向左越界之前停止；这也就是说，在 [first, last) 之间必然存在不大于 value 的元素。因此，为防止越界，在调用该函数模板之前，我们必须要保证这一假设成立。 接下来我们来看内部函数 __linear_insert 的实现。 1234567891011template &lt;class RandomAccessIterator, class T&gt;inline void __linear_insert(RandomAccessIterator first, RandomAccessIterator last, T*) &#123; T value = *last; if (value &lt; *first) &#123; copy_backward(first, last, last + 1); *first = value; &#125; else &#123; __unguarded_linear_insert(last, value); &#125;&#125; __linear_insert 函数模板的意图是将 last 所指向的元素插入到正确位置，这里蕴含的前提假设是[first, last) 区间的元素是已经排好序的。在这一假设下，若 *last &lt; *first，则毫无疑问，last 指向的元素应当插入在上述区间的最前面，因此有 std::copy_backward；若不满足条件判断，则在 [first, last) 之间必然存在不大于 value 的元素（比如至少 *first 是这样），因此可以调用 __unguarded_linear_insert 来解决问题，而不必担心在 __unguarded_linear_insert 中 next 迭代器向左越界。对于 *last &lt; *first 的情况，__linear_insert 将 last - first - 1 次比较和交换操作变成了一次 std::copy_backward 操作，相当于节省了 last - first - 1 次比较操作。 利用 __linear_insert 可以将 last 指向的元素插入到已排序区间中的正确位置；而这正式标准的插入排序函数中 (2)(3)(4) 处的目的。因此 __insertion_sort 就很好理解了。 123456template &lt;class RandomAccessIterator&gt;void __insertion_sort(RandomAccessIterator first, RandomAccessIterator last) &#123; if (first == last) return; for (RandomAccessIterator i = first + 1; i != last; ++i) __linear_insert(first, i, value_type(first));&#125; 接下来我们看 __unguarded_insertion_sort 的实现。 123456789101112template &lt;class RandomAccessIterator, class T&gt;void __unguarded_insertion_sort_aux(RandomAccessIterator first, RandomAccessIterator last, T*) &#123; for (RandomAccessIterator i = first; i != last; ++i) __unguarded_linear_insert(i, T(*i));&#125;template &lt;class RandomAccessIterator&gt;inline void __unguarded_insertion_sort(RandomAccessIterator first, RandomAccessIterator last) &#123; __unguarded_insertion_sort_aux(first, last, value_type(first));&#125; __unguarded_insertion_sort_aux 是一个简单的辅助函数，其目的只是获取模板参数 T，以便正确调用 __unguarded_linear_insert。__unguarded_insertion_sort 没有边界检查，因此它一定比 __insertion_sort 要快。但由于 __unguarded_insertion_sort_aux 会从 first 开始调用 __unguarded_linear_insert；因此使用 __unguarded_insertion_sort 的条件比 __unguarded_linear_insert 更加严格。它必须保证以下假设成立：在 first 左边的有效位置上，存在不大于 [first, last) 中所有元素的元素。 回答三个问题至此我们可以回答第一个问题： __insertion_sort 实现了标准的插入排序的功能。但由于内部使用了 __linear_insert 和 __unguarded_linear_insert 内部函数，其效率比标准的插入排序效率要高。 __unguarded_insertion_sort 基本上也实现了插入排序的思想，但它实现的功能比标准的插入排序稍弱。它要求在 first 左边的有效位置上，存在不大于 [first, last) 中所有元素的元素。 以及我们可以部分回答第二个问题： __unguarded_insertion_sort 的效率比 __insertion_sort 高，因此我们应该尽可能对更多的元素使用 __unguarded_insertion_sort。但使用它是有前提的，因此至少对最头部的一些元素，我们不能使用 __unguarded_insertion_sort。 但这只是部分回答了第二个问题；因为我们仍然没有说明为什么对头部 __stl_threshold 个元素之外的元素使用 __unguarded_insertion_sort 是安全的。也即我们需要证明：头部 __stl_threshold 个元素中一定存在不小于区间 [first + __stl_threshold, last) 中所有元素的元素。 以及我们可以回答第三个问题： 若 last - first &gt; __stl_threshold 不成立，则事实上 __introsort_loop 不会对序列做任何实际操作——这是由内省式排序 while 循环的条件确保的。这种情况下，不能使用 __unguarded_insertion_sort，而是要使用具有完整排序能力的 __insertion_sort 来执行最终的插入排序操作。 完整回答第二个问题至此，我们唯独遗留的问题是要证明：头部 __stl_threshold 个元素中一定存在不小于区间 [first + __stl_threshold, last) 中所有元素的元素。 由于 __final_insertion_sort 在 __introsort_loop 之后调用，这个问题某种程度上是显然的。考虑 __introsort_loop 的两个退出条件，然后分类讨论： 因递归切分，导致 last - first &gt; __stl_threshold 不成立而退出。 因递归过深，调用堆排序而退出。 对第一种情况，考虑快排特性可知，最左侧的 [first, last) 区间的所有元素，都不大于右侧所有元素。又因为 last - first &lt;= __stl_threshold，因此在 [first, first + __stl_threshold) 中必然存在一个元素，不大于 [first + __stl_threshold, last) 中的所有元素。 对第二种情况，同样考虑快排特性，最左侧的 [first, last) 区间的所有元素，都不大于右侧所有元素。尽管此时不一定成立 last - first &lt;= __stl_threshold，但堆排保证了 first 元素是该区间内值最小的元素。因此至少它不大于 [first + __stl_threshold, last) 中的所有元素。 因此我们说，经过 __introsort_loop 之后，头部 __stl_threshold 个元素中一定存在不小于区间 [first + __stl_threshold, last) 中所有元素的元素。 结语纵观整个 std::sort 的实现，可以看到很多为了效率，而无所不用其极地对代码进行精雕细琢。作为程序员，相信没有人能对这种精湛技艺熟视无睹。欣赏 STL 代码时，我们一方面需要去理解这样做为什么是对的，还要去理解这样做为什么能提高效率。如此，才能真正吃透 STL 的代码，并能有自己的收获。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Sort</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈感冒的分类及治疗]]></title>
    <url>%2F2018%2F09%2F18%2Fclassification-of-colds%2F</url>
    <content type="text"><![CDATA[又入秋了，天气转凉的时节，患感冒的人总是很多。这篇小文是从「中日友好医院」的宣传画中总结整理出来的，谈一谈感冒的分类及治疗方式，希望能让国人走出「一感冒就吃抗生素」的误区。 一般来说的感冒，典型症状是流鼻涕、咳嗽、咯痰、发热。诱发的原因可以是细菌、普通感冒病毒、流感病毒。但是并不是所有感冒都是流涕、咳嗽、咯痰、发热这些典型症状，有些人感冒了，不流鼻涕不咳嗽，反而拉肚子，但却是也是感冒。 流感病毒分成甲乙丙三类，每类里又分不同亚型。甲流感染，症状最重，传染性最强；乙流次之，丙流又次之。每年 11 – 12 月是甲流的发病高峰，每年的 1 – 2 月是乙流的发病高峰。去年冬天，甲流乙流同时爆发，所以疫情比较重。 三甲大医院一般都有快速的甲流筛查。也就是看看让你感冒的，是不是甲流病毒。但是这些快速筛查，没法确认具体的亚型。确认具体的亚型，需要疾控中心（CDC）来做。疾控中心会定期到医院采集样本，进行分析；然后预测每年流行的流感病毒菌株，并依此研发流感疫苗。由于流感病毒亚型众多，且容易变异，所以流感疫苗都只管一年；来年如果需要疫苗保护，还得继续打疫苗。 因为病毒感染会降低人体抵抗力，所以感染了流感病毒，通常会有一些细菌引起的呼吸道的并发症。这些并发症从上呼吸道感染开始（上感），到下呼吸道感染，再到肺炎。 我们说的抗生素，也就是消炎药，包括青霉素、阿莫西林、头孢类、左氧氟沙星、阿奇霉素之类的，都是针对细菌的。抗生素对病毒感染没有任何疗效。所以在确诊病毒感染引起的感冒后，如果并发症不严重，吃消炎药没有任何意义。 反过来说，对付病毒，人类医学至今没有廉价的广谱抗病毒药物。换言之，没有便宜的特效药。不过，一般来说，感冒病毒、流感病毒的发病周期较短，预后较好，所以回家喝水泡脚睡觉，等周期过了自然就好了。这是广大前往发达国家的留学生留学期间去医院看感冒，医生说：「没什么大事，回家喝水睡觉就好了」的原因。中成药，比如连花清瘟胶囊、蓝岑口服液等等，有一定的抗病毒作用。所以密切接触流感患者的人，可以选其中一个做预防性的治疗。但是真的感染了，再吃这些药，基本没啥效果，也就是个安慰。 没有太好的抗病毒药物，治疗并发症不严重的感冒基本靠睡觉，但是架不住感冒时候人难受啊。于是就有了泰诺、白加黑、感康、康泰克之类的「对症」的药物。这些药物通常是几类物质的混合。比如有对乙酰氨基酚（退热镇痛，让人觉得口渴）、伪麻黄碱（减少鼻窦充血，抗组胺）、右美沙芬（镇咳）、扑尔敏（抗组胺，副作用让人犯困）混合而成的酚麻美敏片（泰诺就是它）。可见这四种成分的主要作用和副作用要不然对应了感冒症状，要不然对应了「多喝水多睡觉」；所以说它是对症药物。这类药物只是让人舒服一点，对抗病毒本身没有任何作用。而且有效时间一般就 4 – 6 小时，超过时间该发烧还是发烧。不过这并不是病情反复——继续吃一颗就好了。 总而言之，轻感冒喝水睡觉就好，重一点的吃点泰诺舒服一些（但是注意不要开车、高空作业），如果并发症比较严重（至少是发展到下呼吸道感染，也就是感觉咳嗽时胸口痛，咳得比较深）那就加抗生素，还不行，就去医院看看是不是发展成肺炎了让大夫开药治疗。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Cold</tag>
        <tag>Virus</tag>
        <tag>Bacterium</tag>
        <tag>Antibiotic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈内省式排序算法]]></title>
    <url>%2F2018%2F08%2F29%2Fintrospective-sort%2F</url>
    <content type="text"><![CDATA[前作站在信息论的角度，讨论了基于比较的排序算法复杂度的理论下界为 $\Omega(n\log n)$，同时指出了： 每一次判定 $ a &lt; b $，都相当于回答了一次「是否问题」。按照已有的知识，若要尽可能快地完成排序，就要让每一次大小判断的结果落在两种答案之一的概率接近；若不然，则这次比较带来的信息量较小，也就需要更多次的比较来完成排序。 此篇建立在这些知识的基础上，首先探讨以下三个问题，而后引出号称「在所有情况下，都能较快完成排序任务的内省式排序（Introspective Sort）」： 为什么堆排序一般快不过快速排序？ 快速排序快得无懈可击吗？ 插入排序什么时候快？ 回顾三种排序算法堆排序慢在哪首先回顾一下堆排序的大致流程： 在未排序部分建堆——一棵二叉树，父节点总是比子节点大； 将堆顶元素与最后一个未排序元素兑换； 回到 1，直至排序完成。 这里需要注意，在用数组实现的堆当中，父节点 $i$ 的左右子节点的位置分别是 $2i + 1$ 与 $2i + 2$，而子节点 $i$ 的父节点所在的位置是 $\bigl\lfloor \frac{i - 1}{2} \bigr\rfloor$。因此，堆排序的核心步骤实际上是在交换堆顶、堆底元素，而后重新建堆。 按照前述的原则，不难发现，堆底元素几乎是必然要小于堆顶元素的两个子节点元素。因此，在重新建堆时，原本的堆底元素与上述两个元素的比较 $ a &lt; b $ 成立的概率几乎为 0。这就意味着，在堆排序中，存在诸多类似这样「不平衡」的判断，而这些判断带来的信息量很小，因此需要额外的比较次数来提供足够的信息量。 这就是堆排序不够快的原因。具体来说，尽管在平均情况下，堆排序的时间复杂度与快速排序都是 $\Theta(n \log n)$，但是它时间复杂度的常数项要比快速排序大不少。不过，由于堆排序所需的比较次数是恒定的，所以它在最坏的情况下，复杂度也是 $\Theta(n \log n)$。这算是堆排序的一个优点。 快速排序也没有快得无懈可击快速排序的核心是选取主元（pivot），而后将小于主元的元素置于左边以及大于等于主元的元素置于右边，而后递归这个过程。 现在我们来看元素 $a$ 的比较过程。在全部 $n!$ 种排列中，满足 $a &lt; \text{pivot} $ 的排列有一半，不满足的也有一半。因此这次比较干掉了一半的可能性，nice shot！ 不失一般性，现在假定 $ a &lt; \text{pivot} $ 成立，我们来看元素 $b$ 的比较过程。在剩下的 $\frac{n!}{2}$ 种排列中，满足 $ b &lt; a &lt; \text{pivot} $、$ a &lt; b &lt; \text{pivot} $ 和 $ a &lt; \text{pivot} &lt; b $ 的各占三分之一。这也就是说，若是 $ b &lt; \text{pivot} $，则这一次判断只能排除剩下的三分之一的可能性。这次比较的效果，就不那么令人满意了。 继续下去，则每次比较所能获得的信息量会逐渐下降，距离最优的情形越来越远。特别地，若是 pivot 是序列中最大或最小的元素，则这一次分割没有排除任何可能性——完全是白费功夫。这就是为什么说快排也不是快得无懈可击，以及这就是为什么说 pivot 选择最值时是快速排序的最坏情况。 插入排序在几乎排好序的序列上很快插入排序某种意义上是最生动的排序算法了。在玩扑克牌的时候，大多数人都会使用插入排序的办法，将分派到自己的扑克牌按顺序整理好。 对于一个几乎已经排好序的序列（逆序对很少），使用堆排或快排仍然能达到 $\Theta(n \log n)$ 的时间复杂度。但是插入排序在这种情况下，只需要从头到尾扫描一遍，交换、移动少数元素即可；时间复杂度近乎 $\Theta(n)$。究其原因，堆排或快排按照各自的要求，将已经近似排好序的序列打乱，而后又排序整理，没有用到「几乎已经排好序」的先验知识，所以在这种情况下不如插入排序快就是自然的了。 内省式排序（Introspective Sort）回顾上一节的内容，我们发现： 快速排序在大多数情况下效率最高，应当是首选的排序算法。但是它在某些情况下，会掉入陷阱，复杂度恶化到 $\Theta(n^2)$。 堆排序虽然在大多数情况下不如快速排序效率高，但在所有的情况下复杂度都是 $\Theta(n \log n)$。因此若能检测到快速排序掉入陷阱，则堆排序会是一个很好的补充。 插入排序虽然复杂度虽然只能达到 $O(n^2)$，但若能已知「几乎已经排好序」，切换到插入排序的效率又要比快速排序和堆排序高出不少，能做到 $\Theta(n)$。 显然，三种排序各有优点也各有缺点。若能将它们的优点组合起来，同时避免它们各自的缺点，形成内省式排序，那就能做到在所有情况下都能以较快的速度完成排序任务了。 不难归纳，这样的内省式排序，策略应该如下： 在数据量足够大的情况使用快速排序； 在快速排序掉入陷阱时，主动切换到堆排序； 在快速排序和堆排序已经做到基本有序的情况下，或者数据量较小的情况下，主动切换到插入排序。 于是，问题就变成了，如何定义数据量足够大或者说基本有序，以及如何确定快速排序掉入了陷阱，而对效率没有伤害。现在我们来解决这些问题，从而完善整个内省式排序。 数据量足够大或者基本有序是什么意思？一般来说，当递归调用带来的开销大于递归调用后实际操作的开销时，调用快排、堆排就不太恰当了。因此，如果存在一个阈值，当待排序元素的数量小于该阈值时递归调用的开销相对较大，则该阈值的大小应当取决于机器硬件的特性（位宽、cache 性能）和待排序元素本身的特性（体积、是否对缓存友好）。 这一阈值某种意义上可以算作是算法的「超参数」，它不会在算法执行时带来额外的开销。 如何确定快速排序掉入了陷阱？通过上文的分析，我们知道，快速排序的效率主要取决于 pivot 的选择。若 pivot 恰好是待分割区间内的最大值或最小值，则这种分割没有排除任何可能的排序，因而是白费力气。既然如此，那么最平凡的方式，就是去检查所选的 pivot 是否为待分割区间内的最值即可判定快速排序是否掉入了陷阱。 然而，判定区间最值的问题，不可避免地要遍历区间内的所有元素。这也就是说，我们为了避免快速排序掉入陷阱，而使得复杂度从 $\Theta(n\log n)$ 恶化到 $\Theta(n^2)$，我们在每一次递归中，都要遍历一次所有元素。这相当于额外增加了 $\Theta(n\log n)$ 的遍历操作。诚然，整个算法还是 $\Theta (n\log n)$ 的复杂度，但是无疑增加了常数倍数。考虑到我们的指导原则之一就是尽可能在大多数情况下，避免常数高的堆排序；主动去推高时间常数的做法是不可取的。 行文至此，我们又需要转换一次看待问题的角度。正如数学中有「正难则反」的说法。 我们来回顾一下计算机上的「杀毒软件」。早期的计算机病毒，更新速度较慢；但计算机「小白」太多，所以病毒的威力还是很大的。这时候的杀毒软件，会对病毒样本进行脱壳、反编译分析等操作，获取病毒的特征代码，而后加入特征库中。杀毒软件将更新的特征库分发给用户后，用户的杀毒软件就有能力查杀新的病毒了。这种方式的优点是精准，不易误杀；但是缺点也很明显——滞后性。 为了解决这个问题，后来反病毒工程师就想了一个办法。我们说，判断一个事物可以有两种思路。一个是判断其本质特征，例如使用特征码判断病毒；二个是观察其行为特性。对于病毒来说，它总是要潜伏下来搞破坏的，所以必然有某些行为特征。杀毒软件可以利用这些行为特征来判断一个可执行文件是否是计算机病毒。而这件事情是可以不依赖中心服务器，交由杀毒软件客户端自己处理的。这就解决了传统杀毒软件滞后性的问题。 杀毒软件的例子应当给予我们有一些启发。既然正面处理问题有困难，那就反过来，看看快速排序掉入陷阱会有什么行为特征。这似乎也不难，是显而易见的。快速排序调入陷阱，意味着在递归时快速排序算法会连续多次选中带分割区间的最值元素，从而导致多次「无效」分割，进而导致递归层数快速增加。因此，我们可以设置一个阈值；一旦递归深度超出该阈值，则认为快速排序掉入陷阱了并切换到堆排序算法。 快速排序在理想状态下，应当递归约 $\log n$ 次。因此，我们可以说，如果递归深度明显大于 $\log n$，快速排序就掉进陷阱了。于是，我们可以将该阈值设置为 $\log n$ 的某一倍数，比如 $2\log n$；一旦递归深度超过 $2\log n$，就从快速排序切换到堆排序。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Introspective Sort</tag>
        <tag>Heap Sort</tag>
        <tag>Quick Sort</tag>
        <tag>Insertion Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 LaTeX 中实现一个简易的进度条]]></title>
    <url>%2F2018%2F08%2F29%2Fcolored-progress-bar-in-LaTeX%2F</url>
    <content type="text"><![CDATA[进度条是很有用的工具。它可以表示 slides 放映的进度，也可以表示某种技能的熟练度。特别地，在制作简历时，使用「精通」、「熟练」之类的词就不如用一个进度条给所有技能一个统一的标准去衡量。不仅美观，而且直观。 使用 calc 宏包搭配 xcolor 宏包，我们就能用 TeX 自带的标尺来绘制进度条了。 12345678910111213141516\documentclass&#123;ctexart&#125;\usepackage&#123;xcolor&#125;\usepackage&#123;calc&#125;\definecolor&#123;color1&#125;&#123;rgb&#125;&#123;0.22,0.45,0.70&#125; % light blue\definecolor&#123;color2&#125;&#123;rgb&#125;&#123;0.45,0.45,0.45&#125; % dark grey\newcommand&#123;\progressbar&#125;[2][2cm]&#123;% \textcolor&#123;color1&#125;&#123;\rule&#123;#1 * \real&#123;#2&#125; / 100&#125;&#123;1.5ex&#125;&#125;% \textcolor&#123;color2!15&#125;&#123;\rule&#123;#1 - #1 * \real&#123;#2&#125; / 100&#125;&#123;1.5ex&#125;&#125;&#125;\begin&#123;document&#125;Office 三件套 \hfill \progressbar&#123;70&#125;LaTeX \hfill \progressbar&#123;90&#125;\end&#123;document&#125; 这里，\rule 命令用来绘制标尺——可以理解为色块。它的第一个参数是宽度，第二个参数是高度。两个标尺分别用两种颜色表示「熟练」和「不熟练」，或者「完成」和「未完成」的部分。两个标尺的宽度利用了 calc 宏包提供的功能进行计算。 效果如下。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Progress Bar</tag>
        <tag>Resume</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈基于比较的排序算法的复杂度下界]]></title>
    <url>%2F2018%2F08%2F28%2Flower-bound-of-comparation-based-sort-algorithm%2F</url>
    <content type="text"><![CDATA[基于比较的排序算法的复杂度下界是 $\Omega(n \log n)$，对于学过算法的人来说，这是一个基本常识。但它是怎么来的呢？ 让未知世界无机可乘在讨论排序之前，这里引入一个小游戏，为后续分析做一些准备。 这个游戏很简单。具体来说，我从整数范围 $[a, b)$ 当中（其中 $ b &gt; a $）选择一个数字，由你来猜。你可以通过提问的方式，缩小答案范围。但这些问题的答案只能是「是」或者「否」，并且我保证会如实作答。现在的问题是，何种策略能够在所有情况下，尽可能快地猜到正确答案？ 这个问题对稍有 CS 基础的读者来说应该是仅凭直感就能回答的：二分搜索呗。具体来说，先提问目标数字是不是位于 $\bigl[a, \lceil\frac{a + b}{2}\rceil\bigr)$ 之间，然后根据答案继续提问下去，直到得到正确答案。显然，它的时间复杂度是 $\Theta\bigl(\log_2 (b - a)\bigr)$。 那么问题来了。为什么这样的策略在平均情况下是最优的？换句话说，它为什么这样快呢？ 为了说明这个问题，我们需要换一个角度去思考这个游戏。考虑到区间 $[a, b)$ 当中一共有 $ b - a $ 个整数。因此，「确定随机选择的数字为 $c$」这个命题所携带的信息量应当是 $-\log_2 \frac{1}{b - a}$。在游戏中，每次猜测 + 回答，事实上构成了一个命题。若根据这一系列的命题能够确定随机选择的数字，则这一系列命题所携带的信息量之和应该超过 $-\log_2 \frac{1}{b - a}$。那么，要尽可能快地找到这个数字，本质上就是要系列命题中的每一个都尽可能携带多的信息量，并且相互不重叠。 顺着这个思路往下想。由于游戏中规定了猜测的答案只能是「是」或「否」。我们定义答案为「是」的概率为 $p$，相应答案为「否」的概率为 $ 1 - p$。那么这个猜测 + 答案形成的命题所携带的信息量为 $-p\log_2 p - (1 - p)\log_2(1 - p)$。显然，要使得该命题所携带的信息量最大，就要让 $p = \frac{1}{2}$。这就是为什么二分搜索快的原因了。 这里从信息论的角度，用了一些公式去阐述问题。换成通俗的语言来描述，就是用二分搜索的策略，能够让每一次猜测都排除一半的可能性，并且无论如何都能排除一半的可能性。换而言之，二分搜索的策略，让未知世界无机可乘。 排序问题的重述首先这里需要重新表述一下排序问题。 排序问题的本质可以理解为在 $n$ 个（不同）数的 $n!$ 种全排列中，选出一种，使其满足某种偏序关系（一般是小于或大于）。 现在我们考虑，基于元素比较的排序方法，每一次判定 $ a &lt; b $，都相当于回答了一次「是否问题」。按照已有的知识，若要尽可能快地完成排序，就要让每一次大小判断的结果落在两种答案之一的概率接近；若不然，则这次比较带来的信息量较小，也就需要更多次的比较来完成排序。那么，基于比较的方法，至少需要多少次比较才能完成排序呢？换而言之，基于比较的排序算法，其复杂度下界是什么呢？ 基于比较的排序算法的复杂度下界现在我们已知，有 $n!$ 种可能的不同排列方式。假设我们有一个完美的算法，能够每次去除剩余可能性中的一半，则我们需要 $\log_2 n!$ 次比较。这就是基于比较的排序算法的复杂度下界：$\Omega (\log n!)$。 现在我们把它变换成比较好看的形式。考虑斯特灵级数 $$ n! = \sqrt{2\pi n}\Bigl(\frac{n}{\mathrm{e}}\Bigr)^{n}\Bigl(1 + \frac{1}{12n} + \frac{1}{288n^2} + \cdots\Bigr), $$ 这也就是说 $$ \ln n! = n\ln n - n +\frac{1}{2}\ln(2\pi n) + \frac{1}{12n} - \frac{1}{360n^3} + \cdots. $$ 因此，在渐进的意义下，$\log n! = \Theta (n\log n)$。这说明，基于比较的排序算法的复杂度下界是 $\Omega (n\log n)$。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Complexity</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 实现的 HTTP 报文头回声服务]]></title>
    <url>%2F2018%2F05%2F29%2FPython-HTTP-header-echo-service%2F</url>
    <content type="text"><![CDATA[前作实现了收款码多合一的功能，这是基于我们能够正确识别不同 App 的不同 UserAgent 特征字段之上的。前作没有解说我们是如何获取相应 UA 的。通过嗅探抓包当然是一个解决方案，在计算机上运行模拟器也可行。但这些方法都太重量级了。 本文用 Python 实现一个简单的 HTTP 报文头回声服务；这个服务什么也不干，就只是把发向服务的请求中的 HTTP 报文头返回。 Python 代码代码位于 GitHub Repository。核心功能实现在 RequestHandler 类的 do_GET 方法中。该方法将受到的 HTTP 请求的报文头写入响应正文，而后打印在本地标准输出上。此外，HTTP 中其它三种请求方法的处理与 GET 完全相同。可谓一目了然。 实际我们只需执行 python HTTP_header_echo_service.py 即可在 8080 端口运行服务。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#!/usr/bin/env python# Reflects the requests from HTTP methods GET, POST, PUT, and DELETE# Author: Liam Huang (Yuuki) &lt;liamhuang0205@gmail.com&gt;try: from http.server import HTTPServer, BaseHTTPRequestHandlerexcept: from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandlerfrom optparse import OptionParserimport jsonclass RequestHandler(BaseHTTPRequestHandler): def do_GET(self): request_path = self.path self.send_response(200) self.send_header('Content-Type', 'application/json') self.end_headers() json_string = json.dumps(dict(self.headers)) self.wfile.write(json_string) print('%sBegin of Headers%s' % ('-' * 5, '-' * 5)) for k, v in self.headers.items(): print('%s: %s' % (k, v)) print('%sEnd of Headers%s' % ('-' * 5, '-' * 5)) return None do_POST = do_GET do_PUT = do_GET do_DELETE = do_GETdef main(): port = 8080 print('Listening on all interfaces:%s' % port) server = HTTPServer(('', port), RequestHandler) server.serve_forever()if __name__ == "__main__": parser = OptionParser() parser.usage = ("Creates an HTTP-header-echo-server.") (options, args) = parser.parse_args() main() 实际运行看看执行 python HTTP_header_echo_service.py 后，服务会监听本机 8080 端口。在浏览器中访问 http://localhost:8080 得到返回结果： 1234567891011&#123; "accept-language": "zh-CN,zh;q=0.8,en-US;q=0.6,en;q=0.4", "accept-encoding": "gzip, deflate", "host": "localhost:8080", "accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8", "user-agent": "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36", "dnt": "1", "connection": "keep-alive", "cookie": "cna=k8yHEPvog1oCAdoedAmhk3yz; l=AoGB/bWp8ixmk2ng-8I0OpNAEcebrvWg; __guid=242983815.4140311236197044700.1504064960140.7058; HULK_TD=t%3D1511410881%26s%3D2cb9fedc6e59ac22bbc416f796970add%26a%3D1; HULK_QD=u%3Duhnatpurapurat%26m%3Duhnatpurapurat%2540360.pa%26d%3D%25E9%25BB%2584%25E6%2599%25A8%25E6%2588%2590; TD=t%3D1511410881%26s%3Da97b7edff5f3e6e7a0920ae7ee326d88%26a%3D1; QD=u%3Duhnatpurapurat%26m%3Duhnatpurapurat%2540360.pa; Prif_66de_st_t=0%7C1522123196%7C06e665a5949159cee56367609a66caaf; Prif_66de_auth=ec018ze%2FGmPt4LA3C3BcDLxQ4Pov3O1HlZIv0EnN%2BBthlGx4IKvidZKtxA; Prif_66de_smile=1D1; Prif_66de_lip=10.18.120.109%2C1522123532; Prif_66de_ulastactivity=9b2dELqg1p%2F6AAzSO8dz8XylvfWBBj748PyquvcqvdLlGncXc5Dy; Prif_66de_saltkey=kRuuho96; Prif_66de_lastvisit=1526726055; Prif_66de_st_p=0%7C1527160289%7C7bae096d1c2d9c2271f9ad539cafc6e4; Prif_66de_visitedfid=106; Prif_66de_viewid=tid_30518", "upgrade-insecure-requests": "1"&#125; 以内网 IP 192.168.0.101 生成二维码，用微信扫描后，访问得到结果中可见微信的特征字段：「MicroMessenger」。 123456789&#123; "accept-language": "zh-cn", "accept-encoding": "gzip, deflate", "connection": "keep-alive", "accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8", "user-agent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E302 MicroMessenger/6.6.6 NetType/WIFI Language/zh_CN", "host": "192.168.0.101:8080", "upgrade-insecure-requests": "1"&#125; 以上。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>HTTP</tag>
        <tag>Headers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成聚合收款二维码：支付宝、微信、QQ 钱包]]></title>
    <url>%2F2018%2F05%2F29%2FFuse-QRCodes-together-Alipay-WeChat-and-QQ-wallet%2F</url>
    <content type="text"><![CDATA[今天在浏览 V2EX 时，看到了一个令人啼笑皆非的帖子。OP 在 GitHub 上开源了一个能将支付宝和微信收款码二合一的项目。由于在项目中，OP 默认填写了自己的支付宝和微信信息；当项目被 fork 出去后，很多人没有修改其中的信息。特别地，有一些被用在恶意用途上的 fork 分支也没有修改。这样一来，就有不少人扫描这些生成的二维码而受骗，最终导致 OP 的微信被封禁了收款功能——连红包都收不了。 虽然故事本身令人啼笑皆非，但是自己动手将支付宝和微信收款码合二为一的想法还是很有趣的。在 Google 上搜索了一番后，我发现收款码合并的套路大概有两种。 其一是以芝麻收款为代表的第三方解决方案。这些第三方解决方案要求用户分别上传支付宝和微信的支付码，而后返回一个新的聚合收款码。按检索到的信息，芝麻收款以前是不收费的，但现在要收费 4.5 元。考虑到收款码涉及到资金流动，交予第三方本身是不安全的；并且，这样一个简单的事情还要收钱，未免有点「故意利用技术壁垒」的意思。作为一个更乐于自己动手丰衣足食的人，妥妥是忍不了的。 其二是以上述 OP 为代表的开源解决方案。这些解决方案对用户动手的能力更高，并且要求有一个可被公共访问的服务器来执行判断脚本。在这种套路里，还可以细分流派。一派是以 PHP 等为代表的解决方案，这要求上述服务器能够执行 PHP 等脚本。这一派的解决方案不适用于 GitHub Pages 等静态页面博客，因而使用范围受限。一派则是以静态 HTML 附议 CSS 和 JavaScript 为解决方案。这一派的方案适用面就广泛得多了。 本文介绍一种以静态 HTML 为基础，辅以 CSS 和 JavaScript 的方案，用以生成聚合收款码。 二维码收款的真相二维码事实上只是一种编码手段，它将信息编码成了正方形的二维码的形状。只不过，在二维码协议中定义了许多用于诸如抗干扰、放破损的冗余等内容。但事实上二维码只是编码了一些信息而已。 我们使用微信、支付宝等手机 App 扫描二维码后，这些 App 的行为取决于二维码编码的信息。App 首先会解码二维码，而后根据这些信息采取相应的动作。具体到二维码收款时，二维码至少应当包含转账的目标人的 uid，以及（若需要）包含要求的金额。 开源中国的工具集中有针对二维码的解码工具。利用这些工具，我们就可以读取二维码中编码的信息了。以下是从我的支付宝、微信、QQ 钱包的收款码中读出的信息（关键信息已隐藏）。 支付宝：https://qr.alipay.com/ape------------81f 微信：https://wx.tenpay.com/f2f?t=AQA----------------------n4= QQ 钱包：https://i.qianbao.qq.com/wallet/sqrcode.htm?m=tenpay&amp;a=1&amp;u=2------5&amp;ac=6B3----------------------------------------------------------F80&amp;n=L&amp;f=wallet 可见，无论是支付宝、微信还是 QQ 钱包，其收款二维码背后实质都是一个 URL。但实际测试表明，只有支付宝能直接由 URL 出发付款动作；微信和 QQ 钱包应当是在此处做了额外的判断保护，以防用户误点链接进行付款。 于是，解决方案就变成了： 当检测到用户使用支付宝扫描聚合码后，返回一个支付宝的收款 URL。 当检测到用户使用微信或者 QQ 扫描聚合码后，返回微信或 QQ 的收款二维码，由相应的二维码再触发后续动作。 显而易见，该判断动作必然发生在一个可被公共访问的服务器上。于是，问题变成了如何使 App 在扫描相应二维码后访问公共服务器上的某个位置；以及如何在该位置判断用户使用哪一个 App 扫描聚合码，并返回合适的内容。前一个问题很容易解决，它是 App 扫描二维码后的默认动作。因此，我们集中解决后面的问题。 UserAgentHTTP 协议报文的头部有所谓用户代理（UserAgent，简称 UA）的信息。UA 实际上就是用户使用的浏览器。因此，可以想见，当用户使用不同 App 扫描二维码并访问公共服务器时，HTTP 报文头部载有的 UA 是不一样的。我们可以据此判断用户使用的 App。 为此，我们需要探测支付宝、微信、QQ 钱包的 UA 中有哪些内容可以作为特征字段。详细做法将在后续文章中阐述，此处给出结论： 支付宝：AlipayClient； 微信：MicroMessenger； QQ 钱包：QQ/。 在 HTML 中，我们可以使用 navigator.userAgent.match(/foobar/i) 来判断 UA 中是否包含有 foobar 这一特征字符串。据此我们有： 123456789if (navigator.userAgent.match(/Alipay/i)) &#123; // 返回支付宝链接&#125; else if (navigator.userAgent.match(/MicroMessenger\//i)) &#123; // 返回微信链接对应的二维码&#125; else if (navigator.userAgent.match(/QQ\//i)) &#123; // 返回 QQ 钱包链接对应的二维码&#125; else &#123; // 不支持的 App&#125; 在线生成二维码由于聚合码被微信或 QQ 钱包扫描时需返回相应链接对应的二维码，我们要不然应保存相应二维码，要不然应想办法在线生成并将二维码返回给用户。在线生成二维码又有两个办法，其一是使用 JQuery 之类工具中的 QRCode 接口，直接由用户浏览器（手机 App）生成二维码，其二是调用现成的接口。此处我们通过调用现成的借口来生成二维码。 此处我们借用百度云盘的接口来生成二维码。具体来说 1https://pan.baidu.com/share/qrcode?w=150&amp;h=150&amp;url=Liam%20loves%20Sophia! 返回的二维码中隐藏的信息是： 1Liam loves Sophia! GitHub Repository至此，解决方案的主要思想就已经阐述清楚了；完整的代码可见 GitHub Repository。 使用时，首先应当获取支付宝、微信和 QQ 钱包的二维码后对应的链接。三个 App 的操作路径分别是： 支付宝：首页 -&gt; 收钱 -&gt; 保存图片 微信：首页 -&gt; + -&gt; 收付款 -&gt; 二维码收款 -&gt; 保存收款码 QQ 钱包：手机 QQ 首页 -&gt; + -&gt; 付款 -&gt; ... -&gt; 我要收款 -&gt; 截屏保存 将上述保存的二维码上传至开源中国，即可获取收款二维码背后的链接。而后，应当把这些链接填空到 index.html 头部的配置当中。最后只需将该 HTML 文档上传至一个公共服务器即可。如此给出的二维码如下，可供扫描测试——当然如果最后转账就最好啦！ 致谢GitHub 项目的原作者应当是孟坤，在此感谢！]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>WeChat</tag>
        <tag>QRCode</tag>
        <tag>HTML</tag>
        <tag>JavaScript</tag>
        <tag>Alipay</tag>
        <tag>QQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TeX 主题选讲：盒子]]></title>
    <url>%2F2018%2F05%2F21%2FTeX-by-Topic-boxes%2F</url>
    <content type="text"><![CDATA[此篇基本上是译文，原文是 Victor Eijkhout 所著的《TeX by Topic》的第五章。译文项目参见：CTeX-org/tex-by-topic-cn。转载请保留本段文字，尊重原作者和译者版权。由于原著使用 GFDL，故而本文也被传染地同样使用 GFDL 许可，而不是本站默认的 BY-NC-SA 4.0 许可。 TeX 中的水平与竖直盒子分别是水平与竖直列表内容的容器。盒子可保存在盒子寄存器当中。本章讨论盒子寄存器，以及关于盒子尺寸、盒子内容相互位置的问题。 所涉命令编目： \hbox： 构造一个水平盒子。 \vbox： 构造一个竖直盒子，其参考点（reference point）是最后一个元素。 \vtop： 构造一个竖直盒子，其参考点是第一个元素。 \vcenter： 构造一个在竖直方向于数学轴（math axis）居中的竖直盒子；该命令仅在数学模式下使用。 \vsplit： 将竖直盒子顶部部分分离。 \box： 使用盒子寄存器，而后清空它。 \setbox： 将盒子赋值给一个盒子寄存器。 \copy： 使用盒子寄存器，但保留其中内容而不清空。 \ifhbox \ifvbox： 判断盒子寄存器中保存的是水平盒子还是竖直盒子。 \ifvoid： 判断盒子寄存器是否为空。 \newbox： 分配新的盒子寄存器。 \unhbox \unvbox： 将保存有水平盒子或竖直盒子的寄存器解包，并将其中内容追加到当前的水平列表或竖直列表中，而后清空寄存器。 \unhcopy \unvcopy： 与 \unhbox、\unvbox 的行为相同，但不清空寄存器。 \ht \dp \wd： 返回及设置盒子寄存器中盒子的高度、深度、宽度。 \boxmaxdepth： 该命令表示 TeX 所允许的盒子的最大深度。在 plain TeX 中，它的默认值是 \maxdimen。 \splitmaxdepth： 该命令表示 TeX 所允许的由 \vsplit 生成盒子的最大深度。 \badness： 刚刚构造的盒子的劣度。 \hfuzz \vfuzz： 该命令表示水平或竖直盒子的尺寸超出指定尺寸的阈值；当超过该阈值时，TeX 会考虑将其认定为溢出的（overfull）盒子。 \hbadness \vbadness： 该命令表示一个阈值；当盒子的劣度超过该阈值时，TeX 会将相应盒子认定为欠满的（underfull）或者溢出的。 \overfullrule： 当水平盒子溢出时，TeX 会打印一条标尺，以表明有溢出的水平盒子；该命令表示上述标尺的宽度。 \hsize： 该命令表示在水平盒子内文本排版可用的行宽。 \vsize： 该命令表示页盒子（page box）的高度。 \lastbox： 若最后追加进当前列表的内容是一个盒子，则该寄存器会保存上述盒子。 \raise \lower： 这两个命令用于在水平模式中调整盒子的垂直位置。 \moveleft \moveright： 这两个命令用于在竖直模式中调整盒子的水平位置。 \everyhbox \everyvbox： 这两个命令分别用于在每个水平盒子或竖直盒子开头处插入的记号列表。 盒子本章我们讨论盒子。TeX 中的水平盒子与竖直盒子分别是盒子是水平与竖直列表内容的容器。需要多次使用的盒子可以保存在盒子寄存器当中。 当 TeX 需要接受一个盒子（&lt;box&gt;）时，TeX 可接受以下形式： \hbox &lt;box specification&gt; {&lt;horizontal material&gt;} \vbox &lt;box specification&gt; {&lt;vertical material&gt;} \vtop &lt;box specification&gt; {&lt;vertical material&gt;} \box &lt;8-bit number&gt; \copy &lt;8-bit number&gt; \vsplit &lt;8-bit number&gt; to &lt;dimen&gt; \lastbox 其中 &lt;box specification&gt; 的定义如下 而 &lt;8-bit number&gt; 则是 0–255 范围内的数字。 包围盒子内容的花括号定义了一个分组；它们可以是分类码为 1 和 2 的显式字符，也可以是通过 \let 定义的控制序列（隐式字符）；见下文。 除下文提到的 \lastbox 之外，盒子通常可以用在水平、竖直和数学模式。盒子与模式之间的关系将在后续章节中讨论。 由 \vcenter 命令（仅可在数学模式下使用）产生的盒子不是通常意义的盒子（&lt;box&gt;）。特别地，它不能赋值给 \setbox；详见后续章节。 \vsplit 命令将在后续章节详细讨论。 盒子寄存器共有 256 个盒子寄存器，它们从 0 开始编号至 255。盒子寄存器要不然是空的（void），要不然包含了一个水平盒子或一个竖直盒子。本节只讨论盒子寄存器；盒子的尺寸、内部内容的排列方式则在后续小节中讨论。 使用 \newbox 分配盒子寄存器plain TeX 中的 \newbox 宏可用于分配一个未被使用的盒子寄存器： 1\newbox\MyBox 此后，我们可以这样给盒子寄存器赋值： 1\setbox\MyBox=... 或者这样使用盒子寄存器里的内容： 1\box\MyBox 连续调用该命令会生成的盒子寄存器的编号也是连续的；这样，宏集合（macro collections）可以各自分配盒子寄存器，而无需担心与其它宏中分配的寄存器冲突。 盒子寄存器的编号是通过 \chardef 赋值的（见后续章节）。这说明，\MyBox 等价于一个数字（&lt;number&gt;），并且能被当做是数字使用。控制序列 \newbox 是一个外部（\outer）宏。新分配的盒子寄存器初始时是空的。 \setbox、\box 和 \copy 的用法我们可以将一个盒子（&lt;box&gt;）赋值给盒子寄存器 ： 此处的 &lt;box&gt; 可以是显式的盒子，比如 1\setbox37=\hbox&#123;...&#125; 以及 \setbox37=\vbox&#123;...&#125; 也可以是另一个盒子寄存器: 1\setbox37=\box38 一般来说，盒子寄存器的编号由 \newbox 命令分配。 通过 \box 和 \copy，我们可以将盒子寄存器中保存的盒子追加在 TeX 正在构建的列表当中。例如，下列命令会将编号为 38 的盒子追加到当前列表中： 1\box38 为节省内存，盒子寄存器在使用后会被清空：TeX 假设当你使用 \box$nn$ 之后，你就不会再需要其中的内容了，于是便会清空它。如果你确实需要重复使用盒子寄存器的内容，你可以用 \copy$nn$ 命令。它与 \box$nn$ 的效果相同，但不会清空盒子寄存器中的内容。 通过 \unhbox 和 \unvbox 及其拷贝版本 \unhcopy 和 \unvcopy 解包盒子寄存器中的内容是可行的。不同于 \box 可以在任何模式下使用，解包盒子的操作只能用在恰当的模式下——因为解包盒子会形成一个部分的水平列表或竖直列表（参见后续章节）。后文有关于解包盒子寄存器的更多信息。 关于盒子的条件判断：\ifvoid、\ifhbox 及 \ifvbox通过 \ifvoid 可以判断盒子寄存器是否为空。当 \box&lt;number&gt; 为空时，下式返回真： 注意，盒子寄存器为空与盒子寄存器保存了空盒子是两码事。空盒子要么是水平盒子要么是竖直盒子；空的盒子寄存器既可以作为水平盒子使用，也可以作为竖直盒子使用。 \ifhbox 和 \ifvbox 则分别用于判断一个盒子寄存器中的盒子是否为水平盒子或竖直盒子： 注意，若寄存器为空，则两个判断都为假。 \lastbox当 TeX 构建完成一个部分列表（partial list）后，此列表中的最后一个盒子可通过 \lastbox 来访问。该命令的行为与盒子寄存器相似；因此，你可以将 \lastbox 赋值给其他盒子寄存器，以将其从列表中删除。如果列表中最后一个元素不是盒子，则 \lastbox 的行为与空寄存器相似。你无法通过 \lastbox 访问主竖直列表中的最后一个元素；在这种情况下，\lastbox 总是空寄存器。 举例来说，下面的语句将当前列表中的最后一个盒子赋值给编号为 0 的盒子寄存器，并将其从当前列表中删除： 1&#123;\setbox0=\lastbox&#125; 由于赋值过程位于分组之内，在分组结束后，寄存器会被清空。因此，在一个自然段开始之时使用这一语句，可以删除缩进盒子（见后续章节）。后文也有关于 \lastbox 的例子。 由于 \lastbox 在外部竖直模式中总是为空，它不能访问追加到输出页上的盒子。但当页面保存在 \box255 中时，我们可以在输出阶段解包这个盒子，而后取得 \lastbox： 译注：关于这一技巧，这里有一个完整的示例：https://gist.github.com/91fd658069b0d3dfb7dbd2cba69b856a 1\vbox&#123;\unvbox255&#123;\setbox0=\lastbox&#125;&#125; 值得一提的是，如果竖直模式中的盒子被 \moveright 或 \moveleft 调整过位置，或是水平模式中的盒子被 \raise 或 \lower 调整过位置，则使用 \lastbox 访问列表中最后一个元素时，这些位置调整信息都会丢失。 盒子天然的尺寸 译注：这里指的是没有其他拉伸、收缩的影响下，盒子自身的尺寸。 已创建的水平盒子的尺寸\hbox 内所有的元素都依次排在一行，并且它们的参考点会在齐盒子的基线（baseline）上对齐，除非显式使用 \raise 或者 \lower 调整它们竖直方向上的位置。 盒子的宽度是盒子内所有元素宽度之和。因此下面盒子的宽度为正 1\hbox&#123;\hskip1cm&#125; 而下面盒子的宽度为负 1\hbox&#123;\hskip-1cm&#125; 具体举例来说： 1a\hbox&#123;\kern-1em b&#125;-- 的输出是 这表明，水平盒子可以有负的宽度。 \hbox 的高度和深度是盒子内所有元素在盒子基线上方和下方的最大值。水平盒子的高度和深度都是非负的。 \raise 和 \lower 命令是在 \hbox 内调整元素水平位置的唯一方法（当然，除了在 \hbox 中嵌套一个新的 \vbox）；TeX 不允许在水平盒子中使用竖直命令（&lt;vertical command&gt;，例如 \vskip）；此外，虽然我们可以在水平盒子中使用 \par，但它却不会有任何作用。 已创建的竖直盒子的尺寸在 \vbox 内，竖直元素的参考点与盒子的参考点在竖直方向上对齐，除非显式使用 \moveright 或者 \moveleft 调整它们水平方向上的位置。 竖直盒子的参考点总是在盒子的左边界上。竖直盒子的宽度是盒子内所有元素的右边界相对参考点向右超出距离的最大值。盒子内元素相对参考点向左超出的距离则不被计算在盒子的宽度之中。因此，与前例相对应，下列代码的结果 1a\vbox&#123;\hbox&#123;\kern-1em b&#125;&#125;-- 是 由 \vbox 和 \vtop 生成的竖直盒子在计算高度和深度时会有所不同。基本原则是，\vbox 的参考点位于最后一个元素的基线之上，而 \vtop 的参考点位于第一个元素的基线之上。一般来说，只要最后一个（第一个）元素是盒子或者标尺（rule），则 \vbox（\vtop）的深度（高度）非零。 \vbox 的高度是除最后一个元素之外所有元素高度与深度之和，再加上最后一个元素的高度；\vbox 的深度则是最后一个元素的深度。\vtop 的高度是第一个元素的高度；\vtop 的深度则是除第一个元素之外所有元素高度与深度之和，再加上第一个元素的深度。也就是说，对于 \vtop 来说，其深度是所包含所有元素的高度与深度之和，再减去第一个元素的高度。 如果 \vtop（\vbox）的第一个元素（最后一个元素）不是盒子或标尺，那么实际规则还要更复杂一点。如果 \vbox 的最后一个元素是铅空（kern）或伸缩胶（glue），则盒子的深度为零；而若 \vtop 的第一个元素是铅空或伸缩胶，则盒子的高度为零。（注意这些定义中的不对称性；可参考后续示例） 关于竖直盒子，还有一个限制：如果 \vbox 或者 \vtop 的深度超出 \boxmaxdepth，则盒子的参考点会下移这一超出的数值。具体来说，超出限制的那一部分深度，会被加在盒子自身的高度之上。如果盒子有 to 或者 spread 声明符，则相关的伸缩胶都会被重新设置，以将追加的高度考虑在内。 通常，\boxmaxdepth 的值是 TeX 能表示的最大尺寸。但在一些情况下，例如，在 plain TeX 的输出阶段的一些计算中，它的值会被修改得小很多。详见后续章节。 例子水平盒子相较而言简单直接一些。水平盒子的宽度是盒子两条竖直边界之间的距离：从开始到结束，因此，水平盒子的宽度不一定是正数。例如在下例中，\box1 的宽度为零。 1\setbox0=\hbox&#123;aa&#125; \setbox1=\hbox&#123;\copy0 \hskip-\wd0&#125; 具体来说 /\box1/ 的结果是（打了引号） 水平盒子的高度和深度则不能为负。例如在下例中，\box1 的深度是 0pt 而高度是 15pt。 12\setbox0=\hbox&#123;\vrule height 5pt depth 5pt&#125;\setbox1=\hbox&#123;\raise 10pt \box0&#125; 竖直盒子相较而言就要麻烦不少。我们首先来讨论其宽度。首先，如下定义的水平盒子的宽度是 10pt。 1\setbox0=\hbox&#123;\hskip 10pt&#125; 则如下定义的竖直盒子宽度是 5pt。 1\setbox1=\vbox&#123;\moveleft 5pt \copy0&#125; 这是因为，在竖直盒子中，位于参考点左边的内容不计入其宽度。同样的，如下定义的竖直盒子宽度是 15pt。 1\setbox2=\vbox&#123;\moveright 5pt \copy0&#125; 如果 \vbox 的最后一个元素是盒子，则其深度是最后一个元素的深度。因此，如下定义的 \vbox 高度为 10pt 深度为 5pt。 1\vbox&#123;\vskip 5pt \hbox&#123;\vrule height 5pt depth 5pt&#125;&#125; 如下定义的 \vbox 的高度则是 0pt 而深度为 5pt。 1\vbox&#123;\vskip -5pt \hbox&#123;\vrule height 5pt depth 5pt&#125;&#125; 如果最后一个元素是铅空或伸缩胶，则竖直盒子的深度为零。因此，如下定义的 \vbox 高度为 15pt 深度为 0pt。 1\vbox&#123;\hbox&#123;\vrule height 5pt depth 5pt&#125;\vskip 5pt&#125; 下列 \vbox 的高度为 5pt 深度则是 0pt。 1\vbox&#123;\hbox&#123;\vrule height 5pt depth 5pt&#125;\vskip -5pt&#125; 与 \vbox 的深度对应，\vtop 的高度基本上就是其第一个元素的高度。重复之前的例子，则如下定义的 \vtop 高度为 0pt 深度为 15pt。 1\vtop&#123;\vskip 5pt \hbox&#123;\vrule height 5pt depth 5pt&#125;&#125; 如下定义的 \vtop 高度为 0pt 深度为 5pt。 1\vtop&#123;\vskip -5pt \hbox&#123;\vrule height 5pt depth 5pt&#125;&#125; 如下定义的 \vtop 高度为 5pt 深度为 10pt。 1\vtop&#123;\hbox&#123;\vrule height 5pt depth 5pt&#125; \vskip 5pt&#125; 如下定义的 \vtop 高度为 5pt 深度为 0pt。 1\vtop&#123;\hbox&#123;\vrule height 5pt depth 5pt&#125; \vskip -5pt&#125; 继续讨论盒子的尺寸预先指定尺寸盒子的尺寸可以通过尺寸说明符（&lt;box specification&gt;）来指定；具体语法可见上文。盒子中的伸缩胶会依需求缩放，使得盒子的尺寸达到上述设定值。预先指定盒子的尺寸的方法是： 12\hbox to &lt;dimen&gt; \lb...\rb,\vbox to &lt;dimen&gt; \lb...\rb 如果盒子中有可以拉伸或收缩的伸缩胶，则这些伸缩胶会被拉伸或收缩，以将盒子的尺寸调整至指定的大小。与伸缩胶伸缩相关的是所谓的劣度值（见后续章节）。如果伸缩胶能够提供的拉伸或收缩值不足所需，则得到的盒子会欠满或溢出。后文有关于欠满和溢出的报错的相关讨论。 还有一个命令可使盒子实际的尺寸异于其天然尺寸。 12\hbox spread &lt;dimen&gt; \lb...\rb,\vbox spread &lt;dimen&gt; \lb...\rb 这种情况下，TeX 会使盒子内的伸缩胶拉伸或收缩，以在盒子天然尺寸的基础上缩放 &lt;dimen&gt;。 与 \vtop 配合使用尺寸说明符相对来说比较复杂。TeX 构造 \vtop 时会先构造一个 \vbox，同时会将尺寸说明符传递给该 \vbox；而后再根据上述规则计算盒子的高度和深度。 伸缩胶相关设置将在后续章节中讨论。 改变盒子的尺寸我们可以用 \ht、\dp 和 \wd 来分别获得盒子寄存器的高度、深度和宽度。举例来说，\dp18 会给出 18 号盒子的深度。盒子的尺寸不光可读，还可写。通过给盒子的尺寸赋值，我们可以在某种意义上愚弄 TeX，使得在 TeX 看来某个盒子的尺寸不同于其真实值。不过，修改盒子尺寸并不会修改其中的内容；特别地，不会修改伸缩胶设置的方式。 不少格式（format）都定义了 \smash 宏： 1\def\smash#1&#123;&#123;\setbox0=\hbox&#123;#1&#125;\dp0=0pt \ht0=0pt \box0\relax&#125;&#125; 在宏定义中，\smash 命令将内容保存在盒子中，但是将盒子的高度和深度都值为零；这也就是说，最终盒子会被输出，但是后续有关盒子尺寸的计算中，TeX 都会将高度和深度认作是零。 改变盒子尺寸只能通过为其赋值来实现：这些盒子尺寸（&lt;box dimen&gt;s）能且只能通过盒子尺寸赋值语句（&lt;box size assignment&gt;）来设置，而不能用诸如 \advance 的命令来修改。 注意，盒子尺寸赋值总是全局赋值。赋值的效果会超出任意限定它的分组（参见后续章节）。因此下列代码 1\setbox0=\hbox&#123;---&#125; &#123;\wd0=0pt&#125; a\box0b 有输出： 上述有关被创建的盒子的尺寸限制并不适用于显式修改盒子尺寸的情况。例如，对水平盒子设置 \dp0=-2pt 是合法的。 移动盒子在水平盒子中，所有元素的参考点与盒子自身的参考点都位于同一条水平线上。水平盒子中的盒子可用 \raise 或 \lower 来上移或下移。 相似地，在竖直盒子中，所有元素的参考点与盒子自身的参考点都位于同一条竖直线上，且各个元素从上到下依次排列。竖直盒子中的盒子可用 \moveleft 或 \moveright 来左移或右移。 注意，上述命令只能用来移动盒子，特别地，这些命令不能用于字符或标尺。 盒子的尺寸与盒子的摆放在确定水平列表和竖直列表中元素的摆放位置时，TeX 需要维护两个变量：当前参考线以及在参考线上的当前位置。对于水平列表来说，参考线是包围当前内容的 \hbox 的基线；对于竖直列表来说，参考线是穿过包围当前内容的 \vbox 的参考点的竖线。 在水平模式中，TeX 放置元素的逻辑如下。初始时，参考线上的当前位置即是包围当前内容的从水平盒子的参考点。此后，TeX 会依如下步骤操作。 如果元素被 \raise 或 \lower 上下移动了位置，则相应地调整元素的位置。 如果元素是水平盒子，则对其内容递归地调用该算法；如果元素是竖直盒子，按盒子的高度向上移动当前位置，而后按照后文所述的有关竖直盒子的算法放置盒子内竖直列表中的元素。 按当前元素的宽度，沿着参考线向右移动当前位置。 对于竖直盒子中的竖直列表，TeX 的会将当前位置初始设置在盒子的左上角，参考线则是穿过该点的竖线——这条竖线同样也会穿过盒子的参考点。竖直盒子中的元素依照如下逻辑摆放。 如果元素被 \moveleft 或 \moveright 上下移动了位置，则相应地调整元素的位置。 将元素的左上角与当前位置对齐。 如果元素是竖直盒子，则对其内容递归地调用该算法；如果元素是水平盒子，按盒子的高度向下移动当前位置，而后按照前文所述的有关竖直盒子的算法放置盒子内水平列表中的元素。 按当前元素的高度与深度之和，沿着参考线向下移动当前位置。 注意，上文中没有描述 TeX 是如何构建盒子的。对于竖直盒子，构建盒子的过程还要包括插入行间距伸缩胶（行间胶，baselineskip glue）的过程。上文介绍的过程描述的是 TeX 会如何输出一个已经构建完成的盒子中的内容。 盒子与反向伸缩胶默认情况下，盒子在一条参考线上依次摆放。但有时，让盒子互相重叠也是很有用的。让盒子互相重叠，最简单的办法是使用反向行间胶。在水平模式中，下列代码会摆放编号为 8 的盒子，但不会移动当前位置。 1&#123;\dimen0=\wd8 \box8 \kern-\dimen0&#125; 更实用的是使用 \llap 和 \rlap 命令。它们的定义如下： 12\def\llap#1&#123;\hbox to 0pt&#123;\hss #1&#125;&#125;\def\rlap#1&#123;\hbox to 0pt&#123;#1\hss&#125;&#125; 这两个命令允许其中的内容基于当前位置向左或向右突出。这里，\hss 伸缩胶等价于 \hskip 0pt plus 1fil minus 1fil，它能吸收 \llap 或 \rlap 的参数中的任意正负宽度。 举例来说，下列代码 1\llap&#123;\hbox to 10pt&#123;a\hfil&#125;&#125; 等价于 1\hbox&#123;\hskip-10pt \hbox to 10pt&#123;a\hfil&#125;&#125; 它们的宽度都是 0pt。 盒子的欠满与溢出如果盒子有尺寸说明符则 TeX 会拉伸或收缩其中的伸缩胶。对于仅有有限伸缩能力的伸缩胶，TeX 会计算其伸缩过程中的劣度（见后续章节）。在 TeX3 中，用户可通过 \badness 宏来检查刚刚构建的盒子的劣度。劣度的取值范围是 $0$–$10\,000$；而如果盒子溢出了，则其劣度为~$1\,000\,000$。 如果 TeX 认为劣度过大，则会给出一条诊断信息。我们首先考虑对水平盒子的报错。 若 \hbadness${}\geqslant10\,000$，则 TeX 不会对需要拉伸其中伸缩胶的水平盒子报错；否则，当水平盒子中的伸缩胶拉伸的劣度超过 \hbadness 时，TeX 会提示盒子欠满（underfull）。 伸缩胶的收缩可能引发盒子溢出的报错：如果盒子内伸缩胶最大的收缩量不足以使盒子的宽度满足指定的宽度，则 TeX 认为该盒子溢出了。当且仅当收缩量不足的量大于 \hfuzz 或者 \hbadness${}&lt;100$ 时（这会使得所有可用的收缩的劣度为 $100$），TeX 才会报告盒子溢出的问题。 举例来说，如果盒子内伸缩胶的最大收缩量不足以使盒子的宽度减小到指定的尺寸，则若设置 \hfuzz=1pt，TeX 会忽略上述不足的部分小于 1pt 的盒子而不报错。 12\hbox to 1pt&#123;\hskip3pt minus .5pt&#125;\hbox to 1pt&#123;\hskip3pt minus 1.5pt&#125; 这里只有第一个盒子会报错：它比目标尺寸大了 1.5pt；但是第二个盒子不会报错，因为它只比目标尺寸大了 0.5pt，小于 \hfuzz。 如果一个盒子虽不至变成溢出盒子但也被收缩了，也有可能被 TeX 报告问题：如果一个盒子比较紧凑，也就是说，如果这个盒子使用了至少一半的收缩能力，则在劣度（介于 13 到 100 之间）超过 \hbadness 时，TeX 会报告这个问题。 对水平盒子与竖直盒子来说，相关警告的逻辑几乎完全相同。对于竖直盒子来说，有 \vbadness 以及 \vfuzz 来控制相关报错。区别之处在于，如果一个水平盒子溢出了，则 TeX 会在盒子右侧绘制一个高度与盒子相同宽度为 \overfullrule 的溢出标尺。此处有一个例外，在 \halign 中，如果 \tabskip 伸缩胶无法提供足够的收缩量时，TeX 不会绘制溢出标尺。 盒子的开始与结束盒子的内容以花括号定界。其中，左右花括号既可以是显式字符（分类码为 1 和 2 的字符），也可以是使用命令 \let 定义的隐式字符。TeX 会将记号 \everyhbox 或者 \everyvbox 插入在左花括号之后。如果盒子位于 \setbox 赋值语句中，则记号 \afterassignment 会在「everybox」记号之前插入在左花括号之后。 举例来说， 1234\everyhbox&#123;b&#125;\afterassignment a\setbox0=\hbox&#123;c&#125;\showbox0 的结果是： 123456&gt; \box0=\hbox(6.94444+0.0)x15.27782.\tenrm a.\tenrm b.\kern0.27779.\tenrm c 借助隐式花括号，我们可以通过宏来开始和结束盒子。比如下面的代码就用到了这一特性： 123\def\openbox#1&#123;\setbox#1=\hbox\bgroup&#125;\def\closebox#1&#123;\egroup\DoSomethingWithBox#1&#125;\openbox0 ... \closebox0 利用这一机制，我们可以提取整个自然段的内容： 译注：这是一个在 plain TeX 下的示例，而非是 LaTeX 下的。因此，这里的 \parbox 不是 LaTeX 里的段落盒子。关于这一技巧，此处有一完整示例：\url{https://gist.github.com/1d8b9bd2f401eb0ea970a47693723ab1 1234\everypar&#123;\setbox\parbox= \vbox\bgroup \everypar&#123;&#125; \def\par&#123;\egroup\UseBox\parbox&#125;&#125; 此处，\everypar 命令 译注：\everypar 命令的参数，会被插入在每个开启自然段的水平列表的头部，位于缩进盒子之后。 开始了一个盒子，并且将自然段的文本内容保存在盒子中。假设段落的开头是： 1Begin a text ... 这就等价于 译注：注意这里忽略了盒子开头位置的 \everypar 以及对 \par 的重定义。 1\setbox\parbox=\vbox&#123;Begin a text ... 由于在盒子中，\par 被重定义了，所以，假设段落的结尾是 译注：注意这里的 \par 可以是手工插入的，也可以是输入处理器在\cstate{S 遇见行尾符自动插入的。}： 1... a text ends.\par 等价于 1... a text ends.&#125;\Usebox\parbox 在这个例子中，\UseBox 命令只能将盒子作为一个整体对待；如果想要分别处理盒子中的元素，则需要使用新的技巧。在下列代码中，\HandleLines 可以访问自然段竖直列表中连续的元素： 12345\everypar&#123;\setbox\parbox= \vbox\bgroup\everypar&#123;&#125;% \def\par&#123;\endgraf\HandleLines \egroup\box\parbox&#125;&#125;\def\HandleLines&#123; ... \lastbox ... &#125; 后文还有一个相关例子。 将盒子解包使用 \unhbox 和 \unvbox 可将盒子解包；\unhcopy 和 \unvcopy 是对应的拷贝版本。由于它们会构建部分的水平列表和竖直列表，它们分别是水平命令和竖直命令（见后续章节）。注意，不能用 \unhbox 去解包一个寄存了 \vbox 的盒子寄存器；反过来也一样不行。不过，空寄存器可以用 \unhbox 也可以用 \unvbox 解包。 解包操作会将盒子寄存器中盒子的内容取出，而后追加在盒子所处的列表中；所有的伸缩胶会被重新设置。因此下列代码 1\setbox0=\hbox to 1cm&#123;\hfil&#125; \hbox to 2cm&#123;\unhbox0&#125; 与下列代码完全相同 1\hbox to 2cm&#123;\hfil&#125; 且与下列代码不同 1\hbox to 2cm&#123;\kern1cm&#125; \unhbox 的这一本质特性被用来定义 \leavevmode： 1\def\leavevmode&#123;\unhbox\voidb@x&#125; 该命令会使 TeX 从竖直模式切换到水平模式，而不向水平列表中添加任何额外的东西。当然，由模式切换出发的 \indent 会在水平列表中添加一个缩进盒子。在水平模式中，\leavevmode 没有任何作用。注意，此处没必要使用 \unhcopy，因为寄存器本身就是空的。 还有一个细节需要注意：在竖直模式中解包竖直盒子的操作不会在前序内容与盒子内容之间添加任何行间伸缩胶。此外，\prevdepth 的值也不会发生改变，因此，盒子内容之间的伸缩胶以及盒子内容与后续内容之间的伸缩胶仅在盒子前面有东西存在的时候才会生效；并且，行间伸缩胶的只取决于之前内容的深度。相似地，在水平模式中解包水平盒子的操作不会改变 \spacefactor。 盒子中的文本水平盒子与竖直盒子里都能装文本，但它们处理文本的方式有所区别。在水平盒子中，文本被摆放在一条直线上，并且盒子的宽度在原则上是文本（及盒子内其它元素）的自然宽度。水平盒子中不允许有竖直命令（&lt;vertical command&gt;），此外 \par 在水平盒子里没有任何作用。 竖直盒子相对来说就要复杂得多了。在竖直盒子中，一旦遇到字符或其他任何水平命令（&lt;horizontal command&gt;），TeX 就会开始在非受限水平模式构建段落；也就是说，仿佛这一段落是直属于页面的一部分。而当遇到竖直命令（&lt;vertical command&gt;）或盒子结束时，TeX 会使用当前的参数值（例如 \hsize）将该段落分段成行。 因此，下列代码的不会输出宽度为 3 厘米的段落（如果 \hsize${} &gt; {}$3cm，则水平盒子会溢出）： 1\hbox to 3cm&#123;\vbox&#123;some reasonably long text&#125;&#125; 下列代码才会输出宽度为 3 厘米的段落： 1\vbox&#123;\hsize=3cm some reasonably long text&#125; 竖直盒子中的成段文本会被分段成行，而后每行都会被打包进一个水平盒子中。这些水平盒子会堆叠在内部竖直模式当中，盒子之间有 \baselineskip 和 \lineskip 分割（见后续章节）。这也是页面当中文本内容摆放的过程；只不过水平盒子是在外部竖直模式当中堆叠起来的。 如果内部竖直列表是空的，则 TeX 不会在段落开始处插入 \parskip 伸缩胶。 由于水平盒子中的文本不会被分段成行，受限和非受限水平模式还有这样一个区别：在受限水平模式中，TeX 不会插入 discretionary nodes 和会改变当前语言值的无名项目（whatsit items）。如果文本随后被解包形成段落的一部分，则这可能引发一些问题。 后续章节有关于这些内容的解释。 杂记忘掉 \box在 \newcount\foo 之后，我们就可以单独用 \foo 来访问这个计数器了。但是，对于盒子来说则必须使用 \box\foo 来访问相应的盒子。其原因在于，TeX 中不存在单独的 \boxdef 命令，而是用 \chardef 命令来代替（详见后续章节）。 举例来说，假设 \newbox\foo 命令分配了编号为 25 的寄存器，则 \textup{\foo} 与 \char25 等价。 特殊用途的盒子有些盒子寄存器有特殊用途。 编号为 255 的盒子 \box255 在 TeX 内部参与页面输出的例程。 \voidb@x 是一个数字，对应的盒子寄存器在 plain.tex 中分配；我们可以总是假设它是一个空寄存器。它被用于定义诸如 \leavevmode 等宏。 使用 plain TeX 宏 \newinsert 创建新的 \insert 之后，TeX 会预留编号相同的若干寄存器，且编号从 254 开始向前倒数。这些寄存器是：\count、\dimen、\skip 以及 \box。 水平模式中竖直盒子的高度在水平模式中，竖直盒子的参考点与包围它的水平盒子的参考点在竖直方向上对齐。TeX 会从竖直盒子的左上角，即竖直盒子参考点上方与参考点距离等于竖直盒子高度的点，开始遍历竖直盒子中的内容。改变盒子的高度会改变盒子中内容摆放的高度。 考虑以下代码 1\hbox&#123;a\setbox0=\vbox&#123;\hbox&#123;b&#125;&#125;\box0 c&#125; 其效果是 再考虑以下代码 1\hbox&#123;a\setbox0=\vbox&#123;\hbox&#123;b&#125;&#125;\ht0=0cm \box0 c&#125; 其效果是 相对的，在竖直模式中改变水平盒子的宽度不会影响水平盒子摆放的位置。 竖直盒子的更多细节有两种竖直盒子：\vbox 和 \vtop。嵌套使用两种盒子的结果可能会令人困惑。例如 1\vtop&#123;\vbox&#123;...&#125;&#125; 完全等价于 1\vbox&#123;...&#125; 如前所述，若 \vbox 的最后一个元素是铅空或伸缩胶，则其深度为零；若 \vtop 的第一个元素是铅空或伸缩胶，则其高度为零。前面的几个例子已经通过用铅空作为第一个元素或者最后一个元素演示了这一点，但是，如果 \vtop 的第一个元素不是铅空或伸缩胶，人们有可能忽视其对 \vtop 的影响。举例来说，尽管下列代码中，第一个元素不是铅空或伸缩胶，但其高度为零。这是因为在 \write 指令中包含了一个无名项目，它会被放在竖直列表当中。 1\vtop&#123;\write16&#123;...&#125;...&#125; 修正的办法是通过 \leavevmode 离开竖直模式，切换到水平模式并开启新的自然段，而后将无名项目放在自然段的起始处，而非是自然段的上方。 1\vtop&#123;\leavevmode\write16&#123;...&#125;...&#125; 摆放数值列表中的元素有时会比较棘手。例如，竖直列表中的水平盒子与竖直盒子的处理方式是不一样的。考虑以下例子，在 \offinterlineskip 之后 译注：\offinterlineskip 会禁止 TeX 在行与行之间自动地插入行间伸缩胶；因此，在 \offinterlineskip 之后，每行的 \hbox 会没有缝隙地堆叠在一起。 第一个例子 1234\vbox&#123;\hbox&#123;a&#125; \setbox0=\vbox&#123;\hbox&#123;(&#125;&#125; \ht0=0pt \dp0=0pt \box0 \hbox&#123; b&#125;&#125; 结果是 稍稍修改之后 1234\vbox&#123;\hbox&#123;a&#125; \setbox0=\hbox&#123;(&#125; \ht0=0pt \dp0=0pt \box0 \hbox&#123; b&#125;&#125; 结果变成了 造成这一区别的原因在于，水平盒子的摆放位置由其参考点确定，而竖直盒子的摆放位置由其左上角确定。 将 \lastbox 还回列表通过 \lastbox 你可以将（内部）竖直列表中最后一个盒子取出。但是，如果你想把取出的盒子换回去，则竖直间距可能会出问题。比如说，如果你这样将它换回去，则行间伸缩胶会有两份。 12\setbox\tmpbox=\lastbox\usethetmpbox \box\tmpbox 而如果你在换回去之前使用 \unskip 命令，看上去解决了问题，但实际上错得更加微妙： 12\setbox\tmpbox=\lastbox\unskip \usethetmpbox \box\tmpbox 此时，内部距离（&lt;internal dimen&gt;）\prevdepth（控制行间伸缩胶；见后续章节）的值会因最后一个盒子而改变，但正确的行间伸缩胶应该由上一个盒子来决定。正确的方法不是使用 \unskip，而是使用 \nointerlineskip： 12\setbox\tmpbox=\lastbox\usethetmpbox \nointerlineskip \box\tmpbox 使用 \lastbox 切分自然段反复调用 \last... 和 \un... 可以将自然段切分开。这里给出一个例子。 1234567891011121314\newbox\linebox \newbox\snapbox\def\eatlines&#123; \setbox\linebox\lastbox % check the last line \ifvoid\linebox \else % if it's not empty \unskip\unpenalty % take whatever is &#123;\eatlines&#125; % above it; % collapse the line \setbox\snapbox\hbox&#123;\unhcopy\linebox&#125; % depending on the difference \ifdim\wd\snapbox&lt;.98\wd\linebox \box\snapbox % take the one or the other, \else \box\linebox \fi \fi&#125; 它的使用方式是 1\vbox&#123; ... some text ... \par\eatlines&#125; 或者也可以用 \everypar 自动插入。 宏 \eatlines 会从竖直列表取得 \lastbox。如果列表为空，则 \ifvoid 将返回真。这些盒子都是水平盒子，每个盒子包含了段落中的一行：如果使用 \ifhbox 来判断盒子分类的话，将返回真。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>List</tag>
        <tag>Vertical</tag>
        <tag>Box</tag>
        <tag>Mode</tag>
        <tag>Horizontal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TeX 主题选讲：字体]]></title>
    <url>%2F2018%2F05%2F12%2FTeX-by-Topic-Fonts%2F</url>
    <content type="text"><![CDATA[此篇基本上是译文，原文是 Victor Eijkhout 所著的《TeX by Topic》的第四章。译文项目参见：CTeX-org/tex-by-topic-cn。转载请保留本段文字，尊重原作者和译者版权。由于原著使用 GFDL，故而本文也被传染地同样使用 GFDL 许可，而不是本站默认的 BY-NC-SA 4.0 许可。 在文本模式下，TeX 会从「当前字体」中取用字符。本章讨论 TeX 是如何识别不同字体的，以及字体都有哪些属性。 所涉命令编目： \font： 该命令可声明一个用于指定字体的控制序列。 \fontname： 字体的外部名字。 \nullfont： 在特殊情况下，TeX 会使用空字体。这是空字体的名字。 \hyphenchar： 字体中连字符的序号。 \defaulthyphenchar： 字体装载时 \hyphenchar 的默认值。在 plain TeX 中，默认是 `-。 \fontdimen： 该命令可访问多种字体参数。 \/： 倾斜校正原语。 \noboundary： 忽略隐式边界字符。 字体在 TeX 语境下，字体（font）这一术语指的是保存在外部文件中的一系列字符的集合。TeX 在运行时，会决定从哪一个字体中选取字符。而具体决策方式在文本模式和数学模式中又是不同的。 TeX 处理普通文本时会从「当前字体」中选取字符。通过字体声明，TeX 会将外部字体文件与字体选择命令联系起来。例如，下列声明会使 TeX 装载名为 myfont10.tfm 的字体文件。 1\font\MyFont=myfont10 此后，通过下列命令，我们就可以选择使用该文件定义的字体了。 1\MyFont 当前字体的状态是可查的：下列命令会产生当前字体对应的控制序列。 1\the\font 数学模式下，TeX 会忽略当前字体；转而考察当前「字族」，其中有三个字体：正文字体（text style），角标字体（script style），双重角标字体（scriptscript style）。 从不同物理字体文件中分别选取部分字符，可以组成的「虚拟字体」。在 TeX 看来，这种虚拟字体就像是真实字体一样。 字体声明TeX 或 IniTeX 在执行时，必然在某处会建立内部字体选择命令与外部字体文件名的联系。font 字体声明的语法如下： 1\font&lt;control sequence&gt;&lt;equals&gt;&lt;file name&gt;&lt;at clause&gt; 这里，&lt;at clause&gt; 指的是： 注意，字体声明仅在当前分组内生效。 用户可以通过 &lt;at clause&gt; 指定字体的放大版本。&lt;at clause&gt; 有两种形式：如果指定缩放比例 scaled $f$，则 TeX 会将该字体中的所有字符尺寸倍乘 $f/1000$；如果指定目标大小 at $f$pt，而字体本身的设计大小是 $d$pt，则 TeX 会将该字体中的所有字符尺寸倍乘 $f/d$。注意，&lt;at clause&gt; 不会影响 TeX 从外部字体文件（.tfm 文件）中读入字体的过程；它只是在尺寸上乘了一个固定的倍数。 这样声明字体后，使用定义得到的控制序列会将当前字体设置为控制序列相应的字体。 字体与 tfm 文件TeX 所需的外部字体文件是 tfm 文件（TeX 字体尺寸文件，TeX Font Metrics File），这些文件不受 \font 声明中 &lt;at clause&gt; 的影响。如果 tfm 事先已装载好（比如在构造格式文件时由 IniTeX 装载），则再次声明同一字体时，不依赖且无需重复载入 tfm 文件。 字体本身的设计大小由字体尺寸文件给出。例如，字体 cmr10 的设计大小是 10 点（point）。但实际上，字体中没有多少字符大小是 10 点：左右圆括号恰好是 10 点，但大写字母明显会小一点。 查询当前字体及字体名前文提到过，当前字体的字体选择命令可通过 \the\font 得到。这是下列语法的一个特例。 1\the&lt;font&gt; 此处，&lt;font&gt; 表示： &lt;fontdef token&gt; 是由 \font 定义的控制序列，或是预定义的 \nullfont。至于 &lt;family member&gt; 的概念，则只与数学模式有关。 此外，外部字体文件名可用以下方式取得： 1\fontname&lt;font&gt; 该命令以字符串的形式（其中的字符记号分类码均为 12，而空格记号的分类码为 10）给出当前字体的文件名；若有相应的 &lt;at clause&gt; 则也一并给出。 例如，在如下声明之后， 1\font\tenroman=cmr10 \tenroman \the\font 和 \the\tenroman 会给出 \tenroman；\fontname\tenroman 则给出 cmr10。 \nullfontTeX 将没有任何字符的字体与定义为 \nullfont。如果没有指定任何字体，或是在数学模式中某一所需的字族成员未定义，则 TeX 会从空字体中取用字符。该控制序列属于 &lt;fontdef token&gt;：它与其它字体选择命令的行为类似；但不与任何外部 tfm 文件相关联。 字体信息TeX 执行时所需的主要字体信息包括尺寸与字符。TeX 会在字体尺寸文件中寻找这些信息，这些文件的扩展名通常是 .tfm。此类文件包含 全局信息：主要是 \fontdiem 参数，还有其他一些信息 字符的尺寸以及倾斜校正（italic corrections） 字符的连字（ligature）及挤压（kerning）指令 字体的设计大小也由 tfm 文件指定。 字体尺寸参数文本字体至少得有 7 个 \fontdimen 参数来描述字体尺寸（对于未指定的参数，TeX 会以零作为默认值）；数学符号以及数学扩展字体还有更多的参数。文本字体的 7 个参数描述如下： 每点倾斜（slant per point）；该参数用于确定重音符号正确的水平位置。 词间空距（interword space）：如果用户没有显式设定 \spaceskip，则该参数会被当做词间空距的默认值。 词间拉伸（interword stretch）：该参数是词间距离的拉伸值部分。 词间收缩（interword shrink）：该参数是词间距离的收缩值部分。 x-高度（x-height）：该参数是 TeX 内部单位（&lt;internal unit&gt;）ex 的值，通常是小写字母「x」的高度。 方块铅空宽度（quad width）：该参数是 TeX 内部单位 em 的值，它大约是大写字母「M」的宽度。 额外空距（extra space）：如果用户没有显式设定 \xspaceskip，则该参数是在句子末尾处加在词间空距之上的额外空距（当 \spacefactor${}\geqslant2000$）。 译注：英文单词「quad」是传统铅印术中的术语，它来自意大利语单词「quadratone」，意思是「大方块」。 第 1 个和第 5 个参数纯粹是字体的信息，因此改变它们没什么意义。其余参数则可以用来调整相关空距；后续章节有关于第 2, 3, 4, 7 个参数的相关示例。 字体尺寸参数可用字体赋值语句（&lt;font assignment&gt;）来修改，这种赋值语句属于全局赋值语句（&lt;global assignment&gt;）： 1\fontdimen&lt;number&gt;&lt;font&gt;&lt;equals&gt;&lt;dimen&gt; &lt;font&gt; 的定义可见上文。 字符挤压通常，每个字符的边界盒子（bounding box）彼此邻接。但对于部分字符组合来说，它们之间的距离应该比边界盒子邻接的情况更近一些。这种情况称为字符挤压（kerning）。对于字体来说，字符挤压的设计与字符形状的设计同等重要。 举个例子： 在 TeX 中，字符挤压由 tfm 文件中的字体信息控制，因此不受用户的影响。不过，tfm 文件是可以修改的。 \kern 命令与字符挤压现象没什么关系；它将在后续章节中介绍。 倾斜校正TeX 原语 \/ 会向前一个字符或连字后面插入倾斜校正（italic correction）。考虑到边界盒子（bounding box）的定义，这种修正是很有必要的：边界盒子总是有竖直的边，并且 TeX 将两条竖直边之间的距离当做是字符的宽度。然而，为了在斜体或意大利体中得到恰当的空距，字符会显著突出其边界盒子。当这种向外突出的字符后边紧跟着一个非倾斜的字符时，就需要插入倾斜校正。 对比以下两例： 这里，有倾斜校正的版本的代码如下。 1&#123;\italic TeX\/&#125; has 各个字符倾斜校正的具体值由字体尺寸文件中的字体信息决定；对于 Computer Modern 字体来说，该值大约是字符向外突出边界盒子距离的一半。倾斜校正与每点倾斜（\fontdimen1）是不一样的；后者仅用于放置重音符号。 倾斜校正仅在 TeX 刚处理完一个字符或者连字时才会插入其后。因此，由于在下例中，在遇到倾斜校正原语之前 TeX 刚处理完行间胶水（而不是字符或者连字），下面对罗马字族文本做的倾斜校正是不会生效的。 1&#123;\italic Some text &#123;\/\roman not&#125; emphasized&#125; 连字将字符序列替换为连字（ligatures）的过程是由字体 tfm 文件中的信息控制的。连字由字符（&lt;character&gt;）命令组成：在某些字体里，诸如 fi 的字符序列会替换为「fi」。 传统上，还有其它的连字，比如 ff, ffi, fl 以及 ffl；在更古老的字体里，可能还有 ft 以及 st，以及类似 fl 的连字：fk 和 fb。 在 TeX 中，连字可由显式字符记号、\char 命令以及 &lt;chardef token&gt; 组成。例如，如果字体里有这样的连字定义，\charf\chari 会被替换成连字「fi」。 我们有多种方式来限制不希望出现的连字。例如 halflife 中不希望出现的连字可以这样避免： 1half&#123;&#125;life, half&#123;l&#125;ife, half\/life, 以及 half\hbox&#123;&#125;life 注意，使用倾斜校正原语避免不希望出现的连字的方案与其它方案的机理不完全一样。 边界连字（Boundary ligatures）在 TeX3 中还有单词边界的概念：每个单词都由左右两个边界字符界定。这样的设定使 TeX 能够实现一些语言中特殊的现象，例如在希腊语中位于词尾的西格玛（$\sigma$）和位于其他位置的西格玛是不一样的。在单词的前后添加 \noboundary 命令，可以抑制相应的边界连字机制。 译注：这里指的是通过边界连字来实现一些语言中特殊的现象。 大致上，TeX 3 的连字机制比 TeX 2 要复杂得多。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Fonts</tag>
        <tag>Kerning</tag>
        <tag>Ligature</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TeX 主题选讲：字符]]></title>
    <url>%2F2018%2F05%2F09%2FTeX-by-Topic-Characters%2F</url>
    <content type="text"><![CDATA[此篇基本上是译文，原文是 Victor Eijkhout 所著的《TeX by Topic》的第三章。译文项目参见：CTeX-org/tex-by-topic-cn。转载请保留本段文字，尊重原作者和译者版权。由于原著使用 GFDL，故而本文也被传染地同样使用 GFDL 许可，而不是本站默认的 BY-NC-SA 4.0 许可。 TeX 在其内部使用字符编码来表示字符；本章讨论字符编码及相关命令。 所涉命令编目： \char: 显式指定所要排版的字符。 \chardef: 将一个控制序列定义为一个字符编码的同义词。 \accent: 放置重音符号的命令。 \if: 测试字符编码是否相等。 \ifx: 测试字符编码与分类码是否都相等。 \let: 将一个控制序列定义为一个记号的同义词。 \uccode: 对于给定的字符编码，查询或设置其对应的大写变体的编码。 \lccode: 对于给定的字符编码，查询或设置其对应的小写变体的编码。 \uppercase: 将普通文本（&lt;general text&gt;）转换为大写形式。 \lowercase: 将普通文本（&lt;general text&gt;）转换为小写形式。 \string: 将一个记号转换为一个字符串。 \escapechar: 将控制序列转换为一串字符记号时，用作转义字符的字符之编码。在 IniTeX 中默认为 92（\）。 字符编码在概念上说，认为 TeX 内部直接对字符进行处理是最简单的；但是实际上 TeX 内部处理的是整数，即字符编码。 不同系统中，字符的编码方式可能不同。因此，TeX 使用其自身定义的字符编码方案。任何从文件或用户终端读入的字符，都会依据编码表转换成字符编码。之后，TeX 会根据这一字符编码为它们分配分类码。编码表基于 7-位 ASCII 编码表，可编码 128 个字符。 反引号（{，或称左引号）可将字符（准确说是字符记号）转换为其字符编码。在 TeX 中，所有需要 &lt;number&gt; 的地方，都可以通过这种方式将一个字符记号的编码传给 TeX：反引号加字符或是反引号加单字符控制序列。例如 \count\a 和 \count`\a 都表示 \count97。 第二种方式在某些情况下是有必要的，例如在下例中，若去掉 \，就会让 TeX 产生误解。 1\catcode`\%=11\quad or\quad \def\CommentSign&#123;\char`\%&#125; 例如在下例中，=11 会被认为是注释。 1\catcode`%=11 单字符的控制序列可以由任何分类码的字符组成。 译注：特别地，可以是无效字符。 当字符记号被转换为字符编码后，字符编码就与字符的形状没有关联了。当然，对于大多数字符来说，在视觉上，其排版输出与输入是一致的。例如输入 a 会排版输出字符「a」。不过，即使在常见的符号中，也有例外情况。在计算机现代罗马字体中，就没有小于号和大于号。 为了使 TeX 在输出端也不依赖具体的机器，dvi 文件格式也是用这种字符编码：操作码 $n=0\ldots127$ 表示：「从当前字体中取出第 $n$ 个字符。」在 TeXprogram 中可以找到 dvi 文件的操作码的完整定义。 字符相关的控制序列有许多种方式可以用控制序列来表示字符。例如说，\char 命令可以指定一个用于打印的字符；\let 命令可引入一个与指定字符记号同义的控制序列——包括其字符编码和其分类码。 表示要排版的字符：\char字符可以通过数值来表示，比如 \char98。该命令会将当前字体中编码为 98 的字符添加到正在构建的水平列表中。 相较而言，用八进制或十六进制表示字符编码可能比用十进制更方便。在数值前加上单引号，即可使用八进制数：\char&#39;142；在数值前使用双引号，即可使用十六进制数：\char&quot;62。注意，连续使用两个单引号，比如 \char&#39;&#39;62 是错误的写法——将两个单引号替换为一个双引号的工作是由可视化处理器承担的，而不是数字扫描操作（执行处理器）。 由于可用反引号获取字符的编码，在当前字体的编码与 ASCII 兼容时，用 \char`b 或 \char`\b 也可以得到 “b” 这个字符。 表面上看，\char 命令与 ^^ 替换机制类似：两种机制都是通过间接的方式来访问字符。但是，^^ 替换机制发生的非常早——在 TeX 的输入处理器为字符分配分类码之前；而 \char 命令则在可视化处理器中起作用。从效果上看，\char 是告诉 TeX：「排版字体中第 $n$ 个字符。」 \chardef 命令可定义一个控制序列定义作为一个字符编码的代替品。它的用法是 1\chardef&lt;control sequence&gt;&lt;equals&gt;&lt;number&gt; 此处的 &lt;number&gt; 可以是显式给出的数字，也可以是计数器值，也可以是用反引号提取得到的字符编码（见上文）。在 plain TeX 中，就有类似下面的用法： 1\chardef\%=`\% 它等价于下面的定义方式： 1\chardef\%=37 如此定义之后，控制字符 \% 就变成了 \char37 的同义词。也就是说，它可以用于排版第 37 个字符（通常是百分号）。 用 \chardef 命令定义的控制序列可作为 &lt;number&gt; 使用。在诸如 \newbox 的分配类命令中，就用到了这一特性。用 \mathchardef 命令定义的记号同样可以这样使用。 隐式字符记号：\let另一种定义表示字符的控制序列的方式是使用 \let 命令，并且将字符记号置于可选等号的右边： 1\let&lt;control sequence&gt;&lt;equals&gt;&lt;token&gt; 如此，得到的控制序列称为隐式字符记号。 在 plain TeX 中有对左右花括号定义同义控制序列： 1\let\bgroup=&#123; \let\egroup=&#125; 如此，得到的控制序列被称为「隐式花括号」。 通过 \let 和 \chardef 将字符赋值给控制序列是有区别的。被 \let 定义的控制序列是字符编码与分类码这一组合的替代品。 例如在下例中，\b 关闭了 \m 定义所在的分组，因此 TeX 会提示错误：「未定义的控制序列」。 123\catcode`|=2 % make the bar an end of group\let\b=| % make \b a bar character&#123;\def\m&#123;...&#125;\b \m 又例如在下例中，\b 的定义在分类码修改之前，因此它无法承担分组结束符的作用，只能表示一条竖线（或是其他任何在当前字体中编号为 124 的字符）。因此，这里构造的是一个不闭合的分组。 123\let\b=| % make \b a bar character\catcode`|=2 % make the bar character end of group&#123;\def\m&#123;...&#125;\b \m 前一个例子表明，即是花括号本身被重定义了（例如在排版 C 语言代码时被定义成活动字符），分组开始和结束的功能依然可以由控制序列 \bgroup 和 \egroup 来承担。 隐式字符记号的行为与真实字符记号非常相似。举例来说，在如此定义之后， 1\catcode`|=2 \let\b=| 以下两个真值测试均为真。 1\if\b| 1\ifcat\b&#125; 再举一例。在 plain TeX 中，有如下对上标和下标符号的定义： 1\let\sp=^ \let\sb=_ 如此一来，即使键盘上没有这两个符号，也可以通过这两个控制序列得到数学环境的上标和下标。 1x\sp2\sb&#123;ij&#125;\quad gives\quad $x\sp2\sb&#123;ij&#125;$ 若是编写格式的人的键盘上也没有这些键，那么就要用更深的技巧了： 12&#123;\lccode`,=94 \lccode`.=95 \catcode`,=7 \catcode`.=8\lowercase&#123;\global\let\sp=, \global\let\sb=.&#125;&#125; 至于它为什么能起作用，可详见后文关于 \lowercase 的介绍。由于我们无法键入 ^，因此 TeX2 中的 ^^ 表示法无法在此解决问题。考虑到上标和下标的字符编码以十六进制表示分别是 5e 和 5f，利用 TeX3 中扩展的表示法可以依照如下方式解决问题： 12&#123;\catcode`\,=7\global\let\sp=,,5e \global\let\sb=,,5f&#125; 使用 \meaning 命令可以查看使用 \let 定义的命令究竟代表哪个字符。例如下列代码将给出 “the character 3”。 1\let\x=3 \meaning\x 重音重音符号可用水平命令（&lt;horizontal command&gt;）\accent 给出。 1\accent&lt;8-bit number&gt;&lt;optional assignments&gt;&lt;character&gt; 其中，&lt;character&gt; 是分类码为 11 或 12 的字符，或是形如 \char` 的命令，抑或是一个由 \chardef 定义的记号。此时，重音符号会被放置在该字符的上方。若 &lt;character&gt; 不是上述四种情况之中的任意一种，则重音符号会被 \char 命令直接处理，从而给出一个「悬在半空」的重音符号。可选的 &lt;optional assignments&gt; 可用于改变重音和字符的字体。 \accent 命令后必须紧跟 &lt;character&gt;。这一规定避免了将重音符号置于连字之上或是置于另一个重音符号之上。在诸如印度语及越南语的少数语言中，确实存在双重音符号的情况；因此这种规定有时可能会令人不爽。不过，将重音符号置于另一个之上可以在数学模式中实现。 添加重音符号不会改变字符的宽度。对于重音符号摆放的位置，TeX 假设字体文件中，重音符号摆放的高度与字母 x 的高度相适应；对于其他高度的字母，TeX 则可以通过向上或向下移动恰当的高度来调整重音符号的位置。 在 TeX 中没有真正的下重音，而是将它们视作位置较低的上重音实现的。更准确的做法是：编写一个宏，测量紧跟着的字符的尺寸，而后相应地升高或降低重音符号的位置。plain TeX 中的变音宏 \c 就是这样做的。不过，对于有下伸部分的字母，它不会降低重音符号的位置。 译注：所谓下伸部分，指的是个别小写字母比其它小写字母更低的部分。比如「p」、「q」的「小尾巴」。 重音符号的水平位置由 \fontdimen1（每点倾斜，slant per point）控制。为此，TeX 会引入铅空以校正重音符号的水平位置。注意，尽管这些铅空是自动插入的，但这些铅空隶属显式铅空。因此，它们会抑制铅空前后的连字符。 译注：铅空是活字印刷排版时代，排版工人用于调整字符水平位置而使用的空白铅块。 以下代码能将水平列表转储出来，作为铅空和重音符号的示例。 12\setbox0=\hbox&#123;\it \`l&#125;\showbox0 其结果是 123456\hbox(9.58334+0.0)x2.55554.\kern -0.61803 (for accent).\hbox(6.94444+0.0)x5.11108, shifted -2.6389..\tenit ^^R.\kern -4.49306 (for accent).\tenit l 注意，TeX 首先放置重音符号，以保证最后一个字符的倾斜校正仍然有效。 字符真值测试使用 \if 可检测两个字符记号的字符编码是否相等： 1\if&lt;token$_1$&gt;&lt;token$_2$&gt; TeX 遇到 \if 后，会对其后的记号持续展开，直至遇见两个不可展开的记号。而后，不管分类码如何，若这两个记号的字符编码相等，则真值测试为真。 对于 TeX 来说，不可展开的控制序列的字符码是 256 而分类码为 16（因此控制序列的字符编码只与控制序列的字符编码相等），除非控制序列被 \let 定义成一个非活动字符记号——如前所述，此时该控制序列的字符编码和分类码与相应的字符相同。 后续章节会介绍用于检验分类码的 \ifcat 命令；此处关注真值测试 1\ifx&lt;token$_1$&gt;&lt;token$_2$&gt; 则检验字符编码和分类码是否均相等。特别注意的是，TeX 不会展开 \ifx 之后的记号。不过，若它们是宏，则 TeX 会检验它们的展开是否相等。 对于 \chardef 定义的数量，则可以用 \ifnum 来检验。 1\chardef\a=`x \chardef\b=`y \ifnum\a=\b % is false 这是因为由 \chardef 定义的记号可被当做是数字来使用。 大写和小写大写和小写的编码每个字符编码都有对应的大写编码和小写编码。它们可分别用 1\uccode&lt;number&gt;&lt;equals&gt;&lt;number&gt; 和 1\lccode&lt;number&gt;&lt;equals&gt;&lt;number&gt; 来指定。在 IniTeX 中，a..z 及 A..Z 的大写编码为 A..Z 而小写编码为 a..z。其余所有的字符的大写编码和小写编码均为零。 大写和小写命令\uppercase{...} 和 \lowercase{...} 命令会遍历参数记号列表，而后将所有对应大写编码或小写编码不为零的显式字符替换成相应的大写编码或小写编码，分类码则维持不变。 \uppercase 和 \lowercase 命令的参数是普通文本（&lt;general text&gt;），其定义如下： 此处，左花括号可以是隐式字符记号，但右花括号必须是分类码为 2 的显式字符记号。在寻找左花括号时，TeX 会进行宏展开。 与 \number 和 \string 不同，大小写转换不是宏展开，而是在执行处理器中执行的。下列尝试得到 \A 的代码会因 \uppercase 不可展开而报错——TeX 将在 \uppercase 之前插入 \endcsname。 译注：这里的表述比较奇怪。事实上，TeX 要求 \csname 和 \endcsname 之间的内容展开到底后不能有不可展开的原语；而 \uppercase 正是一个不可展开的原语，故而报错。这里提出 TeX 在 \uppercase 之前插入 \endcsname，原因可能是 TeX 在发现问题「尝试修复的过程中」，会做这样的操作。 1\expandafter\csname\uppercase&#123;a&#125;\endcsname 正确的写法如下： 1\uppercase&#123;\csname a\endcsname&#125; 下例对 \uppercase 的使用是正确的，它可用于检测一个字符是否为大写： 1\def\ifIsUppercase#1&#123;\uppercase&#123;\if#1&#125;#1&#125; 大写检测也可以这样做：\ifnum`#1=\uccode`#1。 首字母大写（首字母的字符编码与其 \lccode 不同）的单词是否允许截断连字取决于 \uchyph 参数。若改参数为正数，则允许对首字母大写的单词进行截断连字。 关键字的大写与小写形式TeX 关键字可以是大写形式也可以是小写形式。比如 pt 还可以写作 pT、Pt 以及 PT。此处，TeX 不使用 \uccode 及 \lccode 表来确定小写形式；而是直接在大写字母的字符编码上加 32 来得到其小写形式——ASCII 编码中，同一字母大小写形式之差为 32。这种做法与 TeX 在处理非罗马字符时的具体实现方式有些关联；详见 TeXbook 第 370 页。 巧用 \uppercase 和 \lowercase利用 \uppercase 和 \lowercase 不会改变分类码的特性，可以构造出一些其它方式难以构造的字符编码-分类码配对。 再将一个稍有些不同的例子。考虑这一问题（已由 Rainer Schopf 解决）：给定一个计数器 \newcount\mycount，如何将其值作为字符编号输出到终端？解法如下。 1\lccode`a=\mycount \chardef\terminal=16 1\lowercase&#123;\write\terminal&#123;a&#125;&#125; 此处，\lowercase 命令有效地将 \write 命令的参数，从「a」转换成目标值。 字符相关编码每个字符编码都有一系列与之相关的 &lt;codename&gt;。这些整数的取值范围各不相同；它们决定了在不同场合下，TeX 会如何处理该字符，或是决定了在不同场合下，该字符会如何影响 TeX 自身。 这些编码的名字罗列如下： \catcode: 4 位数字（&lt;4-bit number&gt;，0–15）；字符的分类码。 \mathcode: 15 位数字（&lt;15-bit number&gt;，0–&quot;7FFF 或 &quot;8000）；它决定 TeX 在数学环境下如何处理该字符。 \delcode: 27 位数字（&lt;27-bit number&gt;，0–\hex7$\,$FFF$\,$FFF）；它决定 TeX 在数学环境下如何处理出现在 \left 和 \right 之后的该字符。 \sfcode: 整数；它决定 TeX 如何处理位于该字符之后的空距。 \lccode、\uccode: 8 位数字（&lt;8-bit number&gt;，0–255）；如前所述，这是字符的小写及大写的编码。 将记号转换为字符串\string 命令能将其下一个记号展开为由若干字符组成的字符串。例如，下例将输出 \control。 1\tt\string\control 又例如下例将输出 $。 1\tt\string$ 注意，字符串操作位于记号化之后。因此下例不能输出注释符号 %，因为早在输入处理器中，注释符号就被删除了。于是，下例中的 \string 会将下一行的第一个记号转换为字符串。 1\tt\string% \string 命令由展开处理器执行。因此，除非显式地禁止，它必然会被展开。 输出控制序列上例使用了打字机字族。这是因为，在计算机现代字体中，罗马字族里没有反斜线这一字符。 不过，TeX 也可以使用其它字符来打印控制序列：具体来说，TeX 使用 \escapechar 保存的字符编码对应的字符来打印控制序列。在使用下列命令时，也会用到 \escapechar 这个宏保存的值： \write、\message、\errmessage、\show、\showthe 以及 \meaning。若 \escapechar 的值为负或者大于 255，则转义字符不会显示出来；此外，在 IniTeX 中 \escapechar 的默认值是 92，即反斜线的字符编码。 译注：\tt 是 plain TeX 风格的字体选择命令。在 LaTeX 中，应当使用 \ttfamily 或者 \texttt 代替。 在 \write 语句中，有时可用 \noexpand 代替 \string。 \string 输出输出字符串的分类码\string 命令输出的字符串中，各个字符的分类码均为 12，唯独被字符串化的控制序列中的空格，其分类码是 10。由于控制序列内部不存在分类码的说法，\string 输出的所有空格必定只是空格字符，也就是说，它的字符编码是 32。由于 TeX 的输入处理器会将所有空格记号的字符编码设置为 32，「滑稽空格」出现在控制序列中的机会相当渺茫。 在分类码方面，其他命令的行为与 \string 表现一致：\number、\romannumeral、\jobname、\fontname、\meaning 以及 \the。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Character</tag>
        <tag>Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TeX 主题选讲：分类码与内部状态]]></title>
    <url>%2F2018%2F05%2F05%2FTeX-by-Topic-Category-Codes-and-Internal-States%2F</url>
    <content type="text"><![CDATA[此篇基本上是译文，原文是 Victor Eijkhout 所著的《TeX by Topic》的第二章。译文项目参见：CTeX-org/tex-by-topic-cn。转载请保留本段文字，尊重原作者和译者版权。由于原著使用 GFDL，故而本文也被传染地同样使用 GFDL 许可，而不是本站默认的 BY-NC-SA 4.0 许可。 读取字符时，TeX 的输入处理器会为字符分配分类码。根据读取到字符的分类码，输入处理器会在三种内部状态之间切换。本章讨论 TeX 是如何读取字符的，以及字符的分类码是如何影响读取行为的。本章还将讨论空格及行尾的相关问题。 在本文的翻译中：行尾（line ends）是一行末尾及相关问题的统称，行终止符（end-of-line character）是 TeX 的输入处理器主动添加在输入行末尾的字符，行尾符是操作系统中用于标识一行结尾的字符，例如：回车符（carriage return）与换行符（line feed）。 概述TeX 的输入处理器从文件或终端扫描输入行，而后将读取到的字符转换成记号。输入处理器可视作一简单的有限状态自动机，其具有三种内部状态；根据输入处理器所处内部状态的不同，其扫描行为有所不同。本章将分别从内部状态和控制内部状态转换的分类码两个角度来考察该自动机。 初始化处理TeX 逐行处理来自文件的输入（也可能是来自终端的输入，但实际甚少使用，故不再提及）。此处首先讨论在 TeX 语境下，到底什么是「输入行」。 不同计算机系统对输入行的具体定义有所不同。最常见的方式是用回车符（carriage return）紧跟换行符（line feed）作为行尾符，有些系统单用换行符作为行尾符，一些有定长存储（块存储）的系统则根本不使用行尾符。因此，TeX 在结束一行输入时有自己特定的处理方式。 从输入文件读取一行输入行（不包含可能的行尾符）。 移除行尾空格（这是针对块存储系统设计的，同时避免了因行为空格不可见而导致的混乱）。 将编码为 \endlinechar 的行终止符（默认是 ASCII 编码为 13 的 &lt;return&gt;）添加在行尾。若 \endlinechar 的值为负或大于 255（在低于 TeX 3 的版本中则是 127），则输入处理器不会添加任何行终止符；在输入行尾添加注释字符也有相同的作用。 不同计算机在字符编码方面也存在差异（最常见的是 ASCII 和 EBCDIC）。因此，TeX 有必要将从文件读入的字符转换为其内部编码。这些编码仅在 TeX 内适用，因此 TeX 在任何操作系统上的行为都保持一致。 分类码256 个字符编码（0–255）中的每一个都关联了一个不尽相同的分类码。TeX 的分类码共有 16 个，从 0 开始编号至 15。在扫描输入流的过程中，TeX 会生成由字符编码和分类码组成的字符编码-分类码配对（character-code–category-code pairs）；而后，基于这些配对，输入处理器将它们处理成字符记号、控制序列记号和参数记号。这些记号随后被传给 TeX 的展开处理器和执行处理器。 字符记号是简单的字符编码-分类码配对，它们会直接被传给展开处理器。控制序列记号则由转义字符引导，后接一个或多个字符组成。关于控制序列记号和参数记号的介绍详见下文。 以下就这些分类做简单说明，详细的阐述则散布在本章其他位置及后续章节当中。 0，转义字符；用于标记控制序列的开始。IniTeX 默认使用反斜线 \ 作为转义字符（ASCII 码为 92）。 1，分组开始符；TeX 遇到此类字符时，会进入新的一层分组。在 plain TeX 中，默认的分组开始符是左花括号 {。 2，分组结束符；TeX 遇到此类字符时，会关闭并从当前分组中退出。在 plain TeX 中，默认的分组开始符是左花括号 }。 3，数学切换符；此类字符是数学公式的左右定界符。在 plain TeX 中，默认的数学切换符是美元符号 $。 4，制表符；在 \halign（\valign）制作的表格中，作为列（行）间分隔符。在 plain TeX 中，默认的制表符是与符号 &amp;。 5，行终止符；TeX 用来表达输入行结束的字符。IniTeX 将回车符 &lt;return&gt;（ASCII 编码为 13）作为默认的行终止符。这就是为什么 IniTeX 中，\endlinechar 的值是 13（详见前文）。 6，参数符；用于表示宏的参数。在 plain TeX 中，默认的参数符是井号 #。 7，上标符；在数学模式中表示上标；也可用于在输入文件中表示无法直接输入的字符（详见后文）。在 plain TeX 中，默认的上标符即是 ^。 8，下标符；在数学模式中表示下标。在 plain TeX 中，默认的下标符是下划线 _。 9，被忽略字符；此类字符将被 TeX 自输入流中清除，因此不会影响后续处理。在 plain TeX 中，默认将空字符 &lt;null&gt;（ASCII 编码为 0）设置为被忽略字符。 10，空格符；TeX 对待空格符的方式较为特殊。IniTeX 将空格 &lt;space&gt;（ASCII 编码为 32）作为默认的空格符。 11，字母；IniTeX 默认只将 a ... z 和 A ... Z 分为此类。在宏包中，某些「隐秘」字符（例如 @）会被暂时分为此类。 12，其他字符；IniTeX 将所有未归于其他类的字符归于此类。因此，数字和标点都属于此类。 13，活动字符；活动字符相当于一个无需转义字符前导的 TeX 控制序列。在 plain TeX 中，只有带子 ~ 是活动字符，表示不可断行的空格。 14，注释符；TeX 遇见注释符后，会将从注释符开始到输入行尾的所有内容视作注释而忽略。在 IniTeX 中，默认的注释符是百分号 %。 15，无效字符；该分类包含了不应在 TeX 中出现的字符。IniTeX 将退格字符（ASCII 编码为 127）&lt;delete&gt; 归于此类。 用户可使用 \catcode 命令修改字符编码到分类码的映射： 1\catcode&lt;number&gt;&lt;equals&gt;&lt;number&gt; 该语句中，第一个参数可用如下方式给出： 1`&lt;character&gt; 或者 `\&lt;character&gt; 两种写法都表示该字符的字符编码。 plain TeX 格式使用 \chardef 命令将 \active 定义为： 1\chardef\active=13 因此上述语句可写成这样： 1\catcode`\&#123;=\active LaTeX 格式定义了如下两个控制序列，用于开启或关闭「隐秘字符」@（详见下文）： 12\def\makeatletter&#123;\catcode`@=11 &#125;\def\makeatother&#123;\catcode`@=12 &#125; 使用 \catcode 命令查询字符编码对应的分类码，可得到一个数字： 1\count255=\catcode`\&#123; 在例中，{ 的分类码被保存在第 255 号 \count 寄存器中。 下列语句可用于检测两个记号的分类码是否相等： 1\ifcat&lt;token1&gt;&lt;token2&gt; 无论 \ifcat 后有什么，TeX 都会将其展开，直至发现两个不可展开的记号；而后，TeX 将比较这两个记号的分类码。控制序列的分类码被视为 16；因此，所有控制序列的分类码都是相等的，而与所有字符记号的分类码都不相等。 从字符到记号从文件或用户终端扫描输入行后，TeX 的输入处理器会将其中的字符转换为记号。记号共有三种。 字符记号：字符记号会被打上相应的分类码，而后直接传给 TeX 的后续处理器。 控制序列记号：严格来说，控制序列记号分为两种。其一是控制词 —— 分类码为 0 的字符后紧跟一串字母（分类码是 11）。其二是控制字符 —— 转义字符后紧跟单个非字母字符（分类码不是 11）。在无需区分控制词和控制字符的场合，它们统称为控制序列。由转义字符与一个空格字符 ␣ 构成的控制序列，称为控制空格。 参数记号：由一个参数符 —— 分类码为 6，默认为 # —— 和一个紧跟着的1..9 中的数字构成。参数记号只能在宏的上下文中出现。连续两个参数符（字符编码不一定相同）会被替换为单个字符记号。该字符记号的分类码是 6（参数符），字符编码则与上述连续两个参数符中后者的字符编码相同。最常见的情形是 ## 会被替换为 #，其分类码为 6。 输入处理器是有限状态自动机TeX 的输入处理器有三种内部状态，可看做是一个有限状态自动机。这也就是说，在任意瞬间，TeX 的输入处理器都处于并且只能处于三种状态的一种；并且在状态切换完成后，TeX 的输入处理器对先前的状态没有任何记忆。 状态 N：新行当且仅当遇到新的输入行时，TeX 会进入状态 N。在该状态下，TeX 遇到空格记号（分类码为 10 的字符）即会将之忽略；遇到行终止符则会将之替换为 \par 记号；遇到其它记号，则会切换到状态 M。 状态 S：忽略空格在状态 M 下遇到空格记号，或在任意状态下遇到控制词或控制空格之后（注意其他控制字符不在此列），TeX 会进入状态 S。在该状态下，TeX 遇到空格记号或行终止符都会忽略。 状态 M：行内显然，状态 M 是输入处理器最常见的状态，它表示「处理到输入行的中间」（middle of line）。当输入处理器遇到分类码为 1–4、6–8 以及 11–13 的字符或者控制字符（不包括控制空格）之后，就会进入该状态。在该状态下，TeX 会将行终止符替换为空格记号。 访问整个字符集大体上，TeX 的输入处理器可以认为是一个有限状态自动机，但严格来说它并不是。输入处理器在扫描输入行期间，为了让用户能够输入一些特殊字符，而设计了这样的机制：两个相同的上标符（分类码为 7）以及一个字符编码小于 128 的字符（暂称原字符）组成的三元组会被替换为一个新的字符。该字符的编码位于 0 – 127 之间，并且与原字符的编码相差 64。 这种机制可用于访问字体中难以输入的字符。例如 ASCII 中的控制符号 &lt;return&gt;（ASCII 编码为 13）和 &lt;delete&gt;（ASCII 编码为 127）可分别使用 ^^M 和 ^^? 进行访问。当然，由于 ^^? 是无效字符（分类码是 15），故而在访问前需要先修改其分类码。 在 TeX3 中，该机制被扩展为可以访问 256 个字符：四元组 ^^xy 会被替换为一个编码在 0 – 255 之间的字符；其中 x 和 y 是小写十六进制数字 0–9, a–f，而 xy 正是该字符编码的十六进制表示。这一扩展也给先前的机制带来了一些限制：例如 ^^7a 会被输入处理器替换为 z，而不是 wa。 译注：w 和 7 的 ASCII 编码之差为 64。由于 7a 可被理解为是一个十六进制数，所以 TeX 贪婪地将四元组看做一个整体替换为 z。 这种机制一方面使得 TeX 的输入处理器在某种意义上比真正的有限状态自动机更为强大，另一方面还不会影响其余的扫描过程。因此，在概念上，可以简单地假装认为这种对 ^^ 引导的三元组或四元组的替换是提前进行的。不过，在实践中这样做是不可能的。这是因为，在处理输入行的过程中，用户可能将其他字符分类为第 7 类，从而影响后续处理。 译注：也就是说，如果没有其他字符被分类为第 7 类，则这个假设在实践中也是可行的。 内部状态切换现在我们来讨论特定分类码的字符对 TeX 输入处理器内部状态的影响。 0：转义字符遇到转义字符后，TeX 开始构建控制序列记号。取决于转义字符后面的字符之分类码，所得的控制序列记号有三种类型。 若转义字符后的字符之分类码为 11，即字母，则 TeX 将转义字符和之后连续的分类码为 11 的字符构建成一个控制词，而后进入状态 S。 若转义字符后的字符之分类码为 10，即空格，则 TeX 将它们构建成名为控制空格的控制字符，而后进入状态 S。 若转义字符后的字符之分类码不是 10 也不是 11，那么 TeX 将它们构建成控制字符，而后进入状态 M。 控制序列名字的所有字符必须在同一输入行之中；控制序列的名字不能跨行，即使当前行以注释符结尾或者没有行终止符（通过将 \endlinechar 设置为 0 – 255 之外的值）。 1–4, 7–8, 11–13：非空字符分类为 1–4、7–8 及 11–13 的字符会被转换为字符记号，而后 TeX 进入状态 M。 5：行终止符遇到行终止符时，TeX 的行为取决于输入处理器当前的状态。但不论处于何种状态，TeX 会忽略当前行，而后进入状态 N 并开始处理下一行。 处于状态 N，即当前行在此前只有空格，TeX 将插入 \par 记号； 处于状态 M，TeX 将插入一个空格记号； 处于状态 S，TeX 将不插入任何记号。 此处「行终止符」指得是分类码为 5 的字符。因此，它的字符编码不一定是 \endlinechar，也不一定非得出现在行尾。详见后文。 6：参数符在宏定义的上下文中，参数符 —— 通常为 # —— 可跟 1..9 中的数字或另一个参数符。前者产生参数记号，而后者产生单个参数字符记号待后续处理。在这两种情形中，TeX 都会进入状态 M。 单独出现的参数符也被用于阵列的模板行。 7：上标符TeX 对上标符的处理和大多数非空字符一样，仅在上述替换机制中有所不同：连续两个字符编码相同的上标符及其后字符组成的三元组或四元组会按规则被替换为其它字符。 9：被忽略符分类码为 9 的字符会被忽略，且不会影响 TeX 的状态。 10：空格符在状态 N 和状态 S 中，不论字符编码是多少，空格记号—— 分类码为 10 的记号 —— 都会被忽略；同时 TeX 的状态保持不变。在状态 M 中，TeX 会向正在构建的记号序列中插入 ␣（类别码为 10），并进入状态 S。这意味着空格记号的字符编码可能与输入字符的编码不同。 译注：不论输入的是哪一个分类码为 10 的字符，输入处理器都会将其替换为字符编码为 32 的 ASCII 空格。 14：注释符TeX 遇到注释符后，会忽略当前行之后包括注释符本身在内的所有内容。特别地，TeX 会忽略行终止符。因此，哪怕是在状态 M 下，TeX 也不会插入额外的空格记号。 15：无效字符TeX 遇到无效字符时会报错，而 TeX 自身会停留在之前的状态。不过，在控制字符的上下文中，无效字符是合法的。因此， \^^? 不会触发报错。 分类码中的字母与其他字符大部分编程语言的标识符可由字母与数字构成（还可能包含其他诸如下划线之类的字符）。但是，在 TeX 中，控制序列的名字只能由第 11 类字符（即字母）组成。而通常，数字和标点的分类码是 12，即其他字符。 此外，TeX 可以产生一些由第 12 类字符组成的字符串，哪怕其中的字符原本并非都是第 12 类字符。 此类字符串可由 \string、\number、\romannumeral、\jobname、\fontname、\meaning 以及 \the 等命令生成。若这些命令产生的字符串包含空格字符（ASCII 编码为 32），则在输出的字符串中，该字符的分类码为 10。 在极个别情况下，控制序列的展开中可能会包含十六进制数字；因此，除了通常表示字母的 A(11) – F(11) 之外，TeX 中还有表示十六进制数字的 A(12) – F(12)。 举例来说， 1\string\end 得到四个字符记号 1\(12)e(12)n(12)d(12) 注意，此处输出中有转义字符 \(12) 的原因是宏 \escapechar 的值是反斜线的字符编码。而若将 \escapechar 的值改为其它字符的编码，则 \string 将输出另一个字符。 通过一些特殊技巧，空格也可以出现在控制序列的名字当中： 1\csname a b\endcsname 是一个控制序列记号，其名称由三个字符组成，并且其中之一是空格符。将这个控制序列转化为字符串 1\expandafter\string\csname a b\endcsname 可得 \(12)a(12)␣(10)b(12)。 举个更加实用的例子。假设有一系列输入文件：file1.tex、file2.tex，而我们希望写一个宏来输出当前正在处理的文件的序号。第一种解法是： 123\newcount\filenumber\def\getfilenumber file#1.&#123;\filenumber=#1 &#125;\expandafter\getfilenumber\jobname. 宏定义中，参数文本中的 file 会吸走 \jobname 中的 file 部分，从而留下文件编号作为宏的参数。 但这段代码有些小问题。\jobname 输出的 file 四个字符，其分类码为 12。但在 \getfilenumber 的定义中，file 四个字符的分类码是 11。为此，需要对上述代码进行以下修正： 1234&#123;\escapechar=-1 \expandafter\gdef\expandafter\getfilenumber \string\file#1.&#123;\filenumber=#1 &#125;&#125; 此处，\escapechar=-1 让 \string 忽略反斜线；因此 \string\file 的结果会是 f(12)i(12)l(12)e(12) 四个字符。为了在宏定义是得到分类码为 12 的四个字符，我们使用 \expandafter 命令让 \string\file 在宏定义之前先行展开；而由于 \escapechar 的设定被放在分组内部，所以我们需要使用 \gdef 进行宏定义。 \par 记号在遇到空行之后，也就是在状态 N 遇到行终止符（分类码为 5）之后，TeX 会向输入中插入一个 \par 记号。具体来说，由于 TeX 遇到任何非空格字符，都会从状态 N 转移走，因此空行只能包含分类码为 10 的字符。特别地，空行不能以注释符结尾。因此，若输入文件中因格式美观需要保留空行，则可以在该行中放一个注释符。这算是 TeX 这一特性的常见用法。 两个连续的空行产生两个连续的 \par 记号，而实际上它们等同于一个 \par 记号：在遇见第一个 \par 记号之后，TeX 会进入竖直模式，而在竖直模式中，\par 只是充当 TeX 页面构建器，起到清空段落形状参数的作用。 TeX 于非受限水平模式（unrestricted horizontal mode）遇到竖直命令（&lt;vertical command&gt;）时，也会向输入插入一个 \par 记号。当该 \par 被读取和展开后，上述竖直命令会被重新处理。 \end 命令也会向输入插入 \par 记号，而后结束 TeX 的运行。 值得注意的是，遇到空行时 TeX 通常的行为（结束当前自然段）完全取决于 \par 记号的默认定义。重定义 \par 后，空行和竖直命令的行为可能就完全两样了；因此，我们可以借此实现一些特别的效果。在这种情况下，为了使用正常的 \par 的功能，plain TeX 提供了其同义词 \endgraf。 除非宏被声明为 \long 的，不然 \par 记号不能出现在宏的参数当中。对于非 \long 声明的宏，若其参数中包含 \par 记号，则 TeX 会给出「runaway argument」的报错。不过，使用 \let 定义的与 \par 同义的控制序列（例如 \endgraf）是允许出现在这些宏的参数之中的。 空格这一节讨论输入处理器中有关空格字符和空格记号的一些内容。有关文本排版中的空格，留待后续章节讨论。 被忽略的空格在上述有关输入处理器内部状态的讨论中，我们不难发现，有些空格在输入处理器中就被抛弃了，因此永远不会被输出：输入行开头的空格以及在让 TeX 进入状态 S 的字符之后的空格。 另一方面，行终止符尽管不在输入中（而是由 TeX 添加的），但能产生可输出的空格。除此之外，还有第三种空格：它们可以通过输入处理器，甚至干脆由输入处理器产生，但也不会被输出。那便是非强制空格（&lt;optional spaces&gt;）。在 TeX 的语法中，很多地方都会出现此类空格。 非强制空格TeX 语法中有所谓非强制空格与单个非强制空格的概念： 通常单个非强制空格（&lt;one optional space&gt;）允许出现在数字和粘连说明之后；而非强制空格（&lt;optional spaces&gt;）允许出现在数字或粘连中任意允许出现空格的地方（比如负号与数字之间，又比如 plus 和 1fil 之间）。此外，根据 &lt;equals&gt; 的定义，非强制空格允许出现在 = 之前。 以下是有关非强制空格的一些例子： &lt;one optional space&gt; 可用于界定数字的范围。这有助于避免一些意外情况，同时能加速 TeX 的处理过程——这是因为借助单个非强制空格，TeX 能更容易地界定当前正在读入的 &lt;number&gt; 于何时结束。注意，并非每个「数值」都是 &lt;number&gt;。例如说，\magstep2 中的 2 就不是数字，而是作为 \magstep 的参数的单独的字符记号。因此，在其后加上空格或行终止符是有意义的。此外，宏参数中的数字，例如 \#1：因为一个宏最多允许有 9 个参数，故而只需在参数符后扫描一位数字即可。 根据 TeX 的语法，关键字 fill 及 filll 由 fil 与若干单独的 l 字符记号组成；因此此处允许非强制空格。据此，例如 fil␣L␣l 是合法的关键字。这里有一些潜在的问题，可能导致莫名其妙的情况。大多数情况下，在关键字后面加上一个 \relax 即可避免此类问题。 TeX 原语 \ignorespaces 会吃掉其后的非强制空格；故此可将其插入宏定义的末尾，以避免将参量右花括号后的空格无意带入输出当中。例如说下面的例子中 \ignorespaces 吃掉了第二、第三两次调用之后的空格，而这些空格是不希望被排版输出的。不过，在 \ignorespaces 之后的空行仍然会插入 \par 记号。 123\def\item#1&#123;\par\leavevmode \llap&#123;#1\enspace&#125;\ignorespaces&#125;*&#123;a/&#125;one line \item&#123;b/&#125; another line \item&#123;c/&#125;yet another 被忽略和被保留的空格TeX 会忽略控制词之后的空格。不过这不是因为控制词之后的空格是非强制空格，而是因为 TeX 在遇到控制词之后会进入状态 S，从而忽略空格。类似地，控制词之后的行终止符也会被忽略。 数字由单个非强制空格界定，但是 1a\count0=3 b 的输出是 “ab”。这是因为 TeX 在第一个空格记号之后会进入状态 S，从而第二个空格会被 TeX 的输入处理器忽略，永远不会变成空格记号。 当 TeX 处于新行状态 N 时，空格也会被忽略。另一方面，当 TeX 处于竖直模式工作时，空格记号（也就是在一开始未被忽略的空格）会被忽略。例如说，下例第一个盒子之后由行终止符生成的空格记号会被忽略。 123\par\hbox&#123;a&#125;\hbox&#123;b&#125; plain TeX 和 LaTeX 格式都定义了名为 \obeyspaces 的宏。该宏能使每个空格都是有意义的：在一个空格之后，连续的空格会被保留。两种格式中，\obeyspaces 的基本形式是一致的。 1\catcode`\ =13 \def &#123;\space&#125; 不过，对于 \space 的定义，两种格式有所区别。在 plain TeX 中，\space 的定义如下 1\def\space&#123; &#125; 在 LaTeX 中，同名的宏则定义为 1\def\space&#123;\leavevmode&#123;&#125; &#125; 在 \obeylines 的上下文中，比较容易看出这两种定义的区别。使用 \obeylines 后，每个行终止符都会被转换成一个 \par 命令。因此 TeX 开始处理每一行时，都处于竖直模式。在 plain TeX 中，活动空格被展开为空格记号，因此在垂直模式中会被忽略。但在 LaTeX 中，首先会离开竖直模式并进入水平模式，因此每个空格就都是有意义的了。 空格被忽略的其他情形还有三种情形下，TeX 会忽略空格记号： 在寻找未被花括号定界的宏参数时，TeX 会忽略所有空格记号，而将第一个非空记号（或分组）作为参数。 在数学模式中，所有的空格记号会被忽略。 在阵列制表符之后，空格记号会被忽略。 空格记号：&lt;space token&gt;在 TeX 中，空格总是表现得与众不同。举例来说，\string 会将所有字符的分类码设置为 12，唯独空格的分类码是 10 。此外，如前文所述，在状态 M 中，TeX 的输入处理器会将所有分类码为 10 的字符转换为真正的空格：字符编码会被设置为 32。于是，任何分类码为 10 的字符记号称为空格记号（&lt;space token&gt;）。字符编码不是 32 的空格记号称为滑稽空格。 举例来说，将字符 Q 的分类码设置为空格字符之后，如下定义 1\catcode`Q=10 \def\q&#123;aQb&#125; 可得 12\show\qmacro:-&gt; a b 这是因为输入处理器改变了宏定义中滑稽空格的字符编码。 字符编码不为 32 的空格记号可以用 \uppercase 等命令生成。不过，「由于字符编码不同的空格记号的行为是一致的，所以纠缠于这类细节是没有意义的」。详见 TeXbook 第 377 页。 控制空格控制空格命令 \␣ 给出一个与 \spacefactor 等于 1000 时空格记号宽度一样的空格。控制空格不能被当做是空格记号，也不能理解为会展开成一个空格记号的宏（例如 plain TeX 中的 \space）。举例来说，TeX 会忽略所有输入行开头的空格，但是控制空格是一个水平命令（&lt;horizontal command&gt;），故而 TeX 在遇到它之后会从竖直模式切换到水平模式（并插入一个缩进盒子）。 可见空格：␣在 Computer Modern 的打字机字体中，字符编码为 32 的字符是显式空格符号 “␣“。不过，简单地使用 \tt 命令是无法将其打印出来的。这是因为空格在输入处理器中有特别的处理。 使空格字符 ␣ 显形的一种方法是将空格字符的分类码设置为 12： 1\catcode`\ =12 此时，TeX 会将空格字符作为编码为 32 的字符排版出来。此外，连续的空格不会被忽略。这是因为状态 S 只是在遇到分类码为 10 的字符后才会进入。类似地，控制序列之后的空格也会因分类码的改变而显形。 有关行尾的更多知识TeX 从输入文件中获取文本行，但不包括输入行中的行尾符。因此，TeX 的行为不依赖操作系统以及行尾符究竟是什么（CR-LF、LF 抑或是在块存储系统里根本就不存在行尾符）。而后，TeX 会移除输入行末尾的空格。这样处理是有历史原因的：TeX 必须能够适应 IBM 大型计算机的块存储模式有关。对于由计算机的不同而造成的有关行尾符的问题。 此后，字符编码为 \endlinechar 的行终止符会被追加在文本行的末尾；除非 \endlinechar 中保存的数值为负数或大于 255。注意，改行终止符的分类码不一定非得是 5。 保持各行有时候会期望会希望输入文本中的行尾符能与排版输出的行尾一一对应。下面的代码可以可以解决这一问题： 12\catcode`\^^M=13 %\def^^M&#123;\par&#125;% 这里，\endlinechar 成为活动符，其含义变为 \par。上述代码中的注释符用于阻止 TeX 看到代码末尾的行终止符，以防它将其作为活动字符而展开。 需要注意的是，在将上述代码嵌入宏的展开文本中需要特别小心。例如说下列代码会让 TeX 误解： 1\def\obeylines&#123;\catcode`\^^M=13 \def^^M&#123;\par&#125;&#125; 具体来说，TeX 将丢弃第二个 ^^M 之后的所有字符。这是因为，在宏展开的过程中，\catcode 命令尚未执行，因而此时 ^^M 分类码为 5，而非 13。也就是说，这一行实际上变成了： 1\def\obeylines&#123;\catcode`\^^M=13 \def 要修正上述问题，需要为 ^^M 营造一个可作为活动字符使用的环境： 123&#123;\catcode`\^^M=13 % \gdef\obeylines&#123;\catcode`\^^M=13 \def^^M&#123;\par&#125;&#125;%&#125; 这样解决了上面提到的问题，但仍有缺陷。这是因为，该 \obeylines 仍然不能保留输入文本中的空行——连续两个 \par 记号会被当成是一个。为此，我们需要对上述定义稍作改进： 1\def^^M&#123;\par\leavevmode&#125; 这样，输入文本中的每一行都会开启一个新段落，空行则开启一个空段落。 改变 \endlinechar某些情况下，你会希望改变 \endlinechar 的值或者 ^^M 的分类码，以达成一些特殊效果。例如说，可以用行终止符作为宏的参数的定界符。 在这些常识中，通常会有一些陷阱。我们来看以下写法： 123&#123;\catcode`\^^M=12 \endlinechar=`\^^J \catcode`\^^J=5...... &#125; 这段代码的输出不符合预期：由于第一行和最后一行的行终止符，TeX 将输出字符码为 13（^^M）和 10（^^J）的字符。 在第一行和最后一行末尾加上注释符可以解决此问题，但还有另一种方法是将第一行拆成下面两行： 12&#123;\endlinechar=`\^^J \catcode`\^^J=5\catcode`\^^M=12 当然，在多数情况下没必要将行终止符替换为另一个字符；设置 1\endlinechar=-1 就等同于各行都以注释符结尾。 行终止符的更多注记TeX 对所有字符一视同仁，包括追加到输入行末尾的行终止符。考虑到它特别的分类码，通常大家都不会注意行终止符。但是有一些方法可以特别地处理行终止符。 举例来说，假定 \endlinechar 保持默认值为 13，那么，把 “M“。因为它是编码为 13+64 的 ASCII 字符。 再举例来说，如果 \^^M 有定义，此时可称为「控制换行」。则在输入行中用反斜线结尾将执行此控制换行命令。例如，在 plain TeX 中定义 1\def\^^M&#123;\ &#125; 将使得控制换行与控制空格等价。 输入处理器的更多知识输入处理器作为独立过程TeX 处理器的各个阶段都是同时运行的，但是在概念上它们常被视为依次独立运行，前者的输出是后者的输入。关于空格的小戏法很好地展现了这一点。 考虑以下宏定义： 1\def\DoAssign&#123;\count42=800&#125; 及其调用： 1\DoAssign 0 作为构建记号的部分，TeX 的输入处理器在扫描此次调用时，会忽略控制序列之后和零之前的所有空格。因此，此次调用的展开为： 1\count42=8000 不要认为：「\DoAssign 首先被读入，而后展开，而后空格作为分隔符分割了 800，于是 800 被赋值给计数器，并打印出数字零。」不过，需要注意的是，如果数字零出现在下一行，情况就不一样了。 再举一个让非强制空格出现在忽略空格阶段之后的例子： 12\def\c.&#123;\relax&#125;a\c. b 会被展开为： 1a\relax b 其输出是： 1a b 这是因为，「输入处理器忽略控制序列 \relax 之后的空格」这一现象仅出现在该行被首次读取之时，而非在其被展开之时。 另一方面，这个例子： 12\def\c.&#123;\ignorespaces&#125;a\c. b 则会被展开为： 1a\ignorespaces␣b 执行 \ignorespaces 时会删除所有接续其后的连续空格记号。因此，输出是： 1ab 在上述两个例子中，\c 之后的西文句号均为定界符，用于保护控制序列之后的空格不被输入处理器吃掉。 输入处理器不作为独立过程将 TeX 的记号化的过程视作独立过程是一个便利的做法，但有时这种做法会引起困惑。 例如 1\catcode`\^^M=13&#123;&#125; 将行终止符设为活动字符；因此，该行自身的行终止符将报错：「未定义的控制序列（undefined control sequence）」。这表明，执行行内的命令有时会影响对同一行的扫描过程。 另一方面，下面例子则不会报错： 1\catcode`\^^M=13 这是因为，在 TeX 扫描数字 13 时就读入了行终止符，此时，分类码的赋值过程尚未执行；而此时，行终止符被转换成了非强制空格，作为数字的定界符。 输入处理器的递归调用前文中，将参数符和数字替换为参数记号的过程被描述得与将字母捆绑成控制序列记号类似。但实际情况要复杂得多。TeX 的记号扫描机制不仅在扫描文件输入时起作用，在扫描记号列表输入时同样会起作用：例如在处理宏定义时。前文提到的内部状态变化的机制，仅仅适用于前一种情况。 在两种情况下，输入处理器对参数符的处理方式都是相同的。否则 TeX 便无法处理下面这样的宏定义： 1\def\a&#123;\def\b&#123;\def\c####1&#123;####1&#125;&#125;&#125; @ 约定读过 plain TeX 或是 LaTeX 格式的源码就会发现其中有很多包含符号 @ 的控制序列。这种包含 @ 的控制序列不能被普通用户直接使用。 格式文件的起始处附近有命令 1\catcode`@=11 它将 @ 的分类从「其他字符」变为「字母」，从而可以用于组成控制序列。而在格式文件的末尾处附近有命令 1\catcode`@=12 它将 @ 的分类恢复为其他字符。 那么，为什么用户不能直接调用带有 @ 字符的控制序列，却能调用定义中包含此类控制序列的宏呢？原因在于，在宏定义时，带有 @ 的控制序列已被 TeX 内部处理过了，此后，这些控制序列就变成了记号而不是字符串了。在宏展开的过程中，TeX 只需要操作记号，因此，彼时记号内字符的分类码就不影响宏展开的过程了。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Input</tag>
        <tag>TeX</tag>
        <tag>Engine</tag>
        <tag>Catcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTeX 2.4.14：macOS 字体配置升级]]></title>
    <url>%2F2018%2F05%2F03%2Fctex-2-4-14-update-for-the-fontset-for-macOS%2F</url>
    <content type="text"><![CDATA[近日，CTeX 宏集已更新到 2.4.14 版本，本次更新主要是 macOS 字体配置的升级。在此为本次更新做一个注解。 起因近来陆续有用户提出 CTeX 宏集在 macOS 上罗马字族的加粗会变为黑体（见这里和这里），但在较新版的 macOS 中，宋体、黑体、楷书已有多个字重的字体配置，因此 macOS 上，CTeX 宏集的字体配置无需像 Windows 上那样以黑体作为粗宋体的妥协。 此即本次更新的起因。 经过参考知乎孫志貴的建议，结合刘海洋指出无衬线字体在 beamer 内的实际使用情况，我们认为：对于默认的无衬线字体，应当更多地照顾屏显效果，而非是打印效果。因此，我们决定将默认的无衬线字体配置为 PingFang SC，并提供新的字体选择命令 \pingfang；而对于过去的华文黑体，则在字体选择命令 \heiti 中予以保留。此外，考虑到与 Windows 上字体命令的兼容性，我们还决定：在引入苹方黑体后，将字体选择命令 \yahei 作为 macOS 平台上苹方黑体的别名。 考虑到苹方黑体在 El Capitan 才被引入系统，在 Yosemite 及之前的系统中则默认没有该字体，同时考虑到过去旧文档的兼容性，我们决定：对于 macOS/OS X，将字体配置区分为 macold 及 macnew。如此，一方面 CTeX 宏集可以根据苹方黑体是否存在于系统内自动在新旧两个版本的字体配置中选择，另一方面用户可自行指定 macold 字库，以保留和旧文档的兼容性。 据此，对于 macnew 有如下字体配置。 123456789101112131415161718192021222324252627282930%&lt;*macnew&gt;\sys_if_engine_pdftex:TF &#123; \ctex_fontset_error:n &#123; mac &#125; &#125; &#123; \sys_if_engine_uptex:TF &#123; \ctex_fontset_error:n &#123; mac &#125; &#125; &#123; \setCJKmainfont [ UprightFont = *~Light, BoldFont = *~Bold ItalicFont = Kaiti~SC, BoldItalicFont = Kaiti~SC~Bold ] &#123; Songti~SC &#125; \setCJKsansfont &#123; PingFang~SC &#125; \setCJKmonofont &#123; STFangsong &#125; \setCJKfamilyfont &#123; zhsong &#125; [ UprightFont = *~Light, BoldFont = *~Bold, ] &#123; Songti~SC &#125; \setCJKfamilyfont &#123; zhhei &#125; &#123; Heiti~SC &#125; \setCJKfamilyfont &#123; zhpf &#125; &#123; PingFang~SC &#125; \setCJKfamilyfont &#123; zhfs &#125; &#123; STFangsong &#125; \setCJKfamilyfont &#123; zhkai &#125; &#123; Kaiti~SC &#125; &#125; &#125;%&lt;/macnew&gt;%&lt;macnew&gt;\NewDocumentCommand \yahei &#123; &#125; &#123; \CJKfamily &#123; zhpf &#125; &#125;%&lt;macnew&gt;\NewDocumentCommand \pingfang &#123; &#125; &#123; \CJKfamily &#123; zhpf &#125; &#125; 结果经过编码后，CTeX 宏集升级到 2.4.14 (2018/05/01) 版本，新增功能如下： 将 macOS/OS X 上的字库配置区分 macold 及 macnew； 默认情况下若检测到操作系统为 macOS/OS X，或经用户设置 fontset = mac，则 CTeX 宏集将根据 /System/Library/Fonts/PingFang.ttc 的存在性载入 macold 或 macnew 的字库配置； macold 的字库配置和旧版本中 mac 的字库配置完全相同； macnew 的字库配置中 默认罗马字族（\rmfamily） 以 Songti~SC~Light 为 \mdseries 字重； 以 Songti~SC~Bold 为 \bfseries 字重； 以 Kaiti~SC 为 \itshape 字形； 以 Kaiti~SC~Bold 为 \itshape\bfseries 字形字重之组合。 默认无衬线字族（\sffamily）以 PingFang~SC 取代过去的 STXihei/STHeiti 组合 CJK 字族 zhsong 以 Songti~SC 取代过去的 STSong CJK 字族 zhhei 以 Heiti~SC 取代过去的 STHeiti CJK 字族 zhkai 以 Kaiti~SC 取代过去的 STKaiti 新增 CJK 字族 zhpf，作为字体命令 \yahei 和 \pingfang 选择的字族 新版本的 CTeX 宏集已发布到 CTAN，预计将于 2018/05/04 前后可经由 tlmgr/mpm 更新。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>macOS</tag>
        <tag>Yosemite</tag>
        <tag>El Capitan</tag>
        <tag>PingFang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员的自我修养（八）：使用 JProbe 调试 Linux 内核]]></title>
    <url>%2F2018%2F04%2F28%2Fdebug-in-Linux-kernel-jprobe%2F</url>
    <content type="text"><![CDATA[对于我这种普通程序员来说，Linux 内核是神秘而高贵的，轻易我们不敢去说内核相关的事情。不过，有时候逼不得已，也得硬着头皮对内核进行一些调试。（比如发现一些异常现象，怀疑是某个系统调用的异常行为在作祟时）为此，学习一些内核调试技术也是有必要的。 限于个人水平，此篇以操作指南为主，不涉及过多的理论知识——其实是我不懂。 KProbes 介绍JProbe 是 KProbes 的一部分。因此，介绍 JProbe 大致应当从 KProbes 开始。 游戏的名目 The Name of the Game— Knuth, The TeXbook KProbes 的名字由字母 K 和 Probes 组合而成。此处，字母 K 表示是「Kernel」的缩写，表示 Linux 内核；英文单词 probe 则是「探测」的意思。因此 KProbes 从名字来说，即是内核探测工具的意思。 KProbes 的背景在内核或者内核模块的调试过程中，了解一些函数是否被调用、何时被调用、调用后的执行情况如何、传入参数和返回值分别是什么是很自然的想法。为此，最简单的方法是修改这些函数的源码，在适当的位置打印相关日志。不过，这种方案虽然听起来简单，实际操作时候却不简单：需要重新编译内核。这算是很高的代价了。 KProbes 技术大体上就是为了解决这一需求而设计的。KProbes 允许用户 自行定义回调函数； 动态地插入或者移除探测点； 当内核执行到相关探测点时，KProbes 会调用用户注册的回调函数，待回调函数执行完毕后再继续正常的执行流程。 显而易见，利用 KProbes 的回调函数收集和打印相关信息比上述「简单的方法」代价要小得多了。 KProbes 的组成KProbes 提供了三种探测手段： KProbe JProbe KRetProbe 这里，KProbe 最基本也最强大，是后续两种探测手段的基础。KProbe 允许在任意位置放置探测点，例如可以在函数内部某条指令处放置探测点；并且提供了探测点调用前、调用后、访存出错三种情况的回调方式。 调用前回调：pre_handler 调用后回调：post_handler 访存出错回调：fault_handler JProbe 是本文的重点，它和 KRetProbe 都是在 KProbe 的基础上实现的。JProbe 的探测点在函数入口处，可用于收集函数的参数；KRetProbe 则顾名思义，其探测点在函数出口处，可用于收集函数的返回值。 硬件依赖从前面的描述不难看出，KProbes 这类技术一方面需要在某些时候让内核执行流程陷入到用户注册的回调函数中，另一方面需要单步执行被探测点的指令。因此，KProbes 对硬件平台是有依赖的。前者依赖 CPU 的异常处理，而后者依赖单步调试技术。 在目前主流的 i386, x86_64, arm 等平台上，KProbes 已经能较好地工作。在其它平台上，KProbes 则可能只实现了部分功能。具体则需要查看内核相关文档：Documentation/kprobes.txt。 KProbes 的一些限制 KProbes 允许在同一个位置注册多个 KProbe 探测点，但是不能注册多个 JProbe 探测点。 JProbe 不能以 JProbe 的回调函数或者 KProbe post_handler 作为探测点。 KProbes 可以于包括中断处理函数在内的几乎所有函数中注册探测点，但是不能在 KProbes 自身的相关函数中注册探测点（定义在 kernel/kprobes.c 以及 arch/*/kernel/kprobes.c 中的函数），以及不能在 do_page_fault 和 notifier_call_chain 中注册探测点。 KProbes 的探测依赖函数调用，因此在内联函数或者可能被内联的函数中注册探测点可能失效。 KProbes 的各种回调函数会关闭内核抢占，甚至依平台不同关闭终端，因此在回调函数中不应调用会放弃当前 CPU 时间片的函数（例如互斥量相关函数）。 JProbe 使用方法回调函数首先我们要明确，我们希望利用 JProbe 做什么，也就是 JProbe 的回调函数应该如何实现。 我们假设有这样一个任务：关注某一个进程在调用 Linux 虚拟文件系统的 write 操作时，打印其进程 ID (PID)，并打印参数中的偏移量。假设这个进程的名字是 &quot;liam_test&quot;。考虑到我们要在 vfs_write 函数的入口处做探测，我们需要实现的回调函数其实是 vfs_write 的一个代理，因此它的参数应当与 vfs_write 完全一致。因此有如下实现。 1234567ssize_t jvfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos) &#123; if (!strcmp("liam_test", current-&gt;comm) /* we're in the program `liam_test` */ ) &#123; printk(KERN_INFO "pid: %u, pos: %lld.\n", current-&gt;pid, *pos); &#125; jprobe_return(); return 0;&#125; 注意这里涉及了 jprobe_return() 这个 JProbe API。在回调函数执行完毕以后，必须调用该函数，如此执行流才会回到正常的执行路径中去。 JProbe 结构体实现好了回调函数之后，我们来看如何用 JProbe 结构体，将回调函数和被探测的函数关联起来。 1234567891011121314/* * Special probe type that uses setjmp-longjmp type tricks to resume * execution at a specified entry with a matching prototype corresponding * to the probed function - a trick to enable arguments to become * accessible seamlessly by probe handling logic. * Note: * Because of the way compilers allocate stack space for local variables * etc upfront, regardless of sub-scopes within a function, this mirroring * principle currently works only for probes placed on function entry points. */struct jprobe &#123; struct kprobe kp; void *entry; /* probe handling code to jump to */&#125;; 结构体本身非常简单，内里只有一个 struct kprobe 和一个 void* 指针。前者说明 JProbe 是基于 KProbe 实现的，后者保存回调函数的入口。为此我们还需要查看 struct kprobe 的实现，具体每个成员的含义以注释的形式给出。 12345678910111213141516171819202122232425262728struct kprobe &#123; /* Hash 表，索引值为被探测点的地址 */ struct hlist_node hlist; /* 同一探测点上多个 kprobe 结构的链表 */ struct list_head list; /* 记录当前 probe 被暂时放弃的计数器 */ unsigned long nmissed; /* 被探测点的地址 */ kprobe_opcode_t *addr; /* 被探测函数的名字 */ const char *symbol_name; /* 被探测点相对函数入口的偏移量 */ unsigned int offset; /* 被探测点即将被执行时的回调函数 */ kprobe_pre_handler_t pre_handler; /* 被探测点执行完毕后的回调函数 */ kprobe_post_handler_t post_handler; /* 在执行上述两个回调函数或者单步执行被探测点处指令时出现访存错误时的回调函数 */ kprobe_fault_handler_t fault_handler; /* 在上述三个回调函数执行过程中，若触发断点指令，则调用该回调函数 */ kprobe_break_handler_t break_handler; /* 断点处的原始指令 */ kprobe_opcode_t opcode; /* 上述原始指令的拷贝，被用于单步执行 */ struct arch_specific_insn ainsn; /* 该 probe 的状态标记 */ u32 flags;&#125;; 因此，对于一个典型的 JProbe 任务（探测 vfs_write 函数的传入参数），我们通常会设置这样的结构体。 123456static struct jprobe write_stub = &#123; .kp = &#123; .symbol_name = "vfs_write", &#125;, .entry = jvfs_write,&#125;; 这样的结构体表示我们希望在 vfs_write 这个符号（对应内核的 vfs_write() 函数）的入口处进行探测，探测时的回调函数是 jvfs_write。注意，当函数名被用作值时，它等价于一个指针。这样，我们就通过 write_stub 这个 struct jprobe 将回调函数和被探测函数关联起来了。 注册与卸载接下来的工作，就是要向系统内核注册我们实现的 JProbe 了。为此，我们需要实现两个函数 jprobe_init 和 jprobe_exit。 12345678910111213141516static int __init jprobe_init(void) &#123; int ret; ret = register_jprobe(&amp;write_stub); if (ret &lt; 0) &#123; printk(KERN_INFO "register_jprobe failed, returned %d\n", ret); return -1; &#125; printk(KERN_INFO "Planted jprobe at %p, handler addr %p\n", write_stub.kp.addr, write_stub.entry); return 0;&#125;static void __exit jprobe_exit(void) &#123; unregister_jprobe(&amp;write_stub); printk(KERN_INFO "jprobe at %p unregistered\n", write_stub.kp.addr);&#125; 此处 jprobe_init 和 jprobe_exit 两个函数的名字可以自由更改，重点是其中调用的 register_jprobe 和 unregister_jprobe 两个 JProbe API。JProbe 中，注册与卸载相关的 API 有如下一些。 123456789101112/* 向内核注册 JProbe 探测点 */int register_jprobe(struct jprobe *jp)/* 卸载 JProbe 探测点 */void unregister_jprobe(struct jprobe *jp)/* 向内核注册多个 JProbe 探测点 */int register_jprobes(struct jprobe **jps, int num)/* 卸载多个 JProbe 探测点 */void unregister_jprobes(struct jprobe **jps, int num)/* 暂停指定探测点 */int disable_jprobe(struct jprobe *jp)/* 恢复指定探测点 */int enable_jprobe(struct jprobe *jp) 实现为内核模块为了将我们的代码插入内核，我们需要将 JProbe 探测点实现为内核模块。为此我们需要调用一些内核宏。 12345module_init(jprobe_init)module_exit(jprobe_exit)MODULE_AUTHOR("Liam Huang");MODULE_DESCRIPTION("Print information of \"vfs_write\", when current process command name is \"liam_test\"");MODULE_LICENSE("GPL"); 编译内核模块完整的 write_stub.c 文件应当如下。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;linux/module.h&gt;#include &lt;linux/version.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/kprobes.h&gt;ssize_t jvfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos) &#123; if (!strcmp("liam_test", current-&gt;comm) /* we're in the program `liam_test` */ ) &#123; printk(KERN_INFO "pid: %u, pos: %lld.\n", current-&gt;pid, *pos); &#125; jprobe_return(); return 0;&#125;static struct jprobe write_stub = &#123; .kp = &#123; .symbol_name = "vfs_write", &#125;, .entry = jvfs_write,&#125;;static int __init jprobe_init(void) &#123; int ret; ret = register_jprobe(&amp;write_stub); if (ret &lt; 0) &#123; printk(KERN_INFO "register_jprobe failed, returned %d\n", ret); return -1; &#125; printk(KERN_INFO "Planted jprobe at %p, handler addr %p\n", write_stub.kp.addr, write_stub.entry); return 0;&#125;static void __exit jprobe_exit(void) &#123; unregister_jprobe(&amp;write_stub); printk(KERN_INFO "jprobe at %p unregistered\n", write_stub.kp.addr);&#125;module_init(jprobe_init)module_exit(jprobe_exit)MODULE_AUTHOR("Liam Huang");MODULE_DESCRIPTION("Print information of \"vfs_write\", when current process command name is \"liam_test\"");MODULE_LICENSE("GPL"); 我们编写如下 Makefile，以便调用 make 来将源码编译为内核模块。 123456obj-m +=write_stub.oKDIR= /lib/modules/$(shell uname -r)/buildall: $(MAKE) -C $(KDIR) SUBDIRS=$(PWD) modulesclean: rm -rf *.o *.ko *.mod.* .c* .t* 此时调用 make 即可编译得到内核模块 write_stub.ko。 12345678$ makemake -C /lib/modules/2.6.32-2.0.0.8-6/build SUBDIRS=/home/Yuuki/test/c modules'make[1]: Entering directory `/usr/src/kernels/2.6.32-220.7.1.el6.2.0.0.8.x86_64' Building modules, stage 2. MODPOST 1 modulesmake[1]: Leaving directory `/usr/src/kernels/2.6.32-220.7.1.el6.2.0.0.8.x86_64'$ lsdelay_stub.c delay_stub.ko delay_stub.ko.unsigned delay_stub.mod.c delay_stub.mod.o delay_stub.o Makefile 热插拔内核模块Linux 提供了 insmod 和 rmmod 两个命令来热插拔内核模块。因此，在 insmod write_stub.ko 之后，名为 &quot;liam_test&quot; 的程序调用 vfs_write 就会在内核信息中打印 PID 和相关参数了；而在 rmmod write_stub.ko 之后，则可以将该模块从内核中卸载。 1234567891011121314$ lsmodModule Size Used bytcp_diag 1041 0inet_diag 8703 1 tcp_diagfuse 66726 2# ...$ sudo insmod write_stub.ko$ lsmodModule Size Used bydelay_stub 1346 0tcp_diag 1041 0inet_diag 8703 1 tcp_diagfuse 66726 2# ... 需要注意的是，这种做法需要内核支持。具体来说，内核必须打开如下编译选项 CONFIG_KPROBES: 以便支持 KProbes； CONFIG_MODULES：以便支持模块动态加载； CONFIG_MODULE_UNLOAD：以便支持模块动态卸载。 你可以在 /boot/config-XXX 中找到内核编译选项的记录，以检查你的内核是否打开了上述选项。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Kernel</tag>
        <tag>JProbe</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 macOS 上配置 VSCode 与 Skim 的 LaTeX 正反跳转]]></title>
    <url>%2F2018%2F04%2F24%2FWorking-with-VSCode-on-macOS-configuration-LaTeX-workshop-and-Skim%2F</url>
    <content type="text"><![CDATA[VSCode 是微软主导开发的新一代编辑器。自其开发之初，就与 Sublime Text 以及 GitHub 主导开发的 Atom 对标。几年前，VSCode 中的 LaTeX 支持还很不完善，考虑到我个人对 LaTeX 的强需求，当时没有从 Sublime Text 切换到 VSCode 上。时至今日，VSCode 发展得已经很不错。前些日子，东升在他的新主页上发布了一篇博文，讲解如何在当前的 VSCode 上配置 LaTeX IDE。看过之后，我就心动了，立即配置好来使用。 不过，由于东升不在 macOS 下工作，他的博文中没有提到如何让 VSCode 在 macOS 上与诸如 Skim 的外部 PDF 浏览器配合工作——特别是 LaTeX 的正反跳转。检索互联网之后，也没有完整可用的方法。甚至 LaTeX workshop 官方的说法也是不支持，需要用户自己想办法绕过。故此有这篇文章。 正向搜索正向搜索指的是从 .tex 源文件向编译生成的 PDF 文件的跳转。这部分我们主要需要寻找到合适的方式，在命令行状态打开 Skim 应用。 根据 Skim 官网的介绍，Skim 提供了名为 displayline 的脚本，用于和 TeX 正反同步协同工作。其脚本位于 1/Applications/Skim.app/Contents/SharedSupport/displayline 具体用法则是 1/Applications/Skim.app/Contents/SharedSupport/displayline %line "%pdffile" "%texfile" 此处 %line 表示 .tex 文件的行号，%pdffile 表示编译生成的 PDF 文件的完整路径，%texfile 则是对应的 .tex 源文件。考虑到我们对反向搜索也有需求，按照官方文档，我们还需要加上 -r 参数。 因此，在 VSCode 的配置里，我们需要给出这样的 JSON 配置。 12345678910"latex-workshop.view.pdf.viewer": "external","latex-workshop.view.pdf.external.synctex": &#123; "command": "/Applications/Skim.app/Contents/SharedSupport/displayline", "args": [ "-r", "%LINE%", "%PDF%", "%TEX%" ]&#125;, LaTeX workshop 插件的配置中，除了 latex-workshop.view.pdf.external.synctex，还有一项也和打开外部 PDF 浏览器有关。它是 latex-workshop.view.pdf.external.command，表示简单地打开 PDF 文件，而忽略正向搜索功能。Skim 提供的命令行脚本默认不支持这样的操作，我们需要根据 displayline 脚本自行修改。 displayline 脚本调用了 Apple Script 来实现与 Skim.app 的交互，此处我们照葫芦画瓢，模拟一个即可。我们可以将如下脚本保存为 displayfile 并以 chmod u+x displayfile 使其变为可执行脚本，而后将其放在环境变量 PATH 包含的目录中。 你可以在终端（Terminal.app）中执行 echo ${PATH} 来查看你的环境变量。通常，命令会返回以冒号 : 分隔的若干个目录。你可以从中选择一个合适的目录，或者干脆只是你喜欢的目录，保存这个文件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#!/bin/bash# displayfile (Skim)## Usage: displayfile [-r] [-g] PDFFILE## Modified from "displayline" to only revert the file, not jump to a given line#if [ $# == 0 -o "$1" == "-h" -o "$1" == "-help" ]; then echo "Usage: displayfile [-r] [-g] PDFFILEOptions:-r, -revert Revert the file from disk if it was open-g, -background Do not bring Skim to the foreground" exit 0fi# get argumentsrevert=falseactivate=truewhile [ "$&#123;1:0:1&#125;" == "-" ]; do if [ "$1" == "-r" -o "$1" == "-revert" ]; then revert=true elif [ "$1" == "-g" -o "$1" == "-background" ]; then activate=false fi shiftdonefile="$1"#shopt -s extglob#[ $# -gt 2 ] &amp;&amp; source="$3" || source="$&#123;file%.@(pdf|dvi|xdv)&#125;.tex"# expand relative paths[ "$&#123;file:0:1&#125;" == "/" ] || file="$&#123;PWD&#125;/$&#123;file&#125;"# pass file arguments as NULL-separated string to osascript# pass through cat to get them as raw bytes to preserve non-ASCII characters/usr/bin/osascript \ -e "set theFile to POSIX file \"$file\"" \ -e "set thePath to POSIX path of (theFile as alias)" \ -e "tell application \"Skim\"" \ -e " if $activate then activate" \ -e " if $revert then" \ -e " try" \ -e " set theDocs to get documents whose path is thePath" \ -e " if (count of theDocs) &gt; 0 then revert theDocs" \ -e " end try" \ -e " end if" \ -e " open theFile" \ -e "end tell" 至此，我们需要更新 VSCode 的配置。 1234567"latex-workshop.view.pdf.external.command": &#123; "command": "displayfile", "args": [ "-r", "%PDF%" ]&#125;, 反向搜索再反向搜索中，我们需要让 Skim 能够打开 VSCode，并将文件名和相应的行号正确地传给 VSCode。根据 Skim 官网的介绍，它只会从 /usr/bin 和 /usr/local/bin 中检索可执行程序。为此，我们需要将 VSCode 的可执行程序软链到这两个目录中的一个当中。 1ln -sf /Applications/Visual\ Studio\ Code.app/Contents/MacOS/Electron /usr/local/bin/vscode 至此，我们在命令行中执行 vscode -g &quot;%file&quot;:%line 即可打开 %file 文件并定位到第 %line 行。于是，我们只需要在 Skim 的同步配置中将预设改为「自定义」，并将命令和参数分别设置如下： Command: vscode Arguments: -g &quot;%file&quot;:%line 如此即完成了配置。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>OS X</tag>
        <tag>macOS</tag>
        <tag>VSCode</tag>
        <tag>Skim</tag>
        <tag>LaTeX workshop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈激活函数以零为中心的问题]]></title>
    <url>%2F2018%2F04%2F17%2Fzero-centered-active-function%2F</url>
    <content type="text"><![CDATA[今天在讨论神经网络中的激活函数时，陆同学提出 Sigmoid 函数的输出不是以零为中心的（non-zero-centered），这会导致神经网络收敛较慢。关于这一点，过去我只是将其记下，却并未理解背后的原因。此篇谈谈背后的原因。 神经元 图片来自：https://zhuanlan.zhihu.com/p/25110450 如图是神经网络中一个典型的神经元设计，它完全仿照人类大脑中神经元之间传递数据的模式设计。大脑中，神经元通过若干树突（dendrite）的突触（synapse），接受其他神经元的轴突（axon）或树突传递来的消息，而后经过处理再由轴突输出。 在这里，诸 $x_i$ 是其他神经元的轴突传来的消息，诸 $w_i$ 是突触对消息的影响，诸 $w_ix_i$ 则是神经元树突上传递的消息。这些消息经由神经元整合后（$z(\vec x; \vec w, b) = \sum_iw_ix_i + b$）再激活输出（$f(z)$）。这里，整合的过程是线性加权的过程，各输入特征 $x_i$ 之间没有相互作用。激活函数（active function）一般来说则是非线性的，各输入特征 $x_i$ 在此处相互作用。 Sigmoid 与 tanh此篇集中讨论激活函数输出是否以零为中心的问题，因而不对激活函数做过多的介绍，而只讨论 Sigmoid 与 tanh 两个激活函数。 Sigmoid 函数Sigmoid 函数的一般形式是 $$\sigma(x; a) = \frac{1}{1 + \mathrm{e}^{-ax}}.$$ 这里，参数 $a$ 控制 Sigmoid 函数的形状，对函数基本性质没有太大的影响。在神经网络中，一般设置 $a = 1$，直接省略。 Sigmoid 函数的导数很好求 $$\sigma’(x) = \sigma(x)\bigl(1 - \sigma(x)\bigr).$$ 图片来自：https://zhuanlan.zhihu.com/p/25110450 tanh 函数tanh 函数全称 Hyperbolic Tangent，即双曲正切函数。它的表达式是 $$\tanh(x) = 2\sigma(2x) - 1 = \frac{\mathrm{e}^{x} - \mathrm{e}^{-x}}{\mathrm{e}^{x} + \mathrm{e}^{-x}}.$$ 双曲正切函数的导数也很好求 $$\tanh’(x) = 1 - \tanh^2(x).$$ 图片来自：https://zhuanlan.zhihu.com/p/25110450 一些性质Sigmoid 和 tanh 两个函数非常相似，具有不少相同的性质。简单罗列如下 优点：平滑 优点：易于求导 缺点：幂运算相对耗时 缺点：导数值小于 $1$，反向传播易导致梯度消失（Gradient Vanishing） 对于 Sigmoid 函数来说，它的值域是 $(0, 1)$，因此又有如下特点 优点：可以作为概率，辅助模型解释 缺点：输出值不以零为中心，可能导致模型收敛速度慢 此篇重点讲 Sigmoid 函数输出值不以零为中心的这一缺点。 收敛速度这里首先需要给收敛速度做一个诠释。模型的最优解即是模型参数的最优解。通过逐轮迭代，模型参数会被更新到接近其最优解。这一过程中，迭代轮次多，则我们说模型收敛速度慢；反之，迭代轮次少，则我们说模型收敛速度快。 参数更新深度学习一般的学习方法是反向传播。简单来说，就是通过链式法则，求解全局损失函数 $L(\vec x)$ 对某一参数 $w$ 的偏导数（梯度）；而后辅以学习率 $\eta$，向梯度的反方向更新参数 $w$。 $$w \gets w - \eta\cdot\frac{\partial L}{\partial w}.$$ 考虑学习率 $\eta$ 是全局设置的超参数，参数更新的核心步骤即是计算 $\frac{\partial L}{\partial w}$。再考虑到对于某个神经元来说，其输入与输出的关系是 $$f(\vec x; \vec w, b) = f\Bigl(\sum_iw_ix_i + b\Bigr).$$ 因此，对于参数 $w_i$ 来说， $$\frac{\partial L}{\partial w_i} = \frac{\partial L}{\partial f}\frac{\partial f}{\partial w_i} = x_i \cdot \frac{\partial L}{\partial f}.$$ 因此，参数的更新步骤变为 $$w_i \gets w_i - \eta x_i\cdot \frac{\partial L}{\partial f}.$$ 更新方向由于 $w_i$ 是上一轮迭代的结果，此处可视为常数，而 $\eta$ 是模型超参数，参数 $w_i$ 的更新方向实际上由 $x_i\cdot \frac{\partial L}{\partial f}$ 决定。 又考虑到 $\frac{\partial L}{\partial f}$ 对于所有的 $w_i$ 来说是常数，因此各个 $w_i$ 更新方向之间的差异，完全由对应的输入值 $x_i$ 的符号决定。 以零为中心的影响至此，为了描述方便，我们以二维的情况为例。亦即，神经元描述为 $$f(\vec x; \vec w, b) = f\bigl(w_0x_0 + w_1x_1 + b\bigr).$$ 现在假设，参数 $w_0$, $w_1$ 的最优解 $w_0^{*}$, $w_1^{*}$ 满足条件 $$\begin{cases}w_0 &lt; w_0^{*}, \\ w_1\geqslant w_1^{*}.\end{cases}$$ 这也就是说，我们希望 $w_0$ 适当增大，但希望 $w_1$ 适当减小。考虑到上一小节提到的更新方向的问题，这就必然要求 $x_0$ 和 $x_1$ 符号相反。 但在 Sigmoid 函数中，输出值恒为正。这也就是说，如果上一级神经元采用 Sigmoid 函数作为激活函数，那么我们无法做到 $x_0$ 和 $x_1$ 符号相反。此时，模型为了收敛，不得不向逆风前行的风助力帆船一样，走 Z 字形逼近最优解。 如图，模型参数走绿色箭头能够最快收敛，但由于输入值的符号总是为正，所以模型参数可能走类似红色折线的箭头。如此一来，使用 Sigmoid 函数作为激活函数的神经网络，收敛速度就会慢上不少了。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Zero-centered</tag>
        <tag>Active Function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最佳搭档：利用正反 SSH 隧道穿透防火墙访问内网服务器]]></title>
    <url>%2F2018%2F04%2F11%2Fbreak-firewall-by-the-use-of-SSH-tunnel%2F</url>
    <content type="text"><![CDATA[SSH 最基本的用法相信你已经了解。这次我们要用 SSH 来做一些特别的事情：建立正反 SSH 隧道，穿透防火墙，访问本不可见的内网服务器。 管道和隧道我们先来看最简单的 SSH 命令。 1ssh [-p &lt;onPort&gt;] [&lt;user&gt;@] &lt;connectToHost&gt; 此处方括号内的内容是可以省略的，尖括号内的内容是根据实际情况可修改的参数。这条命令表示，自执行命令的本机，向 connectToHost 的 onPort 端口发起请求，尝试以 user 身份登录。在上述 SSH 命令执行成功之后，我们就建立了从本机到 connectToHost 的连接。具体来说，本机的 SSH client 与 connectToHost 的 SSH server 建立了连接。我们可以将这一连接想像成一个有方向的管道；它的起点是本机的某个端口，而终点是 connectToHost 上的 onPort 端口。 SSH 的 -L 和 -R 选项，允许用户在上述管道内部，再创建一个有向隧道。大体上，你可以将其想像为外部的大号管道套住了内部的小号隧道。隧道的两端与管道的两端相同，起点则由 -Local/-Remote 决定。使用 -L 选项时，本机的某个端口是起点；这种隧道称之为正向隧道；而使用 -R 选项时，起点是 connectToHost 上的 onPort 端口，这种隧道称之为反向隧道。 来自：https://unix.stackexchange.com/a/46271/140887 隧道与转发上述隧道可在已建立的 SSH 连接（管道）的基础上进行端口转发。我们从其语法开始说起，首先以 -L 为例。 1ssh -L [&lt;bindHost&gt;:]&lt;sourcePort&gt;:&lt;forwardToHost&gt;:&lt;onPort&gt; &lt;connectToHost&gt; 这条命令表示，本机的 SSH 客户端将与 connectToHost 建立连接（管道），并在管道内建立从本机到 connectToHost 的隧道。此后，本机将把所有来自 bindHost 发往本机的 sourcePort 端口的消息，通过上述隧道转交给 connectToHost，并由 connectToHost 负责发往 forwardToHost 的 onPort 端口。此处有两点值得注意。其一，bindHost 省略时或置为 * 时，表示本机将转发所有主机发往 sourcePort 的消息。其二，forwardToHost 是站在 connectToHost 的视角看待的，因此若 forwardToHost 的值是 localhost，则在此语境下表示 connectToHost 这台主机的本地回环。 来自：https://unix.stackexchange.com/a/118650/140887 于是，-R 的版本也就容易理解了。 1ssh -R [&lt;bindHost&gt;:]&lt;sourcePort&gt;:&lt;forwardToHost&gt;:&lt;onPort&gt; &lt;connectToHost&gt; 这条命令表示，本机的 SSH 客户端将与 connectToHost 建立连接（管道），并在管道内建立从 connectToHost 到本机的隧道。此后，connectToHost 将把所有来自 bindHost 发往 connectToHost 的 sourcePort 端口的消息，通过上述隧道转交给本机，并由本机负责发往 forwardToHost 的 onPort 端口。至于 bindHost 和 forwardToHost 的语义则与 -L 版本类似。 来自：https://unix.stackexchange.com/a/118650/140887 相关参数在使用隧道之前，还应了解一些参数。 -f：使 SSH 在建立连接之后保持在后台运行。 -N：告诉 SSH，我们只希望建立隧道，而不会在远程主机上执行任何指令。 -T：告诉 SSH，我们只希望建立隧道，因而不需要创建虚拟终端。 -C：允许 SSH 压缩数据。 穿透防火墙我们做如下假设。 HOST_A：目标机器；内网机器，位于防火墙之后，可以访问外网，但无法从外网访问。 HOST_B：跳板机；外网机器，位于防火墙之前，可以访问外网，但无法访问内网机器。 HOST_C：工作机；外网机器，网络环境与 HOST_B 类似。 我们的目的是希望 HOST_C 上能够随时随地访问 HOST_A，那么需要怎么做呢？ 分析由于所有位于外网的机器都不可见 HOST_A，因此最终连接到 HOST_A 的方式必然在根本上从 HOST_A 发起，而后又将流量反向交给 HOST_A。因此，不难发现，在 HOST_A 上应当向跳板机 HOST_B 发起 SSH 连接，并通过反向隧道将流量返回 HOST_A。 至此，跳板机 HOST_B 上已有一个端口可以连接到目标机器 HOST_A。现在的问题是，如何将连向跳板机的 SSH 连接转发到跳板机上的这个特殊端口。为此，我们可以在跳板机上向其自身建立一个 SSH 连接，而后通过正向隧道将流量在跳板机内部转发到上述端口。 实际操作看看首先在 HOST_A 上执行： 1ssh -fNTCR localhost:1556:localhost:22 HOST_B 这里，HOST_A 向 HOST_B 发起 SSH 连接，建立了一个管道。而后，在管道内建立了一个从 HOST_B 到 HOST_A 的反向隧道。HOST_B 会将所有来自（第一个）localhost（即 HOST_B 本机）的发往 HOST_B 1556 端口的流量，经由上述隧道转交给 HOST_A 本机，而后转发给（第二个）localhost（即 HOST_A）的 22 端口。 而后在 HOST_B 上执行： 1ssh -fNTCL *:1555:localhost:1556 localhost 这里，HOST_B 向自身（第二个 localhost）发起 SSH 连接，建立了一个管道。而后，在管道内建立了一个从 HOST_B（本机）到 HOST_B（这里，HOST_B 向自身（第二个 localhost）的正向隧道。HOST_B（本机）会将来自任意主机的发往其 1555 端口的流量，经由上述隧道转交给 HOST_B（第二个 localhost），而后转发给（第一个）localhost（即 HOST_B）的 1556 端口。 如此一来，所有发往 HOST_B 的 1555 端口的流量，会先转发到 HOST_B 的 1556 端口，再转发到 HOST_A 的 22 端口。因此，只需要在 HOST_C 上对 HOST_B 的 1555 端口发起 SSH 连接，就相当于是对 HOST_A 的 22 端口发起连接。 1ssh -p 1555 HOST_B 如此即可。]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>SSH</tag>
        <tag>Tunnel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[借由系统调用实现 Linux 原生线程]]></title>
    <url>%2F2018%2F04%2F10%2FRaw-Linux-Threads-via-System-Calls%2F</url>
    <content type="text"><![CDATA[本文是译文，原文由 Chris Wellons 创作，首刊于这里。本文已被翻译成日语、乌克兰语及中文。本文还有一后续。 Linux 的线程设计十分优美：线程只不过是共享虚拟地址空间和文件描述符表的进程而已。由某一进程产生的线程是该主线程（父进程）的子进程。除了少数线程相关的系统调用，操作线程的系统调用与操作进程的系统调用完全相同。这种优美与文件描述符的优美异曲同工。 通常来说，在类-Unix 的系统上，进程是通过 fork() 来生成的。新生成的进程的虚拟内存空间是原进程的拷贝，但具有独立的地址空间和文件描述符表。（Linux 使用写时拷贝技术提升了这一步骤的效率）不过，对于创建线程来说，这种做法太高级（high-level）了；因此 Linux 还有名为 clone() 的系统调用。它与 fork() 的行为大致相同，只不过它能通过一系列参数控制其行为：主要是控制子进程与父进程之间共享那些运行时上下文。 在进程的栈上创建一个新的线程非常简单——只需要 15 条命令，而无需任何库，特别是不需要调用 pthread 库！本文中，我将以 x86-64 平台为例。所有代码均以 NASM 语法写就，因为，依我愚见，它是至今为止最好的（参见：这里）。 此处是完整的示例代码：Pure assembly, library-free Linux threading demo。 x86-64 启蒙 为了在你不熟悉 x86-64 汇编的情况下能够读完本文，此处给出 x86-64 中相关内容的启蒙教程。若你对这些内容很熟悉，则可跳过本节。 x86-64 有 16 个 64 位通用寄存器（general purpose registers）。它们主要被用来操作包括内存地址在内的整数。除此之外，还有很多有各种用途的寄存器；不过它们与线程没什么关系。 rsp：栈指针 rbp：基指针（在排错和效能分析中仍有用到） rax rbx rcx rdx：通用寄存器（注意 a, b, c, d） rdi rsi：d 和 r 分别表示 “destination” 和 “source”，不过现在已经没有意义了 r8 r9 r10 r11 r12 r13 r14 r15：在 x86-64 中新增的寄存器 前缀 r 表明它们是 64 位寄存器。虽与本文主旨无关，但仍然提一句：前缀 e 表示同一寄存器的最低 32 位，以及没有前缀的则表示同一寄存器的最低 16 位。这是因为 x86 最早是 16 位的，后来扩展到 32 位，又扩展到 64 位。历史上这些寄存器都有专门的用途，但是在 x86-64 上，它们基本上是地位等同的。 还有一个名为 rip 的指令指针寄存器。概念上说，在程序执行时，它随着执行过程遍历进程空间中的机器指令。尽管它的特别之处在于它无法被直接操作，而只能被间接修改；但考虑到代码和数据处于同一地址空间中，rip 和其他数据指针也就没什么区别了。 栈（stack） rsp 寄存器指向调用栈的「栈顶」。调用栈始终追踪着当前函数的调用者，以及局部变量和函数状态（这是栈帧保存的内容）。之所以「栈顶」打上了引号，是因为在 x86 中，栈实际上是往地址较低的方向生长的，因此栈指针指向栈的最低有效地址。这部分信息在讨论线程时十分关键，因为在生成线程时我们要在栈上分配内存。 有时栈也被用来向其他函数传参。在 x86-64 上，这种情况甚少发生，尤其是在 Linux 使用的 System V 二进制接口中：前 6 个参数通过寄存器传参。函数的返回值则通过 rax 寄存器返回。当函数调用发生时，整型变量/指针按照如下顺序通过寄存器传递：rdi, rsi, rdx, rcx, r8, r9。 因此，举例来说，当调用 foo(1, 2, 3) 时，参数 1, 2, 3 会被分别保存在 rdi, rsi 和 rdx 三个寄存器当中。mov 指令将第二个操作数的值保存在第一个操作数（寄存器名称）中。call 指令将 rip 寄存器的当前值压栈，而后将 rip 设置为目标函数的起始地址（跳转）。当被调用的函数执行完毕准备返回时，它会使用 ret 指令将 rip 寄存器的原始值弹栈并保存在 rip 寄存器当中，以将程序的控制权交还给调用者。 1234mov rdi, 1mov rsi, 2mov rdx, 3call foo 在被调用函数返回时，它还必须保证下列寄存器的值与被调用前保持一致：rbx, rsp, rbp, r12, r13, r14, r15。 系统调用 执行系统调用时，用于传参的寄存器稍有不同。注意，rcx 换成了 r10：rdi, rsi, rdx, r10, r8, r9。 每个系统调用都有一个整数标识符。在不同平台上，系统调用的编号可能不同。不过，在 Linux 中，这些标识符是永远不会变的。与 call 指令不同，在 syscall 指令之前，相应的系统调用编号需要保存在 rax 当中，而后由 syscall 指令向系统内核发起系统调用请求。在 x86-64 之前，系统调用是通过旧式的中断来实现的。因为中断效率低下，旧式的中断先后被一个特别的静态定位的 vsyscall 帧（现在因为安全风险而弃用）和 vDSO 所代替，使得一些系统调用能像普通函数调用那样被调用。在本文中，我们只需要 syscall 指令即可。 因此，例如说系统调用 write() 有如下 C 函数原型。 1ssize_t write(int fd, const void *buf, size_t count); 在 x86-64 中，系统调用 write() 位于系统调用表的顶端，编号为 1（编号为 0 的是系统调用 read()）。标准输出的文件描述符是 1（标准输入是 0）。下面的代码将从内存地址 buffer 中（在汇编程序其他位置定义的符号）读取 10 字节的内容写至标准输出。成功写入的字节数将被保存在 rax 中返回；若返回 -1，则表示出现错误。 12345mov rdi, 1 ; fdmov rsi, buffermov rdx, 10 ; 10 bytesmov rax, 1 ; SYS_writesyscall 有效地址 还有最后一个知识点：寄存器通常保存着内存地址（也就是一个指针），而你需要有办法读取这一地址中保存的内容。在 NASM 语法中，用方括号包裹寄存器的名字（例如 [rax]）和 C 中对指针进行解引用是一个效果。 这些方括号表达式被称为有效地址。在单条指令中，方括号内可以有有限的算数表达式去计算基地址之上的偏移量。这种表达式内可以有另一个寄存器（index）、一个 2 的幂方的标量（按位移动）以及一个有符号的偏移量。比如对于该表达式：[rax + rdx * 8 + 12]；如果 rax 是一个指向结构体的指针，rdx 是结构体内数组内某一元素的索引，则读取该元素只需要一条指令即可。NASM 聪明地扩展了有效地址表达式，它允许汇编程序员写出超出上述模式的表达式。例如：[base + index * 2 ^ exp + offset]。 本文不关注寻址的细节，因此如果搞不懂它也没关系。 分配栈 线程之间共享除寄存器、栈、线程内本地存储（thread-local storage, TLS）之外的所有东西。操作系统和底层硬件天然地保证了线程不会共享寄存器；而由于 TLS 不是必须的，所以本文也不表 TLS 相关操作——在实践中，通常会将栈作为 TLS 使用。因此，我们需要特别处理的就是栈了。在创建线程之前，我们必须先为之分配一个栈。当然，这种栈不仅仅是内存缓冲区那么简单。 最平凡的方式是在可执行程序的 .bss 段（全零初始化）中为线程保留固定长度的存储空间。但我希望如 pthread 之类的线程库那样，以正确的方式动态分配栈空间。否则，应用程序所能支持的线程数量在编译期就会被限制死了。 在虚拟内存空间内你不能直接的任意地址上读取或写入，而是必须向操作系统请求分配内存页帧。Linux 系统中有两个系统调用能实现我们的需求： brk()：扩展或缩减执行中进程的堆的大小。堆通常在 .bss 端后不远处；许多分配器会在分配少量内存或初始化时这样做。考虑到栈是向下生长的，而 brk() 在默认情况下不会设置保护页帧，栈的生长可能会破坏临近的重要数据，因而这不是一个很好的选择。这种情况下，攻击者的实施栈溢出会更加容易。所谓保护页帧是位于栈空间尾部的页帧，它被锁住，并且在栈溢出时会触发段错误，而不会让栈溢出的数据破坏其他内存数据。当然，也可以用系统调用 mprotect() 手工创建一个保护页帧。除了保护页帧的问题之外，这种方式设置的线程栈无法继续生长，也是一个问题。 mmap()：使用匿名映射，在随机内存地址上分配一组连续的内存页帧。如我们即将看到的，你可以明确告诉内核，这部分内存将被用来做线程的栈。这比使用系统调用 brk() 来得简单。 在 x86-64 中，系统调用 mmap() 的编号是 9。我将以如下 C 函数原型来分配一个线程栈。 1void *stack_create(void); 系统调用 mmap() 需要 6 个参数。不过在创建匿名内存映射时，最后两个参数会被忽略掉。对于我们的需求来说，它有如下 C 函数原型。 1void *mmap(void *addr, size_t length, int prot, int flags); 对于 flags，考虑到我们将用这块内存作为线程栈，我们将选择私有、匿名、向下生长。不过，哪怕设置了向下生长，系统调用 mmap() 仍然会返回内存映射的底部地址。一会儿会用到这一重要信息。于是，事情就简单了：只需要将寄存器的值设置好，而后执行 syscall 指令即可。 1234567891011%define SYS_mmap 9%define STACK_SIZE (4096 * 1024) ; 4 MBstack_create: mov rdi, 0 mov rsi, STACK_SIZE mov rdx, PROT_WRITE | PROT_READ mov r10, MAP_ANONYMOUS | MAP_PRIVATE | MAP_GROWSDOWN mov rax, SYS_mmap syscall ret 此时，我们就能为线程分配栈空间（或者准确说是和栈大小相同的内存缓冲区）了。 生成线程 生成线程非常简单，因为它甚至不涉及指令分支！只需往系统调用 clone() 中传入两个参数即可：clone() 的标记以及指向新线程栈的指针。注意，和其他诸多系统调用一样，glibc 包装的函数，其参数顺序与原始系统调用有所不同。总之，包括我们使用的标记在内，它接收两个参数。 1long sys_clone(unsigned long flags, void *child_stack); 我们用于生成线程的函数有如下 C 原型。它接收一个函数指针，而后在线程中执行该函数。 1long thread_create(void (*)(void)); 根据 ABI，函数指针参数会通过寄存器 rdi 传给 thread_create 函数。首先，我们将其安全地保存（push）在栈中，并调用 stack_create()。最后，当函数返回时，线程栈的底部地址会保存在寄存器 rax 当中。 12345678910thread_create: push rdi call stack_create lea rsi, [rax + STACK_SIZE - 8] pop qword [rsi] mov rdi, CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | \ CLONE_PARENT | CLONE_THREAD | CLONE_IO mov rax, SYS_clone syscall ret 系统调用 clone() 的第二个参数指向线程栈的顶部地址（具体来说，是线程栈顶部上方页帧的地址）。在代码中，我们通过 lea 指令来计算：读取有效地址（load effective address）。尽管有花括号，但它并不会真的去读取目标内存地址中的内容，而是将该地址保存在目标寄存器（rsi）当中。在代码中，我回退 8 字节的原因是我希望在下一条指令中，把线程函数的指针放在栈顶端。这样做的原因稍后即晓。 注意，函数指针先前被压栈。此处我们将其弹栈并写入当前线程栈空间保留的空间中。 如你所见，使用系统调用 clone() 创建线程时使用了不少标记。这是因为，在默认情况下，大多数东西新的进程都不与原进程共享。你可在 clone(2) 的手册页上找到这些标记的详细含义。 CLONE_THREAD：将子进程放在与父进程相同的线程组内。 CLONE_VM：子进程与父进程在同一虚拟内存空间内运行。 CLONE_PARENT：新的进程与当前进程共享父进程。 CLONE_SIGHAND：共享信号处理器。 CLONE_FS, CLONE_FILES, CLONE_IO：共享文件系统信息。 如此，系统会创建新的线程，并且，如 fork() 一样，syscall 会在两个线程的同一指令处返回。两个线程中，所有的寄存器的值完全相同；但在新线程中 rax 的值是 0，并且在新线程中 rsp 的值与 rsi 的值相等（指向新的线程的栈的指针）。 最酷的地方来了，我们来看看为什么不需要指令分支；即，为什么我们没有必要检查 rax 的值，来确定是原始线程（返回到调用者）还是新线程（跳转到线程函数）？注意新线程的栈顶部保存着指向线程函数的指针：当函数在新线程返回时，执行序列会跳转到线程函数，且线程栈是空的。而原始线程则会使用原始线程的栈，返回调用者。 函数 thread_create() 的返回值是新线程的 PID，本质上就是线程对象（例如 pthread_t）。 清理并退出线程 由于线程函数没有逻辑上的调用者，所以它不能有返回（ret 指令）；否则，将导致执行序列脱离线程栈而引发段错误并使程序停止运行。还记得线程其实只是进程吗？它们必须使用系统调用 exit() 来结束运行。在线程中执行系统调用 exit() 不会退出其他线程。 12345%define SYS_exit 60exit: mov rax, SYS_exit syscall 在退出前，应当使用系统调用 munmap() 释放线程栈，以防有资源泄漏。主线程中等价于 pthread_join() 的系统调用是 wait4()。 后续 若你觉得本文有趣，别忘了查看文章开头处的完整示例之链接。有能力产生线程之后，我们就有机会探索并实验 x86 的同步原语了；例如 lock 前缀的各种锁、xadd 以及诸如 compare-and-exchange（cmpxchg）之类的原子操作。这些内容将在后续文章中讨论。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>System Call</tag>
        <tag>Tutorial</tag>
        <tag>C</tag>
        <tag>Thread</tag>
        <tag>x86</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乐理漫谈：音高、音程、泛音]]></title>
    <url>%2F2018%2F04%2F09%2Fpitch-interval-and-harmonic%2F</url>
    <content type="text"><![CDATA[我打小就与音乐结缘，先后学习过声乐和钢琴，接触过的乐器就更多。作为人类智慧的结晶（EVA 渚薰语），音乐总是与高贵、优雅、美丽这些美好的形容词挂钩。另一方面，物理和数学又代表着人类心智的荣耀。作为写作的缘和由，这无疑是很强大的了。因此，这一系列将介绍音乐中的物理和数学知识。 这是系列文章的第一篇，讲讲和声音相关最基本的一些知识。 声音在物理学和生理学中，声音的是在传播介质（气体、液体、固体）中以音波的形式存在和传播的振动，其在人的听觉感受系统上产生的压力为人的听觉感受系统接收，而后在大脑中产生感觉的现象。 由于声音的本质是振动，因此声音天然具有两个要素：频率和响度。此处的频率即是振动的频率，其单位是赫兹（Hz）。响度则取决于振动的幅度，其单位为分贝（dB）：振动幅度越大，响度越高；反之，响度越低。 声音的响度取决于振动的幅度。具体到音乐中，即是吹奏时吐气的力量大小、拉弓时运弓的急缓、弹奏时敲击的力量大小。响度是很直观的，不需要做过多的讨论。因此之后的内容都主要讨论声音的频率。 音高与音程音高音高（pitch）是人类对声音频率的感受。相对而言，低沉的声音音高低，而尖锐的声音音高高。 人对音高的感受基本由声音本身的基频（见「泛音」一节）决定，同时受人类生理结构和心理因素制约和影响。这也就是说，对于相同频率的声音，不论由何种发声器激发，人都会认为它们的音高相同。但反过来，对于频率不同却相近的声音，人们可能认为具有同样的音高。 尽管如此，在绝大多数情况下，频率可视作是音高的唯一决定因素。 音高科学记号法音高科学记号法（scientific pitch notation）结合了音符名（CD–AB）与八度序号的音高记号法。在该记号法中，每个八度的升降发生在 $B_{i - 1}$ 和 $C_i$ 之间。大多数人熟知的中央 C，在音高科学记号法中记为 $C_4$；或在纯文本中记为 C4。 标准音高中央 C 之上的 A 音符，即 $A_4$，通常被认为是标准音。在诸如视唱练耳的训练、测试中，它通常会被首先给出。标准音的音高随历史变迁而变化，目前公认的标准音高为 440Hz。 音程音程（pitch interval）是人类感受到两个音音高之间的差距。在人类听力的中频段，人类对不同音高音符之间音程的感知大致是对数的；在高频段则不太符合对数规则。人类听力的这一特性是由人的听觉系统的生理结构决定的。 这也就是说，频率分别为 200Hz/400Hz/800Hz 的三个音，其中两段音程大致是相等的；而频率分别为 200Hz/400Hz/600Hz 的三个音，人类听起这两段音程则不相等。 对于频率相差一倍的两个音，例如 440Hz/880Hz，其间的音程定为八度（见后文「音级」一节）。 音分音分（cent）是一个用于度量音程的对数标度单位。按照定义，一个八度音程的频率比为 2:1，其间均匀地包含 1200 个音分。因此，相邻两个音分之间的频率倍数应当为 $2^{1/1200}$。 音程为 1 音分两个音符，人耳是很难分辨的。按照 I. Peretz 和 K.L. Hyde的说法，普通成人可以清晰分辨的最短音程差至少是 25 音分。而患有乐感丧失症的成人（一般意义上的五音不全者即属此类），不能分辨小于 100 音分的音程差。 半音和全音半音（semitone）也是一个用于度量音程的对数标度单位。半音的音程大小，根据不同的音律（见后续文章）而不同。在十二平均律中，一个半音的音程等于 100 音分。两个半音组成一个全音。 在钢琴上，相邻两个琴键之间的音程是一个半音，而间隔一个琴键之间的音程是一个全音。 十二平均律中不同音高的频率，单位为赫兹。括号内为距离中央 C（261.63 赫兹）的半音距离。八度→音名↓0123456C16.352（−48）32.703（−36）65.406（−24）130.81（−12）261.63（0）523.25（+12）1046.5（+24）C♯/D♭17.324（−47）34.648（−35）69.296（−23）138.59（−11）277.18（+1）554.37（+13）1108.7（+25）D18.354（−46）36.708（−34）73.416（−22）146.83（−10）293.66（+2）587.33（+14）1174.7（+26）D♯/E♭19.445（−45）38.891（−33）77.782（−21）155.56（−9）311.13（+3）622.25（+15）1244.5（+27）E20.602（−44）41.203（−32）82.407（−20）164.81（−8）329.63（+4）659.26（+16）1318.5（+28）F21.827（−43）43.654（−31）87.307（−19）174.61（−7）349.23（+5）698.46（+17）1396.9（+29）F♯/G♭23.125（−42）46.249（−30）92.499（−18）185.00（−6）369.99（+6）739.99（+18）1480.0（+30）G24.500（−41）48.999（−29）97.999（−17）196.00（−5）392.00（+7）783.99（+19）1568.0（+31）G♯/A♭25.957（−40）51.913（−28）103.83（−16）207.65（−4）415.30（+8）830.61（+20）1661.2（+32）A27.500（−39）55.000（−27）110.00（−15）220.00（−3）440.00（+9）880.00（+21）1760.0（+33）A♯/B♭29.135（−38）58.270（−26）116.54（−14）233.08（−2）466.16（+10）932.33（+22）1864.7（+34）B30.868（−37）61.735（−25）123.47（−13）246.94（−1）493.88（+11）987.77（+23）1975.5（+35） 音级音级指的是两个音之间包括多少基本音，是讨论音程时用来表达两个音音高之间距离的手段。所谓基本音，即使 C, D, E, F, G, A, B 七个音；这七个音符合现代钢琴上白键发出的声音。因此，在五线谱中，每条线、每个间都是一个音级；通常以「度」来表达音级。 举例来说，当两个音处于同一条线或同一个间上时，称为一度；当两个音处于相邻的线和间上时，称为二度。其余度数又可以此类推。 音程命名按照音程之间半音数与度数的不同，乐理上为不同的音程命名。首先来看相对完整的命名表格。 半音数一度举例二度举例三度举例四度举例五度举例六度举例七度举例八度举例0纯C-C减E-F♭1增C-C♯小E-F倍减Dx-F2倍增D♭-D♯大C-D减D♯-F3增C-D♯小D-F倍减D♯-G♭4倍增G♭-A♯大C-E减D♯-G5增F-A♯纯C-F倍减C♯-G♭6倍增F-Ax增F-B减B-F倍减C♯-A♭♭7倍增F-B♯纯C-G减C♯-A♭8增C-G♯小E-C倍减Dx-C9倍增D♭-A♯大C-A减D♯-C10增C-A♯小D-C倍减G♯-G’♭11倍增C-Ax大C-B减G-G’♭12增C-B♯纯C-C’13倍增C-Bx增C-C’♯14倍增C-C’x 为便于理解，这里给出相关解释。首先是钢琴上白键之间能看到的音程： 纯一度：0 个半音组成的一度音程； 小二度：1 个半音组成的二度音程； 大二度：2 个半音组成的二度音程，由两个小二度构成； 大三度：4 个半音组成的三度音程，由两个大二度构成； 纯四度：5 个半音组成的四度音程，由一个大三度和一个小二度构成； 纯五度：7 个半音组成的五度音程，由一个纯四度和一个大二度构成； 大六度：9 个半音组成的六度音程，由一个纯五度和一个大二度构成； 大七度：11 个半音组成的七度音程，由一个大六度和一个大二度构成； 纯八度：12 个半音组成的八度音程，由一个大七度和一个小二度构成。 而后是音程之间的变化： 同度大音程与小音程之间总是差一个半音； 增音程：大音程和纯音程增加半音时，叫增音程； 减音程：小音程和纯音程减少半音时，叫减音程； 倍增音程：增音程再增加半音时，叫倍增音程； 倍减音程：减音程再减少半音时，叫倍减音程。 其中，除了增四度和减五度之外，所有的增音程、减音程、倍增音程和倍减音程通称变化音程。 按照不同音程给人的不同感受，乐理上将音程分为 极完全协和音程（极纯音程）：纯一度、纯八度； 完全协和音程（纯音程）：纯四度、纯五度； 不完全协和音程：大三度、小三度、大六度、小六度； 不协和音程：大二度、小二度、大七度、小七度； 极不协和音程：增四度、减五度以及所有变化音程。 按照通常的理解，音程越和谐，奏出的声音给人的感觉就越松弛、安静；反过来，音程越不和谐，奏出的声音给人的感觉就越紧张、动态。 泛音驻波驻波（standing wave 或 stationary wave）是高中物理中的概念。两个波长、频率（周期）和波速都相同的波相向而行互相干涉，则形成驻波。驻波中，每一个质点都做简谐振动，但各点的振幅不同。振幅为零的点即是波节（Node）。 上图中，振动从弦的左端开始，以机械波的形式向右传递。在遇见右侧障碍物时，行波反射而回。此后两个行波叠加干涉，在弦上形成驻波。 驻波与泛音以弦乐器为例，根据梅森法则（Mersenne’s laws），弦的基础振动频率 $f_0$ 与弦长 $L$ 成反比； 与弦内张力 $F$ 的平方根成正比； 与弦的单位长度质量 $\mu$ 的平方根成反比。 $$f_0 \propto \frac{\sqrt{F}}{L\sqrt{\mu}}.$$ 考虑到上一小节中提到的驻波，在弦乐器中的弦上也会发生；于是驻波的各个波节对整个弦进行了分割。由于被分割的弦，长度显然要小于弦的总长，因此这部分驻波的频率会比弦的基础频率高。这样一来，弦乐器上弦的振动实际上是不同长度弦组成的复合振动。因此 弦乐器振动发声时，混合了多个不同音高的音； 频率对应总弦长的音响度最高，称为基音，也称第一泛音； 频率对应由驻波波节划分的更短的弦的音，是一系列泛音，称作泛音列； 泛音列中，按频率从低到高依次称为第二泛音、第三泛音…… 上图是在 iPhone 上使用 SpectrumView 观察小提琴四根弦振动发声的频谱。它们的基音分别是：$G_3$/$D_4$/$A_4$/$E_5$。不难发现，$G_3$ 的第三泛音和 $D_4$ 的第二泛音频率几乎相等。这说明 $3f(G_3) \approx 2f(D_4)$，亦即 $G_3$ 和 $D_4$ 之间是纯五度音程。$D_4$/$A_4$/$E_5$ 三根弦之间也能观察到相同现象，说明也是纯五度音程。 管乐器的声音由管内空气柱的振动产生。在管内的空气柱中，也会形成驻波，因而也会形成泛音。 乐器泛音列上各个泛音的强度，与基音一起决定了乐器的音色。]]></content>
      <categories>
        <category>Mathematics and Natural Sciences</category>
      </categories>
      <tags>
        <tag>Music</tag>
        <tag>Pitch</tag>
        <tag>Interval</tag>
        <tag>Harmonic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 中的 typename 及 class 关键字的区别]]></title>
    <url>%2F2018%2F03%2F16%2Fkeywords-typename-and-class-in-Cxx%2F</url>
    <content type="text"><![CDATA[其实这是一个老掉牙的问题，网络上已有很多辨析。但看下来都有遗漏其中一个区别，所以有了这篇文章。 共同点如果两个事物没有任何共同点，那么也就没必要讨论他们的区别——因为他们所有的特性都是区别。所以这里我们首先来看一下 typename 和 class 关键字的共同点。 在定义类模板或者函数模板时，typename 和 class 关键字都可以用于指定模板参数中的类型。也就是说，以下两种用法是完全等价的。这在大多数文章中都有提到。 12template&lt;typename T&gt; /* class or function declaration */;template&lt;class T&gt; /* class or function declaration */; 关于这个问题，Stan Lippman 曾在其博客中表示，最早 Stroustrup 使用 class 来声明模板参数列表中的类型是为了避免增加不必要的关键字；后来委员会认为这样混用可能造成概念上的混淆才加上了 typename 关键字。 typename 独有的功能除此之外，typename 还有其独有的功能。 由于 C++ 允许在类内定义类型别名，且其使用方法与通过类型名访问类成员的方法相同。故而，在类定义不可知的时候，编译器无法知晓类似 Type::foo 的写法具体指的是一个类型还是类内成员。 例如在以下代码中，类模板 Bar 的原意是使用类 Foo 实例化，而后引用其中的 bar_type 定义名为 bar 的类内成员。然而，就 T::bar_type 而言，编译器在编译期无法确定它究竟是不是一个类型。此时就需要 typename 关键字来辅助编译器的判断。 12345678910class Foo &#123; public: typedef int bar_type;&#125;;template&lt;typename T&gt;class Bar &#123; /* typename */ T::bar_type bar;&#125;; 这在大多数文章中也都有提到。 值得一提的是，在编译期能够判断的情形，例如在上例中直接使用 Foo::bar_type 时，使用冗余的 typename 会报错。 只有少数文章提到了这一点。 class 独有的功能class 关键字最众所周知的功能是声明或定义一个类。这当然是其相对 typename 的一个独有功能。为了完整性，这里也列出。 除此之外，在模板的使用中，class 关键字也有其特有的功能。而这是绝大多数文章不会提及的。 C++ 的标准模板库中有名为 std::stack 的容器适配器，它能适配许多容器作为底层，实现栈的功能。其声明为 12template &lt;typename T, typename Containter = std::deque&lt;T&gt; &gt;class stack; 因此，在使用中，我们可以使用 std::stack&lt;int&gt; 来声明一个以 std::deque&lt;int&gt; 保存整型变量的栈；也可以使用 std::stack&lt;int, std::vector&lt;int&gt; &gt; 来声明一个以 std::vector&lt;int&gt; 保存整型变量的栈。 现在的问题是，是否有可能以类似 Stack&lt;int, std::vector&gt; 的形式，来达到同样的目的？ 为此，我们需要有类似这样的声明 123template &lt;typename T, template &lt;typename E, typename = std::allocater&lt;E&gt; &gt; class Container = std::deque&gt;class Stack; 由于 Container 必须是一个容器类模板，所以，如果不适用具体的模板参数实例化，就必须将其声明为一个类模板。故此，Container 之前需要保留标准库中容器类模板的模板参数。注意此处使用了标准库提供的内存分配器。 此处 class 特有的功能，体现在 class Container 之处。此处虽然是在声明 Stack 这个类模板，但是此处的 class 不能替换为 typename；否则编译器会报错。 不过，在 C++17 标准中，此处也允许使用 typename 了。参见此处。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>Keywords</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三门问题的数学原理及模拟实验]]></title>
    <url>%2F2018%2F02%2F26%2FMonty-Hall-problem%2F</url>
    <content type="text"><![CDATA[三门问题是一个源自博弈论的数学游戏。三门问题的等价问题出现的很早，三囚犯问题至少在 1959 年马丁·加德纳的《数学游戏》专栏中就已有阐述。但是让三门问题真正引起广泛讨论的，当属美国的电视游戏节目 Let’s Make a Deal。因该节目的主持人名为蒙蒂·霍尔，故而该问题也称为「蒙蒂·霍尔问题」。问题的描述大致如下： 参赛者会看见三扇关闭了的门，其中一扇的后面有汽车，选中后面有汽车的那扇门就可以赢得该汽车，而另外两扇门后面则各藏有一只山羊。当参赛者选定了一扇门，但未去开启它的时候，节目主持人开启剩下两扇门的其中一扇，露出其中一只山羊。主持人其后会问参赛者要不要换另一扇仍然关上的门。问题是：换另一扇门会否增加参赛者赢得汽车的机会率？ 三门问题引起了广泛的讨论。例如在果壳网和知乎网上，你能找到大量相关讨论。 本文将尽可能清晰地对三门问题做完整讨论。 三门问题的概率表述贝叶斯公式贝叶斯公式，是关于条件概率的公式。假设有事件 $A$ 和事件 $B$，它们地位等同。贝叶斯公式可以根据给定事件 $A$ 时事件 $B$ 的条件概率 $P(B\mid A)$ 去计算给定事件 $B$ 时事件 $A$ 的条件概率 $P(A\mid B)$；或者反过来。贝叶斯公式的数学表示是： $$P(A\mid B) = \frac{P(A) P(B\mid A)}{P(B)}.$$ 其中，$P(A)$ 是事件 $A$ 的先验概率；$P(A\mid B)$ 是给定事件 $B$ 时事件 $A$ 的条件概率，在此一般称为后验概率；$P(B)$ 是事件 $B$ 的先验概率，在此一般称为边缘概率；$P(B\mid A)$ 是给定时间 $A$ 时事件 $B$ 的条件概率。 三门问题的概率建模在三门问题中，若有以下定义： 事件 $A$：参赛者选择的门后有汽车； 事件 $B$：主持人选择的门后有汽车。 则，根据贝叶斯公式，有 $$P(A\mid \bar B) = \frac{P(A) P(\bar B\mid A)}{P(\bar B)}.$$ 因此，问题转换为求解并判断后验概率 $P(A\mid \bar B)$： 若 $P(A\mid \bar B) &lt; \frac{1}{2}$，则答案是「是」； 若 $P(A\mid \bar B) \geqslant \frac{1}{2}$，则答案是「否」。 考虑 $P(\bar B\mid A)$ 表示已知参赛者选择的门后有汽车时，主持人选择的门后无汽车的概率，因为已知三扇门后只有一台汽车，因此 $P(\bar B\mid A)\equiv 1$。又考虑到参赛者选择的门后有汽车的概率始终是 $P(A) = \frac{1}{3}$，因此问题实质上是要看边缘概率 $P(\bar B)$ 的值： 若 $P(\bar B) &gt; \frac{2}{3}$，则 $P(A\mid \bar B) &lt; \frac{1}{2}$，答案是「是」； 若 $P(\bar B) \leqslant \frac{2}{3}$，则 $P(A\mid \bar B) \geqslant \frac{1}{2}$，答案是「否」。 边缘概率 $P(\bar B)$ 之谜两种答案关于三门问题，两种答案争执已久。归纳起来，可以是： 既然主持人排除了一个错误选项，那么原始问题就变成了二选一的新问题，此时选哪个都一样，中奖概率都是 $\frac{1}{2}$。因此答案是「否」。 三扇门的中奖概率都是 $\frac{1}{3}$，参赛者选中的门的中奖概率自然也是 $\frac{1}{3}$；而主持人选择的门打开后，$\frac{1}{3}$ 就「跑到」另一扇门上去了，所以另一扇门的中奖概率是 $\frac{2}{3}$。因此答案是「是」。 暗藏的假设根据贝叶斯公式，目标后验概率为 $P(A\mid \bar B) = \frac{1}{3P(\bar B)}$。因此，以上两种答案对应边缘概率 $P(\bar B)$ 分别是 $P(\bar B) = \frac{2}{3}$ 和 $P(\bar B) = 1$；这又对应了两种假设： 主持人并不知道门后的情况，随机选择后恰好门后是羊；特别地，主持人不知道参赛者选择的门后的情况，因而主持人的选择没有带来新的信息量。即：$$P(\bar B) = P(\bar B\mid A)P(A) + P(\bar B\mid\bar A)P(\bar A) = 1\cdot\frac{1}{3} + \frac{1}{2}\cdot\frac{2}{3} = \frac{2}{3}.$$ 主持人知道门后的情况，因此选择的门后边必然是羊；特别地，主持人知道参赛者选择的门后的情况，因而主持人的选择带来了新的信息量。即：$P(\bar B) = 1$。 这两种假设即是长期持续的争论的直接原因，而其根源在于原始问题用模糊的语言玩了一个文字游戏。「节目主持人开启剩下两扇门的其中一扇」，并没有体现出主持人事先是否知道门后的情况；因而两种理解都算是可以接受的。这即是三门问题引起争论的原因，也是其陷阱所在。 破解谜题尽管在原始问题中，有「文字游戏」的嫌疑，但由于「露出其中一只山羊」的保证，事实上主持人的选择就变成了确定性的结论，因而带来了信息量。以概率论的角度来描述，即是 $P(\bar B) = 1$。 因此，三门问题的答案，应当是「换另一扇门会增加参赛者赢得汽车的机会（概率从 $\frac{1}{3}$ 增加到 $\frac{2}{3}$）」。 回到小孩子的思维行文至此，尽管已经从概率论的角度解答了原始问题，并给出了问题令人困惑的根本原因，但可能仍然有人拒绝这一反直觉的答案。为此，此处给出一个运用小孩子的思维的解法：枚举。 根据题目，参赛者需要在三扇门中进行选择，而门后共有一台汽车和两只羊。不妨将其设为汽车和羊A 及羊B。那么，若参赛者在主持人展示一只羊之后更改选择，则获胜的概率为 $\frac{2}{3}$（失败的概率则是 $\frac{1}{3}$）。所有可能的情况枚举如下： 当参赛者一开始选择汽车时（$\frac{1}{3}$ 概率），不论主持人选择羊A 还是羊B，若参赛者更换选择，都不能赢得汽车。 当参赛者一开始选择羊A时（$\frac{1}{3}$ 概率），主持人必然选择羊B，若参赛者更换选择，则必然赢得汽车。 当参赛者一开始选择羊B时（$\frac{1}{3}$ 概率），主持人必然选择羊A，若参赛者更换选择，则必然赢得汽车。 计算机模拟实验所谓「实践是检验真理的唯一标准」，在给出了尽可能清晰的解答之后，本文也尝试用计算机模拟的方法，进行实践检验。 Python 代码（在此下载）读起来很容易，因此不做详细说明，而只给出简单的解释。对于参赛者的两种选择（在主持人打开一扇门后是否更改选择），代码分别进行了 10000 轮，每轮 1000 次的实验。而后，代码统计每轮 1000 次实验中，参赛者成功赢得汽车的频率；并将 10000 轮频率绘制成图展示。 以下是「不更改」的实验结果。不难发现，频率分布在 $\frac{1}{3}$ 左右，每轮实验的具体频率在它附近抖动。 以下是「更改」的实验结果。不难发现，频率分布在 $\frac{2}{3}$ 左右，每轮实验的具体频率在它附近抖动。 据此，计算机模拟实验的结果，与前文分析的结果相同。]]></content>
      <categories>
        <category>Mathematics and Natural Sciences</category>
      </categories>
      <tags>
        <tag>Three Gates</tag>
        <tag>Monty Hall</tag>
        <tag>Probability</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[质疑与污蔑的区别]]></title>
    <url>%2F2018%2F02%2F08%2Fdifference-between-calling-a-question-and-vilification%2F</url>
    <content type="text"><![CDATA[今天不讲技术，谈一些更加抽象的事情：质疑与污蔑的区别。 希冀读者能够借此理解质疑与污蔑的区别，学会在被污蔑时保护自身；同时也希望读者学会合理质疑，避免将合理质疑的范围扩大为无限质疑，变成污蔑者。 共性如果我们有意讨论某两个事物的区别，那么这两个事物一定具有某方面的共性，并且这些共性常使人忽略他们的区别。因此，在讨论质疑与污蔑的区别之前，我们需要先看看他们的共性。 质疑和污蔑的核心共性是它们都是对他人观点态度的批判、反对甚至指责。 韩春雨团队于 2016 年 5 月 2 日在《自然·生物技术》杂志上发表有关 Natronobacterium gregoryi Argonaute 能够有效引起 DNA 双链断裂，并对人体细胞进行基因编辑的论文。由于持续无法复现韩春雨团队在论文中声称的结果，2016 年 11 月，国内外 20 名学者联名撰写了一篇名为 Questions about NgAgo 的学术论文，发表在《蛋白质与细胞》杂志上。在论文中，中外 20 名学者表示他们按照韩春雨团队在论文中提及的实验步骤重复实验，但均未能复现韩春雨团队声称的实验结果。因此，他们认为韩春雨团队发表的论文是有缺陷的，并要求公布更多细节，以让其它实验室能够重现韩春雨团队的实验成果。显然，这篇论文是对韩春雨团队论文的一种批判。 方舟子在个人微信公众号上发表的「喝茶能防癌还是致癌？」一文指出：「普洱茶的发酵、储存，各种有毒真菌及易生长，所以容易污染黄曲霉素、伏马毒素、呕吐毒素等各种真菌毒素。这些毒素中最著名的是黄曲霉素，它是最强烈的致癌物之一。」显然，这篇文章是对持有「喝茶能防癌」这一观点的人做的批判。 区别由于质疑和污蔑的核心共性在于它们都在对他人的观点态度进行批判，以至于有人混淆了它们之间的区别，甚至将人们面对质疑应当做的事情嫁接到面对污蔑时应当做的事情，并美其名曰「你要自证清白」。这里说一说他们之间的区别。 质疑和污蔑的区别之核心在于两点： 对他人之观点进行批判的论证过程是否符合逻辑及约定俗成的学术伦理； 对他人之观点进行批判的目的只是为辨明是非还是包含了打压迫害（俗称搞臭）。 我一向是不喜对他人言行的目的进行讨论的，但这里仍然列出了第二条核心区别。不喜讨论的原因在于这些都不是实实在在的东西，讨论这些难免因一些微末细节，随着自己心意偏好，「见微知著」出他人的心理活动，继而得诛心之论。但这里仍然将其列出，是因为质疑和污蔑的这一区别是客观存在的。 但不论如何，此处只是将其列出，真正展开讨论的，还是第一条区别。 在上述例子中，中外 20 余科学家对韩春雨团队 NgAgo 实验结果的批判属于质疑。因为他们的批判过程，包括了严谨的论证过程，并详细说明了各自实验的流程，以事实说明韩春雨团队的结论在其时无法复现。 而在方舟子批判普洱茶致癌的例子中，尽管方舟子也列举了一些检测报告，使整个批判看似符合逻辑；但实际上，方舟子文章中的两份关键性证据（分别来自 2010 年广州疾控中心和 2013 年南昌大学吴静同学的硕士学位论文）的研究对象都是「湿仓存储」的普洱茶，而非正常普洱茶，并且其主要目的也是指出湿仓存储对普洱茶内菌落的影响。可见，方舟子批判的论证过程中存在以偏概全、偷换概念的现象，并不符合逻辑及约定俗称的学术伦理；因此，这种批判属于污蔑。 特别地，中外 20 余科学家发表质疑文章的主要目的是希望韩春雨团队公布更多实验细节，以便其他实验室能够正确重现其实验结果；而方舟子则在不久之后被发现为自家茶叶进行推广宣传。二者差别高下，读者心中应该自有公论。 除了上述核心区别，质疑和污蔑的区别还在于人们面对质疑和污蔑时应当采取的做法和立场是不一样的。面对有理有据的质疑，人们应当以同样符合逻辑和学术伦理的方式正面回应、自证清白。而面对污蔑，人们则应当考虑以合适的方式维护自己的权益，并保留采取法律手段维护自身权益的权力。 更有甚者，有的污蔑者甚至会要求被污蔑者自证清白。这种流氓行径本质上是将污蔑伪装成质疑，将合理质疑扩展为无限质疑，而后要求被污蔑者以面对质疑的态度面对污蔑。若被污蔑者未能识得这其中的差异，则往往会被污蔑者抓住话里微疵，而陷入无尽的自证清白的沼泽中，疲于应付无法自拔。]]></content>
      <categories>
        <category>Logic</category>
      </categories>
      <tags>
        <tag>Question</tag>
        <tag>Vilification</tag>
        <tag>Difference</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[产生不重复的均匀随机整数]]></title>
    <url>%2F2018%2F02%2F02%2Fgenerate-uniformly-distinctly-random-integers-in-Cpp%2F</url>
    <content type="text"><![CDATA[前文介绍了梅森旋转算法；该算法可用于产生高质量的长周期随机数。不过，随机数生成算法并不保证在一定连续长度内产生的随机数都是不重复的。即，有可能出现这样的随机数序列： 11 1 2 8 6 ... 实际生产中，我们也会需要有能力生成不重复的均匀随机整数。此篇用 C++ 实现，做一个简单的记录。 不考虑不重复性在 C++ 中，不考虑不重复性，标准库（C++ 11 及以上）提供的设施已足够完成任务。 123456789101112#include &lt;iostream&gt;#include &lt;random&gt;int main() &#123; std::random_device rd; // 1. std::mt19937 gen(rd()); // 2. std::uniform_int_distribution&lt;&gt; dis(1, 100); // 3. for (int n = 0; n != 10; ++n) std::cout &lt;&lt; dis(gen) &lt;&lt; ' '; // 4. std::cout &lt;&lt; '\n';&#125; 这里，(1) 是一个由实现决定的非确定性随机数生成器（一般与硬件有关）；(2) 借由 rd 产生的随机数种子，初始化了标准的梅森旋转生成器；(3) 则定义了 [1, 6] 之间的均匀整数分布。最后，(4) 将梅森旋转生成器输出的随机数转换为均匀整数分布。 加入不重复性保证不重复性有两种解决方案： 随机数生成器的算法本生保证了一定连续数量的随机结果不重复； 通过外部数据结构提供「重复生成」这样的信息。 对于高质量随机数生成器来说，保证一定连续数量的随机结果不重复会严重影响周期性。因此第一种方案实际上是不可取的。于是，我们需要第二个方案。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;unordered_set&gt;#include &lt;random&gt;template &lt;typename IntType = int&gt;class distinct_uniform_int_distribution &#123; public: using result_type = IntType; private: using set_type = std::unordered_set&lt;result_type&gt;; using distr_type = std::uniform_int_distribution&lt;result_type&gt;; public: distinct_uniform_int_distribution(result_type inf, result_type sup) : // 1. inf_(inf), sup_(sup), range_(sup_ - inf_ + 1), // 2. distr_(inf_, sup_) &#123;&#125; void reset() &#123; // 3. uset_.clear(); distr_.reset(); &#125; template &lt;typename Generator&gt; result_type operator()(Generator&amp; engine) &#123; // 4. if (not(uset_.size() &lt; range_)) &#123; std::terminate(); &#125; // *. result_type res; do &#123; res = distr_(engine); &#125; while (uset_.count(res) &gt; 0); // 5. uset_.insert(res); return res; &#125; result_type min() const &#123; return inf_; &#125; result_type max() const &#123; return sup_; &#125; private: const result_type inf_; const result_type sup_; const size_t range_; distr_type distr_; set_type uset_;&#125;; 首先，(1) 处在构造时必须要知道生成的整数范围是多少。而后，由于我们希望分布产生不重复的随机数，故而能产生这样的随机数是有上限的，我们于 (2) 处将这个范围保存在 range_ 中。仿照 std::uniform_int_distribution，(3) 也给出了用于清理内部状态的函数 reset：一方面将计数集合 uset_ 清空，另一方面重置内部 distr_type 的状态。(4) 重载了函数调用运算符，它是一个函数模板，接受一个随机数生成器。由于我们需要知道产生的随机数是否已经出现过，所以我们必须维护一个集合，用于保存已经输出过的整数。(5) 借助这个集合，保证了输出的不重复性。特别地，(*) 处检查了已输出不重复随机整数的数量，避免 (5) 处陷入死循环。 对它的调用也很简单，与 std::uniform_int_distribution 基本一致。 123456789101112#include &lt;iostream&gt;#include &lt;random&gt;int main() &#123; std::random_device rd; // 1. std::mt19937 gen(rd()); // 2. distinct_uniform_int_distribution&lt;&gt; dis(1, 100); // 3. for (int n = 0; n != 10; ++n) std::cout &lt;&lt; dis(gen) &lt;&lt; ' '; // 4. std::cout &lt;&lt; '\n';&#125;]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Random</tag>
        <tag>Dinstinct</tag>
        <tag>Uniform</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客百万访问纪念]]></title>
    <url>%2F2018%2F02%2F02%2Fmega-access%2F</url>
    <content type="text"><![CDATA[个人博客自 2013 年开机至今，已有四年余时间。自 2015 年 4 月 10 日引入 Bruce 开发的不蒜子，博客开始记录全站和单页的访问。 时至今日，个人博客总访问量已逾一百万，撒花庆祝！]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Million</tag>
        <tag>Access</tag>
        <tag>Commemoration</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TeX 主题选讲：TeX 处理器的结构]]></title>
    <url>%2F2018%2F01%2F31%2FTeX-by-Topic-the-Structure-of-the-TeX-processor%2F</url>
    <content type="text"><![CDATA[此篇基本上是译文，原文是 Victor Eijkhout 所著的《TeX by Topic》的第一章。译文项目参见：CTeX-org/tex-by-topic-cn。转载请保留本段文字，尊重原作者和译者版权。由于原著使用 GFDL，故而本文也被传染地同样使用 GFDL 许可，而不是本站默认的 BY-NC-SA 4.0 许可。 TeX 处理输入的过程可分为 4 个层次。你可以认为 TeX 处理器（也称 TeX 引擎）有4 个独立的单元，每个单元接收前序步骤的输出，并将输出作为后续单元的输入。第一阶段的输入是 .tex 文件，最后一个阶段的输出是 .dvi 文件。 通常而言，这样理解上述 4 个层次方便且直观：每个层次完整地接收上一个层次的输出。然而，这样并不完全正确：4 个层次的处理是同时进行的，层次之间也有交互。 4 个层次列举如下（按 Knuth 最初的叫法，分别是「眼睛」、「嘴巴」、「胃」和「肠道」）： 输入处理器（input processor）：负责为 TeX 从文件系统中读入输入，并处理为记号。记号是两种 TeX 内部对象的统称：构成排版文本的字符记号、待后续两个层次作为命令处理的控制序列记号。 展开处理器（expansion processor）：负责展开输入处理器输出的部分记号：宏、条件式、以及部分 TeX 原语。记号展开的过程会将一些（连续的）记号删除或替换为其它记号。 执行处理器（execution processor）：不可展开的控制序列即是可执行的；执行处理器负责执行这些可执行的控制序列。执行处理器的部分活动涉及到 TeX 的内部状态之变化：赋值（包括宏定义）是其中典型。除此之外，执行处理器负责构造水平列表、垂直列表和数学列表。 可视化处理器（visual processor）：TeX 的最后一个层次负责排版内容的可视化。可视化处理器将水平列表分行成段，将垂直列表分割成页，将数学列表构建成数学公式；最终输出 .dvi 文件。可视化处理器的内部算法对于用户是不可见的；不过用户可以通过一系列参数来控制。 输入处理器输入处理器是 TeX 的一部分，负责将 TeX 从输入文件中读入的内容翻译成记号。它的输出是记号流（stream of tokens）：记号组成的列表。大部分记号属于以下两类：字符记号和控制序列记号。还有一类记号是参数记号，留待后续章节讨论。 字符的输入对于简单的输入文本，其中的字符被输入处理器翻译为字符记号。在某些情况下，TeX 会忽略一些输入字符；例如，连续空格通常等价于单个空格。此外，TeX 也会向记号流中插入一些与输入字符无关的记号。例如在每一行的末尾插入一个空格，以及在每一个空行末尾插入一个 \par 记号。 并非所有的字符记号都会被最终排版出来。事实上，在 TeX 中，字符被分类为 16 类 —— 每一类都有特定的功能 —— 而只有两类最终会被排版出来。其它字符类，像 {、}、&amp; 和 #，都不会被排版出来。因此，TeX 的字符记号的含义由一对数字决定：字符编码 —— 通常是 ASCII 编码 —— 和分类码。具体某一编码的字符对应的分类码是可修改的。 当输入处理器遇到转义字符时（默认是 \），它会将转义字符之后的若干连续个字符拼在一起，形成一个控制序列记号。 对于分类码的处理，TeX 输入处理器的行为可想像为在三种内部状态（$N$，新行；$M$，行内；$S$，忽略空格）中切换的机器。在下一篇中我们会讨论这些状态及其切换。 输入处理器的两个阶段TeX 的输入处理器本身也可分为两个阶段。因为一些限制（来自终端、编辑器或者操作系统），某些字符可能很难输入。为此，TeX 设计了一套机制来表达这些字符：以两个连续的上标字符来获取所有可用字符。这套机制可视作输入处理器中相对独立的阶段；它运行于上述三状态机之前。 例如，由于 k 和 + 的 ASCII 码之差为 64，所以 ^^+ 会被输入处理器等价地转换为 k。由于这种替换机制发生在形成记号之前，所以输入 \vs^^+ip 5cm 与输入 \vskip 5cm 是等价的。某些情况下，这种用法是很有用的。 注意，这是 TeX 输入处理器的第一阶段，它不考虑分类码，而只是一个从字符到字符的变换。分类码只在输入处理器的第二阶段才起作用：字符的编码和分类码组合在一起，变成一个字符记号。 展开处理器TeX 的展开处理器接受记号流，并将记号流里的记号逐一展开，直到再无可展开记号为止。宏展开即是其中一例：如果一个控制序列是一个宏名，则根据定义，它将（和可能的参数记号一起）被替换。 展开处理器的输入主要来自输入处理器。自输入处理器而来的记号流被展开处理器展开成仅含有不可展开记号的记号流，最终流向执行处理器。 此外，在处理类似 \edef 及 \write 命令时，展开处理器也会参与工作。这些命令的参数记号会被直接展开，变成顶层的替换文本，而不是这些命令的参数。 记号的展开过程记号展开的步骤如下： 确认当前待处理的记号是否可展开。 若当前待处理的记号不可展开，则直接将其加入正在构建的记号列表中，并读入下一个记号。 若当前待处理记号可展开，则将其替换为其展开。对不带参数的宏以及一些 TeX 原语（例如 \jobname），该过程只需简单地进行记号替换即可。不过，通常 TeX 需要从输入流中读取一些参数记号，以便构造当前待处理记号的替换形式。举例说，对于带参数的宏，TeX 将读取足够的参数（parameters）记号，而后将这些参数记号作为宏的参数（arguments）。 将展开结果的第一个记号作为待处理记号，继续展开。 宏的可展开性之判断很简单：所有的宏、活动字符、条件式以及部分 TeX 原语（后续文章将给出列表）是可展开的，其他记号都不可展开。因此，展开处理器会负责诸如将宏替换为其展开、对条件是求值而后忽略条件为假的部分的任务；诸如 \vskip、字符记号（包括美元符号和花括号）则原封不动地传到输出流。 几个特例：\expandafter、\noexpand 和 \the如前所述，记号被展开后，TeX 会继续展开其展开后得到的记号。 \expandafter 是一个特例。初看之下，它只做一步展开，因而破坏了这个规则。例如说， 1\expandafter&lt;token_1&gt;&lt;token_2&gt; 会被替换为 1&lt;token_1&gt;&lt;expansion of token_2&gt; 但实际上，这个替换结果还会被展开处理器再次处理。 \noexpand 是另一个特例。当 TeX 遇到 \noexpand，则其下一个记号会被展开处理器当做是不可展开的。因此，展开处理器会把 \noexpand 的下一个记号当做是 \relax 那样，直接将其加入正在构建的记号列表。 举例说，以下宏定义中，其替换文本 \noexpand\b 会在宏定义时被展开： 1\edef\a&#123;\noexpand\b&#125; \noexpand 展开后，其后的记号暂时会被当做是 \relax 的意思。于是，当展开处理器处理下一个记号 \b 时，认为它是不可展开的，并将其直接加入正在构建的记号列表中。因此 \b 就是这个宏的替换文本。 \the 也是一个特例。在 \edef 宏定义中，\the&lt;token variable&gt; 的展开结果不会被继续展开。 展开处理器中的花括号之前提到，展开处理器将花括号视为不可展开的字符记号。通常而言，这没错。例如说 TeX 在展开下列 \romannumeral 控制序列时，会一直展开，直到遇见花括号： 1\romannumeral1\number\count2 3&#123;4 ... 因此，如果 \count2 的值是 0，那么这个控制序列的展开结果是 103 的罗马数字表示。又例如说，展开处理器对待 1\iftrue &#123;\else &#125;\fi 的方式与对待 1\iftrue a\else b\fi 的方式完全一致；即：此时 { 只是一个字符记号，与它的分类码无关。 不过，在宏展开的上下文中，展开处理器会识别和处理花括号。首先，配对的花括号内可用于将其内的一组记号标记为宏的参数。例如，下面定义的单参数宏： 1\def\macro#1&#123; ... &#125; 你可以单传一个参数来调用它： 1\macro 1 \macro \$ 也可以使用配对的花括号包裹一组记号作为宏的参数： 1\macro &#123;abc&#125; \macro &#123;d&#123;ef&#125;g&#125; 其次，对于带参数的宏，其参数中不得包含未配对的花括号。例如，如下定义的 \a 带有一个参数：包含从 \a 之后开始，直到遇见第一个花括号外的 \stop 位置的全部记号。 1\def\a#1\stop&#123; ... &#125; 对于以下用法，\a 的参数应当是 bc{d\stop}e；因为宏的参数中花括号必须是配对的。 1\a bc&#123;d\stop&#125;e\stop 执行处理器执行处理器构建水平列表、竖直列表和数学列表。与之相应，执行处理器有三种工作模式：水平模式、竖直模式、数学模式。这三种模式又分别有「内部」和「外部」两种类型。除了构建列表，执行处理器还需要处理一些与模式无关的操作，例如赋值。 执行处理器的输入是展开处理器输出的不可展开记号组成的流。在执行处理器看来，这条记号流中有两种类型的记号： 触发赋值操作（包括宏定义）的记号，以及触发与模式无关的其他操作的记号（例如 \show 和 \aftergroup）。 构建列表的记号：字符、盒子、粘连。执行处理器对它们的处理方式根据所处模式的不同而改变。 有些记号在所有模式下都可用；比如盒子可用于水平、竖直、数学三种模式。当然，这些记号的作用与效果，根据所处的模式不同而不同。也有记号只在特定模式下可用。例如说，字符记号（确切说是分类码为 11 和 12 的字符记号）则与水平模式密切相关：当执行处理器在竖直模式中遇到字符记号时，会切换到水平模式继续工作。 并非所有字符记号都是可排版的。执行处理器可能遇到数学模式切换标志（默认是 $）、分组起止符（默认是 { 和 }）。当执行处理器遇到数学模式切换标志时，它会进入或退出数学模式；而分组起止符则让执行处理器进入或退出新的一层分组。 控制序列 \relax 有些特别：该控制序列是不可展开的，同时执行时啥也不做。为说明 \relax 的作用，可与 \empty 进行比较。 \empty 的定义如下： 1\def\empty&#123;&#125; 使用 \relax 时，因其不可展开，故而下例中计数寄存器被赋值为 1： 1\count0=1\relax 2 使用 \empty 时，因 \empty 的展开结果为空，故而下例中计数寄存器被赋值为 12： 1\count0=1\empty 2 可视化处理器TeX 的可视化处理器使用了若干用户不可直接控制的算法：断行、切齐、分页、数学排版以及 dvi 文件生成算法。尽管用户不可直接控制这些算法，但可通过一些参数，间接控制它们。 这些算法当中，部分算法的输出结果可被执行处理器继续处理。例如说，分段成行得到一系列行组成的列表；这些行会被加入主竖直列表当中；而每一行又是由若干水平盒子及其中的行间粘连和惩罚组成的。又例如说，分页算法将其结果保存在 \box255 当中；而后交由输出例程继续处理。其余算法的输出结果则不然，例如数学公式不可以分解，又例如输出至 dvi 文件的盒子也是不可逆的。 示例被忽略的空格被忽略的空格可以反映数据在 TeX 各层处理器之间的流动情况。例如： 12\def\a&#123;\penalty200&#125;\a 0 展开的结果不是（设置惩罚项为 200，并排版数字 0） 1\penalty200 0 而是 1\penalty2000 这是由于输入处理器会忽略 \a 后的空格，因此展开处理器的输入流中的内容是： 1\a0 内部量值及其表示TeX使用了多种内部量，比如说整数和尺寸。这些内部量的外部表示是同一的：字符组成的字符串。例如 4711 和 91.44cm。 内部量与外部表示之间的转换发生在执行处理器或展开处理器中。具体来说，外部表示向内部量的转换发生在执行处理器中： 12\pageno=12 \baselineskip=13pt\vskip 5.71pt 内部量向外部表示的转换发生在展开处理器中： 12\number\pageno \romannumeral\year\the\baselineskip 最后再举一例。假设 \count2=45，则下列代码 1\count0=1\number\count2 3 首先将 \number\count2 被展开为字符串 45，注意 \count2 后的空格被用于界定计数器编号而已被展开。因此，下一级处理时，执行处理器看到并执行的是： 1\count0=1453]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Input</tag>
        <tag>TeX</tag>
        <tag>Engine</tag>
        <tag>Expansion</tag>
        <tag>Execution</tag>
        <tag>Visual</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用 ssh-keyscan 获取集群机器 SSH 公钥指纹]]></title>
    <url>%2F2018%2F01%2F24%2Fssh-keyscan%2F</url>
    <content type="text"><![CDATA[前作提到为了防止中间人攻击，SSH 会要求 client 用户确认 server 的密钥指纹。这个设计很有用，但是如果在可靠环境里有大量机器组成的集群，而我们需要自动化地进行 SSH 访问和相关部署，交叉地去确认密钥指纹是很大的工作量。 前作提到了 ssh-keygen 命令，用以在机器上生成密钥。此处我们需要用到 ssh-keyscan 命令，批量获取集群上机器的密钥指纹。 ssh-keyscanssh-keyscan 的语法是 1ssh-keyscan [-46Hv] [-f file] [-p port] [-T timeout] [-t type] [host | addrlist namelist] ... -46 是限定以 IPv4 或者 IPv6 连接机器；-H 则会对机器名进行散列，隐藏真实机器名，但仍能用于 SSH 相关连接；-v 则打印大量调试信息。 host | addrlist namelist 是需要扫描的机器列表；而 -f 指定一个文件，包含若干需要扫描的机器列表。-f - 表示从标准输入读取机器列表。 -p 指定连接远端 server 时的端口号；-T 指定超时时间；-t 则选择需要获取哪些类型的公钥指纹。 获取公钥指纹首先应准备好需要获取公钥指纹的 IP 或 HOSTNAME 列表，保存在文件中。例如演示用的文件是这样的。 hostlist.txt12127.0.0.1127.0.0.2 而后执行命令 123456789$ ssh-keyscan -f hostlist.txt# 127.0.0.1 SSH-2.0-OpenSSH_6.6.1127.0.0.1 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCWBZ3XrIajPmnd6R+g/wcUuOPOiRBMOYjAl4Dv8SfcZtgHqKTK6Zb1EeG3u/uzRYxqXMctG/2A4iXRDG9mvg9H9bimCWbA3xtR79NImPYg4m7BNuH9C+OXRYYJwoOGpjVMs0rGLXkq3/WVkXvQreBuhVD8NI2pEPnQsT1J5abdVbCHlwFYG6wVCJQqFY6jdntJJlxQv5EJu6w4/+Fd4LvdjysH+ngqArac6HMJUxqSxLQjzMdCRWEQKp3ySwmnRp9rHYVaJnnsXeYPfnMN1iMjdIQJPzc89Mepg4ip1q2bCMbMcx2XFO3I7YjYRdcOameFNafMGY0q5RHzhvgnNnal# 127.0.0.1 SSH-2.0-OpenSSH_6.6.1127.0.0.1 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBCPWoEQ7iCCYDrpyb5KeMmCaQ8aOnSfehqmrplZRkbqqnkS9++PdSX/eSLJ0tkFd5902/C+HTCqbDgso4mCKpMo=# 127.0.0.2 SSH-2.0-OpenSSH_6.6.1127.0.0.2 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCWBZ3XrIajPmnd6R+g/wcUuOPOiRBMOYjAl4Dv8SfcZtgHqKTK6Zb1EeG3u/uzRYxqXMctG/2A4iXRDG9mvg9H9bimCWbA3xtR79NImPYg4m7BNuH9C+OXRYYJwoOGpjVMs0rGLXkq3/WVkXvQreBuhVD8NI2pEPnQsT1J5abdVbCHlwFYG6wVCJQqFY6jdntJJlxQv5EJu6w4/+Fd4LvdjysH+ngqArac6HMJUxqSxLQjzMdCRWEQKp3ySwmnRp9rHYVaJnnsXeYPfnMN1iMjdIQJPzc89Mepg4ip1q2bCMbMcx2XFO3I7YjYRdcOameFNafMGY0q5RHzhvgnNnal# 127.0.0.2 SSH-2.0-OpenSSH_6.6.1127.0.0.2 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBCPWoEQ7iCCYDrpyb5KeMmCaQ8aOnSfehqmrplZRkbqqnkS9++PdSX/eSLJ0tkFd5902/C+HTCqbDgso4mCKpMo= 如此，将标准错误的输出重定向到 /dev/null 即可获得机器列表的公钥指纹了。 1$ ssh-keyscan -f hostlist.txt 1&gt;&gt;~/.ssh/known_hosts 2&gt;/dev/null 而后将 ~/.ssh/known_hosts 用 scp 拷贝到 hostlist.txt 中的所有机器上即可。]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>SSH</tag>
        <tag>FingerPrint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过虚函数表访问私有函数]]></title>
    <url>%2F2018%2F01%2F23%2Fcrack-private-member-function-by-vtable%2F</url>
    <content type="text"><![CDATA[一直听说 C++ 继承体系中对虚函数调用的动态绑定是基于虚函数表和虚表指针的，但是因为一些原因，我一直没有去搞清楚。今天想起这件事情，就去翻看了 C++ 的标准文档。然而，标准文档只提及了动态绑定的各种规则，却并没有提及任何有关虚函数表或虚表指针的内容。显然，我看的不会是假的标准文档，那么只可能是动态绑定是由编译器实现决定的了。 本想具体详细地写一写虚函数表相关的问题，但已入深夜，就简单记录一份实验的代码吧。详细的内容待后续再讨论。 不多做分析，直接上代码。 crack_private.cc123456789101112131415161718192021222324252627282930313233#include &lt;stddef.h&gt;#include &lt;iostream&gt;class Base &#123; public: virtual void f() &#123; std::cout &lt;&lt; "Your are calling Base::f (public)." &lt;&lt; std::endl; &#125; private: virtual void g() &#123; std::cout &lt;&lt; "Your are calling Base::g (private)." &lt;&lt; std::endl; &#125;&#125;;class Derived : public Base&#123;&#125;;using funcptr_t = void(*)(void);using ptr_t = uint64_t*;funcptr_t fuckcxx(Base* const ptr, const ptrdiff_t offset) &#123; ptr_t pvtbl = reinterpret_cast&lt;ptr_t&gt;(ptr); // 1. ptr_t pfunc = reinterpret_cast&lt;ptr_t&gt;(*pvtbl); return reinterpret_cast&lt;funcptr_t&gt;(*(pfunc + offset));&#125;int main() &#123; Derived d; auto f = fuckcxx(&amp;d, 0); auto g = fuckcxx(&amp;d, 1); // 2. f(); g(); return 0;&#125; 编译并执行。 12345678910$ g++-6 --versiong++-6 (Homebrew GCC 6.4.0_1) 6.4.0Copyright (C) 2017 Free Software Foundation, Inc.This is free software; see the source for copying conditions. There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.$ g++-6 crack_private.cc$ ./a.outYour are calling Base::f (public).Your are calling Base::g (private). 无疑，我们已经成功地访问了 Base 类的私有函数 g。现在我们来看看是怎样做到的。 主函数很简单，无非是取了一个 Derived 类型的变量 d。而后借助它，用 fuckcxx 函数通过偏移量，去获得 Base 的函数指针。最后实现函数调用。这里可以作出几个推断。 尽管 Derived 内没有任何数据成员和成员函数，但 Derived 类的对象仍保有虚表指针和类型对应的虚函数表。 在 GCC6 中虚表指针保存在类对象的起始处 (1)。 类的成员函数在至少是汇编层面与普通的函数没有两样，因此我们才能像 (2) 那样直接调用；尽管道理上说，Base::g 的函数指针类型应该是 void(Base::*)(void)。参见前作。 C++ 类的访问控制，仅限于编译期；由于对 C 语言的兼容，运行期还是和 C 一样的那一套。 还可以细致地分析多重继承以及多级继承时虚函数表和虚表指针的结构是怎样，并运用类似的方法实行函数调用。这些内容读者可自行探索，以及将在后续文章中讨论。 就酱，碎叫。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Class</tag>
        <tag>Virtual</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈 C/C++ 中的 volatile]]></title>
    <url>%2F2018%2F01%2F18%2Fvolatile-in-C-and-Cpp%2F</url>
    <content type="text"><![CDATA[最近在讨论多线程编程中的一个可能的 false sharing 问题时，有人提出加 volatile 可能可以解决问题。这种错误的认识荼毒多年，促使我写下这篇文章。 约定Volatile 这个话题，涉及到计算机科学多个领域多个层次的诸多细节。仅靠一篇博客，很难穷尽这些细节。因此，若不对讨论范围做一些约定，很容易就有诸多漏洞。到时误人子弟，就不好了。以下是一些基本的约定： 这篇博文讨论的 volatile 关键字，是 C 和 C++ 语言中的关键字。Java 等语言中，也有 volatile 关键字。但它们和 C/C++ 里的 volatile 不完全相同，不在这篇博文的讨论范围内。 这篇博文讨论的 volatile 关键字，是限定在 C/C++ 标准之下的。这也就是说，我们讨论的内容应该是与平台无关的，同时也是与编译器扩展无关的。 相应的，这篇文章讨论的「标准」指的是 C/C++ 的标准，而不是其他什么东西。 我们希望编写的代码是 (1) 符合标准的，(2) 性能良好的，(3) 可移植的。这里 (1) 保证了代码执行结果的正确性，(2) 保证了高效性，(3) 体现了平台无关性（以及编译器扩展等的无关性）。 含义单词 volatile 的含义在谈及 C/C++ 中的 volatile 关键字时，总有人会拿 volatile 这个英文单词的中文解释说事。他们把 volatile 翻译作「易变的」。但事实上，对于翻译来说，很多时候目标语言很难找到一个词能够反映源语言中单词的全部含义和细节。此处「易变的」就无法做到这一点。 Volatile 的意思，若要详细理解，还是应该查阅权威的英英字典。在柯林斯高阶学习词典中，volatile 是这样解释的： A situation that is volatile is likely to change suddenly and unexpectedly. 这里对 volatile 的解释有三个精髓的形容词和副词，体现了 volatile 的含义。 likely：可能的。这意味着被 volatile 形容的对象「有可能也有可能不」发生改变，因此我们不能对这样的对象的状态做出任何假设。 suddenly：突然地。这意味着被 volatile 形容的对象可能发生瞬时改变。 unexpectedly：不可预期地。这与 likely 相互呼应，意味着被 volatile 形容的对象可能以各种不可预期的方式和时间发生更改。 因此，volatile 其实就是告诉我们，被它修饰的对象出现任何情况都不要奇怪，我们不能对它们做任何假设。 程序中 volatile 的含义对于程序员来说，程序本身的任何行为都必须是可预期的。那么，在程序当中，什么才叫 volatile 呢？这个问题的答案也很简单：程序可能受到程序之外的因素影响。 考虑以下 C/C++ 代码。 1234volatile int *p = /* ... */;int a, b;a = *p;b = *p; 若忽略 volatile，那么 p 就只是一个「指向 int 类型的指针」。这样一来，a = *p; 和 b = *p; 两句，就只需要从内存中读取一次就够了。因为从内存中读取一次之后，CPU 的寄存器中就已经有了这个值；把这个值直接复用就可以了。这样一来，编译器就会做优化，把两次访存的操作优化成一次。这样做是基于一个假设：我们在代码里没有改变 p 指向内存地址的值，那么这个值就一定不会发生改变。 此处说的「读取内存」，包括了读取 CPU 缓存和读取计算机主存。 然而，由于 MMIP（Memory mapped I/O）的存在，这个假设不一定是真的。例如说，假设 p 指向的内存是一个硬件设备。这样一来，从 p 指向的内存读取数据可能伴随着可观测的副作用：硬件状态的修改。此时，代码的原意可能是将硬件设备返回的连续两个 int 分别保存在 a 和 b 当中。这种情况下，编译器的优化就会导致程序行为不符合预期了。 总结来说，被 volatile 修饰的变量，在对其进行读写操作时，会引发一些可观测的副作用。而这些可观测的副作用，是由程序之外的因素决定的。 关键字 volatile 的含义CPP reference 网站是对 C 和 C++ 语言标准的整理。因此，绝大多数时候，我们可以通过这个网站对语言标准进行查询。关于 volatile 关键字，有 C 语言标准和 C++ 语言标准可查。这里摘录两份标准对 volatile 访问的描述。 C 语言：Every access (both read and write) made through an lvalue expression of volatile-qualified type is considered an observable side effect for the purpose of optimization and is evaluated strictly according to the rules of the abstract machine (that is, all writes are completed at some time before the next sequence point). This means that within a single thread of execution, a volatile access cannot be optimized out or reordered relative to another visible side effect that is separated by a sequence point from the volatile access.C++ 语言：Every access (read or write operation, member function call, etc.) made through a glvalue expression of volatile-qualified type is treated as a visible side-effect for the purposes of optimization (that is, within a single thread of execution, volatile accesses cannot be optimized out or reordered with another visible side effect that is sequenced-before or sequenced-after the volatile access. This makes volatile objects suitable for communication with a signal handler, but not with another thread of execution, see std::memory_order). Any attempt to refer to a volatile object through a non-volatile glvalue (e.g. through a reference or pointer to non-volatile type) results in undefined behavior. 这里首先解释两组概念：值类型和序列点（执行序列）。 值类型指的是左值（lvalue）右值（rvalue）这些概念。关于左值和右值，前作有过介绍。简单的理解，左值可以出现在赋值等号的左边，使用时取的是作为对象的身份；右值不可以出现在赋值等号的左边，使用时取的是对象的值。除了 lvalue 和 rvalue，C++ 还定义了其他的值类型。其中，xvalue 大体可以理解为返回右值引用的函数调用或表达式，而 glvalue 则是 lvalue 和 xvalue 之和。 序列点则是 C/C++ 中讨论执行顺序时会提到的概念。对于 C/C++ 的表达式来说，执行表达式有两种类型的动作：(1) 计算某个值、(2) 副作用（例如访问 volatile 对象，原子同步，修改文件等）。因此，如果在两个表达式 E1 和 E2 中间有一个序列点，或者在 C++ 中 E1 于序列中在 E2 之前，则 E1 的求值动作和副作用都会在 E2 的求值动作和副作用之前。关于序列点和序列顺序规则，可以参考：这里和这里。 因此我们讲，在 C/C++ 中，对 volatile 对象的访问，有编译器优化上的副作用： 不允许被优化消失（optimized out）； 于序列上在另一个对 volatile 对象的访问之前。 这里提及的「不允许被优化」表示对 volatile 变量的访问，编译器不能做任何假设和推理，都必须按部就班地与「内存」进行交互。因此，上述例中「复用寄存器中的值」就是不允许的。 需要注意的是，无论是 C 还是 C++ 的标准，对于 volatile 访问的序列性，都有单线程执行的前提。其中 C++ 标准特别提及，这个顺序性在多线程环境里不一定成立。 volatile 与多线程volatile 可以解决多线程中的某些问题，这一错误认识荼毒多年。例如，在知乎「volatile」话题下的介绍就是「多线程开发中保持可见性的关键字」。为了拨乱反正，这里先给出结论（注意这些结论都基于本文第一节提出的约定之上）： volatile 不能解决多线程中的问题。 按照 Hans Boehm &amp; Nick Maclaren 的总结，volatile 只在三种场合下是合适的。 和信号处理（signal handler）相关的场合； 和内存映射硬件（memory mapped hardware）相关的场合； 和非本地跳转（setjmp 和 longjmp）相关的场合。 以下我们尝试来用 volatile 关键字解决多线程同步的一个基本问题：happens-before。 naïve case首先我们考虑这样一段（伪）代码。 123456789101112131415161718192021222324// global shared databool flag = false;thread1() &#123; flag = false; Type* value = new Type(/* parameters */); thread2(value); while (true) &#123; if (flag == true) &#123; apply(value); break; &#125; &#125; thread2.join(); if (nullptr != value) &#123; delete value; &#125; return;&#125;thread2(Type* value) &#123; // do some evaluations value-&gt;update(/* parameters */); flag = true; return;&#125; 这段代码将 thread1 作为主线程，等待 thread2 准备好 value。因此，thread2 在更新 value 之后将 flag 置为真，而 thread1 死循环地检测 flag。简单来说，这段代码的意图希望实现 thread2 在 thread1 使用 value 之前执行完毕这样的语义。 对多线程编程稍有了解的人应该知道，这段代码是有问题的。问题主要出在两个方面。其一，在 thread1 中，flag = false 赋值之后，在 while 死循环里，没有任何机会修改 flag 的值，因此在运行之前，编译器优化可能会将 if (flag == true) 的内容全部优化掉。其二，在 thread2 中，尽管逻辑上 update 需要发生在 flag = true 之前，但编译器和 CPU 并不知道；因此编译器优化和 CPU 乱序执行可能会使 flag = true 发生在 update 完成之前，因此 thread1 执行 apply(value) 时可能 value 还未准备好。 加一个 volatile 试试？在错误的理解中，此时就到了 volatile 登场的时候了。 首先我们考虑这样一段（伪）代码。 123456789101112131415161718192021222324// global shared datavolatile bool flag = false; // 1.thread1() &#123; flag = false; Type* value = new Type(/* parameters */); thread2(value); while (true) &#123; if (flag == true) &#123; // 2. apply(value); break; &#125; &#125; thread2.join(); if (nullptr != value) &#123; delete value; &#125; return;&#125;thread2(Type* value) &#123; // do some evaluations value-&gt;update(/* parameters */); flag = true; return;&#125; 这里，在 (1) 处，我们将 flag 声明为 volatile-qualified。因此，在 (2) 处，由于 flag == true 是对 volatile 变量的访问，故而 if-block 不会被优化消失。然而，尽管 flag 是 volatile-qualified，但 value 并不是。因此，编译器仍有可能在优化时将 thread2 中的 update 和对 flag 的赋值交换顺序。此外，由于 volatile 禁止了编译器对 flag 的优化，这样使用 volatile 不仅无法达成目的，反而会导致性能下降。 再加一个 volatile 呢？在错误的理解中，可能会对 value 也加以 volatile 关键字修饰；颇有些「没有什么是一个 volatile 解决不了的；如果不行，那就两个」的意思。 123456789101112131415161718192021222324// global shared datavolatile bool flag = false;thread1() &#123; flag = false; volatile Type* value = new Type(/* parameters */); // 1. thread2(value); while (true) &#123; if (flag == true) &#123; apply(value); break; &#125; &#125; thread2.join(); if (nullptr != value) &#123; delete value; &#125; return;&#125;thread2(volatile Type* value) &#123; // do some evaluations value-&gt;update(/* parameters */); // 2. flag = true; return;&#125; 在上一节代码的基础上，(1) 将 value 声明为 volatile-qualified。因此 (2) 处对两个 volatile-qualified 变量进行访问时，编译器不会交换他们的顺序。看起来就万事大吉了。 然而，volatile 只作用在编译器上，但我们的代码最终是要运行在 CPU 上的。尽管编译器不会将 (2) 处换序，但 CPU 的乱序执行（out-of-order execution）已是几十年的老技术了；在 CPU 执行时，value 和 flag 的赋值仍有可能是被换序了的（store-store）。 也许有人会说，x86 和 AMD64 架构的 CPU（大多数个人机器和服务器使用这两种架构的 CPU）只允许 sotre-load 乱序，而不会发生 store-store 乱序；或者在诸如 IA64 架构的处理器上，对 volatile-qualified 变量的访问采用了专门的指令。因而，在这些条件下，这段代码是安全的。尽管如此，使用 volatile 会禁止编译器优化相关变量，从而降低性能，所以也不建议依赖 volatile 在这种情况下做线程同步。另一方面，这严重依赖具体的硬件规范，超出了本文的约定讨论范围。 到底应该怎样做？回顾一下，我们最初遇到的问题其实需要解决两件事情。一是 flag 相关的代码块不能被轻易优化消失，二是要保证线程同步的 happens-before 语义。但本质上，设计使用 flag 本身也就是为了构建 happens-before 语义。这也就是说，两个问题，后者才是核心；如有其他不用 flag 的办法解决问题，那么 flag 就不重要。 对于当前问题，最简单的办法是使用原子操作。 123456789101112131415161718192021222324// global shared datastd::atomic&lt;bool&gt; flag = false; // #include &lt;atomic&gt;thread1() &#123; flag = false; Type* value = new Type(/* parameters */); thread2(value); while (true) &#123; if (flag == true) &#123; apply(value); break; &#125; &#125; thread2.join(); if (nullptr != value) &#123; delete value; &#125; return;&#125;thread2(Type* value) &#123; // do some evaluations value-&gt;update(/* parameters */); flag = true; return;&#125; 由于对 std::atomic&lt;bool&gt; 的操作是原子的，同时构建了良好的内存屏障，因此整个代码的行为在标准下是良定义的。 除此之外，还可以结合使用互斥量和条件变量。 1234567891011121314151617181920212223242526// global shared datastd::mutex m; // #include &lt;mutex&gt;std::condition_variable cv; // #include &lt;condition_variable&gt;bool flag = false;thread1() &#123; flag = false; Type* value = new Type(/* parameters */); thread2(value); std::unique_lock&lt;std::mutex&gt; lk(m); cv.wait(lk, []()&#123; return flag; &#125;); apply(value); lk.unlock(); thread2.join(); if (nullptr != value) &#123; delete value; &#125; return;&#125;thread2(Type* value) &#123; std::lock_guard&lt;std::mutex&gt; lk(m); // do some evaluations value-&gt;update(/* parameters */); flag = true; cv.notify_one(); return;&#125; 这样一来，由线程之间的同步由互斥量和条件变量来保证，同时也避免了 while (true) 死循环空耗 CPU 的情况。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将 Apple ID 迁移转区到美国]]></title>
    <url>%2F2018%2F01%2F15%2FAppleID-transfer-to-US%2F</url>
    <content type="text"><![CDATA[因为一些原因，我需要将 Apple ID 迁移转区到美国。这篇记录一下操作步骤。 若已加入「家庭共享（Family Sharing）」，则退出当前家庭共享。 准备好一个可用的美国地址（可使用 Google 地图，确认邮编等信息）。 准备好一个可用的美国电话号码（可使用 TextNow 注册，获取一个可用的美国 VoIP 电话号码）。 准备好一个可用的美国支付方式（可在 PayPal 注册美国区账号，结合支持美元支付的信用卡）。 打开最新版的 iTunes，按如下操作步骤，进入到修改付款方式的界面：菜单栏 -&gt; 账户 -&gt; 查看我的账户 -&gt; 更改国家/地区 -&gt; 一路下一步。 填写准备好的可用的美国支付方式；对于 Paypal，选择后会弹出浏览器并跳转到 PayPal 界面登录验证。 填写准备好的可用的美国地址、电话。 完成。 备注：将 Apple ID 迁移转区到美国之后，若要组建新的家庭共享，则必须绑定美国银行发行的信用卡/储蓄卡；使用 PayPal 或他国发行的信用卡/储蓄卡是不行的。]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>iCloud</tag>
        <tag>Apple</tag>
        <tag>Apple ID</tag>
        <tag>PayPal</tag>
        <tag>Credit Card</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈智能指针：原理及其实现]]></title>
    <url>%2F2018%2F01%2F13%2Fsmart-pointer%2F</url>
    <content type="text"><![CDATA[前作中，我们借助代理类对 Animal 及其子类的实例（事实上 Animal 是纯虚类，无法实例化）进行代理。 本文，我们将对代理类进行进一步分析，察觉一些细微的差别，而后引出智能指针。 反思代理类前作设计的代理类主要有两个方面的考量。其一是希望代理类将被代理的对象完全地管理起来，使得程序员自己不需要手动去分配和释放内存。基于这个考量，对代理类的复制、移动、赋值都伴随着被代理对象的相应变化。其二是希望代理类在一定程度上保留被代理对象多态的特性。为此，代理类需要保存基类指针作为代理类成员，并为相关函数预留接口（单独实现的 say() 函数）。 从第二个方面来看，代理类的行为，其实类似于指针。但从第一个方面来看，代理类又破坏了指针语义，而带上了值语义。这是因为，当我们复制代理类对象时，其内部的对象也会随之复制。 考虑到对于某些类型的对象，复制操作的开销很大，甚至是在逻辑上不可行的。因此，我们需要思考，如何在保留代理类的优势时，避免不必要的复制和移动操作。这就引出了智能指针（smart pointer）的话题。 代理类与智能指针要避免不必要的对被代理对象的复制和移动操作，就要反过来回顾我们为何要这样设计。若是想清楚了如此设计的原因，再能想到替代方案，就有可能避免这些多余的复制和移动操作。 在代理类中，为了保证被代理的对象的生存期覆盖相应代理类对象的生存期，我们强迫每个代理类的对象生成时，都与初始化它的对象脱离关系。脱离关系的办法，一方面是复制，一方面是移动。复制的情况下，代理类对象里保存了被代理的原对象的副本，因此二者没有关系。移动的情况下，代理类对象里保存了从原对象中窃取的资源；原对象在代理类对象生成之后，就（在逻辑上）不可用了，因此二者也没有关系。这部分的设计，从逻辑上说是不可避免的，因而是没有问题的。 除此之外，在对代理类的对象进行复制、移动时，代理类对象中被代理的部分也会被复制和移动。这样一来，代理类实现了与被代理对象的一一对应。如果「代理对象与被代理对象一一对应」是确实的需求，那么这样设计就是不可避免的，也就没有问题。然而，在大多数情况下，我们希望代理类仍然能像指针那样工作：允许多个代理类对象绑定在同一个被代理对象上。这样一来频繁的复制、移动就变成缺陷了。这样的需求是很自然的，举几例如下： 向函数拷贝传值时； 代理类对象作为函数的返回值时； 在循环中，将代理类对象作为临时值，用于保存中间状态时。 这样一来，我们对代理类的需求就形成了看似矛盾的两个方面： 代理类能控制被代理对象的生存期，也就是要处理好对象的构造、析构； 要允许多个代理类绑定同一个被代理对象。 为了解决这样的矛盾，我们必须付出一些代价：维护一个计数器，用于记录有多少个代理类绑定在被代理的对象之上。由于我们希望这样的代理类使用起来和指针相似，所以这样的代理类又称为智能指针。 第一次尝试被绑定的对象前作使用了 Animal 及其派生类 Cat/Dog 为例。不失一般性，此处先不考虑继承与多态，考虑将智能指针实现出来。因此，我们考虑代表屏幕上像素点坐标的类 Point，它的定义如下。 12345678910111213141516class Point &#123; private: int x_ = 0; // 1. int y_ = 0; public: Point() = default; // 2. Point(int x, int y) : x_&#123;x&#125;, y_&#123;y&#125; &#123;&#125; // 3. public: int x() const &#123; return x_; &#125; // 4. int y() const &#123; return y_; &#125; Point&amp; x(int x) &#123; x_ = x; return *this; &#125; // 5. Point&amp; y(int y) &#123; y_ = y; return *this; &#125;&#125;; 这里，由于 (1) 处给出了数据成员的类内初始值，所以 (2) 处无需自己定义默认构造函数，让编译器合成即可。(3) 处的参数没有给函数参数默认值（即没有声明为 Point(int x = 0, int y = 0)，这是为了防止类似 Point(0) 的调用（因为对于平面上的点来说，这样初始化在语义上是不正确的）。对于移动和拷贝构造函数及赋值运算符，则可由编译器自动合成。(4) 和 (5) 利用函数重载，实现了对数据成员的访问和修改的接口。其中 (5) 处设计为返回 Point&amp; 是为了允许类似这样的语法 point.x(42).y(42)。 智能指针我们先不考虑智能指针对类型的泛用性（不使用模板），来观察对 Point 类应该如何设计智能指针类 SmartPointer。 管理对象和前作遇到的问题一样，我们也要考虑智能指针如何管理对象。为了避免被管理的对象生存期短于智能指针对象，我们只能有以下几种情况，从 Point 对象开始去构造智能指针对象。 传入 new 得到的指针：SmartPointer sp(new Point());； 传入 Point 对象，而后拷贝一份被 SmartPointer 管理：SmartPointer sp(p);； 将用于构造 Point 的参数传递给 SmartPointer 的构造函数，直接构造：SmartPointer sp(0, 0);。 因此，我们的 SmartPointer 类应该有以下一些构造函数。 12345678910111213141516SmartPointer &#123; public: SmartPointer(Point* pp); SmartPointer(Point p); SmartPointer(int x, int y); public: SmartPointer(); SmartPointer(const SmartPointer&amp; other); SmartPointer(SmartPointer&amp;&amp; other); SmartPointer&amp; operator=(const SmartPointer&amp; other); SmartPointer&amp; operator=(SmartPointer&amp;&amp; other) noexcept; ~SmartPointer(); // ...&#125;; 获取对象我们还需要考虑，如何从智能指针对象出发，使用被绑定的对象。为此，我们可以重载 SmartPointer 类的 operator-&gt;() 和 operator*() 操作符，将相关操作转发给底层的 Point 对象。 因此，SmartPointer 类的声明又多了两个重载函数。 123456789101112131415161718192021SmartPointer &#123; public: SmartPointer(Point* pp); SmartPointer(const Point&amp; p); SmartPointer(Point&amp;&amp; p); SmartPointer(int x, int y); public: SmartPointer(); SmartPointer(const SmartPointer&amp; other); SmartPointer(SmartPointer&amp;&amp; other) noexcept; SmartPointer&amp; operator=(const SmartPointer&amp; other); SmartPointer&amp; operator=(SmartPointer&amp;&amp; other) noexcept; ~SmartPointer(); public: Point* operator-&gt;() const noexcept; Point&amp; operator*() const noexcept; // ...&#125;; 引用计数先前提到，为了实现智能指针的效果，我们必须借助一个计数器，以便随时获知有多少智能指针绑定在同一个对象上。显而易见，这个计数器不应该是 SmartPointer 的一部分。这是因为，如果计数器是 SmartPointer 的一部分，那么每次增减计数器的值，都必须广播到每一个管理着目标对象的智能指针。这样做的代价太大了。 为此，我们为 Point 类构造一个辅助类 PointCounter，来做计数器使用。PointCounter 类完全是为了实现 SmartPointer 而设计的，它不应被 SmartPointer 类以外的代码修改。因此，PointCounter 类的所有成员都应是 private 的，并声明 SmartPointer 为其友元类。 123456789101112class PointCounter &#123; private: friend class SmartPointer; Point p_; size_t count_; PointCounter() : count_&#123;1&#125; &#123;&#125; // 1. PointCounter(const Point&amp; p) : p_&#123;p&#125;, count_&#123;1&#125; &#123;&#125; // 2. PointCounter(Point&amp;&amp; p) : p_&#123;p&#125;, count_&#123;1&#125; &#123;&#125; // 3. PointCounter(int x, int y) : p_&#123;x, y&#125;, count_&#123;1&#125; &#123;&#125; // 4.&#125;; 由于 PointCounter 是为了计数而设计的，因此 (1) 处的所有构造函数，在构造时都将计数器设置为 1。(2), (3) 两处则分别是调用 Point 类的拷贝和移动构造函数。(4) 则调用 Point(int x, int y)。 SmartPointer 的实现至此，我们可以实现 SmartPointer 类了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class SmartPointer &#123; public: SmartPointer(Point* pp) : ptctr_&#123;new PointCounter(*pp)&#125; &#123;&#125; // 1. SmartPointer(const Point&amp; p) : ptctr_&#123;new PointCounter(p)&#125; &#123;&#125; SmartPointer(Point&amp;&amp; p) : ptctr_&#123;new PointCounter(p)&#125; &#123;&#125; SmartPointer(int x, int y) : ptctr_&#123;new PointCounter(x, y)&#125; &#123;&#125; private: void try_decrease() &#123; if (nullptr != ptctr_) &#123; if (1 == ptctr_-&gt;count_) &#123; delete ptctr_; &#125; else &#123; --(ptctr_-&gt;count_); &#125; &#125; else &#123;&#125; &#125; public: SmartPointer() : ptctr_&#123;new PointCounter&#125; &#123;&#125; // 2. SmartPointer(const SmartPointer&amp; other) : ptctr_&#123;other.ptctr_&#125; &#123; // 3. ++(ptctr_-&gt;count_); &#125; SmartPointer(SmartPointer&amp;&amp; other) noexcept : ptctr_&#123;other.ptctr_&#125; &#123; other.ptctr_ = nullptr; &#125; SmartPointer&amp; operator=(const SmartPointer&amp; other) &#123; // 4. try_decrease(); ptctr_ = other.ptctr_; ++(ptctr_-&gt;count_); return *this; &#125; SmartPointer&amp; operator=(SmartPointer&amp;&amp; other) noexcept &#123; try_decrease(); ptctr_ = other.ptctr_; other.ptctr_ = nullptr; return *this; &#125; ~SmartPointer() &#123; try_decrease(); ptctr_ = nullptr; &#125; public: Point* operator-&gt;() const noexcept &#123; // 5. return &amp;(ptctr_-&gt;p_); &#125; Point&amp; operator*() const noexcept &#123; return ptctr_-&gt;p_; &#125; private: PointCounter* ptctr_ = nullptr;&#125;; 这里，(1) 处四个构造函数负责构造一个新的 PointCounter 对象，并将其指针赋值给 ptctr_；(2) 处的默认构造函数则构造了一个空的 PointCounter 对象（其计数值也为 1）；(3) 处的拷贝和移动构造函数负责从 other 处获得 ptctr_ 的值，并处理好计数器的值的变化；(4) 是拷贝和移动赋值运算符，在执行时，首先要先释放计数器辅助类，而后从 other 处获取新的计数器辅助类对象的指针；(5) 处重载了成员访问运算符，将成员访问的操作转发到 Point 对象上。 如此，我们就得到了第一版的智能指针的实现。 第二次尝试分析在第一次尝试的过程中，为了快速搭建模型，我们做一个假设：我们的例子从 Animal 切换到了 Point，从而忽略了继承和动态绑定。这个假设导致我们在后续处理引用计数的过程中，使用了十分粗暴的方式：定义一个与 Point 对应的 PointCounter 类。事实上，这种方法是很不好的。 首先，PointCounter 类内包含了一个类型为 Point 的成员，从而禁止了动态绑定。这是因为 C++ 的动态绑定是建立在基类的指针或引用的基础之上的。其次，从抽象的角度来说，SmartPointer 需要的计数器，与 SmartPointer 内绑定的对象的类型没有关系，因此不应该针对 Point 类构建一个 PointCounter 辅助类。 当前 SmartPointer 类存在的问题，促使我们继续思考去解决。基本来说，我们需要对引用技术器进行单独的抽象，将数据与计数器分离开来。 引用计数器我们从最基本的部分开始。 一个引用计数器类，至少应该包含一个指向无符号整数类型的指针。使用无符号的整数，是因为我们的目的是引用计数，它不会小于零。使用指针是因为我们希望为这个计数器动态分配内存，使得多个引用计数器类的对象可以共享。 因此，考虑构造函数、析构函数、赋值运算符，引用计数器类的定义目前看起来是这样。 1234567891011121314151617181920212223242526272829303132333435363738class RefCount &#123; private: size_t* count_ = nullptr; private: void try_decrease() &#123; if (nullptr != count_) &#123; if (1 == *count_) &#123; delete count_; &#125; else &#123; --(*count_); &#125; &#125; else &#123;&#125; &#125; public: RefCount() : count_&#123;new size_t(1)&#125; &#123;&#125; RefCount(const RefCount&amp; other) : count_&#123;other.count_&#125; &#123; ++(*count_); &#125; RefCount(RefCount&amp;&amp; other) : count_&#123;other.count_&#125; &#123; other.count_ = nullptr; &#125; RefCount&amp; operator=(const RefCount&amp; other) &#123; try_decrease(); count_ = other.count_; ++(*count_); return *this; &#125; RefCount&amp; operator=(RefCount&amp;&amp; other) &#123; try_decrease(); count_ = other.count_; other.count_ = nullptr; return *this; &#125; ~RefCount() &#123; try_decrease(); count_ = nullptr; &#125; // ...&#125;; 回顾 SmartPointer 的析构函数，我们不难发现：为了在合适的实际销毁 Point 对象，我们必须有办法知道当前析构的 SmartPointer 是否为最后一个绑定在目标 Point 对象上的智能指针。因此，我们的 RefCount 类必须提供这样的接口。 123456class RefCounter &#123; // ... public: bool only() const &#123; return (1 == *count_); &#125;&#125;; 重新实现智能指针至此，我们可以考虑重新实现智能指针类了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class SmartPointer &#123; public: SmartPointer(Point* pp) : point_&#123;pp&#125; &#123;&#125; // 1. SmartPointer(const Point&amp; p) : point_&#123;new Point(p)&#125; &#123;&#125; SmartPointer(Point&amp;&amp; p) : point_&#123;new Point&#123;p&#125;&#125; &#123;&#125; SmartPointer(int x, int y) : point_&#123;new Point&#123;x, y&#125;&#125; &#123;&#125; public: SmartPointer() : point_&#123;new Point&#125; &#123;&#125; SmartPointer(const SmartPointer&amp; other) = default; // 2. SmartPointer(SmartPointer&amp;&amp; other) noexcept : point_&#123;other.point_&#125;, refc_&#123;std::move(other.refc_)&#125; &#123; other.point_ = nullptr; &#125; SmartPointer&amp; operator=(const SmartPointer&amp; other) &#123; // 3. if (refc_.only()) &#123; delete point_; &#125; refc_ = other.refc_; point_ = other.point_; return *this; &#125; SmartPointer&amp; operator=(SmartPointer&amp;&amp; other) noexcept &#123; if (refc_.only()) &#123; delete point_; &#125; refc_ = std::move(other.refc_); point_ = other.point_; other.point_ = nullptr; return *this; &#125; ~SmartPointer() &#123; // 4. if (point_ and refc_.only()) &#123; delete point_; point_ = nullptr; &#125; &#125; public: Point* operator-&gt;() const noexcept &#123; return point_; &#125; Point&amp; operator*() const noexcept &#123; return *point_; &#125; private: Point* point_ = nullptr; RefCount refc_;&#125;; 这里，(1) 处定义的四个构造函数，由于无需再使用 PointCounter 类，变得简单了一些；由于 SmartPointer 的所有数据成员都能自己处理好拷贝和移动，因此 (2) 处 SmartPointer 的拷贝构造函数可以让编译器自动生成；(3) 处实现的拷贝和移动赋值运算符和之前相比也有了很大变化：由于 RefCount 可以提供了 only() 接口，同时由于 RefCount 能够自行处理好拷贝和移动赋值，赋值运算的实现变得简单了很多；基于同样的原因，(4) 处的析构函数也无需处理 RefCount 类型的数据成员——交给它自己处理即可。 第三次尝试分析相比第一版，第二版的 SmartPointer 有了不少改进。但是，它有点名不副实——虽然类的名字是 SmartPointer，但是却只能和 Point 这一个类联用。为此，我们需要 C++ 中的模板技术。 在第二版 SmartPointer 实现中，大多数的内容都与 Point 类无关，唯独构造函数 SmartPointer(int x, int y) 是专为 Point 类设计的。这一构造函数所作的唯一一件事情，是将收到的参数转发给 Point 相应的构造函数。我们希望 SmartPointer 类的形式是 template &lt;typename T&gt; class SmartPointer;。但 T 的构造函数可以千奇百怪，于是若要将 T 的构造函数都在 SmartPointer 中做转发，就不得不变成 template &lt;typename T, typename... Args&gt; class SmartPointer;。这很不好；因此，我们需要将这类构造函数从 SmartPointer 的定义中迁移出去。 另一方面，我们又希望能够保留从 T 的构造函数出发，直接构造 SmartPointer 的能力。为此，我们需要引入一个函数模板 make_smart。 12template&lt;typename T, typename... Args&gt;SmartPointer&lt;T&gt; make_smart(Args&amp;&amp;... args); 这个函数模板能够接受任意个数及类型的参数，并构造一个 SmartPointer&lt;T&gt; 类型的智能指针。 接下来，我们首先改造 SmartPointer 的定义，然后实现 make_smart 函数模板。 改造智能指针将 SmartPointer 改造成类模板是很容易的事情：只需要将所有的 Point 改成 T，并声明为类模板即可——当然，要去掉上述构造函数。为了区分，这里将 SmartPointer 重命名为 smart_ptr。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950template&lt;typename T&gt;class smart_ptr &#123; public: using value_type = T; public: smart_ptr(value_type* pp) : value_&#123;pp&#125; &#123;&#125; smart_ptr(const value_type&amp; p) : value_&#123;new value_type(p)&#125; &#123;&#125; smart_ptr(value_type&amp;&amp; p) : value_&#123;new value_type&#123;p&#125;&#125; &#123;&#125; public: smart_ptr() : value_&#123;new value_type&#125; &#123;&#125; smart_ptr(const smart_ptr&amp; other) = default; smart_ptr(smart_ptr&amp;&amp; other) = default; smart_ptr&amp; operator=(const smart_ptr&amp; other) &#123; if (refc_.only()) &#123; delete value_; &#125; refc_ = other.refc_; value_ = other.value_; return *this; &#125; smart_ptr&amp; operator=(smart_ptr&amp;&amp; other) noexcept &#123; if (refc_.only()) &#123; delete value_; &#125; refc_ = std::move(other.refc_); value_ = other.value_; other.value_ = nullptr; return *this; &#125; ~smart_ptr() &#123; if (value_ and refc_.only()) &#123; delete value_; value_ = nullptr; &#125; &#125; public: value_type* operator-&gt;() const noexcept &#123; return value_; &#125; value_type&amp; operator*() const noexcept &#123; return *value_; &#125; private: value_type* value_ = nullptr; RefCount refc_;&#125;; 实现 make_smart 函数模板基础版本的 make_smart 也是很容易的，只需要将接收到的参数转发给 T 的构造函数即可。 1234template&lt;typename T, typename... Args&gt; // 1.smart_ptr&lt;T&gt; make_smart(Args&amp;&amp;... args) &#123; // 2. return smart_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...)); // 3.&#125; 这里，(1) 处使用了 C++11 中名为「参数包」的技术，使得函数模板可以接收任意多个任意类型的参数；(2) 处对参数包进行解包，使用右值引用模式接受参数，借助「引用折叠」技术接收任意类型的参数；(3) 处使用了 std::forward，将接收到的参数原封不动地完美地转发给 T 的构造函数。 关于参数包技术，将在未来的博文中介绍。 至此，完整代码可见这里。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Surrogate</tag>
        <tag>Handler</tag>
        <tag>Pointer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈梅森旋转：算法及其爆破]]></title>
    <url>%2F2018%2F01%2F12%2FMersenne-twister%2F</url>
    <content type="text"><![CDATA[现代编程语言，大都在标准库中包含了随机库。例如，C++ 在 C++11 标准中添加了 random 头文件，提供了现代的随机库；Python 则有 random。C++11 的随机库将生成随机数的过程在逻辑上切分成了两个步骤：随机数生成引擎和分布。在学习 C++11 的 random 库时，std::mt19937 这一随机数生成引擎的名字看起来十分奇怪，成功吸引了我的注意力。 查询后得知，std::mt19937 中的 MT 是 Mersenne Twister 的缩写，这是伪随机数生成算法的名字（梅森旋转算法）；而 19937 则取自算法中用到的梅森素数 $2^{19937} - 1$。这里，梅森素数是算法生成伪随机数的循环长度（period），而旋转则说的是算法内部对定长二进制串循环位移的过程。 此篇讲解梅森旋转算法的一些原理，并介绍对其的一个「爆破」方法。 伪随机数发生器质量的度量——$k$-维 $v$-比特准确度梅森旋转算法（Mersenne Twister Algorithm，简称 MT）是为了解决过去伪随机数发生器（Pseudo-Random Number Generator，简称 PRNG）产生的伪随机数质量不高而提出的新算法。该算法由松本眞（Makoto Matsumoto）和西村拓士（Takuji Nishimura）在 1997 年提出，期间还得到了「算法之神」高德纳（Donald Ervin Knuth）的帮助。 既然 MT 是为了解决过去 PRNG 质量低下的问题，那么首先我们就必须要有一个能够度量 PRNG 质量的方法。否则，「公说公有理婆说婆有理」，我们就无法对 PRNG 作出统一的评价了。 这里介绍评价 PRNG 最严格指标[Tootill et al. 1973][Fushimi and Tezuka 1983][Couture et al. 1993][Tezuka 1995][Tezuka 1994][Tezuka and L’Ecuyer 1991][L’Ecuyer 1996]：$k$-维 $v$-比特准确度（$k$-distributed to $v$-bit accuracy）。 假设某一 PRNG 能够产生周期为 $P$ 的 $w$-比特的随机数序列 $\{\vec x_i\}$；同时，将 $w$-比特的随机数 $\vec x$ 的最高 $v$ 位组成的数记作 $\text{trunc}_v(\vec x)$。现构造如下长度为 $kv$-比特的二进制数 $$\text{PRNG}_{k, v}(i) \overset{\text{def}}{=}(\text{trunc}_v(\vec x_i),\text{trunc}_v(\vec x_{i + 1}),\ldots,\text{trunc}_v(\vec x_{i + k - 1})).$$ 由于 $\text{PRNG}_{k, v}(i)$ 是长度为 $kv$-比特的二进制数，所以它可以有 $2^{kv}$ 中不同的取值。若当 $i$ 遍历 $[0, P)$，$\text{PRNG}_{k, v}(i)$ 的取值在这 $2^{kv}$ 中均匀分布。具体来说，$\text{PRNG}_{k, v}(i)$ 落在这 $2^{kv}$ 个取值上的数量完全相等（$\frac{P + 1}{2^{kv}}$），除了全零的取值会少不多不少正好一次（$\frac{P + 1}{2^{kv}} - 1$）。 显而易见，对任意固定的 $v$，若 PRNG 是 $k$-维 $v$-比特准确的，那么必然也是 $(k - 1)$-维 $v$-比特准确的，但不一定是 $(k + 1)$-维 $v$-比特准确的。考虑 $k$ 是有上限的，因此，对于任意固定的 $v$，必然存在最大的 $k = k(v)$ 使得 PRNG 是 $k(v)$-维 $v$-比特准确的。那么，根据定义，显然有 $2^{k(v)v} - 1 \leqslant P$。 $k$-维 $v$-比特准确度也可以有密码学角度的描述：若 PRNG 是 $k$-维 $v$-比特准确的，那么即使已知 PRNG 生成的 $l &lt; k$ 个伪随机数的最高 $v$ 位，也无法推出 PRNG 生成的第 $l + 1$ 个伪随机数的最高 $v$ 位。 根据这样的定义，MT 算法具有非常优良的性能。首先 MT 算法（MT19937）的周期非常长。其周期 $P = 2^{19937} - 1$，要比预估的宇宙可观测的粒子总数（$10^{87}$）还要高出数千个数量级。其次，作为一个 $32$ 比特随机数生成器，MT19937 是 $623$-维 $32$-比特准确的。考虑到 $\bigl\lfloor \frac{19937}{32}\bigr\rfloor = 623$，MT19937 在 $k$-维 $v$-比特准确度上的性能已达到理论上的最大值。因此，MT19937 具有非常优良的性能。 梅森旋转算法的描述旋转32 位的梅森旋转算法能够产生周期为 $P$ 的 $w$-比特的随机数序列 $\{\vec x_i\}$；其中 $w = 32$。这也就是说，每一个 $\vec x$ 是一个长度为 32 的行向量，并且其中的每一个元素都是二元数域 $\mathbb{F}_2 \overset{\text{def}}{=} \{0, 1\}$ 中的元素。现在，我们定义如下一些记号，来描述梅森旋转算法是如何进行旋转（线性移位）的。 $n$：参与梅森旋转的随机数个数； $r$：$[0, w)$ 之间的整数； $m$：$(0, n]$ 之间的整数； $\mathbf{A}$：$w \times w$ 的常矩阵； $\vec x^{(u)}$：$\vec x$ 的最高 $w - r$ 比特组成的数（低位补零）； $\vec x^{(l)}$：$\vec x$ 的最低 $r$ 比特组成的数（高位补零）。 梅森旋转算法，首先需要根据随机数种子初始化 $n$ 个行向量： $$\vec x_0, \vec x_1, \ldots, \vec x_{n - 1}.$$ 而后根据下式，从 $k = 0$ 开始依次计算 $\vec x_{n}$： \begin{equation}\vec x_{k + n} \overset{\text{def}}{=} \vec x_{k + m}\oplus \bigl(\vec x_{k}^{(u)}\mid \vec x_{k + 1}^{(l)}\bigr)\mathbf{A}.\label{eq:twister}\end{equation} 其中，$\vec x\mid \vec x&#39;$ 表示两个二进制数按位或；$\vec x\oplus \vec x&#39;$ 表示两个二进制数按位半加（不进位，也就是按位异或）；$\vec x\mathbf A$ 则表示按位半加的矩阵乘法。在 MT 中，$\mathbf A$ 被定义为 $$\begin{pmatrix} &amp; 1 \\ &amp; &amp; 1 \\ &amp; &amp; &amp; \ddots \\ &amp; &amp; &amp; &amp; 1 \\ a_{w - 1} &amp; a_{w - 2} &amp; a_{w - 3} &amp; \cdots &amp; a_0 \end{pmatrix}$$ 因此 $$\vec x\mathbf A = \begin{cases}\vec x &gt;&gt; 1&amp; \text{if $x_0 = 0$} \\ (\vec x &gt;&gt; 1)\oplus\vec a&amp; \text{if $x_0 = 1$}\end{cases}.$$ 此处，若 $r = 0$，则 MT 退化为 TGFSR (Matsumoto and Kurita 1992, 1994)；若再加上 $\mathbf A = \mathbf I_{w}$，则又从 TGFSR 退化为 GFSR (Lewis and Payne 1973)。 因此，梅森旋转 \ref{eq:twister} 式完全由位运算组成（移位、按位与、按位或、按位异或）。 线性反馈移位寄存器、旋转之名、周期上一小节我们介绍了 MT 算法当中的「旋转」。但只凭抽象的数学公式（尤其是二进制的逻辑数学），很难看出它为什么是「旋转」。这一节我们首先介绍线性反馈移位寄存器（Linear Feedback Shifting Register，简称 LFSR），看到它是如何「旋转」的；最后再将 LFSR 和 MT 算法当中的旋转步骤统一起来。 反馈移位寄存器是对二进制序列进行等长变换的一种特殊函数。它包括两个部分： 级。等长変换的长度即是反馈移位寄存器的级。 反馈函数。若反馈函数是线性的，则称线性反馈移位寄存器；否则是非线性反馈移位寄存器。 一般来说，LFSR 是基于异或运算的。一个 LFSR 的工作步骤是这样的： 将原寄存器状态的最低位作为输出。 执行线性反馈函数；也就是选取其中若干位，从高位到低位迭代异或。 将元寄存器状态向低位移位 1 位，并以上述迭代异或的结果作为填充值填入最高位。 在不断的迭代异或、填充高位的过程中，二进制位在寄存器中循环旋转。这就是「旋转」的来由。 对于一个 4 级的 LFSR 来说，假设其反馈函数是 $f(x) = x^4 + x^2 + x + 1$。则 LFSR 每次从最低位取出结果，将最高位（$x^4$）和倒数第二低位（$x^2$）取异或后，再与最低位（$x$）取异或后，填入移位后的最高位。 因此，若初始状态为 $(1000)_2$，则有 12345671000110011100111001100011000 # 复原 如此，我们就构建了一个循环长度为 6 的 LFSR。 考虑一个 $w$ 级的 LFSR，其最多共有 $2^w$ 种状态。又考虑对于异或来说，全零的状态是不可用的（因为不论如何运算都是全零），因此一个 $w$ 级的 LFSR，其有效状态共有 $2^w - 1$ 个。因此，理论上，一个 LFSR 的循环长度最大为 $2^w - 1$。可以证明，当且仅当反馈函数是 $\mathbb F_2$ 上的本原多项式（素多项式）时，LFSR 的循环长度达到最大值。 回过头来看 \ref{eq:twister} 式，不难发现，这其实相当于一个 $nw - r$ 级的线性反馈移位寄存器（取 $\vec x_k^{(u)}$ 的最高 $w - r$ 位与 $\vec x_{k + 1}^{(l)}$ 的最低 $r$ 位进行迭代异或，再经过一个不影响周期的线性变换 $\mathbf A$）。只不过，\ref{eq:twister} 式每一次运算，相当于 LFSR 进行了 $w$ 轮计算。若 $w$ 与 $nw - r$ 互素，那么这一微小的改变是不会影响 LFSR 的周期的。考虑到 LFSR 的计算过程像是在「旋转」，这即是「梅森『旋转』」名字的来由。 对这个等效的 $nw - r$ 级 LFSR 来说，当且仅当反馈函数是 $\mathbb F_2$ 上的本原多项式（素多项式）时，MT 的循环周期长度 $P$ 达到最大值（$2^{nw - r} - 1$）。 提取（tempering）输出MT19937 有两个主要特性。一是周期很长，达到 $2^{19937} - 1$，二是满足 $623$-维 $32$-比特准确性。上述「旋转」的过程，帮助我们达成了较长的周期。接下来，我们需要将每次旋转的结果提取（tempering）输出，以保证 MT 是 $623$-维 $32$-比特准确的。 提取的方法很简单，只需要将每次旋转得到的输出右乘一个可逆矩阵 $\mathbf T$ 即可。将 $\vec x\mapsto \vec x\mathbf T$ 表述成位运算，则有 \begin{align} \vec y &amp;{}\gets \vec x\oplus (\vec x &gt;&gt; u) \\ \vec y &amp;{}\gets \vec y\oplus ((\vec y &lt;&lt; s) \mathop{\mathbf{AND}} \vec b) \\ \vec y &amp;{}\gets \vec y\oplus ((\vec y &lt;&lt; t) \mathop{\mathbf{AND}} \vec c) \\ \vec z &amp;{}\gets \vec y\oplus (\vec y &gt;&gt; l) \end{align} 此处，$u$, $s$, $t$, $l$ 是整数参数；$\vec b$ 和 $\vec c$ 是 $w$-比特的整数，用作比特遮罩（bit mask）；最终能得到的 $\vec z$ 即是当前轮次的随机数输出。 算法描述这样一来，MT 算法的主要有两个部分：旋转、提取。 旋转部分有参数 $w$：生成的随机数的二进制长度； $n$：参与旋转的随机数个数（旋转的深度）； $m$：参与旋转的中间项； $r$：$\vec x_{k}^{(u)}$ 和 $\vec x_{k + 1}^{(l)}$ 的切分位置； $\vec a$：矩阵 $\mathbf A$ 的最后一行。 提取部分有参数 $u$, $s$, $t$, $l$：整数参数，移位运算的移动距离； $\vec b$, $\vec c$：比特遮罩。 于是，我们得到 MT 算法的完整描述如下。 常量初始化。\begin{align*} \vec{lower} &amp;{}\gets 0 \\ \vec{lower} &amp;{}\gets (\vec{lower} &lt;&lt; 1) \mathop{\mathrm{AND}} 1\quad \text{for $r$ times.} \\ \vec{upper} &amp;{}\gets \mathop{\mathrm{COMPL}}\vec{lower} \\ \vec a &amp;{}\gets a_{w - 1}a_{w - 2}\cdots a_{1}a_{0} \\ i &amp;{}\gets 0 \end{align*} 工作区非零初始化。$$\vec x[0], \vec x[1], \ldots, \vec x[n - 1]$$ 旋转\begin{align*} \vec t &amp;{}\gets (\vec x[i]\mathop{\mathrm{AND}} \vec{upper}) \mathop{\mathrm{OR}} (\vec x[(i + 1) \mod n]\mathop{\mathrm{AND}} \vec{lower}) \\ \vec x[i] &amp;{}\gets \vec x[(i + m) \mod n]\mathop{\mathrm{XOR}} (\vec t &gt;&gt; 1) \mathop{\mathrm{XOR}} \begin{cases}\vec 0&amp; \text{if $t_0 = 0$}\\ \vec a&amp; \text{otherwise}\end{cases} \end{align*} 提取输出。\begin{align*} \vec y &amp;{}\gets \vec x[i] \\ \vec y &amp;{}\gets \vec y \mathop{\mathbf{XOR}} (\vec y &gt;&gt; u) \\ \vec y &amp;{}\gets \vec y \mathop{\mathbf{XOR}} ((\vec y &lt;&lt; s) \mathop{\mathbf{AND}} \vec b) \\ \vec y &amp;{}\gets \vec y \mathop{\mathbf{XOR}} ((\vec y &lt;&lt; t) \mathop{\mathbf{AND}} \vec c) \\ \vec y &amp;{}\gets \vec y \mathop{\mathbf{XOR}} (\vec y &gt;&gt; l) \\ &amp;{} \text{output $\vec y$} \end{align*} 更新循环变量 $i\gets (i + 1)\mod n$，而后跳转至步骤 3 继续进行。 再探梅森旋转至此，我们已经探索了梅森旋转算法表面上的全部内容：我们已经知道梅森旋转算法是什么，也知道梅森旋转算法为什么这样起名，也有了完整的算法描述。但是，关于梅森旋转算法还有很多深层的问题我们未曾探索。比如说，对于 $n$, $w$ 和 $r$ 的组合，我们是否有必要追求最长周期 $P$ 使得 $P = w^{nw - r} - 1$？又比如说，我们提到 LFSR 取得最长周期的充要条件是反馈函数是 $\mathbb F_{2}$ 上的素多项式，那么怎样验证反馈函数是否是素的？ 这一节，我们来讨论这些问题。 关于周期前文提到，梅森旋转的过程，实际上是对长度为 $nw - r$ 的二进制串做了一个 LFSR 的变体。这里，我们将它记作 $\mathbf B$。 我们已经知道，这个 LFSR 的变体，其周期的上限是 $2^{nw - r} - 1$。这样一来，整个序列的周期达到这一上限就意味着除去全零的状态，整个序列每一种可能状态都被遍历了一遍；而全零的状态则被遍历了 1 遍。考虑在这 $nw - r$ 比特的序列中，$\\{\vec x_n\\}$ 有 $n - 1$ 个完整的 $w$-比特向量；因此，$\\{\vec x_n\\}$ 显然是 $(n - 1)$-维的。这也就是说，选择不同的随机数种子，至多只能改变 ${\vec x_n}$ 序列的起始相位。 这样一来，我们有：当梅森旋转达到最大周期时，若 $n$ 确定，$n - 1$ 就确定了，进而整个序列同分布的维数 $n - 1$ 也就确定了。因此，对于梅森旋转而言，提升维数是很容易的事情。 这即是努力使梅森旋转达到最大周期的意义。 多项式素检测与参数调优在梅森旋转算法中，反馈函数（$\mathbf B$ 的特征多项式）的素检测是很容易的。这是因为，对于 $p = nw - r$（其中 $p$ 是梅森素数的幂）级的 LFSR 来说，其反馈函数在 $\mathbb F_2$ 上的素检测的复杂度是 $O(p^2)$。这一方面得益于梅森素数的性质，另一方面得益于 MT 是工作在 $\mathbb F_2$ 上的算法。(Matsumoto and Nishimura, 1997) 这一特性的证明，牵扯到很多抽象代数和数论方面的知识；此处我们按下不表，留待后续用专门的文章来证明。 梅森旋转算法中，要实现 PRNG 的最佳性能，需要对旋转和提取两部分参数做细致的调整。调整这部分参数，寻得最优参数组合，是有特定算法可寻的。这部分内容十分繁琐，此处也不表。有兴趣的用户可阅读梅森旋转算法原始论文第四节、第五节。 梅森旋转算法的 Python 实现此处给出一个 Python 实现的梅森旋转算法（mt19937），为后续对算法的「爆破」提供素材。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#! coding: utf-8class MersenneTwister: __n = 624 __m = 397 __a = 0x9908b0df __b = 0x9d2c5680 __c = 0xefc60000 __kInitOperand = 0x6c078965 __kMaxBits = 0xffffffff __kUpperBits = 0x80000000 __kLowerBits = 0x7fffffff def __init__(self, seed = 0): self.__register = [0] * self.__n self.__state = 0 self.__register[0] = seed for i in range(1, self.__n): prev = self.__register[i - 1] temp = self.__kInitOperand * (prev ^ (prev &gt;&gt; 30)) + i self.__register[i] = temp &amp; self.__kMaxBits def __twister(self): for i in range(self.__n): y = (self.__register[i] &amp; self.__kUpperBits) + \ (self.__register[(i + 1) % self.__n] &amp; self.__kLowerBits) self.__register[i] = self.__register[(i + self.__m) % self.__n] ^ (y &gt;&gt; 1) if y % 2: self.__register[i] ^= self.__a return None def __temper(self): if self.__state == 0: self.__twister() y = self.__register[self.__state] y = y ^ (y &gt;&gt; 11) y = y ^ (y &lt;&lt; 7) &amp; self.__b y = y ^ (y &lt;&lt; 15) &amp; self.__c y = y ^ (y &gt;&gt; 18) self.__state = (self.__state + 1) % self.__n return y def __call__(self): return self.__temper() def load_register(self, register): self.__state = 0 self.__register = registerif __name__ == "__main__": mt = MersenneTwister(0) tank = set() kLen = 100 for i in range(kLen): t = mt() tank.add(t) print(t) print(len(tank) == kLen) 爆破梅森旋转算法梅森旋转算法的设计目的是优秀的伪随机数发生算法，而不是产生密码学上安全的随机数。从梅森旋转算法的结构上说，其提取算法 __temper 完全基于二进制的按位异或；而二进制按位异或是可逆的，故而 __temper 是可逆的。这就意味着，攻击者可以从梅森旋转算法的输出，逆推出产生该输出的内部寄存器状态 __register[__state]。若攻击者能够获得连续的至少 __n 个寄存器状态，那么攻击者就能预测出接下来的随机数序列。 现在我们遵循这个思路，爆破梅森旋转算法。 逆向 __temper我们以向右移位后异或为例，首先观察原函数。 1234def right_shift_xor(value, shift): result = value result ^= (result &gt;&gt; shift) return result 简单起见，我们观察一个 8 位二进制数，右移 3 位后异或的过程。 123value: 1101 0010shifted: 0001 1010 # 010 (&gt;&gt; 3)result: 1100 1000 首先，观察到 result 的最高 shift 位与 value 的最高 shift 位是一样的。因此，在 result 的基础上，我们可以将其与一个二进制遮罩取与，得到 value 的最高 shift 位。这个遮罩应该是：1111 1111 &lt;&lt; (8 - 3) = 1110 0000。于是我们得到 1100 0000。 其次，注意到对于异或运算有如下事实：a ^ b ^ b = a。依靠二进制遮罩，我们已经获得了 value 的最高 shift 位。因此，我们也就能得到 shifted 的最高 2 * shift 位。它应该是 1100 0000 &gt;&gt; 3 = 0001 1000。将其与 result 取异或，则能得到 value 的最高 2 * shift 位。于是我们得到 1101 0000。 如此往复，即可复原 value。据此有代码 123456789def inverse_right_shift_xor(value, shift): i, result = 0, 0 while i * shift &lt; 32: part_mask = ((0xffffffff &lt;&lt; (32 - shift)) &amp; 0xffffffff) &gt;&gt; (i * shift) part = value &amp; part_mask value ^= part &gt;&gt; shift result |= part i += 1 return result 对左移后取异或，也有类似分析。于是，得到对 __temper 的完整求逆代码。 1234567891011121314151617181920212223242526272829303132333435class TemperInverser: __b = 0x9d2c5680 __c = 0xefc60000 __kMaxBits = 0xffffffff def __inverse_right_shift_xor(self, value, shift): i, result = 0, 0 while i * shift &lt; 32: part_mask = ((self.__kMaxBits &lt;&lt; (32 - shift)) &amp; self.__kMaxBits) &gt;&gt; (i * shift) part = value &amp; part_mask value ^= part &gt;&gt; shift result |= part i += 1 return result def __inverse_left_shift_xor(self, value, shift, mask): i, result = 0, 0 while i * shift &lt; 32: part_mask = (self.__kMaxBits &gt;&gt; (32 - shift)) &lt;&lt; (i * shift) part = value &amp; part_mask value ^= (part &lt;&lt; shift) &amp; mask result |= part i += 1 return result def __inverse_temper(self, tempered): value = tempered value = self.__inverse_right_shift_xor(value, 18) value = self.__inverse_left_shift_xor(value, 15, self.__c) value = self.__inverse_left_shift_xor(value, 7, self.__b) value = self.__inverse_right_shift_xor(value, 11) return value def __call__(self, tempered): return self.__inverse_temper(tempered) 爆破逆向 __temper() 之后，只要获得足够的状态，即可构建出梅森旋转内部的寄存器状态。因此有如下验证代码。 12345678910111213141516171819class MersenneTwisterCracker: __n = 624 def __init__(self, mt_obj): inverser = TemperInverser() register = [inverser(mt_obj()) for i in range(self.__n)] self.__mt = MersenneTwister(0) self.__mt.load_register(register) def __call__(self): return self.__mt()if __name__ == "__main__": mt = MersenneTwister(0) for i in range(100): mt() mtc = MersenneTwisterCracker(mt) for i in range(100): assert(mt() == mtc()) 运行后，Python 没有抛出异常，顺利推出。这说明 mtc 已能够成功预测 mt 之后的任意顺序输出。 总结梅森旋转算法，是一个优秀的伪随机数发生算法。在伪随机数的评价体系中，它是一个相当优秀的算法：周期长、均匀性好、速度快（基本都是位运算）。在条件允可的情形下，若有使用随机数的需求，应首先考虑梅森旋转算法。 同时也应该注意到，梅森旋转算法不是为了密码学随机而设计的——在获得足够连续输出的情况下，梅森旋转算法接下来的输出值是可以准确预测的。梅森旋转算法容易被爆破的根源在于，其提取输出函数是可逆的，因此暴露了其内部状态。若要产生密码学上的随机数，可考虑在梅森旋转算法之后，拼接一值得信赖的单向杂凑函数（如 sha256）。否则，若直接用梅森旋转算法的输出值作密码学用途，则有信息泄露的风险，应引起注意。 错误应用梅森旋转算法，导致高危漏洞的一个典型是 Discuz! 的密码重置漏洞。 扩展阅读：梅森旋转算法的原始论文]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Random</tag>
        <tag>PRNG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTeX 中的浮动体：摆放多个子元素]]></title>
    <url>%2F2018%2F01%2F11%2Ffloats-in-LaTeX-multiple-elements-in-a-single-float%2F</url>
    <content type="text"><![CDATA[这是这一系列文章，也是计划中的最后一篇。此篇介绍复杂一些的话题：如何在浮动体中摆放多个元素，以及如何处理它们的题注（caption）。 思想一旦被禁锢，心灵就会孱弱。 浮动体是会移动的文本框 解放思想，然后解放生产力。 浮动体这个概念，对于大多数 LaTeX 用户来说，应该都有隔着一层纱的感觉。考虑到大多数 LaTeX 用户是从 M$ Word 开始接触电子文档，也没有机会接触专业排版的机会，这种现象并不奇怪：因为大多数用户没有养成关于排版规则和成因的思考习惯。 在系列文章第一篇中，我们介绍了「为什么需要浮动体」。简单来说，诸如图片表格这种占据篇幅较大的内容，强行插入在「当前位置」是不合适的，通常会造成大片的空白，因此需要浮动。为此，LaTeX 的浮动机制允许用户将图表置于浮动体中，按照一定算法在文中浮动。 对于有过 M$ Word 使用经验的用户来说，理解 LaTeX 中的浮动体，最简便的方式是将其理解为「一个支持 \caption 会按照算法浮动位置的文本框」。在 M$ Word 当中，文本框中可以放置任意内容；在 LaTeX 浮动体中也是一样。在 M$ Word 当中，文本框可以没有 \caption，在 LaTeX 浮动体中也是一样。 123456789\documentclass&#123;article&#125;\usepackage&#123;mwe&#125; % for dummy text\begin&#123;document&#125;Foo\begin&#123;figure&#125;[htb] % a float environment without \caption containing text\blindtext\end&#123;figure&#125;bar\end&#123;document&#125; 可以看到，LaTeX 中的浮动体中，字体、分词、折行等行为，与正文中一般无二；只不过，由于 figure 环境整体浮动，让 Foo 和 bar 排在了同一行，而 \blindtext 的输出则浮动到了 Foo bar 的下方。 多个元素上例中，我们在浮动体（figure 环境）中插入了一段文本（由 \blindtext 生成），以此来演示浮动体内的排版逻辑。事实上，由于 TeX 的排版过程实际是一个盒子套盒子的搭积木的过程（TeX 在排版时不关心具体内容，只关心描述每个元素尺寸的 bounding box），上例中我们已经可以认为是在浮动体中插入了多个元素了。接下来的任务，只需要将图片或者表格想像为「特别大的字符」，套用排版的基本逻辑，就能在浮动体内排版多个图表元素了。 12345678910\documentclass&#123;article&#125;\usepackage&#123;mwe&#125; % for dummy text\usepackage[showframe]&#123;geometry&#125; % for showing frames of pages\begin&#123;document&#125;Foo\begin&#123;figure&#125;[htb]\rule&#123;4cm&#125;&#123;3cm&#125;\quad\rule&#123;4cm&#125;&#123;3cm&#125;\quad\rule&#123;4cm&#125;&#123;3cm&#125;\quad\rule&#123;4cm&#125;&#123;3cm&#125;\end&#123;figure&#125;bar\end&#123;document&#125; 在 geometry 宏包的辅助下，可以看到，浮动体中摆放了 4 个黑色的标尺（\rule{&lt;width&gt;}{&lt;height&gt;}）。这 4 个标尺是对图表的模拟——若是将 \rule 命令换成 \includegraphics，则得到 4 张图片；若是将 \rule 命令换成 tabular 等环境，则得到 4 个表格。前文说，TeX 排版时不关心内容，只关心尺寸，因此可以把图表都想像为特别大的字符，而后套用正常的排版逻辑即可。此处，在浮动体内，同一行有 4 个「字符」；由于宽度不够摆放 4 个字符，所以 TeX 在第三个字符之后折行，在下一行排版第四个字符。因此得到这样的排版结果。 题注是有一定格式的编号文本 因为不了解，所以不敢轻易尝试。 对于浮动体的处理，另外一个重要的部分是对题注的处理。基于同样的原因，很多 LaTeX 初学者对题注知之甚少。特别地，由于使用「交叉引用」的意识淡薄，大多数 M$ Word 基础用户完全不知道有「题注」这个东西。于是，当他们转而使用 LaTeX 的时候，一方面感叹于 \caption 的易用性，另一方面恐怕会对之心存敬畏。 在 LaTeX 输出的一个典型题注的代码如下： 123456789101112\documentclass&#123;article&#125;\usepackage&#123;mwe&#125; % for dummy text\usepackage[showframe]&#123;geometry&#125; % for showing frames of pages\begin&#123;document&#125;Foo\begin&#123;figure&#125;[htb]\rule&#123;4cm&#125;&#123;3cm&#125;\quad\rule&#123;4cm&#125;&#123;3cm&#125;\quad\rule&#123;4cm&#125;&#123;3cm&#125;\quad\rule&#123;4cm&#125;&#123;3cm&#125;\caption&#123;Foo bar.&#125;\end&#123;figure&#125;bar\end&#123;document&#125; 其中，Figure 1 是题注的「标签（label）」，其中由包含题注类型和编号；Foo bar. 是题注的「文本（text）」；标签和文本之间则是「分隔符（label sep）」，此处是 :。 不难发现，题注的默认格式大致是： 居中：\centering； 罗马字族：\rmfamily； 直立字形：\upshape; 标准字体大小：\normalsize； 标准字重：\mdseries。 若想修改题注的格式，可以用 caption 宏包（而不是 caption2）。 在此基础上，我们可以尝试做各种奇怪的事情。 插入一个手工题注由于浮动体其实只是一个文本框，所以我们可以向其中添加任何内容。对于题注来说，作为实验用途，我们完全可以按照格式，手工创建一个题注。 12345678910111213\documentclass&#123;article&#125;\usepackage&#123;mwe&#125; % for dummy text\usepackage[showframe]&#123;geometry&#125; % for showing frames of pages\begin&#123;document&#125;Foo\begin&#123;figure&#125;[htb]\rule&#123;4cm&#125;&#123;3cm&#125;\quad\rule&#123;4cm&#125;&#123;3cm&#125;\quad\rule&#123;4cm&#125;&#123;3cm&#125;\quad\rule&#123;4cm&#125;&#123;3cm&#125;\centering&#123;\rmfamily\upshape\normalsize\mdseries Figure 1: Foo bar.&#125;\end&#123;figure&#125;bar\end&#123;document&#125; 从效果上说，除了没有自动编号，与 \caption 生成的题注一般无二。 使用多个 \caption同样，由于 \caption 只是一个格式化输出的宏，LaTeX 也不会禁止我们在同一个浮动体中多次使用 \caption。 12345678910111213\documentclass&#123;article&#125;\usepackage&#123;mwe&#125; % for dummy text\usepackage[showframe]&#123;geometry&#125; % for showing frames of pages\begin&#123;document&#125;Foo\begin&#123;figure&#125;[htb]\rule&#123;4cm&#125;&#123;3cm&#125;\quad\rule&#123;4cm&#125;&#123;3cm&#125;\quad\rule&#123;4cm&#125;&#123;3cm&#125;\quad\rule&#123;4cm&#125;&#123;3cm&#125;\caption&#123;Foo.&#125;\caption&#123;Bar.&#125;\end&#123;figure&#125;bar\end&#123;document&#125; 可以看到，两个题注格式相同，分别编号，先后排版在居中位置。 关于图表题注位置的区别 本段插入一些扩展内容。 一般来说，在学术论文中，表格的题注置于表格之前，而图片的题注置于图片之后。其原因大致可说明如下： It has to do with the way people absorb printed information or, more accurately, how readers of Western texts are acculturated into this. Tables are textual devices and are, to some or other approximate degree, structured to be read in the same left-&gt;right, top-&gt;bottom order (*). To this degree, they therefore do not differ in important information processing ways from the body text. Normal text (not, e.g., poetry or other intentionally disruptive forms) is ordinarily structured in a “pyramidal” form: general and introductory concepts are best placed at the beginning, with increasingly fleshed-out details placed later on. The reading eye that saccades across text and the brain that controls it has learnt beginning at the age of two or whatever to most efficiently gather (Western) textual information in this way. By our age, we cannotnot process text this way. Graphics, on the other hand, are iconic. The eye does not scan pictures for information in remotely the same way (in fact entirely different cerebral systems are in charge of gathering and interpreting textual and graphical information - you can knock out one part of the brain and impair one system without noticeably affecting the performance of the other; see, e.g., almost any popular writing by Oliver Sachs). It would be almost impossible to prevent the normal human brain from scanning and interpreting, no matter how briefly, a picture on the page before forcing it to reading the caption (no matter where the caption is placed because by that time the attentional mechanisms in the part of the brain that is now switched on is directing the eye to saccade in non-linear sequences). So, to answer your question, good typesetting sets out to provide readers the most productive (rate of information processing for expended effort) reading experience that it can. For text: the caption summary is placed above the details to fit in with linear eye saccades and the pyramid principle of text interpretation; for graphics: the graphic is placed first to fit in with quite different attentional control mechanisms, non-linear eye saccading and non-linear information processing. (*) Factor in acculturation. Good typesetting for R-&gt;L or bottom-&gt;top reading orders will follow these general principles (for biologically human species (**)) , leading however to different outcomes. (**) The point is that it’s our brain biology that has ultimately led to the development of these rules. Here’s something to think about: what are the optimal typesetting rules for non-human species, e.g., maybe sapient machines, or echo-locating information gatherers like bats or porpoises. Where would they like to “see” their captions? :)) graphics - Why should a table caption be placed above the table? 简单来说，这样的设计是为了方便人们更舒服地阅读文章。 人类阅读表格和图片的方式是不一样的。表格也算是一种文字信息，人们阅读它和平时阅读整块文本的习惯相符合，大致是：从上到下、从左到右。因此，表格标题这种总结提示性的信息，应该放在表格开始之前。图片与表格不同，人类大脑处理图片的方式与表格大相径庭，甚至阅读图片时激活的大脑区域也与处理表格时不同。对于人类来说，在正常的阅读过程中，强迫先阅读图片标题而后阅读图片，要不然做不到，要不然做到了也很难受。因此，不如就把图片放前面，让大脑处理完之后再去阅读图片标题。 当然，这本质上是一个约定行为。如果杂志社要求你按照固定的方式去摆放图标及其标题，你却非要按照你的习惯去做——这属于自己找事。不过，基于上述考虑，图片先于标题而表格后于标题，几乎已经是约定俗成的了。 多个元素与题注文章行文至此，大多数用户应该已经能构建出一些在浮动体中排版多个元素的代码，并为他们附上题注了。不考虑子题注，在浮动体中插入两个元素，按照元素排布形状和题注规律，大致有以下一些组合。 并排摆放，无题注 并排摆放，共享题注 并排摆放，各自题注 纵向摆放，无题注 纵向摆放，共享题注 纵向摆放，各有题注（无用，因为可以分割成两个浮动体） 由于元素排布形状和题注是相互独立控制的，因此，此处无须给出所有可能的结果，就足够读者举一反三了。 并排摆放，无题注所有并排摆放的要点，都只有一个：让同一行内所有元素的总宽度不大于允可的宽度。因此，很容易构建出如下代码。 123456789101112\documentclass&#123;article&#125;\usepackage&#123;graphicx&#125;\usepackage[showframe]&#123;geometry&#125; % for showing frames of pages\begin&#123;document&#125;Foo\begin&#123;figure&#125;[htb]\centering\includegraphics[width = .48\linewidth]&#123;example-image-a&#125;\hfill\includegraphics[width = .48\linewidth]&#123;example-image-b&#125;\end&#123;figure&#125;bar\end&#123;document&#125; 此处以 \includegraphics 的参数控制，两幅图片的宽度和为 0.96\linewidth，小于允可的宽度（\linewidth）。因此，两副图片能够并排摆放。 并排摆放，共享题注相比上一节的代码，只需加上题注即可。 12345678910111213\documentclass&#123;article&#125;\usepackage&#123;graphicx&#125;\usepackage[showframe]&#123;geometry&#125; % for showing frames of pages\begin&#123;document&#125;Foo\begin&#123;figure&#125;[htb]\centering\includegraphics[width = .48\linewidth]&#123;example-image-a&#125;\hfill\includegraphics[width = .48\linewidth]&#123;example-image-b&#125;\caption&#123;Dummy Caption.&#125;\end&#123;figure&#125;bar\end&#123;document&#125; 并排摆放，各自题注由于题注是针对当前环境居中的；因此，若我们希望为并排摆放的两个图片分别添加题注，就需要让并排摆放的两个图片分别处于单独的盒子当中。 1234567891011121314151617181920\documentclass&#123;article&#125;\usepackage&#123;graphicx&#125;\usepackage[showframe]&#123;geometry&#125; % for showing frames of pages\begin&#123;document&#125;Foo\begin&#123;figure&#125;[htb]\centering\begin&#123;minipage&#125;&#123;0.48\linewidth&#125;\centering\includegraphics[width = \linewidth]&#123;example-image-a&#125;\caption&#123;Dummy Caption A.&#125;\end&#123;minipage&#125;\hfill\begin&#123;minipage&#125;&#123;0.48\linewidth&#125;\centering\includegraphics[width = \linewidth]&#123;example-image-b&#125;\caption&#123;Dummy Caption B.&#125;\end&#123;minipage&#125;\end&#123;figure&#125;bar\end&#123;document&#125; 代码中，我们用 minipage 环境将两个图片和他们分别的题注放在一起。这样，两张图片并排摆放，分别有题注。注意，由于图片放在小页环境中，所以 \includegraphics 环境的宽度参数应改为 \linewidth，表示小页环境当中的行宽。 纵向摆放，无题注横向摆放的要点在于同一行的元素总宽度不大于允可的宽度，这是了解到浮动体文本框内排版逻辑之后的直接推论。有此了解之后，控制两个元素纵向摆放也就很简单了：只需要让两个元素的总宽度大于允可的宽度，或是手工换行即可。 123456789101112\documentclass&#123;article&#125;\usepackage&#123;graphicx&#125;\usepackage[showframe]&#123;geometry&#125; % for showing frames of pages\begin&#123;document&#125;Foo\begin&#123;figure&#125;[htb]\centering\includegraphics[width = .6\linewidth]&#123;example-image-a&#125;\\[2ex]\includegraphics[width = .6\linewidth]&#123;example-image-b&#125;\end&#123;figure&#125;bar\end&#123;document&#125; 多个元素与子题注有时，我们会希望给每个元素分别加上题注，但同时又共享一个题注。这时候，每个元素的题注就应该是共享的题注的子题注。 为了使用子题注，应该使用 subfig 宏包（提供了 \subfloat 命令）或者 subcaption 宏包（适合与 caption 宏包联用，提供了 \subcaption 等命令）。 使用 subfig 宏包subfig 宏包的核心即是 \subfloat 命令；\subfloat 命令为其中的内容（图片或表格）创建了一个盒子，并支持设置子题注。具体用法如下。 1234567891011121314\documentclass&#123;article&#125;\usepackage&#123;graphicx&#125;\usepackage&#123;subfig&#125;\usepackage[showframe]&#123;geometry&#125; % for showing frames of pages\begin&#123;document&#125;Foo\begin&#123;figure&#125;[htb]\centering\subfloat[Subcaption A]&#123;\includegraphics[width = .48\linewidth]&#123;example-image-a&#125;&#125;\hfill\subfloat[Subcaption B]&#123;\includegraphics[width = .48\linewidth]&#123;example-image-b&#125;&#125;\caption&#123;Two figures.&#125;\end&#123;figure&#125;bar\end&#123;document&#125; 使用 subcaption 宏包subcaption 宏包适合与 caption 宏包联用。因此，若文档中已经使用了 caption 调整题注的样式，首先应考虑 subcaption 宏包来实现子题注。 subcaption 提供的 \subcaption 命令是实现子题注最简便的方式：只需要在上述「并排摆放，各有标题」的基础上，将 \caption 命令替换成 \subcaption 命令即可。 1234567891011121314151617181920212223\documentclass&#123;article&#125;\usepackage&#123;graphicx&#125;\usepackage&#123;caption&#125;\usepackage&#123;subcaption&#125;\usepackage[showframe]&#123;geometry&#125; % for showing frames of pages\begin&#123;document&#125;Foo\begin&#123;figure&#125;[htb]\centering\begin&#123;minipage&#125;&#123;0.48\linewidth&#125;\centering\includegraphics[width = \linewidth]&#123;example-image-a&#125;\subcaption&#123;Dummy Subcaption A.&#125;\end&#123;minipage&#125;\hfill\begin&#123;minipage&#125;&#123;0.48\linewidth&#125;\centering\includegraphics[width = \linewidth]&#123;example-image-b&#125;\subcaption&#123;Dummy Subcaption B.&#125;\end&#123;minipage&#125;\caption&#123;Dummy Caption.&#125;\end&#123;figure&#125;bar\end&#123;document&#125; 虽然 \subcaption 用起来方便，但是由于外面要套一层小页环境，所有代码加在一起就很繁琐了。为此，可以使用 subcaption 宏包提供的另一个命令：\subcaptionbox。\subcaptionbox 的用法类似 \subfloat。 123456789101112131415\documentclass&#123;article&#125;\usepackage&#123;graphicx&#125;\usepackage&#123;caption&#125;\usepackage&#123;subcaption&#125;\usepackage[showframe]&#123;geometry&#125; % for showing frames of pages\begin&#123;document&#125;Foo\begin&#123;figure&#125;[htb]\centering\subcaptionbox&#123;Dummy Subcaption A.&#125;&#123;\includegraphics[width = .48\linewidth]&#123;example-image-a&#125;&#125;\hfill\subcaptionbox&#123;Dummy Subcaption B.&#125;&#123;\includegraphics[width = .48\linewidth]&#123;example-image-b&#125;&#125;\caption&#123;Dummy Caption.&#125;\end&#123;figure&#125;bar\end&#123;document&#125; 扩展阅读至此，此篇文章需要介绍的内容就此完结，本系列也即将宣告结束。以下是一些扩展阅读。 caption 宏包：提供了一系列控制题注格式的接口； subcaption 宏包：提供了控制子题注的接口，适合与 caption 宏包联用； subfig 宏包：提供了控制子题注的接口； floatrow 宏包：提供了更多的控制浮动体格式的接口。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Caption</tag>
        <tag>Floats</tag>
        <tag>Subcaption</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈 C/C++ 中的 offsetof]]></title>
    <url>%2F2018%2F01%2F10%2Fa-customized-offsetof-in-Cpp%2F</url>
    <content type="text"><![CDATA[此篇讲一讲 C/C++ 中的 offsetof。 介绍offsetof 是源自 C 语言的宏，它接受两个参数（类型名和成员名），返回一个 std::size_t 类型的常量表达式。offsetof 的返回值是成员在该类型对象中以字节计算的的偏移量。其中，传入计算的类型名，必须满足标准内存布局的要求；即 所有非 static 数据成员的访问控制权限相同； 没有虚函数； 不从虚基类继承； 所有非 static 数据成员都不是引用类型； 所有非 static 数据成员类型和基类都满足上述要求。 若传入计算的类型名不满足内存布局的要求，或者求解的成员是 static 成员或成员函数，则调用该宏是未定义行为（Undefined Behaviour）。 实现按照定义，有 offsetof(s, m) 的值只与类型和成员有关，也就是说，在计算 offsetof(s, m) 的时候，不应传入 s 类型具体某个对象，也不应为计算该值而临时构造一个对象； offsetof(s, m) 的值，其单位是字节； offsetof(s, m) 的值应是 std::size_t 类型。 offsetof 的这三个特性，也是实现 offsetof 宏的三个难点。为了解决这些问题，首先，实现应当让编译器相信在某处存在一个「虚拟的」但是「可用的」对象。而后，根据该虚拟对象，可以取得目标成员 m 的地址。随后，利用 m 的地址与该虚拟对象的起始地址做差，即可得知 m 的偏移量；为了求得以字节为单位的 ptrdiff_t，需将 m 的地址转变为 char 类型的指针。最后，只需将 ptrdiff_t 转换为 std::size_t 即可。 因此，有如下 C++ 实现： 1#define offsetof(s, m) (reinterpret_cast&lt;size_t&gt;(&amp;reinterpret_cast&lt;const volatile char&amp;&gt;(static_cast&lt;s*&gt;(nullptr)-&gt;m))) 此处，通过 static_cast&lt;s*&gt;(nullptr)，编译器相信在 nullptr 处（0x0）有一个真实存在的 s 类型的对象。此处使用 static_cast 而非 reinterpret_cast 是因为 C++ 标准不允许将 nullptr 通过 reinterpret_cast 转换成其他类型的指针；此类转换应用 static_cast。由于 static_cast&lt;s*&gt;(nullptr) 返回指向 s 类型对象的指针，因此 static_cast&lt;s*&gt;(nullptr)-&gt;m 就是一个虚拟但在编译器看来可用的成员变量 m。为了求得以字节为单位的 ptrdiff_t，实现中通过 &amp;reinterpret_cast&lt;const volatile char&amp;&gt;(static_cast&lt;s*&gt;(nullptr)-&gt;m) 获得一个 const volatile char* 类型的变量。由于在该实现中，虚拟的变量位于 0x0 位置，故而 &amp;reinterpret_cast&lt;const volatile char&amp;&gt;(static_cast&lt;s*&gt;(nullptr)-&gt;m) 即是 m 在 s 类型对象当中相对对象起始地址的偏移量。最后，只需将它转换为 size_t 类型的值即可：reinterpret_cast&lt;size_t&gt;(&amp;reinterpret_cast&lt;const volatile char&amp;&gt;(static_cast&lt;s*&gt;(nullptr)-&gt;m))。 同样，可以有 C 风格的实现： 1#define offsetof(s, m) (size_t)((char*)(&amp;((s*)0)-&gt;m)) 测试1234567891011121314#include &lt;stdio.h&gt;#define offsetof(s, m) (reinterpret_cast&lt;size_t&gt;(&amp;reinterpret_cast&lt;const volatile char&amp;&gt;(static_cast&lt;s*&gt;(nullptr)-&gt;m)))struct S &#123; char c; double d; char cc;&#125;;int main(void) &#123; printf("the first element is at offset %zu\n", offsetof(struct S, c)); printf("the double is at offset %zu\n", offsetof(struct S, d)); printf("the third element is at offset %zu\n", offsetof(struct S, cc));&#125; 上述测试代码的结果是： 1234$ ./a.outthe first element is at offset 0the double is at offset 8the third element is at offset 16]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Macro</tag>
        <tag>C++</tag>
        <tag>C</tag>
        <tag>offsetof</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈 C++ 中流的缓冲区]]></title>
    <url>%2F2017%2F12%2F31%2Fbuffer-of-stream-in-Cpp%2F</url>
    <content type="text"><![CDATA[众所周知，C++ 语言本身并不提供 I/O 功能。C++ 的 I/O 是通过标准库中输入输出流来实现的。标准库在 iostream 头文件当中，预定义了六个流对象，他们是： istream &lt;- std::cin/std::wcin，对应标准输入的输入流； ostream &lt;- std::cout/std::wcout，对应标准输出的输出流； ostream &lt;- std::cerr/std::wcerr，对应标准错误的输出流。 稍有经验的 C++ 程序员都应对这些流熟悉（至少对非宽字符版本的三个流对象熟悉），因此此篇不介绍它们的基本用法，而是讨论流的缓冲区。 为什么要有缓冲区？首先需要思考的问题是：为什么要有缓冲区，而不是与相关的文件/设备进行直接的读写操作。提出这个问题是很显然的。这是因为任何决定都是一种在代价和收益中的权衡。考虑到加上缓冲区是有代价的（代码变得更加复杂、需要控制的内容增多），所以加上缓冲区必然有随之而来的收益。 众所周知，相对于 CPU 的指令执行和主存访问，I/O 操作是非常慢的。这也就是说，在不考虑缓冲区的情况下，如果程序有频繁的 I/O 操作，那么相当于程序的「高速」部分就会被频繁打断。这对于程序的整体性能是不利的。有了缓冲区，程序就可以避免频繁的 I/O 操作，而是对缓冲区进行读写，只有在必须的情况下，才通过刷新缓冲区进行真实的 I/O 操作。这样一来，程序就能将多个缓慢的 I/O 操作合并成一个，从而在整体上提高了程序的性能。 因此，问题的答案是：使用缓冲区有助于提高程序的整体性能。 缓冲区要做哪些工作？确定了必须要使用缓冲区，接下来的问题就是，这种缓冲区应该有哪些功能。 从上一节的描述中，不难发现缓冲区向上连接了程序的输入输出请求，向下连接了真实的 I/O 操作。作为中间层，必然需要分别处理好与上下两层之间的接口，以及要处理好上下两层之间的协作。（后者即是中间层本身的功能） 在 C++ 中，流的缓冲区之基类是定义在 streambuf 头文件当中的 std::basic_streambuf。这是一个类模板；其声明如下： 1234template&lt; class CharT, class Traits = std::char_traits&lt;CharT&gt;&gt; class basic_streambuf; std::basic_streambuf 包含两个字符序列，并提供对这两个序列控制和访问的能力： 受控字符序列（controlled character sequence）：又称缓冲序列（buffer sequence），由读取区（get area）和/或写入区（put area）组成。此二者分别用来缓冲上层流的读写操作。 关联字符序列（associated character sequence）：对于输入流来说又称源（source），对于输出流来说又称槽（sink）。关联字符序列通常是通过系统 API 与 I/O 设备关联，或是与 std::vector/array/字符串字面值等能作为源或槽的对象关联。 对于关联字符序列来说，需要 std::basic_streambuf 自己实现的功能不多。因为，大多数情况可通过系统 API 或是相关对象的接口来实现。std::basic_streambuf 大多数的功能集中在对受控字符序列的管理上。 读取区或写入区，通常实现为相应 CharT 的 C 风格数组，并辅以 3 个指针，以实现对受控字符序列的控制： 起始指针（beginning pointer）：用于标识相应缓冲序列可用范围的起始位置； 终止指针（end pointer）：用于标识相应缓冲序列可用范围的尾后位置； 工作指针（next pointer）：指向相应缓冲序列中，下一个等待读/写的元素的位置。 若是一个受控字符序列单单是读取区或写入区，则它必然有这三个指针；若一个受控字符序列同时是读取区和写入区，那么则有两套共六个这样的指针。通过这些指针，std::basic_streambuf 就能实现对换受控字符序列的控制。 流中的缓冲区在头文件 ios 当中，定义着两个类（模板）：std::ios_base 和 std::basic_ios。前者是所有 I/O 类的祖先，提供了状态信息、控制信息、内部存储、回调等设施。后者继承自前者，额外提供了与 std::basic_streambuf 的接口；同时允许多个 std::basic_ios 对象绑定同一个 std::basic_streambuf 对象。它们的声明分别是： 12345class ios_base;template&lt; class CharT, class Traits = std::char_traits&lt;CharT&gt;&gt; class basic_ios; // : public ios_base 由于 std::ios_base 没有提供与 std::basic_streambuf 的接口，std::basic_ios 才是标准库内所有 I/O 类（模板）事实上的最近共同祖先。std::basic_ios 的成员函数 rdbuf 是读取和设置流对象（std::basic_ios 的对象）绑定缓冲区的成员函数，它有两个不同的重载形式，分别如下： 1234std::basic_streambuf&lt;CharT, Traits&gt;*rdbuf() const; // 1.std::basic_streambuf&lt;CharT, Traits&gt;*rdbuf( std::basic_streambuf&lt;CharT, Traits&gt;* sb ); // 2. 两个重载版本，第一版不接受任何参数，第二版接受一个指向 std::basic_streambuf&lt;CharT, Traits&gt; 类型对象的指针。 不接受参数的版本返回流对象绑定的缓冲区对象的指针；而若流对象未绑定任何缓冲区对象，则返回空指针 nullptr。接受指针的版本首先返回上述指针，而后与先前绑定的缓冲区对象（如果有）解绑，再绑定参数中传入指针指向的缓冲区对象；而若传入空指针 nullptr，则流对象不与任何缓冲区对象绑定。 巧妙设置流中的缓冲区通过巧妙设置流中的缓冲区，可以达成各种特殊的效果。这里给出几个演示。 输出流共享缓冲区从机制上说，std::basic_ios 允许多个流对象绑定同一个缓冲区对象。当然，虽然机制上允许，一般来说这样做却不是好主意。不过，在某些情况下，让多个流对象绑定同一个缓冲区对象，也是有好处的。 在具体介绍具体操作之前，还有一事必须说明。如前所述，缓冲区对象是在流和 I/O 设备之间加入的抽象中间层。因此，实际上对于流的所有操作，都会反馈在缓冲区对象之上，而非直接作用域 I/O。这也就是说，一旦流对象绑定的缓冲区对象发生变化，最终的 I/O 效果也会随之发生变化。 众所周知，头文件 iomanip 当中定义了许多与 std::ios_base 相关的格式控制函数与对象。通过这些函数与对象，程序员可以控制从 I/O 流的行为。但若上述行为需要频繁在若干状态之间发生切换，则代码会显得相当繁琐。此时，让多个流对象绑定同一个缓冲区对象就是有好处的了。程序员可以让多个流对象绑定同一个缓冲区对象，而后为每个流对象设置不同的 I/O 行为，即可在需要的时候使用对应的流对象。由于这些流对象绑定了同一个缓冲区对象，这些 I/O 操作最终会合在一起。如此，就达成了目的。 以下是让输出流共享缓冲区的示例。 ostream_shares_buf.cc1234567891011121314151617#include &lt;iostream&gt;#include &lt;iomanip&gt;int main() &#123; std::ostream fixed&#123;std::cout.rdbuf()&#125;; // 1. std::ostream sci&#123;std::cout.rdbuf()&#125;; fixed.setf(std::ios_base::fixed, std::ios_base::floatfield); // 2. fixed.precision(5); sci.setf(std::ios_base::scientific, std::ios_base::floatfield); sci.precision(3); fixed &lt;&lt; 15.518 &lt;&lt; '\n'; // 3. sci &lt;&lt; 15.518 &lt;&lt; '\n'; return 0;&#125; 此处，(1) 将新建的两个流对象 fixed 和 sci 都与 std::cout 的缓冲区对象绑定，而后在 (2) 处分别设置两个流对象的输出格式，最后在 (3) 处用两个不同的流对象输出同一浮点数。编译后得到的结果如下。 1234$ g++ -std=c++11 ostream_shares_buf.cc$ ./a.out15.518001.552e+01 替换输入流的缓冲区标准库的 std::cin 默认与关联标准输入的缓冲区对象绑定。因此，使用 std::cin 可以从标准输入中读取输入。不过，在某些情况下，程序员也会希望改变这一点。例如，在 Online Judge 训练时，程序员可能会希望让 std::cin 从本地的测试文件中读取测试用例。考虑到 C++ 中的流对象实际上是对缓冲区进行操作；此时，替换 std::cin 的缓冲区，即可达成目的。 以下是替换标准输入流的示例。 istream_replace_buf.cc1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;string&gt;#ifdef DEBUG_ // 1.#include &lt;fstream&gt;namespace &#123; // 2.const constexpr char* kTestFileName = "oj.test.txt";std::ifstream fin&#123;kTestFileName&#125;; // 3.auto cin_buf = std::cin.rdbuf(fin.rdbuf()); // 4.&#125; // namespace#endif // DEBUG_int main() &#123;#ifdef DEBUG_ std::cin.tie(nullptr); // 5.#endif // DEBUG_ std::string temp; std::getline(std::cin, temp); std::cout &lt;&lt; temp &lt;&lt; '\n'; return 0;&#125; 此处，(1) 在 DEBUG_ 宏有定义的情况下，进行 (2)(3)(4)(5) 的步骤。其中 (2) 启用了一个匿名空间，起到 C 语言中文件 static 的作用（C++ 也支持这样的用法，但是已经不推荐）；(3) 声明了一个与测试文件关联的文件输入流；(4) 将 std::cin 与上述文件输入流的缓冲区绑定，同时将 std::cin 原本的缓冲区指针保存在 cin_buf 当中。由于在 DEBUG_ 宏有定义的情况下，std::cin 与标准输入解绑，因此无需与标准输入绑定，故而 (5）处取消这种绑定。编译后得到的结果如下。 12345$ cat oj.test.txtThis is a file for testing.$ g++ -std=c++11 -DDEBUG_ istream_replace_buf.cc$ ./a.outThis is a file for testing. 可见，无需在标准输入手工输入测试样例，程序在 DEBUG_ 有定义时，直接从测试样例文件中读取测试。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Stream</tag>
        <tag>Buffer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写博客的动机]]></title>
    <url>%2F2017%2F12%2F27%2Fmotivation-to-blogs%2F</url>
    <content type="text"><![CDATA[作为一个偏科严重的理工男，高中时期，我可以在数学和理综考试中拿到满分或者接近满分的成绩，但我也可以在语文和英语两门科目当中考出刚及格甚至不及格的成绩。因此，迷上写博客文章，以及出版一本 GRE 的练习册对我而言也算是很神奇的事情了。 刚开始写类似博客的文章，是本科快毕业的时候。那时候人人网还没有变成现在这副死样子；于是，作为一个技术弱鸡，我没能耐自己搭建博客，就选择在校内日志上撰写偏技术的文章。坦率地说，虽然写博文的原因可以有很多，但归根到底回忆最早初始的动机其实只有两个： 作为一个记忆力极差的人，将自己好不容易理解记住的东西写下来，给自己备查； 作为一个害怕被遗忘的人，将自己觉得有些意思的东西写下来，刷新自己的存在感。 因此，直白点说，一是为了防蠢，二是为了装屄。 后来，写了一些文章之后，我发现写文章一方面改变了我，一方面这件事情本身也发生了些许改变。 如刚才所说，我是一个在中学阶段语文非常差的学生。特别地，在「作文」方面，我是历任老师眼里不折不扣的「问题少年」。于我自己而言，中学时写作文是非常痛苦的事情。一方面我写字速度很慢，每次练习都耗时耗力；另一方面我在写作文这件事情上实在「难产」——每次要求 800 字的作文，都要「憋」许久才行。然而，坚持写文章一段时间之后，「如泉涌」的状态取代了「难产」的状态，变成我写文章时更普遍的感受。这也就是说，写文章这件事情在一定程度上改变了我「不会写文章」的状态。 我虽然一直自诩是一个理智有逻辑的人，但我发现那都是「自己以为」。因为我发现，如果不能把自己所思所想用「他人」能够理解的方式，有逻辑地讲解出来，那么所谓的「有逻辑」都是幻觉。这就引出了写作对我的第二个改变。为了使自己写的文章能让「别人」明白，不论是行文还是平时说话时，我都会以超脱自己的立场，将事情的前因后果讲述清楚。这第二个改变，也让我时时苦恼。在很多问答场景下，我发现向我提问的人并没有这种将事情前因后果讲述清楚的能力；更多的时候，是类似「头疼砍头给医生、脚疼剁脚给大夫」的求问方式。因此，为了「如何讲清楚问题」这件事情，我又写了一些文章，但目前看来收效甚微。 写文章当然不止给我带来了这些变化。工作之后我发现，因为这样那样的原因，雇员会经常需要写文章。例如说平日周期性的周报、组内分享；又例如说时不时会需要的述职、评级、汇报。我不敢说我长期坚持写作在这方面给我带来了多少收益，但至少相比我能看到的同事，在这些方面我花费的时间、消耗的脑力是要少得多了。 在坚持的过程中，写文章改变了我，也改变了这件事情本身。 如前所述，最初开始写文章，一是为了防蠢，二是为了装屄。经历了这些改变之后，写文章于我已经慢慢变成了一种日常的习惯——不写就不舒服。特别地，我慢慢发现，因为「一定要把某件事情讲清楚」，所以我必须现在动笔之前把某件事情的前因后果以及潜在的坑理解透彻。因此，写文章实际上在「防蠢」和「装屄」之外，还多了「督促我进步」这样的功能。当我感受到写作这件事情本身有了这样的改变之后，当时的我给自己定下了这样的小目标：平均每周必须要写一篇原创文章。所幸，这个小目标已经变成了自然而然的习惯，并一直坚持至今。 所以，你愿意开始坚持写博客了吗？ 另有早些时候的文章一篇：为什么我乐于分享？。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Motivation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用位运算验证数独正确性]]></title>
    <url>%2F2017%2F12%2F17%2Fvalidating-sudoku-in-a-efficient-way%2F</url>
    <content type="text"><![CDATA[数独是一种益智解谜游戏。初始状态，在 $9\times 9$ 的盘面上，零星分布着一些 1 – 9 的整数。规则要求玩家在初始状态的基础上，填入 1 – 9 的数字，使得 $9\times 9$ 的盘面上，每个横行、纵列、$3\times 3$ 宫都有完整且不重复的 1 – 9 组合。 现在的问题是，给定一个数独答案，如何用代码验证这个答案的正确性。本文使用 C++ 来实现该目标。 分析根据规则，验证程序必然要验证 9 个横行、9 个纵列、9 个宫分别的正确性。在这个层面上，没有投机取巧的余地。因为，哪怕只省略了一个横行、纵列或是宫，都有可能造成误判——程序认为数独答案正确，但实际错误。反过来，只要程序发现有一个横行、纵列或是宫有异常，就可断定答案错误。 在行列宫的角度，数独验证的方法简单明了。但验证横行、纵列和宫中的数字组合的细节，却藏着魔鬼。 按照规则，正确的数独每一个行列宫，其中的数字组合都应当是完整且不重复的 1 – 9 的组合。这样，似乎只需验证行列宫中数字之和为 $45 = \sum_{i = 1}^{9} i$ 即可。我们称之为求和验证法。然而，这藏着一个魔鬼——求和验证法暗藏了一个假设，而这个假设不总是成立：每一个行列宫中的数字只能是 1 – 9 中的整数，并且若这一行列宫的数字组合有误，则只能是有一个数字重复一次。于是，至少有两种特殊情形能够轻易地推翻这一假设，从而推翻求和验证法。其一，数字组合 $[1, 2, 3, 4, 6, 6, 6, 8, 9]$ 中 $6$ 重复了 3 次，但整个组合的和为 45。其二，数字组合 $[0, 2, 3, 4, 5, 6, 7, 8, 10]$ 中，出现了 1 – 9 之外的数字，但整个组合的和为 45。考虑第二种情况是有意义的，因为，尽管规则要求仅使用 1 – 9 之间的整数，但是却无法保证数独答案中只有这些数字——不能对用户输入做任何假设，完全有可能出现规则之外的输入。 在讨论求和验证法时，本文指出了其暗含的假设。通过指出假设的不合理处，推翻了求和验证法。事实上，这一假设只是表象，还可以深入挖掘。 主张求和验证法的人，事实上受到了某种欺骗。数独及其要求人们以 1 – 9 的整数填充宫格的规则，看似是一个数字问题；但实际上，数独规则的核心不在「数」而在「独」。若把 1 – 9 换成任意其它 9 个符号，比如字母 A – I，不难发现也能套入数独的规则。因此，在数独中，数字仅仅是一个符号，代表不同的个体，没有运算上的价值。这也就是说，任何假定数独中数字可以运算的验证方法，都是不正确的。 考虑到数独中的数字仅仅是符号，代表不同的个体，验证程序只能从集合相等的角度进行验证。也就是说，在 C++ 中，程序要将每一个行列宫中的数字纳入一个集合，与正确的集合进行比对。若比对不符，则说明数独答案错误；否则，若所有行列宫均比对成功，则说明数独答案正确。 集合说到集合，C++ 的标准模板库提供了 std::set 和 std::unordered_set 两种容器模板。按前文介绍，std::set 以平衡二叉树实现，而 std::unordered_set 以哈希表实现。因此，一个可行的方案，是以 std::set 或 std::unordered_set 为容器，保存每一个行列宫中的数字组合，然后与正确的集合比对。考虑到此处数字的顺序不重要，使用 std::unordered_set 更为妥当。因此，正确的集合应是： 12stataic const constexprstd::unordered_set&lt;const uint8_t&gt; kCorrectSet&#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; 标准模板库提供了高效的容器，程序需要的集合这一数据结构已经有了着落。但标准模板库是为一般情形设计的，在绝大多数情况下，其中的设施都可堪使用，但并不一定是最优选择。在数独验证任务中，程序所需的集合总是非常小的——不超过 9 个元素（对于 9 宫格的数独来说）。在这样的数据规模下，频繁对集合进行建立、插入、比对、销毁的成本是很高的。 事实上，在数独验证这一有严格限定的问题下，集合这一数据结构的实现有更优的方案。当然，选用任何方案都会有一定的代价；而选用这一方案的代价即是：需要预先假定一种对应关系。 这一方案相关的假设如下： 首先，以一个整型变量代替标准模板库中的设施，作为集合容器。 其次，假定整型变量中的二进制位（bit）代表对应元素在集合中是否存在。例如若 1 在集合中，则该整型变量的倒数第 1 位（最低位）置 1，否则置 0。又例如若 4 在集合中，则该整型变量的倒数第 4 位置 1，否则置 0。 在这样的假设下，集合的操作有： 操作 方法 建立 int16_t flag = 0x0 插入（x） flag or_eq (1 &lt;&lt; (x - 1)) 比较 if (kFlag == flag) 显而易见，对单个整型变量的操作，比对标准模板库的容器的操作要快至少一个数量级。 这一方案受到了 Milo Yip 的知乎答案中提到的 Optimizing software in C++ 中关于布尔变量优化（7.5 节）的启发。 实现首先，本文给出测试文件。测试文件的第一行是一个整数，表示测试文件中有多少个数独答案。而后则是每个数独答案的具体内容。 sudoku.test.txt1234567891011121314151617181920212223242526272837 2 6 4 9 3 8 1 53 1 5 7 2 8 9 4 64 8 9 6 5 1 2 3 78 5 2 1 4 7 6 9 36 7 3 9 8 5 1 2 49 4 1 3 6 2 7 5 81 9 4 8 3 6 5 7 25 6 7 2 1 4 3 8 92 3 8 5 7 9 4 6 17 2 6 4 9 3 8 1 53 1 5 7 2 8 9 4 64 8 9 6 5 1 2 7 38 5 2 1 4 7 6 9 36 7 3 9 8 5 1 2 49 4 1 3 6 2 7 5 81 9 4 8 3 6 5 7 25 6 7 2 1 4 3 8 92 3 8 5 7 9 4 6 19 3 1 4 7 6 5 2 84 8 6 1 2 5 7 3 97 2 5 8 9 3 1 4 65 7 4 2 3 9 8 6 11 6 8 7 5 4 2 9 33 9 2 6 1 8 4 5 72 4 3 9 8 7 6 1 58 1 9 5 6 2 3 7 46 5 7 3 4 1 9 8 2 接下来，本文给出具体实现。实现中，通过替换 std::cin 的缓冲区，可在定义 DEBUG_ 宏的情况下从测试文件中读取内容。其他逻辑，可于上文参考。 validate_sudoku.cc123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstdint&gt;#ifdef DEBUG_#include &lt;fstream&gt;namespace std &#123;ifstream fin&#123;"./sudoku.test.txt"&#125;;streambuf* cin_buf = cin.rdbuf(fin.rdbuf());&#125; // namespace std#endifclass Sudoku &#123; private: const size_t size_ = 9; const size_t total_ = size_ * size_; const size_t block_size_ = static_cast&lt;const size_t&gt;(std::sqrt(size_)); const int64_t flag_ = 0x1FF; int* matrix_ = nullptr; public: Sudoku() : Sudoku(9) &#123;&#125; explicit Sudoku(size_t size) : size_&#123;size&#125;, total_&#123;size_ * size_&#125;, block_size_&#123;CalculateBlockSize(size_)&#125;, flag_&#123;CalculateFlag(size_)&#125;, matrix_&#123;ConstructMatrix(size_)&#125; &#123;&#125; ~Sudoku() &#123; DestroyMatrix(matrix_); &#125; private: Sudoku(const Sudoku&amp;) = delete; Sudoku(Sudoku&amp;&amp;) = delete; Sudoku&amp; operator=(const Sudoku&amp;) = delete; Sudoku&amp; operator=(Sudoku&amp;&amp;) = delete; private: const size_t CalculateBlockSize(const size_t range) &#123; const size_t res = static_cast&lt;const size_t&gt;(std::sqrt(range)); if (not(range == res * res)) &#123; std::terminate(); &#125; return res; &#125; const int64_t CalculateFlag(const size_t range) &#123; if (not(range &lt;= 64)) &#123; std::terminate(); &#125; int64_t res = 0; for (size_t i = 0; i != range; ++i) &#123; res |= 1 &lt;&lt; i; &#125; return res; &#125; int* ConstructMatrix(const size_t total) &#123; return new int[total]; &#125; void DestroyMatrix(int*&amp; matrix) noexcept &#123; if (nullptr != matrix) &#123; delete[] matrix; matrix = nullptr; &#125; return; &#125; public: bool ReadFromStream(std::istream&amp; is) &#123; int* const m = const_cast&lt;int* const&gt;(this-&gt;matrix_); if (is and m) &#123; for (size_t i = 0; i != total_; ++i) &#123; if (is) &#123; is &gt;&gt; m[i]; &#125; else &#123; return false; &#125; &#125; return true; &#125; else &#123; return false; &#125; &#125; bool Validate() const &#123; const int* const m = const_cast&lt;const int* const&gt;(this-&gt;matrix_); for (size_t i = 0; i != size_; ++i) &#123; // validate rows int64_t flag = 0x0; for (size_t j = 0; j != size_; ++j) &#123; flag |= (1 &lt;&lt; (m[i * size_ + j] - 1)); &#125; if (flag_ != flag) &#123; return false; &#125; &#125; for (size_t j = 0; j != size_; ++j) &#123; // validate columns int64_t flag = 0x0; for (size_t i = 0; i != size_; ++i) &#123; flag |= (1 &lt;&lt; (m[i * size_ + j] - 1)); &#125; if (flag_ != flag) &#123; return false; &#125; &#125; for (size_t i = 0; i != block_size_; ++i) &#123; // validate blocks for (size_t j = 0; j != block_size_; ++j) &#123; int64_t flag = 0x0; for (size_t ii = 0; ii != block_size_; ++ii) &#123; for (size_t jj = 0; jj != block_size_; ++jj) &#123; flag |= (1 &lt;&lt; (m[(i * block_size_ + ii) * size_ + j * block_size_ + jj] - 1)); &#125; &#125; if (flag_ != flag) &#123; return false; &#125; &#125; &#125; return true; &#125;&#125;;int main() &#123; size_t case_num; std::cin &gt;&gt; case_num; Sudoku sudoku(9); for (size_t i = 0; i != case_num; ++i) &#123; if (sudoku.ReadFromStream(std::cin)) &#123; std::cout &lt;&lt; ((sudoku.Validate()) ? "YES" : "NO") &lt;&lt; '\n'; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Sudoku</tag>
        <tag>Bitwise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 标准库中缺少的字符串函数：`starts_with` 和 `ends_with`]]></title>
    <url>%2F2017%2F12%2F14%2Fthe-missing-starts-with-and-ends-with-in-Cpp-for-std-string%2F</url>
    <content type="text"><![CDATA[这是一篇简短的记录。 C++ 标准模板库的 std::string 很好很强大，但是并没有提供判断一个字符串是否以另一个字符串开始/结束的接口。这里为 std::basic_string&lt;charT&gt; 提供这两个接口。 string_predicate.hpp12345678910111213141516171819202122#include &lt;string&gt;namespace std &#123;template &lt;typename charT&gt;inline bool starts_with(const basic_string&lt;charT&gt;&amp; big, const basic_string&lt;charT&gt;&amp; small) &#123; if (&amp;big == &amp;small) return true; const typename basic_string&lt;charT&gt;::size_type big_size = big.size(); const typename basic_string&lt;charT&gt;::size_type small_size = small.size(); const bool valid_ = (big_size &gt;= small_size); const bool starts_with_ = (big.compare(0, small_size, small) == 0); return valid_ and starts_with_;&#125;template &lt;typename charT&gt;inline bool ends_with(const basic_string&lt;charT&gt;&amp; big, const basic_string&lt;charT&gt;&amp; small) &#123; if (&amp;big == &amp;small) return true; const typename basic_string&lt;charT&gt;::size_type big_size = big.size(); const typename basic_string&lt;charT&gt;::size_type small_size = small.size(); const bool valid_ = (big_size &gt;= small_size); const bool ends_with_ = (big.compare(big_size - small_size, small_size, small) == 0); return valid_ and ends_with_;&#125;&#125; // namespace std 用法： test.cc12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;string&gt;#include "string_predicate.hpp"int main() &#123; std::string compared = "Hello world!"; std::string start = "Hello"; std::string end = "world!"; std::cout &lt;&lt; std::starts_with(compared, start) &lt;&lt; std::endl; std::cout &lt;&lt; std::ends_with(compared, end) &lt;&lt; std::endl; std::wstring wcompared = L"你好世界"; std::wstring wstart = L"你好"; std::wstring wend = L"世界"; std::cout &lt;&lt; std::starts_with(wcompared, wstart) &lt;&lt; std::endl; std::cout &lt;&lt; std::ends_with(wcompared, wend) &lt;&lt; std::endl; return 0;&#125; 结果： 123456$ g++ test.cc$ ./a.out1111]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>String</tag>
        <tag>Starts With</tag>
        <tag>Ends With</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用 std::transform 对字符串进行大小写转换]]></title>
    <url>%2F2017%2F12%2F14%2Fstd-transform-and-converting-string-to-upper-or-lower-case%2F</url>
    <content type="text"><![CDATA[对字符串的操作一直被认为是程序员的基本功之一。对于一个英文的字符串来说，最简单的操作，就是进行大小写转换了。这不是什么难事，但这里我们讨论的是 C++ 风格的写法。 std::transformstd::transform 是定义在头文件 algorithm 当中的一个函数模板。它和标准库中大多数其他函数模板一样，是对迭代器进行操作的函数。在 C++11 中，它有两个函数签名。 1234567891011121314151617template &lt;typename InputIt, typename OutputIt, typename UnaryOperation &gt;OutputIt transform(InputIt first, // 1. InputIt last, OutputIt d_first, UnaryOperation unary_op);template &lt;typename InputIt1, typename InputIt2, typename OutputIt, typename BinaryOperation &gt;OutputIt transform(InputIt1 first1, // 2. InputIt1 last1, InputIt2 first2, OutputIt d_first, BinaryOperation binary_op ); 从功能上说，std::transform 和 Python 当中的内建函数 map() 非常相似。 (1) 接收两个 InputIt 类型的迭代器，界定了待处理的元素的范围（左闭右开区间），被一元操作 unary_op 处理之后，依次保存在 OutputIt 对应的容器当中。这基本上就是 Python 当中的 map(lambda x: return &lt;do_something&gt;, &lt;iterable&gt;)。只不过，Python 当中的 map() 将结果作为返回值返回，而 std::transform 将结果保存在 d_first 对应的容器中。 有了 (1) 的知识，(2) 也就不难理解了。(2) 的输入接受两组迭代器。第一组迭代器与 (1) 中的情形相同，第二组迭代器则只有一个起始位置 first2而没有尾后截止。这样一来，我们必须保证第二组迭代器对应的容器足够大；即 std::distance(first1, last1) &lt;= std::distance(first2, c2.end())，其中 c2.end() 表示 first2 对应的容器的尾后迭代器。(2) 与 (1) 还有一处不同在于，(1) 接受一个 UnaryOperation，而 (2) 接受一个 BinaryOperation。因此，(2) 通过两个输入迭代器分别获取一个元素，经过 BinaryOperation 处理之后，保存在输出迭代器 d_frist 当中。这与 Python 当中的 map(lambda x, y: return &lt;do_something&gt;, &lt;iterable_1&gt;, &lt;iterable_2&gt;) 类似。 我们用如下代码说明 std::transform 的用法。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iterator&gt;int main() &#123; std::vector&lt;int&gt; vec&#123;1, 2, 3, 4, 5&#125;; for (const auto&amp; e : vec) &#123; std::cout &lt;&lt; e &lt;&lt; ' '; &#125; std::cout &lt;&lt; '\n'; std::vector&lt;int&gt; vec_out; vec_out.reserve(vec.size()); // 1. std::transform(vec.begin(), vec.end(), // 2. std::back_inserter(vec_out), // 3. [](int i)&#123; return i * i; &#125;); // 4. for (const auto&amp; e : vec_out) &#123; std::cout &lt;&lt; e &lt;&lt; ' '; &#125; std::cout &lt;&lt; '\n'; std::vector&lt;int&gt; vec_res; vec_res.reserve(vec.size()); std::transform(vec.begin(), vec.end(), // 5. vec_out.begin(), // 6. std::back_inserter(vec_res), // 7. [](int lhs, int rhs)&#123; return rhs - lhs; &#125;); // 8. for (const auto&amp; e : vec_res) &#123; std::cout &lt;&lt; e &lt;&lt; ' '; &#125; std::cout &lt;&lt; '\n'; return 0;&#125; 这里，(1) 为 vec_out 预留好了足够的空间，避免在后续不断 push_back 的过程中动态扩容，降低效率。在实际工程中，若一个向量的长度是预计确定的，或者能够预估的，那么提前预留好空间能大幅提高效率。 在 (2)(3)(4) 处，我们调用了 std::transform 函数。(2) 处输入了待处理序列的起止位置迭代器（左闭右开）；(3) 处输入了结果保存位置的迭代器；(4) 则以 C++ 的 Lambda 函数创建了一个临时的一元函数（求平方）。 在 (5)(6)(7)(8) 处，我们再次调用了 std::transform 函数。(5) 处输入了第一个待处理序列的起止位置迭代器（左闭右开）；(6) 处输入了第二个待处理序列的起始位置迭代器（两个 std::vector&lt;int&gt; 长度相同，因而合法）；(7) 照例输入了结果保存位置的迭代器；(8) 则以 C++ 的 Lambda 函数创建了一个临时的二元函数（求差）。 这样一来，结果应该是： 1234$ ./a.out1 2 3 4 51 4 9 16 250 2 6 12 20 std::tolower 和 std::toupperstd::tolower 和 std::toupper 是定义在头文件 cctype 当中的两个函数。它们的函数签名分别是 12int tolower(int ch);int toupper(int ch); 需要额外注意的是，两个函数对参数是有要求的。ch 必须不能是 EOF，并且必须能转换为 unsigned char。 对字符串进行大小写转换考虑到 std::string 和 std::vector 类似，都可以用迭代器进行逐元素地操作；我们可以利用 std::transform 和 std::tolower 及 std::toupper 对整个字符串进行大小写转换。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;namespace std &#123;std::string tolower(std::string str) &#123; std::transform(str.begin(), str.end(), str.begin(), [](unsigned char ch)&#123; return tolower(ch); &#125;); return std::move(str);&#125;std::string toupper(std::string str) &#123; std::transform(str.begin(), str.end(), str.begin(), [](unsigned char ch)&#123; return toupper(ch); &#125;); return std::move(str);&#125;&#125; // namespace stdint main() &#123; std::string str = "Hello World!"; std::cout &lt;&lt; "original:\t" &lt;&lt; str &lt;&lt; std::endl; std::cout &lt;&lt; "tolower:\t" &lt;&lt; std::tolower(str) &lt;&lt; std::endl; std::cout &lt;&lt; "toupper:\t" &lt;&lt; std::toupper(str) &lt;&lt; std::endl; return 0;&#125; 有了之前的知识，这份代码是不言自明的。它的输出应该是： 1234$ ./a.outoriginal: Hello World!tolower: hello world!toupper: HELLO WORLD!]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Transform</tag>
        <tag>Lower Case</tag>
        <tag>Upper Case</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈 C++ 中集合的交集和并集]]></title>
    <url>%2F2017%2F12%2F13%2Fset-intersection-and-union-in-Cpp%2F</url>
    <content type="text"><![CDATA[在数学中，集合是最基本的概念之一。编程时，我们不可避免地会涉及到集合及其相关操作。在 C++ 中，标准模板库（STL）提供了 std::set/std::unordered_set 两种传统意义上的集合（除此之外，还有 std::multiset 和 std::unordered_multiset）。其中，std::set（和 std::multiset）定义在头文件 set 当中，从 C++98 起就有支持；而 std::unordered_set（和 std::unordered_multiset）则定义在头文件 unordered_set 当中，从 C++11 开始支持。 此篇我们讨论如何在 C++ 中进行集合的交集和并集操作。 std::set 和 std::unordered_set 简介在 C++ 标准中，std::set 是基于平衡二叉树的（经典的 SGI STL 以红黑树实现），因而是有序的。以恰当的方式，比如以 std::set 的迭代器，遍历，可以得到有序的结果。在 C++ 标准中，std::unordered_set 则是基于哈希表的。因此，遍历 std::unordered_set 得到的顺序是不被保证的。std::unordered_set 的插入、查找、计数等操作的时间复杂度是 $O(1)$。 如果你更喜欢 hash_set 这个名字，你也可以借助 C++11 的 using 关键字的新功能，将 hash_set 作为 unordered_set 的别名。12345678#include &lt;unordered_set&gt;namespace std &#123;template &lt;typename Key, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, typename Allocator = std::allocator&lt;Key&gt;&gt;using hash_set = unordered_set&lt;Key, Hash, KeyEqual, Allocator&gt;;&#125; // namespace std 之后，就能像使用 std::unordered_set 那样使用 std::hash_set 了。 因为 std::set 和 std::unordered_set 底层使用了不同的数据结构，它们对外表现出来的性能也不相同。std::set 的插入、查找、计数等操作的时间复杂度是 $O(\log n)$。std::unordered_set 的插入、查找、计数等操作的时间复杂度是 $O(1)$。因此，在集合中元素的顺序很重要时，可以考虑使用 set::set 来保存元素；当顺序相对不重要，但会反复进行插入、查找等操作时，则应考虑使用 set::unordered_set。 我们用下面这段代码来演示 std::set 和 std::unordered_set 的用法。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;string&gt;#ifdef HASH_ // 1.#include &lt;unordered_set&gt;#else // HASH_#include &lt;set&gt;#endifnamespace test &#123;#ifdef HASH_ // 1.template &lt;typename Key, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, typename Allocator = std::allocator&lt;Key&gt;&gt;using set = std::unordered_set&lt;Key, Hash, KeyEqual, Allocator&gt;;#else // HASH_template &lt;typename Key, typename Compare = std::less&lt;Key&gt;, typename Allocator = std::allocator&lt;Key&gt;&gt;using set = std::set&lt;Key, Compare, Allocator&gt;;#endif // HASH_&#125; // namespace testint main() &#123; test::set&lt;std::string&gt; set&#123;"Hello", "world", "!"&#125;; // 2. set.insert("hello"); // 3. set.insert("world"); // 4. for (const auto&amp; i : set) &#123; std::cout &lt;&lt; i; // 5. if ((set.count(i) &gt; 0) == (set.find(i) != set.end())) &#123; // 6. std::cout &lt;&lt; "\tYES!\n"; &#125; &#125; return 0;&#125; (1) 利用预处理器，在 HASH_ 有定义时，加载 unordered_set 头文件，并将 test::set 作为 std::unordered_set 的等价类型；否则，加载 set 头文件，并将 test::set 作为 std::set 的等价类型。(2) 声明并定义了名为 set 的变量，其中包含 &quot;Hello&quot;/&quot;world&quot;/&quot;!&quot; 三个元素。注意，这里的 set 不带名字空间前缀，因而不会与 std::set 或者 test::set 冲突。(3) 和 (4) 处分别将 &quot;hello&quot; 和 &quot;world&quot; 插入 set。(5) 在按迭代器顺序遍历集合。(6) 则给出了查询元素是否属于集合的两种等价方式。 当定义 HASH_ 时，可能的输出为： 123456$ g++ -std=c++11 foo.cpp -DHASH_$ ./a.outhello YES!! YES!world YES!Hello YES! 当不定义 HASH_ 时，输出应为： 123456$ g++ -std=c++11 foo.cpp$ ./a.out! YES!Hello YES!hello YES!world YES! 不难发现，不论是使用 std::set 还是 std::unordered_set，重复插入的 &quot;hello&quot; 在集合中都只存在一份；此外，std::set 是有序的，而 std::unordered_set 是无序的。另一方面，我们发现，使用 set.count(i) &gt; 0 和 set.find(i) != set.end() 判断集合中是否存在元素 i 是等价的。 标准库提供的 std::set_intersection 和 std::set_union标准库提供了 std::set_intersection 和 std::set_union 两个函数，用于对容器内的元素进行集合求交、求并，而后将得到的结果保存在 OutputIt 对应的容器当中。这两个函数定义在头文件 algorithm 当中。 不过，这两个函数都要求原始集合是排序的。因此，我们无法将这两个函数直接运用在 std::unordered_set 上。 我们用下面这段代码演示这两个函数的用法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;iterator&gt;#include &lt;algorithm&gt;#ifdef HASH_#include &lt;unordered_set&gt;#else // HASH_#include &lt;set&gt;#endifnamespace test &#123;#ifdef HASH_template &lt;typename Key, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, typename Allocator = std::allocator&lt;Key&gt;&gt;using set = std::unordered_set&lt;Key, Hash, KeyEqual, Allocator&gt;;#else // HASH_template &lt;typename Key, typename Compare = std::less&lt;Key&gt;, typename Allocator = std::allocator&lt;Key&gt;&gt;using set = std::set&lt;Key, Compare, Allocator&gt;;#endif // HASH_&#125; // namespace testint main() &#123; test::set&lt;int&gt; lhs&#123;1, 2, 3, 4&#125;; // 1. test::set&lt;int&gt; rhs&#123;3, 4, 5, 6&#125;; // 2. test::set&lt;int&gt; result; std::set_intersection(lhs.begin(), lhs.end(), // 3. rhs.begin(), rhs.end(), // 4. std::inserter(result, result.end())); // 5. for (const auto&amp; i : result) &#123; std::cout &lt;&lt; i &lt;&lt; ' '; &#125; std::cout &lt;&lt; '\n'; result.clear(); std::set_union(lhs.begin(), lhs.end(), // 6. rhs.begin(), rhs.end(), // 7. std::inserter(result, result.end())); // 8. for (const auto&amp; i : result) &#123; std::cout &lt;&lt; i &lt;&lt; ' '; &#125; std::cout &lt;&lt; '\n'; return 0;&#125; (1) 和 (2) 声明并定义了两个 test::set&lt;int&gt; 类的对象：lhs 和 rhs。在 (3) 处，我们向 std::set_intersection 传入了 lhs 的首末位置迭代器；在 (4) 处，我们向函数传入了 rhs 的首末位置迭代器；在 (5) 处，我们向函数传入了 result 的输出迭代器。随后，我们在 (6)(7)(8) 处做了类似的事情，不过是把函数 std::set_intersection 替换成了 std::set_union。 如此一来，我们应有可能的输出： 12345678$ g++ -std=c++11 foo.cpp -DHASH_$ ./a.out5 6 1 2 3 4$ g++ -std=c++11 foo.cpp$ ./a.out3 41 2 3 4 5 6 不难发现，当使用 std::unordered_set 时，函数 std::set_intersection 工作不正常（std::set_union 恰好看起来正常，实际也不正常）。当使用 std::set 时，由于基于平衡二叉树的集合是有序的，因此两个函数工作正常。 由于 std::set_intersection 和 std::set_union 接受的输入是迭代器；事实上，这两个函数不光能对集合求交集和并集，还能接收任意有序的序列的迭代器并求交集和并集。可见，虽然名字是「集合交集」和「集合并集」，但这两个函数的行为与我们默认的交集和并集的概念并不一致。更有甚者，由于这两个函数要求容器有序，所以不能作用在 std::unoredered_set 类型的对象上。因此，我们可以考虑定义自己的求交、求并函数。 定义自己的求交、求并函数我们以下面的例子呈现我们自己定义的求交、求并函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#ifdef HASH_#include &lt;unordered_set&gt;#else // HASH_#include &lt;set&gt;#endifnamespace test &#123;#ifdef HASH_template &lt;typename Key, typename Hash = std::hash&lt;Key&gt;, typename KeyEqual = std::equal_to&lt;Key&gt;, typename Allocator = std::allocator&lt;Key&gt;&gt;using set = std::unordered_set&lt;Key, Hash, KeyEqual, Allocator&gt;;#else // HASH_template &lt;typename Key, typename Compare = std::less&lt;Key&gt;, typename Allocator = std::allocator&lt;Key&gt;&gt;using set = std::set&lt;Key, Compare, Allocator&gt;;#endif // HASH_&#125; // namespace testnamespace setop &#123;template &lt;typename Set&gt; // 1.static inline Setset_union(const Set&amp; lhs, const Set&amp; rhs) &#123; Set uset&#123;lhs&#125;; // 2. uset.insert(rhs.begin(), rhs.end()); // 3. return std::move(uset); // 4.&#125;template &lt;typename Set, typename Key = typename Set::value_type&gt; // 5.static inline Setset_intersection(const Set&amp; lhs, const Set&amp; rhs) &#123; if (lhs.size() &lt;= rhs.size()) &#123; // 6. Set iset; for (const Key&amp; key : lhs) &#123; if (rhs.count(key) &gt; 0) &#123; // 7. iset.insert(key); &#125; &#125; return std::move(iset); &#125; else &#123; return set_intersection(rhs, lhs); &#125;&#125;&#125; // namespace setopint main() &#123; test::set&lt;int&gt; lhs&#123;1, 2, 3, 4&#125;; test::set&lt;int&gt; rhs&#123;3, 4, 5, 6&#125;; const auto iset = setop::set_intersection(lhs, rhs); // 8. const auto uset = setop::set_union(lhs, rhs); // 9. for (const auto&amp; i : iset) &#123; std::cout &lt;&lt; i &lt;&lt; ' '; &#125; std::cout &lt;&lt; '\n'; for (const auto&amp; i : uset) &#123; std::cout &lt;&lt; i &lt;&lt; ' '; &#125; std::cout &lt;&lt; '\n'; return 0;&#125; (1) 和 (5) 表明，setop::set_union 和 setop::set_intersection 都是函数模板，可以接受任何符合要求的容器。其中，在 (5) 的模板声明中，我们使用了 typename Set::value_type 这样的语法。这是因为，对于编译器来说，它并不知道 Set::value_type 是一个类型还是 Set 这个名字空间地下的名为 value_type；此处我们明确地告诉编译器，它应当是一个类型名。 在 (2) 处，我们通过 Set 的拷贝构造函数，将 lhs 中的元素全都拷贝到 uset 当中。这样一来，uset 当中就包含了 lhs 中的所有元素。在 (3) 处，我们通过 insert 函数，将 rhs 的全部元素依次插入到 uset 当中。这样一来，uset 当中也包含了 rhs 中的所有元素。因此，此时它是 lhs 和 rhs 的并集；我们在 (4) 处将 uset 返回。值得一提的是，为了避免可能的额外拷贝（返回值拷贝），我们明确使用了 std::move 将 uset 作为右值返回。不过，即使不这么写，现代编译器也会优化这一拷贝过程。 (6) 比较了 lhs 和 rhs 的大小。这里使用 &lt;= 而不使用 &lt;，是为了避免两个集合元素个数相同时无限递归。(7) 处使用了 rhs.count(key) &gt; 0 的方式，验证 key 是否在 rhs 这一集合当中。显然，它比使用 find 然后与 rhs.end() 进行比较来得自然。 如此一来，我们有可能的输出： 12345678$ g++ -std=c++11 foo.cpp -DHASH_$ ./a.out3 45 6 1 2 3 4$ g++ -std=c++11 foo.cpp$ ./a.out3 41 2 3 4 5 6 不难发现，两个函数工作良好。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Set</tag>
        <tag>Intersection</tag>
        <tag>Union</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[crontab 任务误删恢复]]></title>
    <url>%2F2017%2F11%2F30%2Frecovery-crontab-tasks%2F</url>
    <content type="text"><![CDATA[这是一篇简短的记录。 某台服务器某账号的 crontab 任务被清空，原因不明。同时，该服务器上的 crontab 任务备份未开启。故思考如何恢复 crontab 任务。 经查，CentOS 系统的 crontab 任务的日志，打印在 /var/log/cron 之中。考虑过滤日志： 1cat /var/log/cron* | grep CMD | awk -F'CMD' '&#123;print $2&#125;' | awk -F'[(|)]' '&#123;print $2&#125;' | sort -u 由此得到系统记录过的 crontab 执行命令，过滤其他账号的命令后即可追回目标账号的 crontab 任务。 此外，考虑备份 crontab；脚本如下： backup_crontab.sh123456789#!/usr/bin/env bashBACKUP_DIRECTORY="$&#123;HOME&#125;/crontab_backup"if [ ! -e "$&#123;BACKUP_DIRECTORY&#125;" ]; then mkdir -p $&#123;BACKUP_DIRECTORY&#125;ficrontab -l &gt; $&#123;BACKUP_DIRECTORY&#125;/$(date '+%Y%m%d').txt]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Crontab</tag>
        <tag>Recovery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈代理类]]></title>
    <url>%2F2017%2F11%2F26%2Fsurrogate-in-Cpp%2F</url>
    <content type="text"><![CDATA[本文以 C++ 为示例语言，但实际其中思想适用范围远大于 C++ 这一编程语言的范畴。 我们知道，C++ 标准模板类库提供了一系列的容器。诸如 std::vector&lt;ElementType&gt; 的容器需要在声明时指定容器中所储存的元素的类型。例如，我们可以使用 std::vector&lt;int&gt; 声明一个包含整型数字的变长数组；而 std::vector&lt;std::string&gt; 则可以用来声明一个包含 std::string 的变长数组。 显而易见，由于容器在声明时就已指定了其包含的元素的类型，容器内只能包含相同类型的元素。这与面向对象编程（Object-Oriented Programming, OOP, 使用继承和运行时动态绑定的编程方式）的思想似乎是矛盾的。因为 OOP 使用继承和动态绑定，允许程序员将相关但有不同的类的共性部分抽象成基类而将这些不同的部分分别作为子类独有的成员；若是容器内只能包含相同类型的元素，我们就无法直接在一个容器中包含同一个基类不同派生类的对象了——而在实际应用中，这种场景是存在的。 在前作中最后的示例（动物园的例子）中，我们通过保存基类指针（而不是对象本身）部分解决了这个问题。然而，在前例中，我们不可避免地还是需要使用 new 和 delete 来动态分配内存。此篇我们通过构建「代理类」来避免手工动态分配内存。 问题重述我们仍旧以前作中动物园的例子进行讲述；不失一般性，我们忽略 CRTP 惯用法。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;vector&gt;class Animal &#123; public: virtual void say () const = 0; virtual ~Animal() &#123;&#125;&#125;;class Cat: public Animal &#123; public: void say() const override &#123; std::cout &lt;&lt; "Meow~ I'm a cat." &lt;&lt; std::endl; &#125; private: bool valid_cat_&#123;true&#125;;&#125;;class Dog: public Animal &#123; public: void say() const override &#123; std::cout &lt;&lt; "Wang~ I'm a dog." &lt;&lt; std::endl; &#125; private: bool valid_dog_&#123;true&#125;;&#125;;int main () &#123; std::vector&lt;Animal*&gt; zoo; zoo.push_back(new Cat()); zoo.push_back(new Dog()); for (auto iter = zoo.begin(); iter != zoo.end(); ++iter) &#123; (*iter)-&gt;say(); &#125; for (auto iter = zoo.begin(); iter != zoo.end(); ++iter) &#123; delete (*iter); &#125; return 0;&#125; 在主函数中，我们通过 Cat 和 Dog 类的默认构造函数，两次动态分配内存，分别构建了 Cat 和 Dog 类的对象；而后将相应的指针加入 std::vector 的末尾。而后，我们就能通过迭代器，依次访问 Cat 和 Dog 了。当然，最后也不能忘记清理动态分配的内存。 我们的目标是将主函数改成类似下面的效果。 1234567891011int main () &#123; std::vector&lt;ElementType&gt; zoo; Cat cat; Dog dog; zoo.push_back(cat); zoo.push_back(dog); for (auto iter = zoo.begin(); iter != zoo.end(); ++iter) &#123; iter-&gt;say(); &#125; return 0;&#125; 问题分析对比在 zoo 中保存基类指针的方式，我们的目标代码有几点主要的不同。 向 zoo 中追加元素时，加入的是 Cat 和 Dog 类的对象本身，而不是它们的指针； 向 zoo 中追加的元素保存在栈上（而不是堆上），不需要程序员主动分配和释放内存。 这也就是说，数组 zoo 的元素类型必然不是 Cat 或 Dog，而应该和他们的基类 Animal 有一定关系；另外一方面，在功能上，我们要保证 ElementType 的元素支持动态绑定（能够调用合适的 say 函数）。 另一方面，我们也要注意到，由于 cat 和 dog 不是程序员手动分配和释放内存，而是由系统运行时库来自动管理。这样一来，可能存在变长数组 zoo 仍在使用，但 cat 和 dog 已经由于超出生存期而被销毁的现象。因此，在向变长数组 zoo 追加元素时，我们需要考虑拷贝或者移动语义。 代码实现接下来我们分别解决这些问题。 拷贝和移动语义首先我们来实现拷贝和移动语义。 在问题分析一节中，我们提到，数组的元素类型 ElementType 虽不是基类指针，但必然和基类相关。因此，显而易见，拷贝和移动语义的接口应该定义在基类当中。因此，我们首先需要修改基类。 1234567class Animal &#123; public: virtual void say () const = 0; virtual Animal* copy() const = 0; virtual Animal* move() = 0; virtual ~Animal() &#123;&#125;&#125;; 而后，我们需要在 Cat 和 Dog 两个派生类中分别实现 copy 和 move 函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Cat: public Animal &#123; public: void say() const &#123; std::cout &lt;&lt; "Meow~ I'm a cat." &lt;&lt; std::endl; &#125; public: Cat() &#123;&#125; ~Cat() override &#123; valid_cat_ = false; &#125; Cat(const Cat&amp; source) : valid_cat_&#123;source.valid_cat_&#125; &#123;&#125; Cat(Cat&amp;&amp; source) : valid_cat_&#123;source.valid_cat_&#125; &#123; source.valid_cat_ = false; &#125; Cat&amp; operator=(const Cat&amp; source) &#123; this-&gt;valid_cat_ = source.valid_cat_; &#125; Cat&amp; operator=(Cat&amp;&amp; source) &#123; this-&gt;valid_cat_ = source.valid_cat_; source.valid_cat_ = false; &#125; Animal* copy() const override &#123; return dynamic_cast&lt;Animal*&gt;(new Cat(*this)); &#125; Animal* move() override &#123; return dynamic_cast&lt;Animal*&gt;(new Cat(std::move(*this))); &#125; private: bool valid_cat_&#123;true&#125;;&#125;;class Dog: public Animal &#123; public: void say() const &#123; std::cout &lt;&lt; "Wang~ I'm a dog." &lt;&lt; std::endl; &#125; public: Dog() &#123;&#125; ~Dog() override &#123; valid_dog_ = false; &#125; Dog(const Dog&amp; source) : valid_dog_&#123;source.valid_dog_&#125; &#123;&#125; Dog(Dog&amp;&amp; source) : valid_dog_&#123;source.valid_dog_&#125; &#123; source.valid_dog_ = false; &#125; Dog&amp; operator=(const Dog&amp; source) &#123; this-&gt;valid_dog_ = source.valid_dog_; &#125; Dog&amp; operator=(Dog&amp;&amp; source) &#123; this-&gt;valid_dog_ = source.valid_dog_; source.valid_dog_ = false; &#125; Animal* copy() const override &#123; return dynamic_cast&lt;Animal*&gt;(new Dog(*this)); &#125; Animal* move() override &#123; return dynamic_cast&lt;Animal*&gt;(new Dog(std::move(*this))); &#125; private: bool valid_dog_&#123;true&#125;;&#125;; 此处，通过完整实现 Cat 和 Dog 类的析构函数、拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符，我们实现了 copy 和 move 两个函数。 定义基类的代理如问题分析一节中的讨论，我们认为 ElementType 必然和 Cat 和 Dog 的基类 Animal 相关。同时，经过分析，我们发现 ElementType 在构建时，可以直接从 Cat 和 Dog 的实例上构建；在运行时，支持多态。因此，不难发现，ElementType 一方面必须包含一个 Animal 的指针或引用；另一方面它必须有从 Animal 的实例中构造的构造函数（定义从 Animal 到 ElementType 的类型转换）。 这样一来，我们能写出 Animal 类的代理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class AnimalSurrogate &#123; public: AnimalSurrogate() &#123;&#125; explicit AnimalSurrogate(const AnimalSurrogate&amp; animal_surrogate) : animal_&#123;animal_surrogate.animal_ ? animal_surrogate.animal_-&gt;copy() : nullptr&#125; &#123;&#125; explicit AnimalSurrogate(AnimalSurrogate&amp;&amp; animal_surrogate) : animal_&#123;animal_surrogate.animal_ ? animal_surrogate.animal_-&gt;move() : nullptr&#125; &#123; animal_surrogate.animal_ = nullptr; &#125; AnimalSurrogate&amp; operator=(const AnimalSurrogate&amp; animal_surrogate) &#123; animal_ = animal_surrogate.animal_ ? animal_surrogate.animal_-&gt;copy() : nullptr; return (*this); &#125; AnimalSurrogate&amp; operator=(AnimalSurrogate&amp;&amp; animal_surrogate) &#123; animal_ = animal_surrogate.animal_ ? animal_surrogate.animal_-&gt;move() : nullptr; animal_surrogate.animal_ = nullptr; return (*this); &#125; ~AnimalSurrogate() &#123; delete animal_; animal_ = nullptr; &#125; public: AnimalSurrogate(const Animal&amp; animal) : animal_&#123;animal.copy()&#125; &#123;&#125; AnimalSurrogate(Animal&amp;&amp; animal) : animal_&#123;animal.move()&#125; &#123;&#125; AnimalSurrogate&amp; operator=(const Animal&amp; animal) &#123; this-&gt;animal_ = animal.copy(); return (*this); &#125; AnimalSurrogate&amp; operator=(Animal&amp;&amp; animal) &#123; this-&gt;animal_ = animal.move(); return (*this); &#125; public: void say() const &#123; animal_-&gt;say(); return; &#125; private: Animal* animal_&#123;nullptr&#125;;&#125;; 这里，我们定义了 Animal 类的代理类 AnimalSurrogate。在它的一系列构造函数中，我们保证了 AnimalSurrogate 类的实例本身能够拷贝、移动。同时我们允许从 Animal 向 AnimalSurrogate 的类型转换：从左值引用中拷贝以及从右值引用中移动。特别地，由于 Animal 是抽象类，不存在 Animal 类的对象，因此这两个构造函数不应声明为 explicit。这是因为，如果声明为 explicit，则每次使用都必须使用 dynamic_cast 进行显式的类型转换。 另一方面，由于 AnimalSurrogate 类中包含了一个 Animal 类的指针，通过该指针，我们在 AnimalSurrogate::say() 函数中，可以实现多态。 实际执行看看这样一来，我们的主函数就应当写作以下两种形式之一： 123456789101112int main () &#123; std::vector&lt;AnimalSurrogate&gt; zoo; Cat cat; Dog dog; // AnimalSurrogate::AnimalSurrogate(const Animal&amp; animal) is called zoo.push_back(cat); zoo.push_back(dog); for (std::vector&lt;AnimalSurrogate&gt;::const_iterator iter&#123;zoo.begin()&#125;; iter != zoo.end(); ++iter) &#123; iter-&gt;say(); &#125; return 0;&#125; 123456789101112int main () &#123; std::vector&lt;AnimalSurrogate&gt; zoo; Cat cat; Dog dog; // AnimalSurrogate::AnimalSurrogate(Animal&amp;&amp; animal) is called zoo.push_back(std::move(cat)); zoo.push_back(std::move(dog)); for (std::vector&lt;AnimalSurrogate&gt;::const_iterator iter&#123;zoo.begin()&#125;; iter != zoo.end(); ++iter) &#123; iter-&gt;say(); &#125; return 0;&#125; 此处，第一种情况，我们在向 zoo 追加元素时，C++ 会调用 AnimalSurrogate::AnimalSurrogate(const Animal&amp; animal)；以便从 animal 中拷贝内容（调用 copy() 函数）。第二种情况，我们在想 zoo 追加元素时，C++ 会调用 AnimalSurrogate::AnimalSurrogate(Animal&amp;&amp; animal)；以便运用移动语义，从 animal 中「窃取」资源。 需要注意的是，在两种情况下，zoo 中的元素都与外部的 cat 和 dog 无关。不论 cat 和 dog 如何变化（甚至销毁），都不影响 zoo 中的元素。不同的是，在第二种情况下，外部的 cat 和 dog 中的资源被窃取，因此 cat 和 dog 已处于不可用的状态（代码中使用 valid_cat_ 和 valid_dog_ 来表示这种现象）——我们不能对移走的 cat 和 dog 中的资源的状态做任何假设。具体可参见谈谈 C++ 中的右值引用。 执行结果如下： 123$ ./a.outMeow~ I'm a cat.Wang~ I'm a dog. 如此一来，我们就实现了在同一容器中，（间接地）容纳不同类型的实例；同时在保留多态的情况下，避免让程序员手动分配和释放内存。 代理类和 CRTP 是不矛盾的，读者可以试着将二者联系起来，一起使用。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Class</tag>
        <tag>Surrogate</tag>
        <tag>Handler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈矩阵的 SVD 分解]]></title>
    <url>%2F2017%2F11%2F22%2FSVD-for-Human-Beings%2F</url>
    <content type="text"><![CDATA[看似高大上的人工智能、机器学习，实际上都脱不开数学的支持。在这些数学内容中，最重要的无疑是两个部分：代数和概率论。我无法在博客中完整地介绍代数（特别是矩阵论）和概率论，但是将其中部分有趣又重要的内容提出来讲解，还是可行的。 此篇，我们谈谈矩阵的 SVD 分解。 一些矩阵知识首先我们来看一些基本的矩阵知识。 转置与共轭转置矩阵的转置（transpose）是最简单的一种矩阵变换。简单来说，若 $m\times n$ 的矩阵 $\mathbf M$ 的转置记为 $\mathbf M^{\mathsf T}$；则 $\mathbf M^{\mathsf T}$ 是一个 $n\times m$ 的矩阵，并且 $\mathbf M_{i,j} = \mathbf M^{\mathsf T}_{j,i}$。 因此，矩阵的转置相当于将矩阵按照主对角线翻转；同时，我们不难得出 $\mathbf M = \bigl(\mathbf M^{\mathsf T}\bigr)^{\mathsf T}$。 矩阵的共轭转置（conjugate transpose）可能是倒数第二简单的矩阵变换。共轭转置只需要在转置的基础上，再叠加复数的共轭即可。因此，若以 $\mathbf M^{\mathsf H}$ 记矩阵 $\mathbf M$ 的共轭转置，则有 $\mathbf M_{i,j} = \overline{\bigl(\mathbf M^{\mathsf H}\bigr)_{j,i}}$。 酉矩阵酉矩阵（unitary matrix）是一种特殊的方阵，它满足 $$ \mathbf U\mathbf U^{\mathsf H} = \mathbf U^{\mathsf H}\mathbf U = I_n.$$ 不难看出，酉矩阵实际上是推广的正交矩阵（orthogonal matrix）；当酉矩阵中的元素均为实数时，酉矩阵实际就是正交矩阵。另一方面，由于 $\mathbf M\mathbf M^{-1} = \mathbf M^{-1}\mathbf M = I_n$，所以酉矩阵 $\mathbf U$ 满足 $\mathbf U^{-1} = \mathbf U^{\mathsf H}$；事实上，这是一个矩阵是酉矩阵的充分必要条件。 正规矩阵同酉矩阵一样，正规矩阵（normal matrix）也是一种特殊的方阵，它要求在矩阵乘法的意义下与它的共轭转置矩阵满足交换律。这也就是说，若矩阵 $\mathbf M$ 满足如下条件，则称其为正规矩阵： $$\mathbf M\mathbf M^{\mathsf H} = \mathbf M^{\mathsf H}\mathbf M.$$ 显而易见，复系数的酉矩阵和实系数的正交矩阵都是正规矩阵。显而易见，正规矩阵并不只有酉矩阵或正交矩阵。例如说，矩阵 $\mathbf M = \begin{pmatrix}1 &amp; 1 &amp; 0 \\ 0 &amp; 1 &amp; 1 \\ 1 &amp; 0 &amp; 1\end{pmatrix}$ 即是一个正规矩阵，但它显然不是酉矩阵或正交矩阵；因为 $$\mathbf M\mathbf M^{\mathsf H} = \begin{pmatrix}2 &amp; 1 &amp; 1 \\ 1 &amp; 2 &amp; 1 \\ 1 &amp; 1 &amp; 2\end{pmatrix} = \mathbf M^{\mathsf H}\mathbf M.$$ 谱定理和谱分解矩阵的对角化是线性代数中的一个重要命题。谱定理（spectral theorem）给出了方阵对角化的一个结论：若矩阵 $\mathbf M$ 是一个正规矩阵，则存在酉矩阵 $\mathbf U$，以及对角矩阵 $\mathbf \Lambda$，使得 $$\mathbf M = \mathbf U\mathbf \Lambda\mathbf U^{\mathsf H}.$$ 这也就是说，正规矩阵，可经由酉变换，分解为对角矩阵；这种矩阵分解的方式，称为谱分解（spectral decomposition）。 SVD 分解谱定理给出了正规矩阵分解的可能性以及分解形式。然而，对于矩阵来说，正规矩阵是要求非常高的。因此，谱定理是一个非常弱的定理，它的适用范围有限。在实际生产中，我们遇到的很多矩阵都不是正规矩阵。对于这些矩阵，谱定理就失效了。作为谱定理的泛化，SVD 分解对于原矩阵的要求就要弱得多。 SVD 分解说的是：假设 $\mathbf M$ 是一个 $ m\times n$ 的矩阵，其中的元素全部属于数域 $\mathbb K$（实数域 $\mathbb R$ 或复数域 $\mathbb C$）。那么，存在 $m\times m$ 的酉矩阵 $\mathbf U$ 和 $n\times n$ 的酉矩阵 $\mathbf V$ 使得 $$\mathbf M = \mathbf U\mathbf\Sigma\mathbf V^{\mathsf H},$$ 其中 $\mathbf\Sigma$ 是 $m\times n$ 的非负实数对角矩阵；并且 $\mathbf\Sigma$ 对角线上的元素 $\mathbf\Sigma_{i, i}$ 是 $\mathbf M$ 的奇异值。一般来说，我们偏好将这些奇异值按从大到小的顺序排列，这样一来 $\mathbf\Sigma$ 就由 $\mathbf M$ 唯一确定了。 另一方面，因为 $\mathbf U$ 和 $\mathbf V$ 都是酉矩阵，所以 $\mathbf U$ 和 $\mathbf V$ 的列向量分别张成 $\mathbb K^{m}$ 和 $\mathbb K^{n}$ 的一组标准正交基。我们将 $\mathbf U$ 的列向量记作 $\vec u_i,\; 1 \leqslant i\leqslant m$；将 $\mathbf V$ 的列向量记作 $\vec v_j,\; 1\leqslant j\leqslant n$；同时，将 $\mathbf\Sigma$ 对角线上的第 $i$ 个元素记作 $\sigma_k,\; 1\leqslant k\leqslant\min(m,n)$。那么，SVD 分解实际可以将矩阵 $\mathbf M$ 写作一个求和形式 $$\mathbf M = \sum_{i = 1}^{\min(m, n)}\sigma_i\vec u_i\vec v_i^{\mathsf T}.$$ SVD 的计算方法了解了 SVD 的介绍和相关几何解释之后，接下来最直接想要知道的就是如何计算一个矩阵的 SVD 了。我们分成几步来探讨这个问题。 SVD 与特征值现在，假设矩阵 $\mathbf M_{m\times n}$ 的 SVD 分解是 $$\mathbf M = \mathbf U\mathbf\Sigma\mathbf V^{\mathsf H};$$ 那么，我们有 $$\begin{aligned} \mathbf M\mathbf M^{\mathsf H} &amp;{}= \mathbf U\mathbf\Sigma\mathbf V^{\mathsf H}\mathbf V\mathbf\Sigma^{\mathsf H}\mathbf U^{\mathsf H} = \mathbf U(\mathbf\Sigma\mathbf\Sigma^{\mathsf H})\mathbf U^{\mathsf H}\\ \mathbf M^{\mathsf H}\mathbf M &amp;{}= \mathbf V\mathbf\Sigma^{\mathsf H}\mathbf U^{\mathsf H}\mathbf U\mathbf\Sigma\mathbf V^{\mathsf H} = \mathbf V(\mathbf\Sigma^{\mathsf H}\mathbf\Sigma)\mathbf V^{\mathsf H}\\ \end{aligned}$$ 这也就是说，$\mathbf U$ 的列向量（左奇异向量），是 $\mathbf M\mathbf M^{\mathsf H}$ 的特征向量；同时，$\mathbf V$ 的列向量（右奇异向量），是 $\mathbf M^{\mathsf H}\mathbf M$ 的特征向量；另一方面，$\mathbf M$ 的奇异值（$\mathbf\Sigma$ 的非零对角元素）则是 $\mathbf M\mathbf M^{\mathsf H}$ 或者 $\mathbf M^{\mathsf H}\mathbf M$ 的非零特征值的平方根。 如何计算 SVD有了这些知识，我们就能手工计算出任意矩阵的 SVD 分解了；具体来说，算法如下 计算 $\mathbf M\mathbf M^{\mathsf H}$ 和 $\mathbf M^{\mathsf H}\mathbf M$； 分别计算 $\mathbf M\mathbf M^{\mathsf H}$ 和 $\mathbf M^{\mathsf H}\mathbf M$ 的特征向量及其特征值； $\mathbf M\mathbf M^{\mathsf H}$ 的特征向量组成 $\mathbf U$；而 $\mathbf M^{\mathsf H}\mathbf M$ 的特征向量组成 $\mathbf V$； 对 $\mathbf M\mathbf M^{\mathsf H}$ 和 $\mathbf M^{\mathsf H}\mathbf M$ 的非零特征值求平方根，对应上述特征向量的位置，填入 $\mathbf\Sigma$ 的对角元。 实际计算看看现在，我们来试着计算 $\mathbf M = \begin{bmatrix}2 &amp; 4 \\ 1 &amp; 3 \\ 0 &amp; 0 \\ 0 &amp; 0\end{bmatrix}$ 的奇异值分解。计算奇异值分解，需要计算 $\mathbf M$ 与其共轭转置的左右积；这里主要以 $\mathbf M\mathbf M^{\mathsf H}$ 为例。 首先，我们需要计算 $\mathbf M\mathbf M^{\mathsf H}$， $$ \mathbf W = \mathbf M\mathbf M^{\mathsf H} = \begin{bmatrix}2 &amp; 4 \\ 1 &amp; 3 \\ 0 &amp; 0 \\ 0 &amp; 0\end{bmatrix}\begin{bmatrix}2 &amp; 1 &amp; 0 &amp; 0 \\ 4 &amp; 3 &amp; 0 &amp; 0\end{bmatrix} = \begin{bmatrix}20 &amp; 14 &amp; 0 &amp; 0 \\ 14 &amp; 10 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0\end{bmatrix}. $$ 现在，我们要求 $\mathbf W$ 的特征值与特征向量。根据定义 $\mathbf W\vec x = \lambda \vec x$；因此 $(\mathbf W - \lambda\mathbf I)\vec x = \vec 0$。这也就是说 $$ \begin{bmatrix} 20 - \lambda &amp; 14 &amp; 0 &amp; 0 \\ 14 &amp; 10 - \lambda &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; -\lambda &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; -\lambda \end{bmatrix}\vec x = \vec 0. $$ 根据线性方程组的理论，若要该关于 $\vec x$ 的方程有非零解，则要求系数矩阵的行列式为 0；也就是 $$ \begin{vmatrix} 20 - \lambda &amp; 14 &amp; 0 &amp; 0 \\ 14 &amp; 10 - \lambda &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; -\lambda &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; -\lambda \end{vmatrix} = \begin{vmatrix} 20 - \lambda &amp; 14 \\ 14 &amp; 10 - \lambda \\ \end{vmatrix}\begin{vmatrix} -\lambda &amp; 0 \\ 0 &amp; -\lambda \\ \end{vmatrix} = 0, $$ 这也就是 $\bigl((20 - \lambda)(10 - \lambda) - 196\bigr)\lambda^2 = 0$；解得 $\lambda_{1} = \lambda_{2} = 0$, $\lambda_{3} = 15 + \sqrt{221} \approx 29.866$, $\lambda_{4} = 15 - \sqrt{221} \approx 0.134$。将特征值代入原方程，可解得对应的特征向量；这些特征向量即作为列向量，形成矩阵 $$\mathbf U = \begin{bmatrix}-0.82 &amp; -0.58 &amp; 0 &amp; 0 \\ -0.58 &amp; 0.82 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}.$$ 同理可解得（注意，$\mathbf M\mathbf M^{\mathsf T}$ 和 $\mathbf M^{\mathsf T}\mathbf M$ 的特征值相同） $$\mathbf V = \begin{bmatrix}-0.40 &amp; -0.91 \\ -0.91 &amp; 0.40\end{bmatrix}.$$ 以及 $\mathbf\Sigma$ 上的对角线元素由 $\mathbf W$ 的特征值的算术平方根组成；因此有 $$\mathbf\Sigma = \begin{bmatrix}5.46 &amp; 0 \\ 0 &amp; 0.37 \\ 0 &amp; 0 \\ 0 &amp; 0\end{bmatrix}.$$ 因此我们得到矩阵 $\mathbf M$ 的 SVD 分解（数值上做了近似）： $$\begin{bmatrix}2 &amp; 4 \\ 1 &amp; 3 \\ 0 &amp; 0 \\ 0 &amp; 0\end{bmatrix} \approx \begin{bmatrix}-0.82 &amp; -0.58 &amp; 0 &amp; 0 \\ -0.58 &amp; 0.82 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}\begin{bmatrix}5.46 &amp; 0 \\ 0 &amp; 0.37 \\ 0 &amp; 0 \\ 0 &amp; 0\end{bmatrix}\begin{bmatrix}-0.40 &amp; -0.91 \\ -0.91 &amp; 0.40\end{bmatrix}$$ 几何上的直观解释我们先来看一个例子。假设 $\mathbf M$ 是一个 $m\times n$ 的矩阵，而 $\mathbf x$ 是线性空间 $\mathbb K^n$ 中的向量，则 $$\mathbf y = \mathbf M\cdot\mathbf x$$ 是线性空间 $\mathbb K^m$ 中的向量。这样一来，矩阵 $\mathbb A$ 就对应了一个从 $\mathbb K^n$ 到 $\mathbb K^m$ 的变换 $T: \mathbb K^n \to \mathbb K^m$，具体来说既是 $\mathbf x\mapsto \mathbf M\cdot\mathbf x$。 这也就是说，在线性代数中，任意矩阵都能看做是一种变换。这样一来，我们就统一了矩阵和变换。 旋转变换和反射变换（镜像）在线性空间中进行旋转，实际是要改变向量的方向，但是不改变向量的长度和手性。现在假设矩阵 $\mathbf M_{n\times n}$ 是线性空间 $\mathbf R^{n}$ 中的一个旋转变换对应的矩阵，我们来看看它应该是什么样子。 首先，我们考虑向量内积 $\vec a\cdot\vec b = \lvert\vec a\rvert\lvert\vec b\rvert\cos\langle\vec a,\vec b\rangle$。因为旋转不改变向量的长度，且两个向量经过相同的旋转之后，其夹角保持不变。因此，若 $\mathbf M$ 对应一个旋转变换，那么就必须有 $$\vec a\cdot\vec b = \mathbf M\vec a\cdot \mathbf M\vec b,$$ 也就是 $$\vec a\cdot\vec b^{\mathsf T} = \mathbf M\vec a\cdot (\mathbf M\vec b)^{\mathsf T},$$ 这也就是说 $\mathbf M\mathbf M^{\mathsf T} = \mathbf I_{n}$，亦即 $\mathbf M$ 是正交矩阵。 因此，对于二维的情况，$\mathbf M$ 可以写作 $\begin{bmatrix}\cos\varphi &amp; -\sin\varphi \\ \sin\varphi &amp; \cos\varphi\end{bmatrix}$ 或 $\begin{bmatrix}\cos\varphi &amp; \sin\varphi \\ \sin\varphi &amp; -\cos\varphi\end{bmatrix}$。前者行列式为 $1$ 而后者行列式为 $-1$。既然 $\mathbf M$ 是正交矩阵，那么它的行列式值必然是 $\pm 1$。现在的问题是，行列式为 $1$ 和 $-1$ 究竟哪一个才是旋转？或者两个都是旋转？ 回过头，我们需要注意两件事情。其一，在旋转的定义中，我们提出了旋转保持「手性」；其二，在得出旋转矩阵是正交矩阵的过程中，我们并没有运用到「手性不变」这一特性——因为 $\cos\langle\vec a,\vec b\rangle = \cos\langle\vec b,\vec a\rangle$。 事实上，若 $\mathbf M$ 的行列式为 $-1$，则该矩阵对应了一个瑕旋转——先旋转 $\varphi$ 而后按直线 $r = k\varphi$ 镜像。考虑 $\varphi - \alpha = 2\varphi - (\varphi + \alpha)$，这一瑕旋转实质上就是按直线 $r = k(\varphi / 2)$ 镜像。 因此我们说，旋转矩阵是一个行列式为 $1$ 的正定矩阵，其形式为 $$\begin{bmatrix}\cos\varphi &amp; -\sin\varphi \\ \sin\varphi &amp; \cos\varphi\end{bmatrix},$$ 表示向正方向（通常是逆时针方向）旋转 $\varphi$。对于 $\mathbb R^{2}$ 上的标准正交基 $\begin{bmatrix}1 \\ 0\end{bmatrix}$, $\begin{bmatrix}0 \\ 1\end{bmatrix}$，他们分别被变换为 $\begin{bmatrix}\cos\varphi \\ \sin\varphi\end{bmatrix}$ 和 $\begin{bmatrix}-\sin\varphi \\ \cos\varphi\end{bmatrix}$。 行列式为 $-1$ 的正定矩阵，其形式为 $$\begin{bmatrix}\cos\varphi &amp; \sin\varphi \\ \sin\varphi &amp; -\cos\varphi\end{bmatrix},$$ 表示按直线 $r = k(\varphi / 2)$ 镜像。 缩放变换在线性空间中进行缩放，实质就是要让线性空间中的每一维独立地进行变换，而不受其他维度影响。这样一来，很显然，对应的矩阵应该是对角矩阵。 SVD 分解的几何解释现在回过头来看 SVD 分解 $$\mathbf M = \mathbf U\mathbf\Sigma\mathbf V^{\mathsf H},$$ 在实数范围内讨论，我们实质上是将一个复杂的变换 $M:\mathbb R^{m}\to\mathbb R^{n}$ 分解成了三个变换：旋转/镜像 $U:\mathbb R^{m}\to\mathbb R^{m}$、缩放 $\Sigma:\mathbb R^{m}\to\mathbb R^{n}$、旋转/镜像 $V:\mathbb R^{n}\to\mathbb R^{n}$。 不失一般性，我们假设 $m = n$ 以及 $U$ 和 $V$ 都是旋转矩阵，则这个过程可以表示为 不难发现，$\mathbf V^{\mathsf H}$ 首先将（可能是退化的）单位球旋转（旋转标准正交基），而后经由 $\mathbf \Sigma$ 将单位圆缩放拉伸成椭圆（超空间中的超椭球），再经由 $\mathbf U$ 将超椭球在 $\mathbb K^{m}$ 空间中旋转。而这个超椭球的各个半轴的长度，就是矩阵 $\mathbf M$ 的奇异值，也就是矩阵 $\mathbf \Sigma$ 对角线上的元素。 SVD 分解的应用在化学中，有所谓「结构决定性质、性质决定用途」的说法；这反应了一个事物由内而外的特性和人类运用事物的普遍规律。这一规律放在数学上也一样适用。 SVD 将矩阵分解成累加求和的形式，其中每一项的系数即是原矩阵的奇异值。这些奇异值，按之前的几何解释，实际上就是空间超椭球各短轴的长度。现在想象二维平面中一个非常扁的椭圆（离心率非常高），它的长轴远远长于短轴，以至于整个椭圆看起来和一条线段没有什么区别。这时候，如果将椭圆的短轴强行置为零，从直观上看，椭圆退化为线段的过程并不突兀。回到 SVD 分解当中，较大的奇异值反映了矩阵本身的主要特征和信息；较小的奇异值则如例中椭圆非常短的短轴，几乎没有体现矩阵的特征和携带的信息。因此，若我们将 SVD 分解中较小的奇异值强行置为零，则相当于丢弃了矩阵中不重要的一部分信息。 因此，SVD 分解至少有两方面作用： 分析了解原矩阵的主要特征和携带的信息（取若干最大的奇异值），这引出了主成分分析（PCA）； 丢弃忽略原矩阵的次要特征和携带的次要信息（丢弃若干较小的奇异值），这引出了信息有损压缩、矩阵低秩近似等话题。 这两方面的应用实际上是对偶的：因为，按重要度排序之后，一方面我们可以知道哪些信息（奇异值）重要，另一方面我就很自然地就可以丢弃不重要的部分。这里我们以信息的有损压缩为例。 在实际生活和工作当中，很多信息都能被表示为矩阵形式。例如：图像（参见 PIL 简明教程 - 像素操作与图像滤镜）信息，机器学习任务中巨大的特征矩阵等。此处我们循着前文的轨迹，以图像信息的形式直观地展现 SVD 分解在图形压缩中的应用。 首先让我们回顾一下曾经见过的猫咪，它长这样： 经过 SVD 分解之后，RGB 三通道的奇异值值分别形如（代码）： 123456789101112131415161718192021222324[ 8.29754663e+04 1.43568761e+04 8.28098602e+03 7.94075752e+03 6.87204550e+03 4.64118946e+03 3.07326587e+03 2.64043230e+03 2.34251575e+03 2.08293043e+03 1.81457650e+03 1.73772694e+03 1.55535238e+03 1.44987605e+03 1.28556279e+03 1.18657598e+03 1.15156737e+03 1.10588319e+03 1.04069060e+03 9.63555279e+02 ... 2.07308001e+00 2.03810704e+00 2.01670137e+00 1.89766075e+00 1.78169821e+00][ 7.52035286e+04 1.45096769e+04 1.02416708e+04 7.99187399e+03 5.55763091e+03 4.82795595e+03 3.22590281e+03 2.81678573e+03 2.47269533e+03 2.05484885e+03 1.87922653e+03 1.67558281e+03 1.55022246e+03 1.48494502e+03 1.30714569e+03 1.19338672e+03 1.17078655e+03 1.07687752e+03 1.04558020e+03 9.93807772e+02 ... 2.08166328e+00 2.03020090e+00 1.95633445e+00 1.88738236e+00 1.80539295e+00][ 7.15164941e+04 1.60372342e+04 1.20401757e+04 8.69602152e+03 5.69604800e+03 3.76913288e+03 3.48390702e+03 3.17683272e+03 2.73730517e+03 2.32005514e+03 2.08571764e+03 1.76733763e+03 1.55393096e+03 1.47436741e+03 1.39202168e+03 1.21607022e+03 1.17991116e+03 1.16377337e+03 1.01255317e+03 9.97811473e+02 ... 2.17604369e+00 2.13041080e+00 1.99837012e+00 1.88718778e+00 1.80040166e+00] 当我们从大到小开始截断，丢弃较小的奇异值并重建图像之后，我们就能得到「压缩之后」的图像了。 当只取 1 个奇异值时，重建图像如下。基本啥也看不出。 当只取 5 个奇异值时，重建图像如下。此时已经勉强能看出一只猫咪的形象了。 按照观察，在第 20 个奇异值附近，奇异值的大小有数量级的变化（从 +03 跌落至 +02）。因此，当取 20 个奇异值时，重建图像如下；此时猫咪的形象已经很清晰了。 当取用 50 个奇异值时，重建的图像和原图已经相当接近了。 类似地，我们还可以观察取用 100/200/300/400 个奇异值时，重建图像得到的结果。]]></content>
      <categories>
        <category>Mathematics and Natural Sciences</category>
      </categories>
      <tags>
        <tag>Matrix</tag>
        <tag>SVD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 LaTeX 中为参考文献的标题编号]]></title>
    <url>%2F2017%2F11%2F03%2Fnumbering-thebibliography-in-LaTeX%2F</url>
    <content type="text"><![CDATA[一般来说，参考文献、索引等章节的标题在论文中是不编号的。但是，在一些特殊情况下，我们可能也需要为这些标题做章节编号。 这边文章介绍如何处理此类情况。 对参考文献来说，不论采取何种方式，大体上最终都是用 LaTeX 提供的 thebibliography 环境来排版参考文献列表。这个环境一方面打印参考文献标题，另一方面打印参考文献列表。而打印参考文献标题的方式，就是调用 \section*（在 article 文档类中）或 \chapter*（在 book 类中）。 因此，我们需要做的事情，就是重定义 thebibliography 环境，使其调用 \section 或 \chapter，而不是带星号的版本。 在 LaTeX2e 当中，定义名为 foo 的环境，实际上定义了两个命令：\foo 和 \endfoo。前者用于开始环境，而后者用于结束环境。显而易见，thebibliography 环境对应的两个命令是 \thebibliography 和 \endthebibliography；而 \section* 或 \chapter* 的调用位于 \thebibliography 当中。因此，我们只需要使用 xpatch/etoolbox 宏包提供的 \xpatchcmd/\patchcmd 对 \thebibliography 打上补丁即可。 \xpatchcmd/\patchcmd 的介绍和用法可以参见这里和这里。 以下是在 article 文档类中的最简示例。 numbered_bibliography.tex12345678\documentclass&#123;article&#125;\usepackage&#123;xpatch&#125;\xpatchcmd&#123;\thebibliography&#125;&#123;\section*&#125;&#123;\section&#125;&#123;&#125;&#123;&#125;\begin&#123;document&#125;\begin&#123;thebibliography&#125;&#123;0&#125; \bibitem&#123;citekey&#125; test\end&#123;thebibliography&#125;\end&#123;document&#125; 生成带编号的索引标题可以采用类似的方案操作，此处不表。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Section</tag>
        <tag>Numbering</tag>
        <tag>Bibliography</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利息、贷款、按揭以及信用卡分期]]></title>
    <url>%2F2017%2F11%2F02%2Fcredit-card-installment-repayment-is-not-worthwhile%2F</url>
    <content type="text"><![CDATA[最近在自如租房时，负责租房的管家提供了名为「自如分期」的房租付款方式。观其操作模式，与信用卡分期还款、银行现金贷基本无差。印象里，以前有看到过文章讲述信用卡分期还款是不划算的；所以，在选择付款方式时，我就多留了一个心眼。 这里，将相关的分析，记录下来。以便让后来者明白：为什么说信用卡分期还款是不划算的。 利息和利率利息和利率是大家都很熟悉的概念，但是对此二者深入思考的人恐怕不多。为了给读者树立利息的意义，此处我们给出一个抽象的表述：利息（或贴现）度量了资金在时间上积累的价值。 具体是什么意思呢？我们考虑，利息是负债方在还债时向债权方额外支出的费用；因此，负债方实际上是用利息向债权方「购买」了本金在一定时间内的流动性（使用权）。这就是说，利息实际上度量了债权方借出的本金在这段时间内积累的价值。 举例来说，Alice 作为债权方向负债方 Bob 借出 1,000 元，双方约定一年期后，Bob 以 10% 的利率一次性还清本息。那么，一年后，Alice 就会收到 1,100 元。 时间 Alice Bob Bob 的借款本金 借出前 1,000 100 0 借出后 0 1,100 1000 一年后 1,100 0 0 单利与复利在上一节的例子当中，Alice 和 Bob 约定的借款周期是一年，只有一次计息。因此，在上一节的例子当中，不存在单利与复利的分别。这一节，我们介绍单利和复利的分别，以及和收息方式的联系。 所谓单利，指的是在多轮计息的过程中，每次计息的本金保持不变；而复利指的是，在多轮计息的过程中，前次计息产生的利息，作为下一次计息的本金。可以想见，复利的计息方式在长时间积累之下，会产生远高于单利的利息。因此，复利又被称为「利滚利」或「驴打滚」，以形容其在长时间积累之下的可怕「威力」。 我们先来看单利的情况。Alice 作为债权方向负债方 Bob 借出 1,000 元，双方约定借款 3 年，每年年末 Bob 按 10% 的利率向 Alice 支付利息，第 3 年年末还清本金。这样一来，我们有： 时间 Alice Bob Bob 的借款本金 借出前 1,000 300 0 借出后 0 1,300 1,000 一年后 100 1,200 1,000 两年后 200 1,100 1,000 三年后 1,300 0 0 由于 Bob 每年都向 Alice 支付借款利息，因此每年计息时，本金都是 1,000 元。因此，Bob 每次向 Alice 支付的利息，都是 $1000 * 10\% = 100$ 元。 接下来，我们来看复利的情况。Alice 作为债权方向负债方 Bob 借出 1,000 元，双方约定借款 3 年，每年年末按 10% 的利率计算利息并计入本金，第 3 年年末一次性还清本金利息。这样一来，我们有： 时间 Alice Bob Bob 的借款本金 借出前 1,000 331 0 借出后 0 1,331 1,000 一年后 0 1,331 1,100 两年后 0 1,331 1,210 三年后 1,331 0 0 由于每年计息 10% 后计入下一周期的本金，故此 Bob 的借款本金逐年上升。这样一来，三年之后，Bob 总共需要向 Alice 支付 $1000 * (1 + 10\%)^{3} - 1000 = 331$ 元的利息。 在这一节的两个例子当中，Alice 和 Bob 的借贷关系均维持 3 年，借贷利率均为 10%；仅因为还款、计息的方式不同，导致了单利和复利的差别，最终导致 Bob 支付利息总额的区别。由此可见，收息方式会影响利息的计算方式，并影响最终的利息总额。在日常金融生活中，我们应当特别注意收息方式对资金运转的影响。 在大多数的金融活动中，都能看见复利的影子；相对来说，在真实的金融生活中，单利使用得较少。当然，这不是说单利就不存在了。据我了解，一些银行的消费类贷款，就是以单利做计算的：负债方定期向债权方支付等额的利息，到期后归还最后一期利息和全部本金。 计息周期与利率在上一节的例子当中，Alice 和 Bob 约定的计息方式和利率均以「年」为单位计算。在实际生活当中，利率常以年计算，但计息周期往往不为整一年。例如，在下面这个例子中，计息周期为三月：Alice 作为债权方向负债方 Bob 借出 1,000 元，双方约定借款 1 年，利率为 12%，每 3 月计息一次，到期后一次性付清所有本息。这样一来，我们有： 时间 Alice Bob Bob 的借款本金 借出前 1,000 125.5 0 借出后 0 1125.5 1,000 3 月后 0 1125.5 1,030 6 月后 0 1125.5 1,060.9 9 月后 0 1125.5 1,092.73 一年后 1125.5 0 0 这里，具体的计算过程如下： 年利率为 12%，那么 3 个月的利率为 3%； 按利率 3% 计息 4 个周期，本息合计 $1000 * (1 + 3\%)^{4} \approx 1125.5$ 元。 我们知道，若按第一节中的还款方式，Bob 只需在年末还给 Alice $1000 * (1 + 12\%) - 1000 = 120$ 元的利息。如此，我们仅仅改变了计息周期（从一年改为一季度），Bob 就不得不还给 Alice $125.5$ 元的利息。这样算下来，实际上 Bob 承担了 12.55% 的年利率。 由此，我们引出了名义利率和实际利率的关系。设债权方向负债方借出本金 $P$，约定名义年利率为 $r$，年计息 $n$ 次，则一年后本息合计为 $$F = P \cdot \Bigl(1 + \frac{r}{n}\Bigr)^n,$$ 实际利率为 $$i = \Bigl(1 + \frac{r}{n}\Bigr)^n - 1.$$ 不难看出，当 $n = 1$ 时，名义利率即为实际利率；当 $n &gt; 1 $ 时，名义利率小于实际利率；当 $n &lt; 1$ 时，名义利率大于实际利率。 在现实生活中，约定的利率默认都是名义利率。 时间上积累的价值至此，我们已经见过了了利息、利率、单利、复利、计息周期、名义利率、实际利率等概念。若是没有提纲挈领的领悟，想必是挺令人犯恶心的。因此，这一节做一个小结——回到刚开始时的说明：利息（和贴现）度量了资金在时间上积累的价值。 在第一节的例子中，Alice 将 1,000 元钱借出给 Bob 一年。因此，Alice 丧失了这 1,000 元在接下来一年中的流动性。作为补偿/报酬，Bob 在一年后按约定给 Alice 100 元的利息。这 100 元的利息，即是 Alice 借出的 1,000 元在一年时间内积累下来的价值。 在第二节的单利的例子中，由于 Bob 每年都向 Alice 支付利息，也就是每年都补偿了 Alice 借出的 1,000 元在经历的这一年的时间积累的价值，因此每年只需要支付 100 元的利息。这就是单利的实质。 在第二节的复利的例子中，由于 Bob 直到最后一年才一次性还清本息；所以，Bob 本应在第一年年末支付的 100 元利息并没有支付，这就相当于 Bob 在第一年年末又向 Alice 借款 100 元。这样一来，原始的 1,000 元本金在第二年产生 100 元利息；新借的 100 元在第二年产生 10 元利息。加起来，第二年一共产生 110 元利息。以此类推，就变成了复利的模样。这就是复利的实质——每个周期的利息也要在时间上积累产生价值。 第三节介绍计息周期的例子和第二节的复利的例子是类似的。 这样一来，不论是利息多少、怎样计息、计息周期如何，我们都能得到统一的规律：利息系统是公平的，负债人应当支付的利息，等同于他在计息周期起始时应当偿还的金额（本金）在计息周期中积累的价值。简单来说就是：欠多少钱，计多少利息。 理解这个规律之后，接下来的内容就能以此提纲挈领了。 等额本金和等额本息接下来，我们进入更加复杂的领域，两种不同的还款方式：等额本金和等额本息。 在上述所有例子当中，Bob 归还本金都是在约定时间末期一次性归还的。然而，在现实生活中，例如购房贷款都不是这样操作的。事实上，更多的借贷还款，每次还款都同时要偿还本金和支付利息。于是，按照不同的需求，就产生了两种还款方式。 等额本金第一种还款方式是等额本金。这种还款方式一如其名：每次还款中，本金部分保持等额。也就是说，假设 Alice 作为债权方向负债方 Bob 借出 1,200 元，约定年利率 12%，按月计息；Bob 以等额本金的方式分 12 期还款。那么，Bob 每个月还款中本金部分是相等的，均为 $1200 / 12 = 100$ 元。这样一来，我们有 时间 Bob 剩余应还本金 Bob 本期应还利息 Bob 本期应还本息合计 借款后 1,200 0 0 1 月后 1,100 12 112 2 月后 1,000 11 111 3 月后 900 10 110 4 月后 800 9 109 5 月后 700 8 108 6 月后 600 7 107 7 月后 500 6 106 8 月后 400 5 105 9 月后 300 4 104 10 月后 200 3 103 11 月后 100 2 102 一年后 0 1 101 合计 N/A 78 1278 这样的还款方式是符合我们之前所说的「欠多少钱，计多少利息」的。例如说，8 个月后的还款，因月利率是 1%，而 7 个月还款后尚欠款 500 元本金，故此 8 个月后的还款应当还本金 100 元以及利息 5 元，共 105 元。 对于这种还款方式，由于剩余应还本金呈等差序列下降，所以每期归还的利息也呈等差序列下降；这样一来，每次还款的金额也就呈等差序列下降；但是每期还款之中的本金部分是相等的。 这样一来，假设总借款额度为 $P$，年利率为 $r$，年计息 $n$ 次，分 $k$ 个计息周期还款，则第 $i$ 次还款应还的额度为 $$F_i = \frac{P}{k} + \Bigl(1 - \frac{i - 1}{k}\Bigr)\cdot P\cdot \frac{r}{n},$$ 总计应还款额度为 $$F = P\cdot \Bigl(1 + \frac{r}{n}\cdot\frac{k + 1}{2}\Bigr),$$ 总计应还的利息为 $$I = P\cdot\frac{r}{n}\cdot\frac{k + 1}{2}.$$ 等额本息与等额本金相对，还有一种还款方式是等额本息。本息合计即为应还款的总额，因此等额本息还款方式每次还款的金额是相等的。相比等额本金，等额本息的计算稍微复杂一些。 假设总借款额度为 $P$，年利率为 $r$，年计息 $n$ 次，分 $k$ 个计息周期还款，每次还款金额为 $X$，则第 $i$ 次还款后，尚欠款为 $$P_i = P_{i - 1}\Bigl(1 + \frac{r}{n}\Bigr) - X = P\Bigl(1 + \frac{r}{n}\Bigr)^{i} - X\cdot \sum_{j = 0}^{i - 1}\Bigl(1 + \frac{r}{n}\Bigr)^{j}.$$ 这样一来，有 $$P_k = P_{k - 1}\Bigl(1 + \frac{r}{n}\Bigr) - X = 0,$$ 也就是 $$P\Bigl(1 + \frac{r}{n}\Bigr)^{k} - X\cdot\frac{(1 + \frac{r}{n})^{k} - 1}{\frac{r}{n}} = 0.$$ 这样一来，每次还款的金额为 $$X = P\cdot\frac{\frac{r}{n}\cdot(1 + \frac{r}{n})^{k}}{(1 + \frac{r}{n})^{k} - 1},$$ 以及总的利息是 $$I = P\cdot \biggl(k\cdot\frac{\frac{r}{n}\cdot(1 + \frac{r}{n})^{k}}{(1 + \frac{r}{n})^{k} - 1} - 1 \biggr).$$ 因此，假设 Alice 作为债权方向负债方 Bob 借出 1,200 元，约定年利率 12%，按月计息；Bob 以等额本息的方式分 12 期还款。那么，Bob 每个月还款额是相等的，均为 106.62 元。这样一来，我们有 时间 Bob 剩余应还本金 Bob 本期应还利息 Bob 本期应还本息合计 借款后 1,200 0 0 1 月后 1,105.38 12.00 106.62 2 月后 1,009.81 11.05 106.62 3 月后 913.29 10.10 106.62 4 月后 815.80 9.13 106.62 5 月后 717.34 8.16 106.62 6 月后 617.89 7.17 106.62 7 月后 517.45 6.18 106.62 8 月后 416.00 5.17 106.62 9 月后 313.54 4.16 106.62 10 月后 210.06 3.14 106.62 11 月后 105.54 2.10 106.62 一年后 0 1.06 106.62 合计 N/A 79.44 1279.44 在计算的过程中，我们也遵循了之前所说的「欠多少钱，计多少利息」的规律。因此，不论是等额本息还是等额本金，在利率确定的情况下，以「资金在时间上积累是有价的」这个角度，两种还款方式是等价的。 然而，我们也应当注意到，等额本息方式还款的总利息要高于等额本金；但等额本金方式还款初期的每期还款额较高。这两个现象在贷款额度大、还款期限小时表现得特别明显。因此，在实际生活中，具体选用哪种还款方式，要根据具体的资金情况来决定。 信用卡分期还款这里我们以招商银行信用卡分期还款的 12 期版本为例。按照招行的宣传，分期还款无利息，但是要收取每期 0.66% 的手续费。很多人会将这 0.66% 的手续费率理解为实际月利率，从而计算名义年利率为 7.92%。但这是个坑。 为方便对比，我们仍以 1,200 为例。以下是我尝试在招商银行掌上生活 App 中为 1,200 元进行 12 期信用卡分期付款的截屏。 从截屏中，我们不难看到： 分期总额为 1,200 元； 分 12 期； 每期还款 107.92 元； 每期还款包含手续费 7.92 元。 乍一看，这应该是类似「等额本息」的还款方式。但是其实不然，因为，若按照真正的等额本息还款，每期还款额应该是 106.62 元，而不是 107.92 元。猫腻就藏在这里了。我们将还款记录如下 时间 剩余应还本金 本期应还利息 本期应还本息合计 借款后 1,200 0 0 1 月后 1,100 7.92 107.92 2 月后 1,000 7.92 107.92 3 月后 900 7.92 107.92 4 月后 800 7.92 107.92 5 月后 700 7.92 107.92 6 月后 600 7.92 107.92 7 月后 500 7.92 107.92 8 月后 400 7.92 107.92 9 月后 300 7.92 107.92 10 月后 200 7.92 107.92 11 月后 100 7.92 107.92 一年后 0 7.92 107.92 合计 N/A 95.04 1295.04 不难发现，在这样一个还款记录表中，剩余应还本金如同等额本金一样，呈等差序列逐渐下降；然而应还本息合计却如等额本息一样，保持不变。这样一来，相当于变相提高了年化利率。 那么，这种还款方式的实际利率是多少呢？我们说，利率的计算，应当本着「欠多少钱，计多少利息」的原则。纵观整 12 次还款，平均下来每期的应还本金为 650 元。因此，平均月利率为 $7.92 / 650 = 1.22\%$；换算下来，年化利率就应该是 $1.22\% * 12 = 14.62\%$。 这是一个相当高的利率了，与宣传的 7.92% 相去甚远。因此，我们说，信用卡分期还款是非常不划算的。 按公式记录如下：假设总分期金额为 $P$，每次付款的手续费率占总分期金额的比例是 $r$，共分期 $k$ 次，那么实际利率应该是：$$\frac{2k^{2}r}{k + 1} \times 100\%.$$例如，在我们的例子当中，计算如下：$$\frac{2\times 12^{2}\times 0.66\%}{13} \times 100\% \approx 14.62\%. $$ 当然，我们必须承认，信用卡分期还款的方式也确实为我们提供了一种新的资金运转思路。在一些特定的情况下，选择分期还款也可以是一种不错的方式；但这就需要我们足够清醒，能够具体分析自己的财务状况和未来规划之间的平衡了。 特别地，自如提供的一些房子，月付和季付的价格是不同的：通常月付的价格会比季付高出不少；但是，使用自如分期，则能以季付的价格进行分期总价的计算；同时自如分期还会在服务费上有一定的优待。因此，在长期来看，若不在乎因分期带来的总价增长，同时却无法在短期内承受一次性支出季付价格，那么选择自如分期就是不错的方案。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Credit Card</tag>
        <tag>Banking</tag>
        <tag>Accounting</tag>
        <tag>Loan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为 Hexo 博客创建本地搜索引擎]]></title>
    <url>%2F2017%2F09%2F21%2Flocal-search-engine-in-Hexo-site%2F</url>
    <content type="text"><![CDATA[自 2014 年，始终博客就开始使用 Hexo 这个静态站点生成工具了；犹记得当时参考的文章，是 Bruce 的 Hexo 你的博客。 始终博客采用的主题，是 iissan 创建的 NexT。NexT 主题默认提供了两个站内搜索解决方案：swiftype 和 tinysou。早年时候，始终博客采用了 swiftype 作为站内搜索方案；但后来因为 swiftype 改版而失效，就放弃了。 近期，随着始终博客的文章数量不断增加，陆续有友人建议应该为博客加上搜索功能。然而，出于几方面的考虑，我一直没有加上搜索功能： 不愿意受限于第三方服务，第三方服务可能说变就变——曾经的各种博客网站，以及 swiftype 就是如此； 不喜欢第三方服务的样式，与博客样式脱节； 使用第三方服务，需要应用第三方的 JavaScript 脚本等内容，可能存在安全风险。 经过检索之后，我发现 Hexo 已有可以接受的解决方案了。本文来介绍如何在 Hexo 博客中建立自己的本地搜索引擎。 思路分析对于大型搜索引擎来说，在抓取并处理好网页之后，就要建立所谓的「倒排索引」了。所谓倒排索引，指的是以检索词的 term 为键，以包含该 term 的文档列表为值。如此一来，我们就可以根据检索词中的各个 term，获取若干列表。而后，对这些列表求交集，就能得到「包含检索词中所有 term」的文档了。 在个人网站上，特别是 Hexo 生成的静态站点，做类似的工作是不太容易的。这里原因有几点，分列如下 Hexo 生成的是静态站点，因此无法利用服务器做数据库的存储和相关计算； 这就制约了倒排索引的存储和求交； 另外一方面，制作倒排索引的过程，需要应用完善的 NLP 分词，这一工程量相对巨大。 考虑到我们无法在服务器上做数据库存储，我们就必须以文件的形式保存索引，让用户以浏览器下载该文件。此外，考虑到我们无法在服务器上做计算，我们就必须依赖可在浏览器上执行的代码，处理用户的检索任务。因此，我们说，仿照大型搜索引擎制作站内搜索，对于静态站点来说，是不现实的。 那么，我们可以怎样做呢？既然标准的方案无法达成，那我们就只能退而求其次。 首先，不管怎样「求其次」，都必须要有一个索引文件。这是因为，在索引文件当中进行各种操作，总是要比直接对网页页面进行操作来得要方便和快捷的。因此，首先我们需要一个能够嵌入 Hexo 的工具，方便地生成这样的索引文件。其次，有了索引，我们需要一个有效的算法：根据用户输入的检索词，返回包含检索词的文章列表。考虑到这样的算法需要在用户的浏览器上执行，我们选择使用 JavaScript 和 jQuery 来实现。接下来，为了与用户交互：接受检索词和返回结果；我们需要在页面的合适位置展示搜索框和输出结果。最后，还有一些细节问题需要处理。例如说，搜索框和输出结果的样式要如何设计；例如说，索引文件通常比较大，随页面一起下载会导致页面加载缓慢，要如何解决这个问题。 我们依次来解决这些问题。 用 hexo-generator-search 生成索引HaHack 参考 Christian Fei 的 Simple Jekyll Search 实现了名为 hexo-generator-search 的生成器。安装该生成器之后，在执行 hexo generate 的过程中，会按照配置生成一个 XML 文件，用于保存全站的文档数据。这个 XML 文件只是简单地做了数据的结构化存储，而完全没有考虑分词、倒排等问题。 安装 hexo-generator-search 非常简单，只需要在 Hexo 项目目录下执行下列命令即可。 1npm install --save hexo-generator-search 如此一来，我们只需在站点配置文件 _config.yml 当中写入如下配置，即可为全站的文档生成索引文件了。 123search: path: search.xml field: post 具体来说，hexo-generator-search 会为全站所有 post 类型的页面生成结构化的数据，并保存在本站的 /search.xml 当中。若想让 page 类型的页面也纳入索引，则可以将 field 的值修改为 all。 用 JavaScript 和 jQuery 实现检索算法另外一方面，HaHack 建议以 jQuery 的文本匹配为基础，在前端界面上运行站内搜索。主要的处理流程是： 载入 search.xml； 解析 search.xml； 解析检索词； 在索引中进行字符串匹配； 展现结果。 我对官方的版本进行了少许的修改（后详），并加入了注释。这样应该相对比较好理解了。你可以在 GitHub 上看到我修改的版本。 需要注意的是，search.js 依赖 jQuery。因此，你需要在引入 search.js 之前，引入 jQuery 的脚本。比如，你可以在 head 部分这样做：&lt;script src=&quot;//cdn.bootcss.com/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt;。 在合适的位置展示搜索框接下来，我们需要在合适的位置，呈现一个搜索框。 1234&lt;form class="site-search-form"&gt; &lt;input type="text" id="local-search-input" class="st-search-input" /&gt;&lt;/form&gt;&lt;div id="local-search-result" class="local-search-result-cls"&gt;&lt;/div&gt; 此处，local-search-input 是一个输入框，用于接收用户输入的检索词；local-search-result 是用于展现搜索结果的 div 标签。这部分代码，我也已上传到 GitHub。 其他一些细节调用函数现在，我们已经有了索引文件、搜索算法和搜索框。但是，现在而言，搜索框是孤立的：用户在搜索框中输入内容，并不会触发搜索算法。换而言之，搜索函数并没有调用。因此，我们需要调用定义在 search.js 当中定义的 searchFunc。 12var path = "/search.xml";searchFunc(path, 'local-search-input', 'local-search-result'); 在何时的时候触发搜索函数像上面这样调用搜索函数，有一个潜在的问题。调用搜索函数时，首先会尝试载入并解析 search.xml 文件。这个文件包含了站点里所有博文的所有内容；因此，通常来说它的体积非常大。这样一来，如果不做任何限制，函数将在网页加载时被调用；因而，体积庞大的索引文件也将在网页加载的时候引入。这会导致网页整体加载的速度非常缓慢，对用户体验是一种伤害。 因此，我们会考虑，在激活搜索框时，我们才去调用搜索函数。 12var inputArea = document.querySelector("#local-search-input");inputArea.onclick = function()&#123; getSearchFile() &#125; 此处，我们通过 inputArea 这个变量，监控搜索框的状态。只有当用户用鼠标点击搜索框时，才会触发 getSearchFile 函数，载入索引文件并执行 searchFunc。 getSearchFile 函数定义在 search.js 脚本当中了。 不过，这还不够。因为，如此一来，每次用户点击搜索框时，都会触发一次 searchFunc 函数，并加载一次 search.xml 索引文件。我们期待的是，只有当用户第一次点击搜索框之后，才去下载索引文件；之后的搜索行为，直接复用上一次加载的文件即可。 为此，我们需要在执行好 getSearchFile 函数之后，禁用 onclick 时间的 handler。 12var inputArea = document.querySelector("#local-search-input");inputArea.onclick = function()&#123; getSearchFile(); this.onclick = null &#125; 在搜索框中屏蔽回车由于我们在搜索框中使用了 input 标签。这是一个表单，但我们不希望它具有一些表单的行为。例如说，我们的搜索结果是实时呈现的；我们不希望用户在输入检索词之后，误按回车键，导致页面刷新。 为此，我们可以这样做。 1inputArea.onkeydown = function()&#123; if(event.keyCode == 13) return false &#125; 在加载索引文件时，给用户一个提示我们为了保护页面加载的速度，将加载索引文件的过程，后移到用户点击搜索框时进行。然而，如前所述，索引文件通常是比较大的；加载并解析索引文件通常会耗费不少时间。在这个过程中，用户可能已经输入了一些检索词；这些检索词，会因为尚未加载完毕索引文件，而得不到任何的检索结果。这当然是不合适的。 因此，我们需要在加载和解析索引文件的过程中，给用户一个清晰的提示。为此，我们需要修改 search.js 脚本。 12var $resultContent = document.getElementById('local-search-result');$resultContent.innerHTML = BTN + "&lt;ul&gt;&lt;span class='local-search-empty'&gt;首次搜索，正在载入索引文件，请稍后……&lt;span&gt;&lt;/ul&gt;"; 将这段代码放在加载和解析索引文件之前，就能在 local-search-result 中提示「正在载入索引文件」了。 样式表最后，我们可以通过样式表来控制这一系列内容的呈现形式。始终博客使用的样式表可以在 GitHub 上找到。 做完了这些工作，就可以查看效果啦。始终博客的搜索框位于页面的右上角。 参考资料： http://hahack.com/codes/local-search-engine-for-hexo/ http://moxfive.xyz/2016/05/31/hexo-local-search/ http://www.barretlee.com/blog/2017/06/04/hexo-search-insite/ https://github.com/barretlee/hexo-search-plugin-snippets https://github.com/Liam0205/hexo-search-plugin-snippets]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Search Engine</tag>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTeX 黑魔法（五）：在 LaTeX 中输出多国语言]]></title>
    <url>%2F2017%2F09%2F17%2FLaTeX-multi-lingual%2F</url>
    <content type="text"><![CDATA[在 LaTeX 中输出英文之外的其他字符总是不那么自然，需要一些折腾。例如让 LaTeX 输出中文就走过了天元、CCT、CJK、xeCJK 这些路子。 以现在（2017-09）来说，在 LaTeX 中混排中英双语已经不是什么难事，只需要使用 xeCJK 宏包或者 CTeX 宏集即可。但若是想要在一篇文档里排版多语言，则很多人就不知道怎么办了。 需要解决的问题在 LaTeX 中输入多国语言，主要来说，现代的方案就是要解决三件事情： 使用一个包含文档所需所有字符的编码方案； 使 TeX 支持选定的编码方案； 选取合适的字体。 对于编码来说，使用 Unicode 字符集对应的编码方案自然是最简单的。当然，语言本国人自己使用的话，也可能会使用当地的编码（例如俄罗斯人的话可能会使用 CP1251）。若是要同时使用多国语言，则最好还是使用 UTF-8 编码。 对于 TeX 来说，支持 UTF-8 编码的文稿，又分成两类情况。对于 XeLaTeX/LuaLaTeX 来说，它们原生就支持，因此不需要做特别的处理。对于不直接支持 UTF-8 编码的排版命令来说，就需要使用 \usepackage[utf8]{inputenc} 显式地指明引擎吃进去的文稿是 UTF-8 编码的。 以俄语为例使用 XeLaTeX/LuaLaTeX 实现英文、俄文混排就很简单了。我们只需要使用 fontspec 宏包提供的接口，选定同时包含英文和俄文字符的字体即可。这里我们选用 CMU Serif；它包含在 TeX Live 当中。 1234567891011% !TeX encoding = UTF-8\documentclass&#123;article&#125;\usepackage&#123;fontspec&#125;\setmainfont&#123;CMU Serif&#125;\begin&#123;document&#125;\section&#123;Русский язык&#125;Русский язык\end&#123;document&#125; 若不想使用 XeLaTeX/LuaLaTeX，也可以这样做。 123456789101112% !TeX program = pdfLaTeX% !TeX encoding = UTF-8\documentclass&#123;article&#125;\usepackage[utf8]&#123;inputenc&#125;\usepackage[T2A]&#123;fontenc&#125;\begin&#123;document&#125;\section&#123;Русский язык&#125;Русский язык\end&#123;document&#125; 多国语言怎么办？其实，对于大多数文字来说，多国语言混排和英文俄文双语混排没什么差别。无非就是老三样： UTF-8 编码保存文稿； 使 TeX 引擎支持 UTF-8 编码； 选择合适的字体。 例如，我们可以实现英文、希伯来文（需要字体支持）、希腊文、拉丁文、西班牙文、俄文、中文的混排。 CMU Serif 不包括希伯来文字母，因此你可能需要下载并安装 LinLibertine 字体。 12345678910111213141516171819202122232425262728293031323334353637\documentclass&#123;article&#125;\usepackage&#123;hyperref&#125;\usepackage&#123;fontspec&#125;\setmainfont&#123;CMU Serif&#125;% \setmainfont&#123;LinLibertine&#125;\usepackage&#123;xeCJK&#125;\begin&#123;document&#125;\section*&#123;The Tower of Babel, Genesis 11:7&#125;\subsection*&#123;English&#125;Come, let us go down and confuse their language so they will not understand each other.% \subsection*&#123;Hebrew&#125;% הָ֚בָה נֵֽרְדָ֔ה וְנָבְלָ֥ה שָׁ֖ם שְׂפָתָ֑ם אֲשֶׁר֙ לֹ֣א יִשְׁמְע֔וּ אִ֖ישׁ שְׂפַ֥ת רֵעֵֽהוּ׃%\subsection*&#123;Greek&#125;δεῦτε καὶ καταβάντες συγχέωμεν ἐκεῖ αὐτῶν τὴν γλῶσσαν, ἵνα μὴ ἀκούσωσιν ἕκαστος τὴν φωνὴν τοῦ πλησίον.\subsection*&#123;Latin&#125;venite igitur descendamus et confundamus ibi linguam eorum ut non audiat unusquisque vocem proximi sui\subsection*&#123;Spanish&#125;Será mejor que bajemos a confundir su idioma, para que ya no se entiendan entre ellos mismos.\subsection*&#123;Russian&#125;сойдем же и смешаем там язык их, так чтобы один не понимал речи другого.\subsection*&#123;Chinese (Simplified)&#125;来，我们下去，在那里混乱他们的语言，使他们听不懂对方的话。%\bigskip\smallTexts from \url&#123;https://www.biblegateway.com&#125;.Greek Septuagint text from \url&#123;https://www.academic-bible.com/en/online-bibles/septuagint-lxx/read-the-bible-text/&#125;.\end&#123;document&#125;]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Multi-lingual</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最佳搭档：利用 SSH 及其配置文件节省你的生命]]></title>
    <url>%2F2017%2F09%2F12%2Frescue-your-life-with-SSH-config-file%2F</url>
    <content type="text"><![CDATA[SSH 协议是事实上的互联网基石之一。在 SSH 协议出现之前（1995 年由 Tatu Ylonen 设计），通过互联网远程登录其他设备（telnet）的过程是明文的。这意味着，整个通信过程，很容易被旁路嗅探，泄露敏感信息。 OpenSSH 是 SSH 协议的经典实现。目前，它作为各 Linux 发行版默认自带的 SSH 工具分发；因而广为使用。 若你在学习工作生活中，需要通过 SSH 协议，登录、管理多台服务器。那么，一方面你可能会厌烦记忆各个远程服务器的主机名/IP 地址；另一方面你可能会被繁琐的口令输入过程弄得烦躁不安。特别地，若是你需要在同一台远程主机上，打开多个终端窗口进行操作时；你可能需要反复输入多次用户名和口令（在不用 screen/tmux 之类的工具的前提下）。 这篇文章首先会尝试介绍 Linux 自带的 SSH 工具的基本用法，并附带介绍 SSH 配置文件的编写规则。而后，尝试解决上述繁琐的记忆和口令输入命令。 SSH我们说，在创造一件事情之前，你需要想清楚这件事情的意义是什么。通常而言，创造新事物的原动力，是我们发现了旧事物和我们目标之间存在的差距（gap）；而新事物就是为了填上这一差距的。因此，讲道理，我们首先应该去分析在 SSH 协议诞生之前人们使用的远程登录协议有哪些问题；而后去分析 SSH 分别是如何解决这些问题，填上所谓的 gaps 的。 然而，「空谈误国，实干兴邦」。一方面在没有任何实践之前，大谈理论是空洞的；另一方面，我们最终也是要将理论落实到时间上去。因此这一节，我们首先介绍/回顾 SSH 的最基本用法；而后讨论 SSH 是如何解决过去远程登录协议遗留下来的问题的；借此，我们将讨论 SSH 连接建立时会发生什么；介绍完这些内容之后，我们将介绍如何免密登录。 SSH 的基本用法Linux 下，ssh 命令的基本用法是 1ssh [params] [flags] [user@]remotehost [command] 先除去参数（params）和标识（flags）不论，以及不讨论后续的执行命令（command）；ssh 命令的基本用法是 ssh [user@]remotehost。若一切顺利，如此就能成功以用户 user 登录远程服务器 remotehost。其中，若你本地登录账户的用户名与远程服务器上的用户名一致，则可以省略 [user@]。 另外值得一提的是，这里说的 remotehost 指的是「逻辑上」的远程主机。实际上，若是你尝试执行下列命令，就能（利用本地回环）登录你本机的 foo 账户了。此时，本机的主机名/IP 地址，就充当了 ssh 命令中逻辑上的远程主机。 1ssh foo@localhost # 127.0.0.0/24, ::1 127.0.0.0/24 都是本地回环的 IPv4 地址。只不过，因为 127.0.0.1 是其中第一个合法的主机地址；所以被用来指代本地回环。但千万不要以为只有 127.0.0.1 这一个地址能够本地回环。: ) SSH 怎样防止信息泄露？前文提到，SSH 提出的背景即是在它出现之前，远程登录协议无法保障通信安全。那么，在 SSH 出现之前，远程登录可能面临哪些信息泄露风险呢？ 首先是前文提到的旁路嗅探。事实上，这是网络通信不可避免的问题；因为从我们本地主机到远程主机的通信链路，是广域网上通过 IP 协议路由实现的。在这一通信链路上，有太多我们无法控制的通信节点。因此，若是这其中但凡有一个节点被黑客控制，我们经由这条链路的通信信息，就可能被嗅探甚至篡改。 解决这一问题的根本办法是使用加密的信道。这一办法的思路在于，既然我们无法控制流量被嗅探/篡改，那么我们至少可以让敌手得到的信息是难以破译的密文（至少是破译成本远高于明文本身蕴含的价值）。SSH 协议正是这样做的：它通过非对称加密方法（公钥加密方法），在预先交换公钥的前提下，通信双方通过对方的公钥加密信息，而使用自身私钥解开密文。如此一来，若是能保证密钥交换的可信，则基于非对称加密方案的加密信道就是安全的。 除了旁路嗅探，信息泄露的另一大风险来自所谓的中间人攻击。中间人攻击的源头依然来自广域网路由的不可控性。设想，在我们的主机和目标远程主机的通信链路中间，有一个节点充当双面间谍：一方面，它在链路中间截获我们发出的信号，并伪装成目标主机予以返回；另一方面，它在链路中间伪装成我们的主机，转发我们的流量，给真实的远程主机。在这个过程中，如果没有恰当的身份验证手段，那么无论是我们的主机还是远程主机，都无法验证对方的身份。因此，事实上，一方面发起中间人攻击的敌手可以获取所有通信流量，另一方面它可以随意篡改通信流量而难以发现。考虑到上述加密信道的可信性，一方面基于非对称加密的安全性（在这里我们假设为 ground truth，不作怀疑），另一方面基于密钥交换的可信性；那么，由于中间人攻击可能在密钥交换阶段从中作梗，则若 SSH 协议不能妥善解决这一问题，则其安全性就仍然存疑。 这样一来，问题实际上转换成了密钥交换过程的身份验证问题。考虑到我们反复提及的广域网上的通信链路是不可信的；仅凭借当前通信进行身份验证，就变成了「鸡生蛋、蛋生鸡」的循环问题。因此，这类验证不得不采用所谓的「盘外招」。 SSH 的思路的关键点在于：既然正常信道建立后，远程主机需要将自己的公钥发送给本地主机，那么这一公钥本身就能看作是远程主机的一个身份：若是无法验证远程主机的身份，那么本地主机使用这一公钥进行信息加密是不安全的（因为公钥可能来自敌手，而加密信息可能被敌手使用正确私钥解密而窃取）；若是验证了远程主机的身份，则这一公钥就能放心地用来加密信息。因此，在 SSH 建立链接的过程中，它会要求本地主机的操作者确认远程主机返回的公钥的 hash 值。若这一 hash 值和操作者通过其他方式（盘外招）得到的值一致，则认可远程主机的身份。当然，这一验证不需要每次 SSH 连接时都进行——只需要验证一次，而后交由本地计算机验证 hash 与前次连接获得的 hash 的一致性即可。而这又要求本地计算机将远程主机的公钥 hash 值保存下来，以便下次核对。 SSH 远程登录的流程当本机发起登录请求时，SSH 会依次执行以下几个主要步骤： 通过远程主机公钥 hash，确认远程主机身份； 若通过，远程主机验证登录身份，例如：提示输入远程主机目标用户的口令； 本地主机将用户键入的口令，使用远程主机的公钥加密，并发送给远程主机； 远程主机使用上述公钥对应的私钥，对得到的密文进行解密； 远程主机验证解密后的口令； 若通过，则建立 SSH 连接，成功登录。 前面已经说过，localhost 也可以充当逻辑上的远程主机。这里我们就以 localhost 为例，验证一下这一过程。 1234$ ssh liamhuang@localhostThe authenticity of host 'localhost (127.0.0.1)' can't be established.ECDSA key fingerprint is 4d:28:ed:f1:3d:40:fe:68:c8:b3:b0:9b:a7:dc:5d:7e.Are you sure you want to continue connecting (yes/no)? 执行 ssh liamhuang@localhost 尝试以 liamhuang 的用户身份登录（逻辑上的）远程主机 localhost 时，SSH 如我们预期一样，提示我们验证远程主机的身份。这段文字翻译如下。 无法验证主机 ‘localhost (127.0.0.1)’ 的真实性。ECDSA 密钥指纹为 4d:28:ed:f1:3d:40:fe:68:c8:b3:b0:9b:a7:dc:5d:7e。你是否要继续连接？(yes/no) 标准的操作，我们必须通过额外的方式，与远程主机取得联系，验证这一指纹是否真实。不过，此处我们略去这一步骤，键入 yes。 1234567$ ssh liamhuang@localhostThe authenticity of host 'localhost (127.0.0.1)' can't be established.ECDSA key fingerprint is 4d:28:ed:f1:3d:40:fe:68:c8:b3:b0:9b:a7:dc:5d:7e.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added 'localhost' (ECDSA) to the list of known hosts.liamhuang@localhost's password:Last login: Tue Sep 12 17:49:33 2017 from 127.0.0.1 如前所述，为了下次自动地验证远程主机的身份，本地主机会将远程主机的公钥指纹保存下来。新出现的提示，翻译如下。 警告：已将 ‘localhost’ (ECDSA) 永久地加入已知主机列表之中。 在输入远程主机目标用户的口令之后（无终端回显），本地主机会将输入的口令以远程主机提供的密钥加密并发送给远程主机。待远程主机解密并验证通过后，即提示成功登录。 上一次成功登录：2017 年 9 月 12 日（周四）17:49:33，自 127.0.0.1。 那么，具体来说，本地主机将这一信息保存在哪里了呢？答案是当前用户的 ${HOME}/.ssh/known_hosts 文件当中。我们可以执行 exit 命令，退出远程主机；而后使用 tail 命令可以查看刚刚插入在该文件末尾的远程主机信息。 12$ tail -1 $&#123;HOME&#125;/.ssh/known_hostslocalhost ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBCPWoEQ7iCCYDrpyb5KeMmCaQ8aOnSfehqmrplZRkbqqnkS9++PdSX/eSLJ0tkFd5902/C+HTCqbDgso4mCKpMo= 使用公钥验证身份现在我们考虑下一个问题：除去输入远程主机用户口令的方式，是否还有其他方式能够验证登录者的身份？ 对于身份认证来说，通常有三种手段： 你知道的（例如账户口令）； 你独有的（例如网银的 U 盾）； 你身上的（例如指纹）。 通常来说，对于没有极端的安全性要求的场景，通过其一验证即可。在上述登录过程中，我们采取了「你知道的」这一手段来验证登陆者的身份。考虑到，对于远程登录来说，很难通过生物信息识别来验证身份；剩下可行的方案就是验证「你独有的」特殊物件来验证身份了。 对于「你独有的」这一手段来说，使用类似网银的 U 盾显然不现实。一则制作成本太高，二则相关的认证过于复杂。因此，我们须得考虑其他更易行的手段。 在 SSH 协议中，信道的安全是通过非对称加密保证的。事实上，非对称加密需要持有私钥。因此，私钥这件事情本身，也可以认为是一种「你独有的」东西。考虑到，在 SSH 登录成功之前，在不完整的信道中，从本地主机向远程主机通信是安全的（因为有远程主机的公钥可用于加密），而远程主机可以用持有的私钥解密本地主机发来的信息。（例如口令登录验证的过程）。类似的过程也可以反过来用： 本地主机生成一对非对称密钥； 本地主机将公钥交付远程主机； 远程主机在收到登录请求时，使用上述公钥加密一串无害的随机信息； 本地主机将接收到的密文，以本地持有的私钥解密，而后通过远程主机的公钥再进行加密； 远程主机使用相应私钥解密，并与上述随机信息进行比对； 若一致，则认可登录者的身份，许可登录。 在这个过程中，远程主机对比一来一回前后随机信息的一致性，验证了本地主机确实持有一个安全介质——本地主机生成的私钥。因此，这就不需要输入远程主机的用户口令了。 为此，我们首先需要生成一对密钥。 123456789101112131415161718192021$ ssh-keygenGenerating public/private rsa key pair.Enter file in which to save the key (/home/test/.ssh/id_rsa): /home/test/.ssh/id_rsa.testEnter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /home/test/.ssh/id_rsa.test.Your public key has been saved in /home/test/.ssh/id_rsa.test.pub.The key fingerprint is:91:cb:1d:45:65:27:76:cc:66:02:4d:e5:1f:c4:64:6d liam@localhostThe key's randomart image is:+--[ RSA 2048]----+| .o.*o*=.|| .o o.=== || + E .o.=|| . = +o|| S o .|| || || || |+-----------------+ ssh-keygen 是 OpenSSH 的一部分，它用于生成供 SSH 使用的密钥。默认情况下，ssh-keygen 生成的是 RSA 密钥（本机上是 2048 位 RSA），并将私钥保存在 ${HOME}/.ssh/id_rsa 当中。为了避免与已有的密钥冲突，这里我们另存为 id_rsa.test。随后，ssh-keygen 要求我们为生成的私钥设置口令（passphrase）。这一口令是对私钥进行保护的口令，可以留空。这样一来，我们就生成了一对 RSA 密钥。其中，私钥保存在 /home/test/.ssh/id_rsa.test 而公钥保存在 /home/test/.ssh/id_rsa.test.pub。 接下来，我们需要将生成的密钥交付给远程主机。为此，我们需要使用 ssh-copy-id 这一命令。 123456789$ ssh-copy-id -i ~/.ssh/id_rsa.test liamhuang@localhost/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keysliamhuang@localhost's password:Number of key(s) added: 1Now try logging into the machine, with: "ssh 'liamhuang@localhost'"and check to make sure that only the key(s) you wanted were added. ssh-copy-id 会将 ~/.ssh/id_rsa.test 对应的公钥，交付给 liamhuang@localhost。在这个过程中，我们需要输入用户 liamhuang 在远程主机 localhost 上的口令。注意，此处我们使用了 -i 参数，指定了需要交付的密钥。若是省略 -i 参数，则 ssh-copy-id 会将默认的密钥 ~/.ssh/id_rsa 对应的公钥交付给远程主机。 之后，我们就可以「免密登录」了。同样，我们需要使用 -i 参数指定所需使用的私钥。 12$ ssh -i ~/.ssh/id_rsa.test liamhuang@localhostLast login: Tue Sep 12 17:53:11 2017 from 127.0.0.1 类似上面提到过的 ~/.ssh/known_hosts，保存这类公钥也有一个特定的文件：远程主机目标用户的 ${HOME}/.ssh/authorized_keys。登录远程主机后，我们可以使用 tail 命令来查看刚刚添加的公钥。 1234$ tail -1 ~/.ssh/authorized_keysssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCiDajuJwE1cyrRxDiDNB+2T2WiWB29l7C61zfnSTFA31SrsWU2DGuC9qoFqRtsbXUXS57E0kmPSJzmkwj+EihHJmZUt6AXYx8UdwXtzSPyhkLH6K/iH2W4fxe9vMvzSdbhM58LUi9+4d1I3Zte9zdG1/boHPIH/+6reU/2V1l2rr44+/LzZoeoyVWICIq2gf7ZMxdJzLLUtuFUBMLIxre3sob6EYSeIJFPvMXfpk9D/Qxio+x8U+PdFOl5avA0m0BaaatXyBe0jhTs43YJOgONnbBQAuJOEJ8RKHgnEVUh1Wu7eIKheaHAeOqBiNW3UMEUDGY9dyInhvFR0tlY8jg5 test@localhost$ tail -1 ~/.ssh/authorized_keys | md5sum293b27ababace5a6004427af4b0739b9 - 返回到本地主机，可见它正是我们刚刚生成的公钥。 1234$ cat ~/.ssh/id_rsa.test.pubssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCiDajuJwE1cyrRxDiDNB+2T2WiWB29l7C61zfnSTFA31SrsWU2DGuC9qoFqRtsbXUXS57E0kmPSJzmkwj+EihHJmZUt6AXYx8UdwXtzSPyhkLH6K/iH2W4fxe9vMvzSdbhM58LUi9+4d1I3Zte9zdG1/boHPIH/+6reU/2V1l2rr44+/LzZoeoyVWICIq2gf7ZMxdJzLLUtuFUBMLIxre3sob6EYSeIJFPvMXfpk9D/Qxio+x8U+PdFOl5avA0m0BaaatXyBe0jhTs43YJOgONnbBQAuJOEJ8RKHgnEVUh1Wu7eIKheaHAeOqBiNW3UMEUDGY9dyInhvFR0tlY8jg5 test@localhost$ cat ~/.ssh/id_rsa.test.pub | md5sum293b27ababace5a6004427af4b0739b9 - 须得注意的是，出于安全性考虑，若要保证这一特性打开，远程主机上的相关文件必须限制除当前用户之外的权限。个人建议 .ssh 目录权限必须不高于 700；且 authorized_keys 文件权限必须不高于 600。 若是你的机器不支持 ssh-copy-id，也可以直接将公钥信息写入远程主机目标用户的 ${HOME}/.ssh/authorized_keys 当中。 1$ ssh liamhuang@localhost 'mkdir -p .ssh &amp;&amp; chmod 700 .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys &amp;&amp; chmod 600 .ssh/authorized_keys' &lt; ~/.ssh/id_rsa.test.pub SSH 的配置文件我们在文章开头处提出了利用 SSH 登录管理大量机器的两个不便： 需要记忆大量机器的主机名； 需要记忆、输入大量机器上的用户口令。 在上一节中，我们通过在本地主机生成公钥并交付远程主机，利用「你独有的」这条渠道完成了身份认证；从而避免了在登录时输入远程主机用户的口令。虽然，在示例中，我们不得不使用 -i 参数来指定希望使用的私钥文件路径。但这一方面是为了避免与本地主机当前用户默认密钥冲突，另一方面是为了演示这一参数的作用，再者也表明了本地主机用户可以使用功能多个密钥分别用于连接不同主机。 然而，尽管避免了输入口令，但是「需要记忆大量主机名」的问题没有解决；同时还引出了新的问题：需要使用 -i 参数指定私钥路径。怎样解决这些问题呢？ SSH 的配置文件与用户实际执行 ssh 命令时传入的参数协同作用。按照优先级，低优先级的配置项可视作默认值；而高优先级的配置项则会覆盖默认值。按优先级，有如下排序： 用户实际执行 ssh 时传入的参数； 用户的 SSH 配置文件 ${HOME}/.ssh/config； 系统的 SSH 配置文件 /etc/ssh/ssh_config。 这样一来，通过 SSH 配置文件，我们可以按访问的主机来配置 SSH 的默认行为。 SSH 配置文件的说明SSH 的配置文件有很多配置项可供配置。限于篇幅，此处显然是不可能穷尽的。因此，有兴趣的读者可以通过 man ssh_config 查看可用的配置项。 SSH 的配置文件采用空格分割的键值形式。例如 Host localhost 表示键 Host 对应的值为 localhost。此篇涉及到的键如下： Host：值为通配符的模式（Pattern）；该键之后的键值对，将用于匹配于该模式的主机。 HostName：值为真实的目标远程主机名；在值中，%h 可用于命令行接收到的主机名字的转义。 User：值为希望登录的远程主机的用户名； IdentityFile：值为希望登录时使用的密钥文件。 一个简单的例子这样一来，我们可以在配置文件中写入如下内容。 1234Host localliam HostName localhost User liamhuang IdentityFile /home/test/.ssh/id_rsa.test 这样一来，执行 ssh localliam 就相当于执行了 ssh -i /home/test/.ssh/id_rsa.test liamhuang@localhost 了。 12$ ssh localliamLast login: Tue Sep 12 19:03:16 2017 from 127.0.0.1 批量管理现在我们构建这样一个场景。我们有 1000 台服务器；它们的主机名编号从 w-i0.test.sh.localnet 一直到 w-i999.test.sh.localnet。那么，为了免密以 cloud 用户的身份登录这 1000 台机器，我们可以首先将准备好的公钥上传到这 1000 台机器上；而后在 SSH 配置文件里配置如下内容。 1234Host i? i?? i??? Host w-%h.test.sh.localnet User cloud IdentityFile ~/.ssh/id_rsa.test 这样一来，我们就只需要使用 ssh i73 就能以 cloud 用户的身份，登录 w-i73.test.sh.localnet 了。 更多场景在实际使用中，任何基于 SSH 之上的程序，都可以借助 SSH 配置文件达到简化的目的。例如，代码托管网站 bitbucket 支持通过 Git 来管理代码。而 Git 又是支持 SSH 方式与远程仓库进行通信。这样一来，我们就可以通过 SSH 配置文件，简化对 bitbucket 的访问；另一方面，通过 SSH 配置文件，我们可以将访问 bitbucket 时使用的密钥与其它密钥区分开。 首先，我们使用 ssh-keygen 生成一对专用于 bitbucket 的密钥；保存在 ~/.ssh/id_rsa.bitbucket 当中。而后，我们需要将 ~/.ssh/id_rsa.bitbucket.pub 中的内容，粘贴到 bitbucket 的账户设置中去。而后，我们可以在 SSH 配置文件中记录： 123Host bitb HostName bitbucket.org IdentityFile ~/.ssh/id_rsa.bitbucket 这样一来，git clone git@bitb:foo/bar.git 就能克隆 bitbucket 上 foo 用户的 bar 仓库了（前提是你的账户对这个仓库有访问权限）。]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>SSH</tag>
        <tag>Config</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员的自我修养（七）：内存缺页错误]]></title>
    <url>%2F2017%2F09%2F01%2Fpage-fault%2F</url>
    <content type="text"><![CDATA[众所周知，CPU 不能直接和硬盘进行交互。CPU 所作的一切运算，都是通过 CPU 缓存间接与内存进行操作的。若是 CPU 请求的内存数据在物理内存中不存在，那么 CPU 就会报告「缺页错误（Page Fault）」，提示内核。 在内核处理缺页错误时，就有可能进行磁盘的读写操作。这样的操作，相对 CPU 的处理是非常缓慢的。因此，发生大量的缺页错误，势必会对程序的性能造成很大影响。因此，在对性能要求很高的环境下，应当尽可能避免这种情况。 此篇介绍缺页错误本身，并结合一个实际示例作出一些实践分析。这里主要在 Linux 的场景下做讨论；其他现代操作系统，基本也是类似的。 内存页和缺页错误分页模式我们在前作内存寻址中介绍了 CPU 发展过程中内存寻址方式的变化。现代 CPU 都支持分段和分页的内存寻址模式。出于寻址能力的考虑，现代操作系统，也顺应着都支持段页式的内存管理模式。当然，虽然支持段页式，但是 Linux 中只启用了段基址为 0 的段。也就是说，在 Linux 当中，实际起作用的只有分页模式。 具体来说，分页模式在逻辑上将虚拟内存和物理内存同时等分成固定大小的块。这些块在虚拟内存上称之为「页」，而在物理内存上称之为「页帧」，并交由 CPU 中的 MMU 模块来负责页帧和页之间的映射管理。 引入分页模式的好处，可以大致概括为两个方面： 允许虚存空间远大于实际物理内存大小的情况。这是因为，分页之后，操作系统读入磁盘的文件时，无需以文件为单位全部读入，而可以以内存页为单位，分片读入。同时，考虑到 CPU 不可能一次性需要使用整个内存中的数据，因此可以交由特定的算法，进行内存调度：将长时间不用的页帧内的数据暂存到磁盘上。 减少了内存碎片的产生。这是因为，引入分页之后，内存的分配管理都是以页大小（通常是 4KiB，扩展分页模式下是 4MiB）为单位的；虚拟内存中的页总是对应物理内存中实际的页帧。这样一来，在虚拟内存空间中，页内连续的内存在物理内存上也一定是连续的，不会产生碎片。 缺页错误当进程在进行一些计算时，CPU 会请求内存中存储的数据。在这个请求过程中，CPU 发出的地址是逻辑地址（虚拟地址），然后交由 CPU 当中的 MMU 单元进行内存寻址，找到实际物理内存上的内容。若是目标虚存空间中的内存页（因为某种原因），在物理内存中没有对应的页帧，那么 CPU 就无法获取数据。这种情况下，CPU 是无法进行计算的，于是它就会报告一个缺页错误（Page Fault）。 因为 CPU 无法继续进行进程请求的计算，并报告了缺页错误，用户进程必然就中断了。这样的中断称之为缺页中断。在报告 Page Fault 之后，进程会从用户态切换到系统态，交由操作系统内核的 Page Fault Handler 处理缺页错误。 缺页错误的分类和处理基本来说，缺页错误可以分为两类：硬缺页错误（Hard Page Fault）和软缺页错误（Soft Page Fault）。这里，前者又称为主要缺页错误（Major Page Fault）；后者又称为次要缺页错误（Minor Page Fault）。当缺页中断发生后，Page Fault Handler 会判断缺页的类型，进而处理缺页错误，最终将控制权交给用户态代码。 若是此时物理内存里，已经有一个页帧正是此时 CPU 请求的内存页，那么这是一个软缺页错误；于是，Page Fault Hander 会指示 MMU 建立相应的页帧到页的映射关系。这一操作的实质是进程间共享内存——比如动态库（共享对象），比如 mmap 的文件。 若是此时物理内存中，没有相应的页帧，那么这就是一个硬缺页错误；于是 Page Fault Hander 会指示 CPU，从已经打开的磁盘文件中读取相应的内容到物理内存，而后交由 MMU 建立这份页帧到页的映射关系。 不难发现，软缺页错误只是在内核态里轻轻地走了一遭，而硬缺页错误则涉及到磁盘 I/O。因此，处理起来，硬缺页错误要比软缺页错误耗时长得多。这就是为什么我们要求高性能程序必须在对外提供服务时，尽可能少地发生硬缺页错误。 除了硬缺页错误和软缺页错误之外，还有一类缺页错误是因为访问非法内存引起的。前两类缺页错误中，进程尝试访问的虚存地址尚为合法有效的地址，只是对应的物理内存页帧没有在物理内存当中。后者则不然，进程尝试访问的虚存地址是非法无效的地址。比如尝试对 nullptr 解引用，就会访问地址为 0x0 的虚存地址，这是非法地址。此时 CPU 报出无效缺页错误（Invalid Page Fault）。操作系统对无效缺页错误的处理各不相同：Windows 会使用异常机制向进程报告；*nix 则会通过向进程发送 SIGSEGV 信号（11），引发内存转储。 缺页错误的原因之前提到，物理内存中没有 CPU 所需的页帧，就会引发缺页错误。这一现象背后的原因可能有很多。 例如说，进程通过 mmap 系统调用，直接建立了磁盘文件和虚拟内存的映射关系。然而，在 mmap 调用之后，并不会立即从磁盘上读取这一文件。而是在实际需要文件内容时，通过 CPU 触发缺页错误，要求 Page Fault Handler 去将文件内容读入内存。 又例如说，一个进程启动了很久，但是长时间没有活动。若是计算机处在很高的内存压力下，则操作系统会将这一进程长期未使用的页帧内容，从物理内存转储到磁盘上。这个过程称为换出（swap out）。在 *nix 系统下，用于转储这部分内存内容的磁盘空间，称为交换空间；在 Windows 上，这部分磁盘空间，则被称为虚拟内存，对应磁盘上的文件则称为页面文件。在这个过程中，进程在内存中保存的任意内容，都可能被换出到交换空间：可以是数据内容，也可以是进程的代码段内容。 Windows 用户看到这里，应该能明白这部分空间为什么叫做「虚拟内存」——因为它于真实的内存条相对，是在硬盘上虚拟出来的一份内存。通过这样的方式，「好像」将内存的容量扩大了。同样，为什么叫「页面文件」也一目了然。因为事实上，文件内保存的就是一个个内存页帧。在 Windows 上经常能观察到「假死」的现象，就和缺页错误有关。这种现象，实际就是长期不运行某个程序，导致程序对应的内存被换出到磁盘；在需要响应时，由于需要从磁盘上读取大量内容，导致响应很慢，产生假死现象。这种现象发生时，若是监控系统硬错误数量，就会发现在短时间内，目标进程产生了大量的硬错误。 在 Windows XP 流行的年代，有很多来路不明的「系统优化建议」。其中一条就是「扩大页面文件的大小，有助于加快系统速度」。事实上，这种方式只能加大内存「看起来」的容量，却给内存整体（将物理内存和磁盘页面文件看做一个整体）的响应速度带来了巨大的负面影响。因为，尽管容量增大了，但是访问这部分增大的容量时，进程实际上需要先陷入内核态，从磁盘上读取内容做好映射，再继续执行。更有甚者，这些建议会要求「将页面文件分散在多个不同磁盘分区」，并美其名曰「分散压力」。事实上，从页面文件中读取内存页帧本就已经很慢；若是还要求磁盘不断在不同分区上寻址，那就更慢了。可见谣言害死人。 观察缺页错误Windows 系统相对于任务管理器，Windows 的资源监视器知之者甚少。Windows 的资源监视器，可以实时显示一系列硬件、软件资源的适用情况。硬件资源包括 CPU、内存、磁盘和网络；软件资源则是文件句柄和模块。用户可以在启动窗口中，以 resmon.exe 启动资源监视器（Vista 里是 perfmon.exe）。或是由开始按钮→所有程序→辅助程序→系统工具→资源监视器打开。 在内存资源监视标签中，有「硬错误/秒」或者「硬中断/秒」的监控项。若是一直打开资源监视器，以该项降序排列所有进程，则在发现程序卡顿、假死时，能观察到大量硬错误爆发性产生。 上图是 Outlook 长时间不适用后，用户主动切换到 Outlook 时的情形。此时 Outlook 呈现假死状态，同时观察到 Outlook 触发了大量的硬缺页错误。 Linux 系统ps 是一个强大的命令，我们可以用 -o 选项指定希望关注的项目。比如 min_flt: 进程启动至今软缺页中断数量； maj_flt: 进程启动至今硬缺页中断数量； cmd: 执行的命令； args: 执行的命令的参数（从 $0$ 开始）； uid: 执行命令的用户的 ID； gid: 执行命令的用户所在组的 ID。 因此，我们可以用 ps -o min_flt,maj_flt,cmd,args,uid,gid 1 来观察进程号为 1 的进程的缺页错误。 123$ ps -o min_flt,maj_flt,cmd,args,uid,gid 1 MINFL MAJFL CMD COMMAND UID GID 3104 41 /sbin/init /sbin/init 0 0 结合 watch 命令，则可关注进程当前出发缺页中断的状态。 1watch -n 1 --difference "ps -o min_flt,maj_flt,cmd,args,uid,gid 1" 你还可以结合 sort 命令，动态观察产生缺页错误最多的几个进程。 123456789101112$ watch -n 1 "ps -eo min_flt,maj_flt,cmd,args,uid,gid | sort -nrk1 | head -n 8"Every 1.0s: ps -eo min_flt,maj_flt,cmd,args,uid,gid | sort -nrk1 | head -n 83027665711 1 tmux -2 new -s yu-ws tmux -2 new -s yu-ws 19879 198791245846907 9082 tmux tmux 20886 208861082463126 57 /usr/local/bin/tmux /usr/local/bin/tmux 5638 5638868590907 2 irqbalance irqbalance 0 0662275941 289831 tmux tmux 2612 2612424339087 247 perl ./bin_agent/bin/aos_cl perl ./bin_agent/bin/aos_cl 0 0200045670 0 /bin/bash ./t.sh /bin/bash ./t.sh 12498 12498151206845 10335 tmux new -s dev tmux new -s dev 16629 16629 这是公司开发服务器上的一瞥，不难发现，我司有不少 tmux 用户。（笑） 一个硬缺页错误导致的问题我司的某一高性能服务采取了 mmap 的方式，从磁盘加载大量数据。由于调研测试需要，多名组内成员共享一台调研机器。现在的问题是，当共享的人数较多时，新启动的服务进程会在启动时耗费大量时间——以几十分钟计。那么，这是为什么呢？ 因为涉及到公司机密，这里不方便给截图。留待以后，做模拟实验后给出。 以 top 命令观察，机器卡顿时，CPU 负载并不高：32 核只有 1.3 左右的 1min 平均负载。但是，iostat 观察到，磁盘正在以 10MiB/s 级别的速度，不断进行读取。由此判断，这种情况下，目标进程一定有大量的 Page Fault 产生。使用上述 watch -n 1 --difference &quot;ps -o min_flt,maj_flt,cmd,args,uid,gid &lt;pid&gt;&quot; 观察，发现目标进程确实有大量硬缺页错误产生，肯定了这一推断。 然而，诚然进程需要载入大量数据，但是以 mmap 的方式映射，为何会已有大量同类服务存在的情况下，大量读取硬盘呢？这就需要更加深入的分析了。 事实上，这里隐含了一个非常细小的矛盾。一方面，该服务需要从磁盘加载大量数据；另一方面，该服务对性能要求非常高。我们知道，mmap 只是对文件做了映射，不会在调用 mmap 时立即将文件内容加载进内存。这就导致了一个问题：当服务启动对外提供服务时，可能还有数据未能加载进内存；而这种加载是非常慢的，严重影响服务性能。因此，可以推断，为了解决这个问题，程序必然在 mmap 之后，尝试将所有数据加载进物理内存。 这样一来，先前遇到的现象就很容易解释了。 一方面，因为公用机器的人很多，必然造成内存压力大，从而存在大量换出的内存； 另一方面，新启动的进程，会逐帧地扫描文件； 这样一来，新启动的进程，就必须在极大的内存压力下，不断逼迫系统将其它进程的内存换出，而后换入自己需要的内存，不断进行磁盘 I/O； 故此，新启动的进程会耗费大量时间进行不必要的磁盘 I/O。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Memory</tag>
        <tag>Page Fault</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从 Windows 记事本的乱码问题说起]]></title>
    <url>%2F2017%2F08%2F27%2Fmojibake-in-Windows-Notepad-due-to-wrong-encoding-detect%2F</url>
    <content type="text"><![CDATA[网上有一个流传多年的段子。这个段子大致是说，若你在简体中文版本的 Windows 系统下，用系统自带的记事本程序，以默认的 ANSI 编码保存「联通」两个字，那么重新打开后「联通」二字就消失了。如果我没记错的话，还曾有好事者据此编排，认定 Windows 背后的微软和联通有仇，故意不让联通二字正常显示。 当然，这个说法肯定是假的。但是这一现象背后的原因究竟是什么呢？实际上，网络上也有不少文章专门解释了这个问题。虽然以我的经验，能够看懂。但是若是「三秒变小白」，这些文章就不令人满意了。这是此文的缘由。 在介绍 Windows 记事本乱码问题之前，我们先来了解一些基础知识。 字符集及其编码与解码编码与解码所谓编码，就是一种规则，或者说是一种映射关系。它描述了在含义上相同的事物，如何以两种不同的形式表示出来。同一个事物按照编码从一种形式转换成另一种形式的过程，则是编码过程。 这个概念很重要，你可以酌情多读几遍。 例如说，在密码学当中，加密的过程，就是一种编码的过程。在加密体系当中，明文和密文，在含义上是相同的，但是表现形式却不同。明文是人类能够识别的语言，而密文在人类看起来则是莫名其妙的一串字符。又例如说，翻译的过程，也是一种编码的过程。翻译工作者将一句话从英文翻译成中文时，两个句子的含义是相同的，但是表现形式却不同。 和编码过程对应的是解码过程。从编码过程的定义中不难发现，编码规则两端的两种形式，在抽象上是地位等同的。所谓编码和解码的「方向」其实只是认为规定的而已。这在「翻译」的例子中很容易体现：从中文翻译到英文、从英文翻译到中文，二者谁是编码、谁是解码，其实只是具体场景下的约定。当然，在特定的领域，编码和解码是有约定俗成的。例如从明文到密文，约定俗成为编码过程；反过来从密文到明文，约定俗成是解码过程。若是反过来，从概念上当然不是不可以，但是未免让别人难以理解。 字符集人类的语言以字符承载。然而，众所周知，二进制的计算机是无法直接理解这些字符的。在计算机里，不论何种语言的字符，都是以二进制的形式保存、传输、交换的。这就牵扯到字符的编码和解码问题了：同样含义的字符，如何在人类理解的形状这一形式与计算机内部的二进制形式之间做出对应呢？ 不过，在回答这个问题之前，还有一个更基本的问题需要解答：当计算机遭遇字符，我们到底需要计算机表示哪些字符？ 这就引出了字符集（Charset）的概念。通常来说，字符集是一类字符按照一定方式编号排成的表格。比如，中国为汉字曾陆续制定了多个字符集：GB2312、GBK、GB18030；其中 GBK 字符集收录了 21886 个汉字和图形符号。又例如，Unicode 对世界上大多数文字系统进行了同一的整理和编码，因此正在逐渐成为计算机领域内的事实标准。 字符编码有了字符集，人们就可以基于其上制定字符与二进制表示（实际上就是数字）的编码规则了。这些规则，就是字符编码。 很显然，因为字符集本身就带有一组编号。因此，字符集本身也能直接用于字符编码。例如，ASCII 既是字符集，也是字符编码；GBK 也是同样。对于这种情况，字符集和字符编码合二为一，没有任何区别。因此，当人们讲「GBK 编码」的时候，替换成「GBK 字符集」基本上不影响表意。 还有一些字符编码规则，则是基于字符集之上的。这些字符编码，以某种特定的方式，规定了字符集内所有字符的编码规则。例如说，基于 Unicode 字符集，流行的编码规则有 UTF-8、UTF-16、UTF-32 等。它们为所有 Unicode 字符集中的字符指定了编码规则，但又与 Unicode 字符集中的编号不（完全）一致。因此，这种情况下，Unicode 字符集和 UTF-8 等三种编码不能划等号。 Windows 系统记事本里的「Unicode 编码」实际上是「带有 BOM 的小端序 UTF-16」。这意味着 Windows 将 Unicode 字符集和 UTF-16 划上了等号。这实际是不对的。 UTF-8 编码按照 Wikipedia 的介绍，UTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的可变长度字符编码，也是一种前缀码。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个字节仍与ASCII兼容，这使得原来处理ASCII字符的软件无须或只须做少部分修改，即可继续使用。因此，它逐渐成为电子邮件、网页及其他存储或发送文字的应用中，优先采用的编码。 和 UTF-16 和 UTF-32 不同，UTF-8 采用了特别的编码规则，因此不存在「大端序」和「小端序」的差异。 码点位数 码点起始值 码点终止值 字节序列长度 Byte 1 Byte 2 Byte 3 Byte 4 Byte 5 Byte 6 7 U+00 U+7F 1 0xxxxxxx - - - - - 11 U+0080 U+07FF 2 110xxxxx 10xxxxxx - - - - 16 U+0800 U+FFFF 3 1110xxxx 10xxxxxx 10xxxxxx - - - 21 U+10000 U+1FFFFF 4 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx - - 26 U+200000 U+3FFFFFF 5 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx - 31 U+4000000 U+7FFFFFFF 6 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 具体来说，UTF-8 编码的结果，其长度是变长的。但是，除了每个字符编码的「第一个字节」之外，其余所有字节，二进制表示都以 10 开始。这样，每个字符的第一个字节就变得特殊起来。 一方面，首字节不以 10 开始，表达了「字符开始」这一信息； 另一方面，除了 ASCII 范围内的单字节编码，其余多字节编码时，首字节的开始有多少位 1，就记录了这个字符占了多少个字节。 因此，一方面，如果一篇文档只包含 ASCII 字符，那么 UTF-8 编码和 ASCII 编码得到的结果完全相同。这就保证了兼容性。另一方面，这样的编码规则保证了字节顺序的确定性，因此没有大端序和小端序的差异，也就不需要 BOM。 Windows 记事本都做了什么这里着重感谢 margen 对 Windows 记事本程序做的逆向工作。没有他的工作，本文不至于这样精彩。光荣属于前辈！ 保存的过程根据 margen 的逆向分析，在打开文件的过程中，记事本程序会调用 fDetermineFileType 来判断文件的编码类型。翻译成 C 语言代码，大致如下。，Windows 记事本在以 ANSI 保存文件时，没有任何多余的动作，直接将 buffer 中的内容通过 WriteFile 系统调用写入到 txt 文件当中。 我们以 010editor 打开保存了「联通」二字文件看看。 可以看到，在简体中文 Windows 下，以记事本保存「联通」两个字。那么保存得到的 txt 文件内，就仅有 0xC1AACDA8 这些内容。而 0xC1AA 和 0xCDA8 正是「联通」两个字的 GBK 编码。 打开的过程根据 margen 的逆向分析，在打开文件的过程中，记事本程序会调用 fDetermineFileType 来判断文件的编码类型。翻译成 C 语言代码，大致如下。 123456789101112131415161718192021222324252627282930313233343536int __stdcall fDetermineFileType(LPVOID lpBuffer,int cb)&#123; int iType = 0; WORD wSign = 0; if( cb &lt;= 1 ) return 0; wSign = *(PWORD)lpBuffer; switch( wSign ) &#123; case 0xBBEF: &#123; if( cb &gt;= 3 &amp;&amp; (PBYTE)lpBuffer[3] == 0xBF) iType = 3; &#125; break; case 0xFEFF: &#123; iType = 1; &#125; break; case 0xFFFE: &#123; iType = 2; &#125; break; default: &#123; if( !IsInputTextUnicode( lpBuffer, cb ) ) &#123; if( IsTextUTF8( lpBuffer, cb ) ) iType = 3; &#125; else iType = 1; &#125; &#125; return iType;&#125; 首先，代码从文件头部取出了前 2 个字节，然后走 switch 分支判断。 若前两个字节是 0xBBEF，且文件第三个字节是 0xBF，则组成 UTF-8 的 BOM（虽然 UTF-8 不需要）。那么据此判断文件编码是 UTF-8。 若前两个字节是 0xFEFF，那么这是小端序 UTF-16 的 BOM。据此判断文件编码是（Windows 所谓的）Unicode 编码。 若前两个字节是 0xFFFE，那么这是大端序的 UTF-16 的 BOM。据此判断文件编码是（Windows 所谓的）Unicode Big Endian 编码。 否则，则需要做更深层次的判断。注意到，iType 被初始化为 0，代表 ANSI 编码（简体中文下是 CP936，相当于是 GBK 编码）。若已走到了 default 分支，要函数返回 0，当且仅当 IsTextUTF8( lpBuffer, cb ) 为 false 才行。然而，这个函数的写法是这样的。 1234567891011121314151617181920212223242526272829303132BOOL IsTextUTF8( LPSTR lpBuffer, int iBufSize )&#123; int iLeftBytes = 0; BOOL bUtf8 = FALSE; if( iBufSize &lt;= 0 ) return FALSE; for( int i=0;i&lt;iBufSize;i++) &#123; char c = lpBuffer[i]; if( c &lt; 0 ) bUtf8 = TRUE; if( iLeftBytes == 0 ) &#123; if( c &gt;= 0 ) continue; do &#123; c &lt;&lt;= 1; iLeftBytes++; &#125; while( c &lt; 0 ); iLeftBytes--; if( iLeftBytes == 0 ) return FALSE; &#125; else &#123; c &amp;= 0xC0; if( c != (char)0x80 ) return FALSE; else iLeftBytes--; &#125; &#125; if( iLeftBytes ) return FALSE; return bUtf8;&#125; 我们重点看 for 循环内部的逻辑。首先，char c = lpBuffer[i]; 从 buffer 中取出一个字节，保存在 signed char 当中。而后判断 if( c &lt; 0 )。因为 c 是有符号的 char，所以 c &lt; 0 意味着最高位是 1。这就意味着该字符肯定不是 ASCII 字符，可能是一个 UTF-8 字符。因此将 bUtf8 置为 true。 而后，在 if( iLeftBytes == 0 ) 分支中，我们看到 c &lt;&lt;= 1; iLeftBytes++; 的 do-while 循环。这是在判断 UTF-8 编码的首字符中，有多少个前缀的 1。根据 UTF-8 的编码规则，这个数值就是该 UTF-8 字符的编码长度，记录在 iLeftBytes 当中。 接下来，根据 iLeftBytes 的大小，逐一检查后续的字节，是否以 10 开头。一旦发现有不满足条件的字节，就能判定当前文档不是 UTF-8 编码的。或是（在 for 循环结束之后）发现 iLeftBytes 尚未自减到 0 就已经到了文档末尾，则也可以判定当前文档不是 UTF-8 编码的。 也就是说，这个函数的逻辑，是根据 UTF-8 编码规则，全文扫描。若发现有一个字符不符合 UTF-8 的编码规则，则返回 false；否则若全文都符合 UTF-8 的编码规则，则返回 true。 「联通」都经历了什么？回过头，我们看到，联通二字以 ANSI（CP936）保存的 txt 文件里只有 0xC1AACDA8 这些内容。因为无有 BOM，所以在 fDetermineFileType 函数中必然走到 default 分支，而后陷入 IsTextUTF8 函数当中。 不巧的是，0xC1AA 和 0xCDA8 都符合 UTF-8 编码的要求。因此该函数返回 true。于是，Windows 记事本打开这一文件时，认定这是一个无 BOM 的 UTF-8 编码的文件。于是按照 UTF-8 编码去解读 0xC1AACDA8，那么就乱码了。 还有哪些字符从前文的分析，我们可以得到结论：如果一个以 ANSI（CP936/GBK）保存的文档，内里包含的所有字符，都不幸满足了 UTF-8 的编码规则。那么这个文档将被 Windows 记事本当做是 UTF-8 编码的文件打开，就会乱码。 由于 GBK 是双字节的编码格式，只可能满足 UTF-8 中对 U+0080 至 U+07FF 编码的格式：110xxxxx, 10xxxxxx。我们可以将这些字符全都扫描输出出来。以下是完成这一任务的 Python 代码。 1234567891011pluses = map(lambda i:"+%s" % (hex(i)[2:].upper()), xrange(16))headline = "%s%s" % (" " * 7, " ".join(pluses))print headlinefor i in xrange(192, 224): high = hex(i)[2:].upper() for j in xrange(4): low = hex(128 + j * 16)[2:].upper() chars = map(lambda k:(chr(i) + chr(128 + j * 16 + k)).decode("gbk"), xrange(16)) line = u"0x%s%s %s" % (high, low, " ".join(chars)) print line 得到的结果是： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122 +0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B +C +D +E +F0xC080 纮 纴 纻 纼 绖 绤 绬 绹 缊 缐 缞 缷 缹 缻 缼 缽0xC090 缾 缿 罀 罁 罃 罆 罇 罈 罉 罊 罋 罌 罍 罎 罏 罒0xC0A0 罓 馈 愧 溃 坤 昆 捆 困 括 扩 廓 阔 垃 拉 喇 蜡0xC0B0 腊 辣 啦 莱 来 赖 蓝 婪 栏 拦 篮 阑 兰 澜 谰 揽0xC180 羳 羴 羵 羶 羷 羺 羻 羾 翀 翂 翃 翄 翆 翇 翈 翉0xC190 翋 翍 翏 翐 翑 習 翓 翖 翗 翙 翚 翛 翜 翝 翞 翢0xC1A0 翣 痢 立 粒 沥 隶 力 璃 哩 俩 联 莲 连 镰 廉 怜0xC1B0 涟 帘 敛 脸 链 恋 炼 练 粮 凉 梁 粱 良 两 辆 量0xC280 聙 聛 聜 聝 聞 聟 聠 聡 聢 聣 聤 聥 聦 聧 聨 聫0xC290 聬 聭 聮 聯 聰 聲 聳 聴 聵 聶 職 聸 聹 聺 聻 聼0xC2A0 聽 隆 垄 拢 陇 楼 娄 搂 篓 漏 陋 芦 卢 颅 庐 炉0xC2B0 掳 卤 虏 鲁 麓 碌 露 路 赂 鹿 潞 禄 录 陆 戮 驴0xC380 脌 脕 脗 脙 脛 脜 脝 脟 脠 脡 脢 脣 脤 脥 脦 脧0xC390 脨 脩 脪 脫 脭 脮 脰 脳 脴 脵 脷 脹 脺 脻 脼 脽0xC3A0 脿 谩 芒 茫 盲 氓 忙 莽 猫 茅 锚 毛 矛 铆 卯 茂0xC3B0 冒 帽 貌 贸 么 玫 枚 梅 酶 霉 煤 没 眉 媒 镁 每0xC480 膧 膩 膫 膬 膭 膮 膯 膰 膱 膲 膴 膵 膶 膷 膸 膹0xC490 膼 膽 膾 膿 臄 臅 臇 臈 臉 臋 臍 臎 臏 臐 臑 臒0xC4A0 臓 摹 蘑 模 膜 磨 摩 魔 抹 末 莫 墨 默 沫 漠 寞0xC4B0 陌 谋 牟 某 拇 牡 亩 姆 母 墓 暮 幕 募 慕 木 目0xC580 艀 艁 艂 艃 艅 艆 艈 艊 艌 艍 艎 艐 艑 艒 艓 艔0xC590 艕 艖 艗 艙 艛 艜 艝 艞 艠 艡 艢 艣 艤 艥 艦 艧0xC5A0 艩 拧 泞 牛 扭 钮 纽 脓 浓 农 弄 奴 努 怒 女 暖0xC5B0 虐 疟 挪 懦 糯 诺 哦 欧 鸥 殴 藕 呕 偶 沤 啪 趴0xC680 苺 苼 苽 苾 苿 茀 茊 茋 茍 茐 茒 茓 茖 茘 茙 茝0xC690 茞 茟 茠 茡 茢 茣 茤 茥 茦 茩 茪 茮 茰 茲 茷 茻0xC6A0 茽 啤 脾 疲 皮 匹 痞 僻 屁 譬 篇 偏 片 骗 飘 漂0xC6B0 瓢 票 撇 瞥 拼 频 贫 品 聘 乒 坪 苹 萍 平 凭 瓶0xC780 莯 莵 莻 莾 莿 菂 菃 菄 菆 菈 菉 菋 菍 菎 菐 菑0xC790 菒 菓 菕 菗 菙 菚 菛 菞 菢 菣 菤 菦 菧 菨 菫 菬0xC7A0 菭 恰 洽 牵 扦 钎 铅 千 迁 签 仟 谦 乾 黔 钱 钳0xC7B0 前 潜 遣 浅 谴 堑 嵌 欠 歉 枪 呛 腔 羌 墙 蔷 强0xC880 葊 葋 葌 葍 葎 葏 葐 葒 葓 葔 葕 葖 葘 葝 葞 葟0xC890 葠 葢 葤 葥 葦 葧 葨 葪 葮 葯 葰 葲 葴 葷 葹 葻0xC8A0 葼 取 娶 龋 趣 去 圈 颧 权 醛 泉 全 痊 拳 犬 券0xC8B0 劝 缺 炔 瘸 却 鹊 榷 确 雀 裙 群 然 燃 冉 染 瓤0xC980 蓘 蓙 蓚 蓛 蓜 蓞 蓡 蓢 蓤 蓧 蓨 蓩 蓪 蓫 蓭 蓮0xC990 蓯 蓱 蓲 蓳 蓴 蓵 蓶 蓷 蓸 蓹 蓺 蓻 蓽 蓾 蔀 蔁0xC9A0 蔂 伞 散 桑 嗓 丧 搔 骚 扫 嫂 瑟 色 涩 森 僧 莎0xC9B0 砂 杀 刹 沙 纱 傻 啥 煞 筛 晒 珊 苫 杉 山 删 煽0xCA80 蕗 蕘 蕚 蕛 蕜 蕝 蕟 蕠 蕡 蕢 蕣 蕥 蕦 蕧 蕩 蕪0xCA90 蕫 蕬 蕭 蕮 蕯 蕰 蕱 蕳 蕵 蕶 蕷 蕸 蕼 蕽 蕿 薀0xCAA0 薁 省 盛 剩 胜 圣 师 失 狮 施 湿 诗 尸 虱 十 石0xCAB0 拾 时 什 食 蚀 实 识 史 矢 使 屎 驶 始 式 示 士0xCB80 藔 藖 藗 藘 藙 藚 藛 藝 藞 藟 藠 藡 藢 藣 藥 藦0xCB90 藧 藨 藪 藫 藬 藭 藮 藯 藰 藱 藲 藳 藴 藵 藶 藷0xCBA0 藸 恕 刷 耍 摔 衰 甩 帅 栓 拴 霜 双 爽 谁 水 睡0xCBB0 税 吮 瞬 顺 舜 说 硕 朔 烁 斯 撕 嘶 思 私 司 丝0xCC80 虁 虂 虃 虄 虅 虆 虇 虈 虉 虊 虋 虌 虒 虓 處 虖0xCC90 虗 虘 虙 虛 虜 虝 號 虠 虡 虣 虤 虥 虦 虧 虨 虩0xCCA0 虪 獭 挞 蹋 踏 胎 苔 抬 台 泰 酞 太 态 汰 坍 摊0xCCB0 贪 瘫 滩 坛 檀 痰 潭 谭 谈 坦 毯 袒 碳 探 叹 炭0xCD80 蛝 蛠 蛡 蛢 蛣 蛥 蛦 蛧 蛨 蛪 蛫 蛬 蛯 蛵 蛶 蛷0xCD90 蛺 蛻 蛼 蛽 蛿 蜁 蜄 蜅 蜆 蜋 蜌 蜎 蜏 蜐 蜑 蜔0xCDA0 蜖 汀 廷 停 亭 庭 挺 艇 通 桐 酮 瞳 同 铜 彤 童0xCDB0 桶 捅 筒 统 痛 偷 投 头 透 凸 秃 突 图 徒 途 涂0xCE80 蝷 蝸 蝹 蝺 蝿 螀 螁 螄 螆 螇 螉 螊 螌 螎 螏 螐0xCE90 螑 螒 螔 螕 螖 螘 螙 螚 螛 螜 螝 螞 螠 螡 螢 螣0xCEA0 螤 巍 微 危 韦 违 桅 围 唯 惟 为 潍 维 苇 萎 委0xCEB0 伟 伪 尾 纬 未 蔚 味 畏 胃 喂 魏 位 渭 谓 尉 慰0xCF80 蟺 蟻 蟼 蟽 蟿 蠀 蠁 蠂 蠄 蠅 蠆 蠇 蠈 蠉 蠋 蠌0xCF90 蠍 蠎 蠏 蠐 蠑 蠒 蠔 蠗 蠘 蠙 蠚 蠜 蠝 蠞 蠟 蠠0xCFA0 蠣 稀 息 希 悉 膝 夕 惜 熄 烯 溪 汐 犀 檄 袭 席0xCFB0 习 媳 喜 铣 洗 系 隙 戏 细 瞎 虾 匣 霞 辖 暇 峡0xD080 衻 衼 袀 袃 袆 袇 袉 袊 袌 袎 袏 袐 袑 袓 袔 袕0xD090 袗 袘 袙 袚 袛 袝 袞 袟 袠 袡 袣 袥 袦 袧 袨 袩0xD0A0 袪 小 孝 校 肖 啸 笑 效 楔 些 歇 蝎 鞋 协 挟 携0xD0B0 邪 斜 胁 谐 写 械 卸 蟹 懈 泄 泻 谢 屑 薪 芯 锌0xD180 褉 褋 褌 褍 褎 褏 褑 褔 褕 褖 褗 褘 褜 褝 褞 褟0xD190 褠 褢 褣 褤 褦 褧 褨 褩 褬 褭 褮 褯 褱 褲 褳 褵0xD1A0 褷 选 癣 眩 绚 靴 薛 学 穴 雪 血 勋 熏 循 旬 询0xD1B0 寻 驯 巡 殉 汛 训 讯 逊 迅 压 押 鸦 鸭 呀 丫 芽0xD280 襽 襾 覀 覂 覄 覅 覇 覈 覉 覊 見 覌 覍 覎 規 覐0xD290 覑 覒 覓 覔 覕 視 覗 覘 覙 覚 覛 覜 覝 覞 覟 覠0xD2A0 覡 摇 尧 遥 窑 谣 姚 咬 舀 药 要 耀 椰 噎 耶 爷0xD2B0 野 冶 也 页 掖 业 叶 曳 腋 夜 液 一 壹 医 揖 铱0xD380 觻 觼 觽 觾 觿 訁 訂 訃 訄 訅 訆 計 訉 訊 訋 訌0xD390 訍 討 訏 訐 訑 訒 訓 訔 訕 訖 託 記 訙 訚 訛 訜0xD3A0 訝 印 英 樱 婴 鹰 应 缨 莹 萤 营 荧 蝇 迎 赢 盈0xD3B0 影 颖 硬 映 哟 拥 佣 臃 痈 庸 雍 踊 蛹 咏 泳 涌0xD480 詟 詠 詡 詢 詣 詤 詥 試 詧 詨 詩 詪 詫 詬 詭 詮0xD490 詯 詰 話 該 詳 詴 詵 詶 詷 詸 詺 詻 詼 詽 詾 詿0xD4A0 誀 浴 寓 裕 预 豫 驭 鸳 渊 冤 元 垣 袁 原 援 辕0xD6A0 譅 帧 症 郑 证 芝 枝 支 吱 蜘 知 肢 脂 汁 之 织0xD6B0 职 直 植 殖 执 值 侄 址 指 止 趾 只 旨 纸 志 挚0xD780 讇 讈 讉 變 讋 讌 讍 讎 讏 讐 讑 讒 讓 讔 讕 讖0xD790 讗 讘 讙 讚 讛 讜 讝 讞 讟 讬 讱 讻 诇 诐 诪 谉0xD7A0 谞 住 注 祝 驻 抓 爪 拽 专 砖 转 撰 赚 篆 桩 庄0xD7B0 装 妆 撞 壮 状 椎 锥 追 赘 坠 缀 谆 准 捉 拙 卓0xD880 貈 貋 貍 貎 貏 貐 貑 貒 貓 貕 貖 貗 貙 貚 貛 貜0xD890 貝 貞 貟 負 財 貢 貣 貤 貥 貦 貧 貨 販 貪 貫 責0xD8A0 貭 亍 丌 兀 丐 廿 卅 丕 亘 丞 鬲 孬 噩 丨 禺 丿0xD8B0 匕 乇 夭 爻 卮 氐 囟 胤 馗 毓 睾 鼗 丶 亟 鼐 乜0xD980 賭 賮 賯 賰 賱 賲 賳 賴 賵 賶 賷 賸 賹 賺 賻 購0xD990 賽 賾 賿 贀 贁 贂 贃 贄 贅 贆 贇 贈 贉 贊 贋 贌0xD9A0 贍 佟 佗 伲 伽 佶 佴 侑 侉 侃 侏 佾 佻 侪 佼 侬0xD9B0 侔 俦 俨 俪 俅 俚 俣 俜 俑 俟 俸 倩 偌 俳 倬 倏0xDA80 趢 趤 趥 趦 趧 趨 趩 趪 趫 趬 趭 趮 趯 趰 趲 趶0xDA90 趷 趹 趻 趽 跀 跁 跂 跅 跇 跈 跉 跊 跍 跐 跒 跓0xDAA0 跔 凇 冖 冢 冥 讠 讦 讧 讪 讴 讵 讷 诂 诃 诋 诏0xDAB0 诎 诒 诓 诔 诖 诘 诙 诜 诟 诠 诤 诨 诩 诮 诰 诳0xDB80 踿 蹃 蹅 蹆 蹌 蹍 蹎 蹏 蹐 蹓 蹔 蹕 蹖 蹗 蹘 蹚0xDB90 蹛 蹜 蹝 蹞 蹟 蹠 蹡 蹢 蹣 蹤 蹥 蹧 蹨 蹪 蹫 蹮0xDBA0 蹱 邸 邰 郏 郅 邾 郐 郄 郇 郓 郦 郢 郜 郗 郛 郫0xDBB0 郯 郾 鄄 鄢 鄞 鄣 鄱 鄯 鄹 酃 酆 刍 奂 劢 劬 劭0xDC80 軃 軄 軅 軆 軇 軈 軉 車 軋 軌 軍 軏 軐 軑 軒 軓0xDC90 軔 軕 軖 軗 軘 軙 軚 軛 軜 軝 軞 軟 軠 軡 転 軣0xDCA0 軤 堋 堍 埽 埭 堀 堞 堙 塄 堠 塥 塬 墁 墉 墚 墀0xDCB0 馨 鼙 懿 艹 艽 艿 芏 芊 芨 芄 芎 芑 芗 芙 芫 芸0xDD80 輤 輥 輦 輧 輨 輩 輪 輫 輬 輭 輮 輯 輰 輱 輲 輳0xDD90 輴 輵 輶 輷 輸 輹 輺 輻 輼 輽 輾 輿 轀 轁 轂 轃0xDDA0 轄 荨 茛 荩 荬 荪 荭 荮 莰 荸 莳 莴 莠 莪 莓 莜0xDDB0 莅 荼 莶 莩 荽 莸 荻 莘 莞 莨 莺 莼 菁 萁 菥 菘0xDE80 迉 迊 迋 迌 迍 迏 迒 迖 迗 迚 迠 迡 迣 迧 迬 迯0xDE90 迱 迲 迴 迵 迶 迺 迻 迼 迾 迿 逇 逈 逌 逎 逓 逕0xDEA0 逘 蕖 蔻 蓿 蓼 蕙 蕈 蕨 蕤 蕞 蕺 瞢 蕃 蕲 蕻 薤0xDEB0 薨 薇 薏 蕹 薮 薜 薅 薹 薷 薰 藓 藁 藜 藿 蘧 蘅0xDF80 還 邅 邆 邇 邉 邊 邌 邍 邎 邏 邐 邒 邔 邖 邘 邚0xDF90 邜 邞 邟 邠 邤 邥 邧 邨 邩 邫 邭 邲 邷 邼 邽 邿0xDFA0 郀 摺 撷 撸 撙 撺 擀 擐 擗 擤 擢 攉 攥 攮 弋 忒0xDFB0 甙 弑 卟 叱 叽 叩 叨 叻 吒 吖 吆 呋 呒 呓 呔 呖 若一个文档里只包含这个表格中的汉字（可以再包含 ASCII 字符），在简体中文 Windows 下在记事本中以 ANSI 编码保存，则再次打开必然乱码。特别地，这个表格本身也会乱码。 据此，你可以构造出各种跟微软「有仇」的文档。比如「联通」，比如「小泉水」。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>C</tag>
        <tag>Windows</tag>
        <tag>Encoding</tag>
        <tag>Mojibake</tag>
        <tag>Notepad</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTeX 黑魔法（四）：插入动画（animate 宏包教程）]]></title>
    <url>%2F2017%2F08%2F10%2Fimporting-animate-in-LaTeX%2F</url>
    <content type="text"><![CDATA[在最初学习 LaTeX 插图的时候，我就发现，基本的 LaTeX 手段不支持 GIF 格式的动图。虽然一直保持对此的好奇，但是因为没有实际需要，再加上「论文等文稿不适合插入动画」的论调，所以一直没有去探究可行性和解决办法。 前段时间，因为制作一个幻灯片（离散卷积和卷积神经网络）的需要，不得不插入动画以演示「卷积」的过程和效果。于是就借此机会，摸索了如何在 LaTeX 中插入动画。此文是对上述过程的归纳总结。 本文主要介绍两部分内容 如何在 LaTeX 中插入 GIF 格式的动图； 如何在 LaTeX 中插入 TikZ 代码绘制的动画。 以及介绍一些运用动画效果实现的黑科技效果。 主角登场——animate 宏包要在 LaTeX 中插入动画，首先要考虑输出文件类型是否支持这样的需求。否则，插入动画就变成了无根之木、无源之水。 目前来说，主流的 LaTeX 输出格式是 PDF。PDF 的全称是 Portable Document Format。它是最早由 Adobe 公司提出的文档格式标准；因其优良的特性，现已逐渐发展成为固定格式文本交换的事实标准。 自 2000 年始，1.3 版本的 PDF 开始支持 JavaScript。而后，相关特性在后续版本中不断完善。因此，若是 PDF 浏览器支持相关 API，则可以利用 JavaScript 在 PDF 文稿中做到很多事情——当然，包括了动画。因此，在 PDF 中插入动画是可能的。 Alexander Grahn 根据上述 API，开发了 animate 宏包。该宏包利用 JavaScript，允许用户在 LaTeX 文稿中插入动画，并在支持 JavaScript 的 PDF 阅读器中查看。特别喜人的是，animate 宏包支持目前最流行的几种编译方式；因此，你无须像使用 media9 之类的宏包那样，被编译方式绊住脚。目前 animate 支持的编译方式有 pdfLaTeX / LuaLaTeX LaTeX -&gt; dvips -&gt; ps2pdf / LaTeX -&gt; dvipdfmx XeLaTeX -&gt; xdvipdfmx 当然，支持这些特性的 PDF 阅读器则比较少。目前已知的有 Adobe Acrobat / Reader PDF-XChange Foxit Reader 使用 animate 宏包此处不表如何安装 animate 宏包，我们来看如何使用 animate 宏包。 和其它宏包一样，在 LaTeX 中使用 \usepackage[&lt;options&gt;]{animate} 即可引入 animate 宏包。唯独需要注意的有三点 必须在引入 animate 宏包之前，显式地引入 graphicx 宏包； 若希望使用 LaTeX -&gt; dvipdfmx 这一工具链，则需要给 graphicx 和 animate 宏包都加上 dvipdfmx 选项（原因）； 和交叉引用中遇到的问题一样，使用 animate 宏包创建动画，也需要两次编译（第一次创建 JavaScript 内容，第二次在具体位置插入内容）。 animate 宏包支持不少参数。不过，仅有 dvipdfmx 和 xetex 两个驱动选项只能在载入宏包时使用——而其中仅有 dvipdfmx 是必须的。宏包支持的其他参数，具体的命令、环境也都支持。若是在载入宏包是提供这些参数，相当于给命令、环境设置了「默认值」。因此，这部分参数放在之后具体介绍。 使用 animate 宏包插入 GIF 动图——\animategraphicsanimate 提供了 \animategraphics 命令，用于插入「一系列」的图片，而后将他们组成动画——相当于插入了动图。 具体来说，其命令是 1\animategraphics[&lt;options&gt;]&#123;&lt;frame rate&gt;&#125;&#123;&lt;file basename&gt;&#125;&#123;&lt;first&gt;&#125;&#123;&lt;last&gt;&#125; 此处 options 是命令的参数，主要用于控制动画的各种效果，具体参数将在下一节中介绍。先前我们讲过这部分参数大都也可用于宏包选项。frame rate 的单位是 Hz，表示 1 秒钟内，「放映」多少帧。 前面说该命令用于插入一系列图片，animate 宏包要求这一系列图片有共同的文件名前缀，而后以数字编号表述其顺序。file basename 选项用于记录该前缀；first 和 last 则是这一系列图片编号的起止。 关于文件名后缀，animate 也做了具体要求。首先，animate 要求插入的图片，后缀名必须是小写。其次，animate 对文件搜索顺序做了规定（实际上是 graphicx 的规定）： pdfLaTeX / LuaLaTeX：pdf, mps, png, jpg, jpeg, jbig2, jb2, jp2, j2k, jpx XeLaTeX / LaTeX -&gt; dvipdfmx：pdf, mps, eps, ps, png, jpg, jpeg, bmp LaTeX -&gt; dvips -&gt; ps2pdf：eps, mps, ps 注意到两件事情：一，上述后缀名中没有 gif，这意味着不能直接插入 GIF 格式的动图；二，前面提到，使用 animate 宏包插入动图实际是插入一系列的图片，这意味着我们需要将 GIF 格式的动图，预先转换成一系列符合要求的格式之图片。 转换格式需要用到 ImageMagick 这一开源的工具。安装它，Mac 用户可以使用 brew install ImageMagick，Linux 用户可以使用各自的包管理器，Windows 用户则需要下载安装。 安装好 ImageMagick 之后，我们就可以用它提供的 convert 命令将 GIF 格式的动图逐帧地切分成一系列图片了。假设你的目标图片是 foo.gif，那么使用如下命令可以得到一系列图片：foo-0.png, foo-1.png, foo-2.png, … 1convert foo.gif -coalesce foo.png 而后，我们就可以用 animate 提供的 \animategraphics 命令插入动图了。 123456\documentclass&#123;article&#125;\usepackage&#123;graphicx&#125;\usepackage&#123;animate&#125;\begin&#123;document&#125;\animategraphics&#123;24&#125;&#123;foo-&#125;&#123;0&#125;&#123;300&#125;\end&#123;document&#125; 图片引用自 Wikipedia。 animate 选项animate 宏包提供的选项，按照适用范围可以分为三类：只能用于宏包的选项、只能用于接口的选项（命令和环境）、二者皆适用的选项。现分别介绍。 这里仅介绍其中重要的部分，未尽之详细，请参考 animate 的宏包文档。 只能用于宏包的选项 dvipdfmx：驱动选项，表示用户希望使用 LaTeX -&gt; dvipdfmx 进行编译。 xetex：驱动选项，表示用户希望使用 XeLaTeX -&gt; xdvipdfmx 进行编译。 只能用于接口的选项这里的接口指的是 animate 宏包提供的用户接口。例如我们已经见过的 \animategraphics 命令，以及下一节会介绍的 animateinline 环境。 label=&lt;label text&gt;：为 animate 对象指定唯一的标签，可用于之后的 JavaScript 控制。 every=&lt;num&gt;：只为每个第 &lt;num&gt; 帧构建动画，而忽略剩余的帧。 二者皆适用的选项 type=&lt;type name&gt;：使用指定的图片类型（而不按照前面提到的顺序搜索）。 poster[= first | &lt;num&gt; | last | none]：指定用于打印和默认展示的动画帧，默认是第一帧。 autopause：当动画所在页不再呈现时，自动暂停动画。 autoresume：当被暂停的动画重新呈现时，自动恢复播放。 autoplay：当动画所在页在 PDF 阅读器中呈现时，自动播放动画。 loop：播放到最后一帧时，从第一帧开始继续播放；如此往复。 palindrome：播放到最后一帧时，逐帧倒退；如此往复。 step：忽略 frame rate，只在每次点击鼠标时播放一帧。 width=&lt;h-size&gt;, height=&lt;v-size&gt;, totalheight=&lt;v-size&gt;, keepaspectratio：按绝对长度缩放动画的大小。 scale=&lt;factor&gt;：按比例缩放动画的大小。 controls：展示用于控制动画的按钮。 begin=&lt;begin content&gt;, end=&lt;end content&gt;：仅用于 animateinline 环境，在每一帧的内容前后添加相应内容。 使用 animate 插入用户绘制的动画——animateinline 环境之前我们介绍了如何使用 ImageMagick 拆分 GIF 动图，而后用 \animategraphics 将拆分得到的一系列图片在 LaTeX 中插入 PDF 文档，变成动画。然而，这可能存在几个问题 从它处获取的 GIF 动图可能侵犯他人版权； 自行制作 GIF 动图成本较高——不如直接用 TikZ 等工具绘制。 因此，这就引出了更高级的主题：使用 animate 宏包，插入用户自行绘制的动画。这需要引入一个新的用户接口——animateinline 环境。它的语法是这样的： 12345678910\begin&#123;animateinline&#125;[&lt;options&gt;]&#123;&lt;frame rate&gt;&#125;... typeset material ...\newframe[&lt;frame rate&gt;]... typeset material ...\newframe*[&lt;frame rate&gt;]... typeset material ...\newframe\multiframe&#123;&lt;number of frames&gt;&#125;&#123;[&lt;variables&gt;]&#125;&#123;... repeated (parameterized) material ... &#125;\end&#123;animateinline&#125; 显而易见，animateinline 环境的语法比 \animategraphics 要复杂得多。不过，仔细看的话，其实是有相通之处的。 首先，和 \animategraphics 命令一样，animateinline 环境允许用户通过 options 和 frame rate 控制动画的基本行为。不同之处在于，\animategraphics 的动画内容是固定死的——由图片提供，而 animateinline 的动画内容则需要用户在 LaTeX 代码中逐帧绘制。因此，animateinline 环境提供了三个命令来辅助和控制这些内容。 \newframe 和 \newframe* 的作用正如其名：结束上一帧并开始下一帧。唯一的不同在于，\newframe 会立即开始下一帧，而 \newframe* 则会暂停并等待用户的点击再开始下一帧。它们接受一个可选参数，以便在动画的中途改变 frame rate。 \multiframe 则更为强大，它能提供类似循环的功能，并将「循环变量」传递到 \multiframe 内部供内部绘图命令使用。具体来说，首先我们需要给出循环的次数 number of frames，而后指定循环变量 variables。循环变量的书写格式如下 1&lt;variable name&gt;=&lt;initial value&gt;+&lt;increment&gt; 这里，variable name 由若干个字母组成，不含 LaTeX 命令的反斜线。需要注意的是，variable name 的首字母是有意义的，它决定了变量的类型。 整数：i, I 浮点数：n, N, r, R 长度：d, D initial value 表示循环变量的初始值，而 increment 表示循环变量在每次循环末尾自增的值。 因此，我们可以写出如下代码 12\multiframe&#123;10&#125;&#123;iAngle=0+10, dLineWidth=3pt+-0.1pt&#125;&#123;... repeated (parameterized) material ... &#125; 这样，循环会执行 10 次，同时带有两个循环变量：整型变量 iAngle 和 dLineWidth。前者从 0 开始，每次增加 10；后者从 3pt 开始，每次减少 0.1pt。而后，在循环体中（\multiframe 命令的内部），我们就可以使用 \iAngle 和 \dLineWidth 获得循环变量的值了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879\documentclass&#123;article&#125;\usepackage&#123;graphicx&#125;\usepackage&#123;animate&#125;\usepackage&#123;tikz&#125;\usetikzlibrary&#123;positioning&#125;\tikzset&#123;global scale/.style=&#123; scale=#1, every node/.append style=&#123;scale=#1&#125; &#125;&#125;\tikzset&#123;global xscale/.style=&#123; xscale=#1, every node/.append style=&#123;xscale=#1&#125; &#125;&#125;\tikzset&#123;global yslant/.style=&#123; yslant=#1, every node/.append style=&#123;yslant=#1&#125; &#125;&#125;\newcommand&#123;\twodimdrawcontent&#125;[2]&#123;%\useasboundingbox (0, -6) rectangle (16.1, 3);\begin&#123;scope&#125;[global yslant = -0.6, xshift = 1cm, yshift = -1cm] \node (A) at (0, 0) &#123;&#125;; \node (B) at (3, 0) &#123;&#125;; \node (C) at (3, 3) &#123;&#125;; \node (D) at (0, 3) &#123;&#125;; \draw (0,0) grid (3,3);\end&#123;scope&#125;\node[anchor = north, xscale = 2] at (2, -5) &#123;Kernel&#125;;\begin&#123;scope&#125;[xshift = 6cm, global yslant = -0.6, yshift = -2cm] \node (E) at (0cm + #1cm, 2cm - #2cm) &#123;&#125;; \node (F) at (3cm + #1cm, 2cm - #2cm) &#123;&#125;; \node (G) at (3cm + #1cm, 5cm - #2cm) &#123;&#125;; \node (H) at (0cm + #1cm, 5cm - #2cm) &#123;&#125;; \draw[fill, blue!20] (0cm + #1cm, 2cm - #2cm) rectangle (3cm + #1cm, 5cm - #2cm); \draw[fill, blue!50] (1cm + #1cm, 3cm - #2cm) rectangle (2cm + #1cm, 4cm - #2cm); \draw (0,0) grid (5,5);\end&#123;scope&#125;\node[anchor = north, xshift = 6cm, xscale = 2] at (2, -5) &#123;Input&#125;;\begin&#123;scope&#125;[xshift = 12cm, global yslant = -0.6, xshift = 1cm, yshift = -1cm] \node (I) at (0.5cm + #1cm, 2.5cm - #2cm) &#123;&#125;; \draw[fill, red!20] (0cm + #1cm, 2cm - #2cm) rectangle (1cm + #1cm, 3cm - #2cm); \draw (0,0) grid (3, 3);\end&#123;scope&#125;\node[anchor = north, xshift = 12cm, xscale = 2] at (2, -5) &#123;Output&#125;;\draw[dashed, blue] (A.center) -- (E.center);\draw[dashed, blue] (B.center) -- (F.center);\draw[dashed, blue] (C.center) -- (G.center);\draw[dashed, blue] (D.center) -- (H.center);\draw[dashed, red] (E.center) -- (I.center);\draw[dashed, red] (F.center) -- (I.center);\draw[dashed, red] (G.center) -- (I.center);\draw[dashed, red] (H.center) -- (I.center);&#125;\begin&#123;document&#125;\begin&#123;animateinline&#125;[ loop,autopause,controls, buttonsize=1.2em, buttonbg=0.6:0.6:1,buttonfg=0.2:0.2:1, begin=&#123;\begin&#123;tikzpicture&#125;[global scale = 0.7, global xscale = 0.5, on grid]&#125;, end=&#123;\end&#123;tikzpicture&#125;&#125;]&#123;1.8&#125; \multiframe&#123;3&#125;&#123;icol=0+1&#125;&#123;% \xdef\icol&#123;\icol&#125; \xdef\irow&#123;0&#125; \whiledo&#123;\lengthtest&#123;\irow sp &lt; 2sp&#125;&#125;&#123; \twodimdrawcontent&#123;\irow&#125;&#123;\icol&#125; \newframe \pgfmathsetmacro&#123;\irow&#125;&#123;\irow + 1&#125; \xdef\irow&#123;\irow&#125; &#125; \twodimdrawcontent&#123;\irow&#125;&#123;\icol&#125; &#125;\end&#123;animateinline&#125;\end&#123;document&#125; 绘图的核心代码定义在 \twodimdrawcontent 这一命令当中。该命令的内容完全是 TikZ 的语法，不在此篇的涵盖范畴中。因此不表。唯一需要注意的是，我们使用了 \useasboundingbox (0, -6) rectangle (16.1, 3); 限定每一个动画帧的大小。这是因为 animateinline 会根据第一帧的大小来确定动画的大小；若是每一帧大小不同，则可能出现某些帧显示不全的现象。 我们仔细看 animateinline 环境中的参数。loop, autopause, controls 我们很熟悉了；buttomsize, buttonbg, buttonfg 顾名思义，是用来调整按钮的样式的；begin 和 end 则在每一帧的内容前后加上了 tikzpicture 环境。这样，我们可以直接使用 \twodimdrawcontent 来绘制动画帧。 animateinline 环境的帧率（frame rate）是 1.8，这意味着每秒会播放 1.8 个动画帧（每 5 秒播放 9 帧）。具体的动画帧内容，则由 \multiframe 给出。 \multiframe 循环 3 次，对应循环变量为 icol。这是一个整型变量，从 0 开始每次自增 1。在循环体内，我们首先定义 \xdef\icol{\icol}；这是因为，\multiframe 给出的循环变量，若直接传给 \twodimdrawcontent 则无法正确展开。随后我们将 \irow 定义为 0。接下来，我们使用 \whiledo 的循环。此处不使用 \multiframe 的原因是它无法嵌套。这一循环的变量是 \irow。它从 0 开始，每次循环末尾由 \pgfmathsetmacro{\irow}{\irow + 1}, \xdef\irow{\irow} 自增 1。\whiledo 循环两次，内部用 \twodimdrawcontent{\irow}{\icol}, \newframe 制作出一帧动画。最后在 \whiledo 循环的外部，画出第三帧。 如此，就能得到我们在前文中的动画效果了。 偏好使用 PSTricks 的用户，可以参考 animate 宏包文档里的示例。 一点彩蛋123456789101112\documentclass&#123;article&#125;\usepackage&#123;graphicx&#125;\usepackage&#123;animate&#125;\newcommand&#123;\myemph&#125;[1]&#123;% \begin&#123;animateinline&#125;[autoplay, loop]&#123;.5&#125; \emph&#123;#1&#125; \newframe[1.5] \relax \end&#123;animateinline&#125;&#125;\begin&#123;document&#125;This is \myemph&#123;important&#125;!\end&#123;document&#125;]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>GIF</tag>
        <tag>Animate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PIL 简明教程 - 像素操作与图像滤镜]]></title>
    <url>%2F2017%2F08%2F06%2Fpil-tutorial-pixel-operations-and-image-filter%2F</url>
    <content type="text"><![CDATA[这是系列文章的第三篇，参见系列中的相关内容。 这篇文章介绍如何利用 PIL 库，获取图像中的像素内容、修改后生成新的图像。此外，在修改的过程中，我们会引入卷积滤镜，进而引出 PIL 中的图像滤镜库 ImageFilter。 获取像素内容位图是有一个个像素组成的。因此，读入一张图片，实际上就是读入了一系列的像素内容。这些像素内容，按照不同的模式具有不同的格式。对于三通道的 RGB 位图来说，每个像素是一个 8-bit 整数的三元组。例如 rgb(0, 0, 0) 表示纯黑色，而 rgb(255, 255, 255) 则表示纯白色。 前文介绍过，Image.open() 可以打开一张图片，返回一个 Image 类的对象。那么，我们怎样获得这一图片的像素内容呢？ PIL 提供了 PIL.Image.getdata(band = None) 方法，用来获取 Image 类的对象中的像素内容。 该方法会将图片中的像素内容，逐行逐行地拼接起来（俗称降维打击），作为一个完整的序列返回。方法的返回类型，是 PIL 库的内部类型。我们可以用 list(im.getdata()) 得到标准的 Python list 对象。 该方法的参数中，band 意味「通道」。当 band = None 时，方法返回所有通道的像素内容；当 band = 0 时，则返回第一个通道的像素内容。例如，对于 RGB 模式的位图，band = 0 返回 R 通道的内容；band = 2 返回 B 通道的内容。 示例代码： 12345678910111213from PIL import Imageim = Image.open('cat.jpg')rgb_pixels = list(im.getdata())r_pixels = list(im.getdata(band = 0))g_pixels = list(im.getdata(band = 1))b_pixels = list(im.getdata(band = 2))print(rgb_pixels[:10])print(r_pixels[:10])print(g_pixels[:10])print(b_pixels[:10]) 可能的输出： 1234[(130, 82, 8), (132, 84, 8), (136, 87, 10), (141, 90, 11), (143, 90, 10), (145, 90, 7), (144, 88, 3), (144, 87, 0), (147, 85, 0), (148, 84, 0)][130, 132, 136, 141, 143, 145, 144, 144, 147, 148][82, 84, 87, 90, 90, 90, 88, 87, 85, 84][8, 8, 10, 11, 10, 7, 3, 0, 0, 0] 写入像素内容上一节介绍了如何从一个 Image 类的对象中获得像素内容。现在我们考虑它的镜像问题：如何将已知的像素内容写入一个新的 Image 类的对象。 在介绍 PIL.Image.getdata() 的过程中，我们提到，该方法返回的内容是一个一维的序列。这个过程，实际上丢失了图像的模式、尺寸等信息。那么在从像素内容恢复到 Image 类的对象的过程中，我们就必须补足这些信息。因此，我们首先需要获取原图像的模式和尺寸。 12345678from PIL import Imageim = Image.open('cat.jpg')mode = im.modewidth, height = im.sizeimn = Image.new(mode, (height, width)) 如此，我们就创建了一个新的 Image 类的对象。它的模式与 im 保持一致，尺寸则相对 im 长宽颠倒。现在，我们可以向 imn 中写入像素内容了。 PIL.Image.putdata(data, scale=1.0, offset=0.0) 方法允许我们将像素内容写入 Image 类的对象。 该方法将序列类型 data 拷贝进 Image 类的对象，直到 Image 类的对象容纳不下更多的像素或 data 内容已耗尽。scale 和 offset 则是针对每一个像素值进行调整：pixel = value * scale + offset。 据此，我们可以写出完整的代码。首先来看看原图。 示例代码： 123456789101112from PIL import Imageim = Image.open('cat.jpg')mode = im.modewidth, height = im.sizergb_pixels = list(im.getdata())imn = Image.new(mode, (height, width))imn.putdata(data = rgb_pixels)imn.save('funny_cat.jpg') 结果： 实际操作看看——实现卷积滤镜用固定的矩阵扫描更大的矩阵，这个操作称为卷积。若后者是一张图片，那么这一操作，就是对图像的滤镜操作了。我们在前作中介绍了这种操作，此处我们来实践看看。 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from PIL import Imageimport numpy as npfrom scipy import signaldef read_image(fname): im = Image.open(fname) width, height = im.size mode = im.mode pixels = list(im.getdata()) im.close() r_pxs = map(lambda x:x[0], pixels) g_pxs = map(lambda x:x[1], pixels) b_pxs = map(lambda x:x[2], pixels) r_pxs = [r_pxs[i * width:(i + 1) * width] for i in xrange(height)] g_pxs = [g_pxs[i * width:(i + 1) * width] for i in xrange(height)] b_pxs = [b_pxs[i * width:(i + 1) * width] for i in xrange(height)] return mode, (width, height), (r_pxs, g_pxs, b_pxs)def convolve2d(x, ker, mode = 'same', boundary = 'wrap'): a = np.asarray(x, dtype = float) b = np.asarray(ker, dtype = float) res = signal.convolve2d(a, b, mode, boundary) return resdef filter_image(mode, size, rgb, kernel, fname): r = convolve2d(rgb[0], kernel) g = convolve2d(rgb[1], kernel) b = convolve2d(rgb[2], kernel) int_it = lambda f:int(round(f, 0)) pixels = map(lambda x, y, z: (int_it(x), int_it(y), int_it(z)), r.flat, g.flat, b.flat) res = Image.new(mode, size) res.putdata(pixels) res.save(fname) res.close() return Noneif __name__ == '__main__': base, ext = 'cat', 'jpg' ifname = "%s.%s" % (base, ext) ofname = "%s_blur.%s" % (base, ext) blur_5 = [[1.0 / 25.0] * 5] * 5 mode, size, rgb = read_image(ifname) filter_image(mode, size, rgb, blur_5, ofname) ofname = "%s_shrp.%s" % (base, ext) shrp_3 = [[0, -1, 0], [-1, 5, -1], [0, -1, 0]] mode, size, rgb = read_image(ifname) filter_image(mode, size, rgb, shrp_3, ofname) ofname = "%s_dtct.%s" % (base, ext) dtct_3 = [[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]] mode, size, rgb = read_image(ifname) filter_image(mode, size, rgb, dtct_3, ofname) 此处 read_image 函数从一个图像文件中读入其模式、尺寸及 RGB 三通道矩阵。convolve2d 函数利用了 scipy 库中的 signal.convolve2d 函数，对图像的单通道进行卷积操作——滤镜。filter_image 函数则是对 convolve2d 的封装，从上述模式、尺寸及 RGB 三通道矩阵开始，使用 kerner 作为卷积核进行滤镜操作，并将图片保存下来。 此处我们选择了三个卷积核。blur_5 将目标像素周围的 5*5 的像素平均起来，起到 box-模糊化的作用。shrp_3 加强了目标像素的作用，同时减弱了上下左右四个像素的干扰，起到了锐化的作用。dtct_3 则凸显了哪些与周围 8 个像素具有明显差异的像素，起到了边缘检测的作用。三个滤镜的效果可以参见：原图/模糊化/锐化/边缘检测。 使用 ImageFilter 预定义的滤镜PIL 库在 ImageFilter 模块中已经为我们预定义好了一些滤镜。同时 Image 模块也提供了 filter 方法应用滤镜：Image.filter(filter_object)。因此，我们可以用 ImageFilter 提供的 Kernel 滤镜，很方便地复现上一节中的滤镜效果。（Kernel 当前仅支持 33 或 55 的滤镜，sad）。 示例代码： 12345678from PIL import Imagefrom PIL import ImageFilterim = Image.open('cat.jpg')imn = im.filter(ImageFilter.Kernel(size = (5, 5), kernel = [1.0 / 25.0] * 25))imn.show() 效果： 你可以在官方文档中找到更多的滤镜。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PIL</tag>
        <tag>ImageFilter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 C++ 中分割字符串]]></title>
    <url>%2F2017%2F08%2F03%2Fsplit-a-string-in-Cpp%2F</url>
    <content type="text"><![CDATA[昨天在网上看到，C++ 至今为止没有官方实现的字符串分割函数。相比 Python、Java 等语言，多少是有些不便的。 这里我们来在 C++ 中实现字符串分割函数。 利用来自 C 的 strtok 函数 C 语言的 string.h 中提供了名为 strtok 函数，用于对 C 风格的字符串进行分割。其函数签名为 1char* strtok(char* str, const char* delim); 当 str 不是空指针时，strtok 会从头开始寻找第一个合法的分隔符，而后将分隔符替换成 \0，并将分隔符的位置保存在一个静态变量中，最后返回 str。这样，按照 C 风格的字符串，我们就能获取分割得到的第一个 token。当 str 是空指针时，strtok 将会从记录的空指针处继续尝试分割。 因此，我们可以定义这样的 split 函数。 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;void split(const std::string&amp; s, std::vector&lt;std::string&gt;&amp; sv, const char* delim = " ") &#123; sv.clear(); // 1. char* buffer = new char[s.size() + 1]; // 2. std::copy(s.begin(), s.end(), buffer); // 3. char* p = std::strtok(buffer, delim); // 4. do &#123; sv.push_back(p); // 5. &#125; while ((p = std::strtok(NULL, delim))); // 6. return;&#125;int main() &#123; std::string s("abc:def::ghi"); std::vector&lt;std::string&gt; sv; split(s, sv, ":"); for (std::vector&lt;std::string&gt;::const_iterator iter = sv.begin(); iter != sv.end(); ++iter) &#123; std::cout &lt;&lt; *iter &lt;&lt; std::endl; &#125; return 0;&#125; 对于 split 函数来说，它无法预知传入的 sv 变量的情况。因此，在 (1) 处，我们将 sv 这个 std::vector&lt;std::string&gt; 清空备用。由于 std::strtok 函数需要修改传入的 str 的内容，所以它需要 char* 类型的参数。故而，在 (2)(3) 两处，我们将 std::string 当中的内容复制一份。(4)(6) 两处对 std::strtok 的调用，帮助我们将 token 逐个压入 sv 当中。 在 C++11 及更高版本中，(5) 可替换为 sv.emplace_back(p)，以避免额外的拷贝。 上述代码的结果是： 123abcdefghi 利用 C++ 中的流实际上，利用纯 C++ 风格的代码，也是可以实现一个优雅的字符串分割函数的。 在前作中，我们介绍了 C++ 的 std::getline 函数。它接收一个输入流，将输入流至行末/分隔符部分的字符串保存在临时的字符串中；同时，返回输入流的左值引用。考虑到输入流本身可以用作条件判断，我们可以将 std::getline 与 while 循环联用，达成目的。 简单实现如下： split.cc12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;#include &lt;vector&gt;void split(const std::string&amp; s, std::vector&lt;std::string&gt;&amp; sv, const char delim = ' ') &#123; sv.clear(); std::istringstream iss(s); std::string temp; while (std::getline(iss, temp, delim)) &#123; sv.emplace_back(std::move(temp)); &#125; return;&#125;int main() &#123; std::string s("abc:def:ghi"); std::vector&lt;std::string&gt; sv; split(s, sv, ':'); for (const auto&amp; s : sv) &#123; std::cout &lt;&lt; s &lt;&lt; std::endl; &#125; return 0;&#125; 代码中，我们借助字符串输入流 istringstream 处理带分割的字符串 s。而后将各个 delim 之间的内容，保存在临时字符串 temp 当中，并移动到向量 sv 的末尾。 上述代码的结果是： 123abcdefghi]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>Split</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTeX 黑魔法（三）：定义参数变长的命令]]></title>
    <url>%2F2017%2F07%2F30%2Fdefine-a-new-command-with-different-amount-of-parameters-in-LaTeX%2F</url>
    <content type="text"><![CDATA[在 C++ 中，我们可以为同一个函数赋予不同的执行内容，这种行为称之为「函数重载」。具体重载的函数，共享同一个函数名，但是接收的函数参数在数量、类型上不同。LaTeX 是宏语言，没有一般意义上的参数类型的说法。但是，有没有办法在 LaTeX 中「重载」一个宏，根据输入的参数数量不同，而产生不同的效果呢？ 本文给出解决方案。 在 TeX 和 LaTeX2e 中定义新命令TeX 中，定义新命令的标准方法是使用 TeX 原语 \def。它有几个变种，记录如下。 \def：局部定义，定义时不展开； \edef：局部定义，定义时完全展开； \gdef：相当于 \global\def； \xdef：相当于 \global\edef。 建立在 TeX 之上的各种格式，其提供的定义新命令的方案，都是通过这四个 \def 来实现的。LaTeX2e 中定义新命令的标准方法是使用 \newcommand。它也有几个变种，记录如下。 \newcommand：新定义一个命令，如果该命令已有定义，则报错； \renewcommand：重定义一个命令，如果该命令未定义，则报错； \providecommand：如果该命令未定义，则定义一个新的命令；否则，啥也不干。 当然，在 LaTeX2e 中，也有 \DeclareRobustCommand 一系列命令，可以用来定义新的命令。这一系列命令，是 LaTeX2e 针对「脆弱命令」问题，提供的一些保护机制。此处不表。 在标准的方法中，不论是 TeX 还是 LaTeX2e，都没有提供「参数变长」的实现方法。也就是说，如果不引入奇怪的技巧，我们在普通的 LaTeX 文稿中，是无法重载命令的。 \@ifnextchar\@ifnextchar 是一个 LaTeX 内部宏。它的作用，是「预读」输入列表的下一个字符，然后判断预读的字符是否与作者期待的字符一致，执行不同的分支。 例如，我们知道，LaTeX 命令的可选参数，默认是放在所有必选参数之前。那么，我们是否有可能让可选参数放在必选参数之后呢？答案当然是肯定的，利用 \@ifnextchar 就可以做到。 123456789101112131415\documentclass&#123;article&#125;\makeatletter\newcommand&#123;\foo@helper@i&#125;[1]&#123;One parameter: #1&#123;&#125;.&#125;\def\foo@helper@ii #1[#2]&#123;Two parameters: #1&#123;&#125;, #2&#123;&#125;.&#125;\newcommand&#123;\foo&#125;[1]&#123;%\@ifnextchar[% &#123;\foo@helper@ii&#123;#1&#125;&#125;% &#123;\foo@helper@i&#123;#1&#125;&#125;%&#125;\makeatother\begin&#123;document&#125;\foo&#123;hello&#125;\foo&#123;hello&#125;[world]\end&#123;document&#125; 我们来看 \foo 的定义。它接收一个标准的 LaTeX 参数。因此不管是 \foo{hello} 还是 \foo{hello}[world]，LaTeX 都会把其中的 \foo{hello} 先「吃下去」。接下来，LaTeX 会判断下一个字符是否为 [。对于 \foo{hello} 这种用法，下一个字符是换行符，因此判定失败，执行 \foo@helper@i。而对于 \foo{hello}[world] 这种用法，吃下去 \foo{hello} 之后，输入流中剩下了 [world]...，下一个字符正是 [，因此执行 \foo@helper@ii。 对于 \foo@helper@ii，它是使用 TeX 的原语 \def 定义的命令。参数列表 #1[#2] 表示该命令接受两个参数。第一个参数是标准的 TeX 参数——用分组包括起来。因此，上一步执行的 \foo@helper@ii 将第一个参数喂给了 \foo@helper@ii。接下来，\foo@helper@ii 还要吃下去第二个参数。按照定义，第二个参数被方括号 [] 所包围。因此 [world] 中的 world 被吃掉，作为第二个参数。 最终输出如图。 \bgroup上面的 \foo 命令，基本已经达成了我们的目标。只不过，第二个参数必须是用方括号表达的。当然这不是不可以，但强迫症选手们可能会希望第二个参数也能用花括号来界定。强迫症们尝试把 \@ifnextchar[ 尝试换成了 \@ifnextchar{，于是他们得到了报错 1File ended while scanning use of... 这是因为，TeX 遇到 { 时，会将其解释为一个分组。因此，这种写法会造成 TeX 读入的分组不匹配。这样一来，我们就必须用 \bgroup 来代替花括号。它的定义是 \let\bgroup={。 123456789101112131415\documentclass&#123;article&#125;\makeatletter\newcommand&#123;\foo@helper@i&#125;[1]&#123;One parameter: #1&#123;&#125;.&#125;\newcommand&#123;\foo@helper@ii&#125;[2]&#123;Two parameters: #1&#123;&#125;, #2&#123;&#125;.&#125;\newcommand&#123;\foo&#125;[1]&#123;%\@ifnextchar\bgroup% &#123;\foo@helper@ii&#123;#1&#125;&#125;% &#123;\foo@helper@i&#123;#1&#125;&#125;%&#125;\makeatother\begin&#123;document&#125;\foo&#123;hello&#125;\foo&#123;hello&#125;&#123;world&#125;\end&#123;document&#125; 这样一来，我们就实现了一个 \foo 命令，在参数不同的情况下，具有不同的行为。 xparse 宏包基于 LaTeX3 的 xparse 宏包给了我们新的选项。它提供的 \NewDocumentCommand 命令，允许用户使用新的接口定义 LaTeX 命令。其形式为 1\NewDocumentCommand&#123;&lt;command&gt;&#125;&#123;&lt;parameter specificers&gt;&#125;&#123;&lt;replacement text&gt;&#125; 比如，以下两个定义，效果是一致的。 1234\usepackage&#123;xparse&#125;\newcommand&#123;\baz&#125;[1]&#123;I eat #1&#123;&#125;.&#125;\NewDocumentCommand&#123;\bar&#125;&#123;m&#125;&#123;I eat #1&#123;&#125;.&#125; 其中，参数标识符 m 表示 \bar 接收一个标准的 LaTeX 参数。除去 m 之外，xparse 宏包还提供了许多额外的参数标识符（具体参照其手册）。其中，g 表示该参数是一个可选参数，并且以花括号界定其范围。当参数未给出时，参数值为 -NoValue-；否则是实际的参数内容。此时我们可以用 \IfNoValueTF 命令来做分支判断。 于是，上述 \foo 命令可以按如下方式实现。 123456789101112\documentclass&#123;article&#125;\usepackage&#123;xparse&#125;\NewDocumentCommand&#123;\foo&#125;&#123;mg&#125;&#123;% \IfNoValueTF&#123;#2&#125;% &#123;One parameter: #1&#123;&#125;.&#125;% &#123;Two parameters: #1&#123;&#125;, #2&#123;&#125;.&#125;%&#125;\begin&#123;document&#125;\foo&#123;hello&#125;\foo&#123;hello&#125;&#123;world&#125;\end&#123;document&#125; 这样的实现方式，相对在 LaTeX2e 里用 \@ifnextchar\bgroup 判断就简单清晰多了。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Macro</tag>
        <tag>TeX</tag>
        <tag>LaTeX2e</tag>
        <tag>LaTeX3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈离散卷积和卷积神经网络]]></title>
    <url>%2F2017%2F07%2F27%2Fconvolutions-and-convolution-neural-network%2F</url>
    <content type="text"><![CDATA[早在学习数学分析时，我就已经接触过卷积的概念。然而，彼时年少，水平有限，没有完整地理解卷积的概念和精髓。这个遗憾一直持续至今。接触到卷积神经网络（Convolution Neural Network, CNN）之后，旧事重提般地，想要了解清楚卷积的冲动就愈发强烈，终至此文。 这是一篇介绍性质的文章。文中的公式、动画效果限于网页的表现力，无法达至完美。本文有对应的 PDF 格式的幻灯片可供下载（离散卷积和卷积神经网络）。你可能需要使用 Adobe Acrobat/Reader 作为 PDF 阅读器，以获得幻灯片的所有效果。 初识卷积一问卷积「卷积」这个词给人的第一印象就是「萌萌哒」，因此，恐怕很多人听见卷积的第一反应会是：「卷积可以吃吗为什么要叫这个名字」。 粗暴地回答的话，理由有三： 卷在这里对应英文的 convolve 这个单词，在卷积这个概念中，它的本意是「翻转」； 积在这里对应乘积，因为卷积是通过两个函数/序列的乘积实现的； 它真的是在「卷」——把多个乘积卷在一起变成一个值。 形式定义在具体介绍卷积是什么、为什么是这样、有什么用之前，让我们预先「先入为主」地看一看一维卷积的定义是什么样的。 离散形式：$(x * y)[n] = \sum_{m = -\infty}^{+\infty}x[m]\cdot y[n - m]$。 连续形式：$(f * g)(t) = \int_{-\infty}^{+\infty}f(\tau)\cdot g(t - \tau)\mathop{}\!\mathrm{d}\tau$。 当然，此篇主要介绍离散卷积，因此连续卷积从这一刻起就被暂时打入冷宫了。 如果你仔细观察离散卷积的定义，你就会发现，它也可以写成如下等价形式。 $$(x * y)[n] = \sum_{i + k = n}x[i]\cdot y[k].$$ 可以看到，卷积将等式右边的两个变量 $i$, $j$ 变成了等式左边的一个变量 $n$——俗称：降维打击。 一维离散卷积在详细介绍一维离散卷积之前，我们需要先了解什么是「线性时不变系统」。此后，在脉冲激励和冲激响应的叠加中，我们就能得到卷积。 线性时不变系统 线性时不变系统（Linear Time-invariant System）是一种特殊的信号系统。它的特性分成「线性」和「时不变」两个维度。 所谓线性，说的是系统的输出对输入满足齐次性和叠加性。这也就是说，若输入 $x_1(\tau)$ 和 $x_2(\tau)$ 分别得到 $y_1(\tau)$ 和 $y_2(\tau)$，那么对于任意的常数 $c_1$, $c_2$ 满足 $c_1x_1(\tau) + c_2x_2(\tau)$ 的输入在系统的作用下产生输出 $c_1y_1(\tau) + c_2y_2(\tau)$。 输入 输出 $x_1(\tau)$ $y_1(\tau)$ $x_2(\tau)$ $y_2(\tau)$ $c_1x_1(\tau) + c_2x_2(\tau)$ $c_1y_1(\tau) + c_2y_2(\tau)$ 所谓时不变，说的是系统对固定输入的输出响应不随时间发生变化。这也就是说，若输入 $x(\tau)$ 得到输出 $y(\tau)$，则若输入 $x(t_0 + \tau)$ 得到输出 $y(t_0 + \tau)$。 输入 输出 $x(\tau)$ $y(\tau)$ $x(t_0 + \tau)$ $y(t_0 + \tau)$ 冲激和响应信号系统的输入，称之为「激励」。对信号系统来说，它通常会接收一连串的激励。这一连串的激励，通常在瞬时发生，然后消退。因此信号系统的输入又称之为「脉冲激励」，简称「冲激」。若以 $y$ 记信号系统的冲激，则它应该是一个序列 $y[n]$。具体的值 $y[i]$ 或 $y_i$ 表示第 $i$ 时刻信号系统接收的脉冲激励。 $$y[n] = \{ \ldots, y_{-1} = 0, y_0 = i, y_1 = j, y_2 = k, y_3 = 0, \ldots \}.$$ 信号系统的输出，称之为「响应」。对于单位强度冲激的响应，即是「冲激响应」。信号系统对单独的冲激，做出的响应输出，可能在冲激发生之后持续一段时间。若以 $x$ 记信号系统的冲激响应，则它也应该是一个序列 $x[n]$。具体的值 $x[i]$ 或 $x_i$ 表示系统接收到单位强度冲激之后第 $i$ 时刻做出的响应输出。 若你不太理解为何响应会在冲激发生之后持续一段时间，那么你可以把自己比作一个信号系统。当你遇到什么开心/不开心的事情之后，你高兴/伤心的情绪不会只在那一瞬间出现，而是会持续一段时间。 $$x[n] = \{ \ldots, x_{-1} = 0, x_0 = a, x_1 = b, x_2 = c, x_3 = 0, \ldots \}.$$ 连续冲激的响应现在我们知道几个事实： 系统接收到一份输入后，其后的一段时间内会陆续给出输出响应； 系统会连续收到若干输入； 系统是线性时不变的。 特别地，输入冲激 $\hat y$ 在 $x[n]$ 的作用下，第 $i$ 时刻的输出是 $\hat y\cdot x[i]$。因此，整个线性时不变系统在第 $i$ 时刻的输出，应该是$$y[0]\cdot x[i] + y[1]\cdot x[i - 1] + \cdots.$$当然，对于两端延伸的无穷序列，你应该把它写作$$\cdots + y[-1]\cdot x[i + 1] + y[0]\cdot x[i] + y[1]\cdot x[i - 1] + \cdots.$$ 以上一小节的数据为例，将数据制成表如下： time 0 1 2 3 4 $y_0 = i$ $ai$ $bi$ $ci$ $0$ $0$ $y_1 = j$ $0$ $aj$ $bj$ $cj$ $0$ $y_2 = k$ $0$ $0$ $ak$ $bk$ $ck$ 接下来，你只需要纵向观察表格，将每一纵列的值相加，就能得到相应时刻的系统输出响应了。 离散卷积从上面的分析中，可以看出，对于任意时刻 $n$，系统的输出是 $$z[n] \overset{\text{def}}{=} (x*y)[n] = \sum_{m = -\infty}^{+\infty}x[n - m]\cdot y[m] = \sum_{m = -\infty}^{+\infty}x[m]\cdot y[n - m].$$ 这正是一维离散卷积的定义。以 $\sum_{m = -\infty}^{+\infty}x[m]\cdot y[n - m]$ 为例，不难发现，卷积其实是一种推广的加权平均：以 $x$ 为权，以 $n$ 为中心，把 $y$ 距离中心 $-m$ 位置上的值乘上 $x$ 在 $m$ 位置的值，最后加到一起。 定投的例子现在假设有一个一年期定投项目，它的利率始终保持不变。因此，整个定投项目可以视作是一个线性时不变系统。 最终收益对投入的资金是线性累加的； 利率不变，意味着任何时候投入资金的效果是一样的。 因此，你可以定义响应序列 $$x[n] = \{ \ldots, x_{-1} = 0, x_0 = 1.05^0, x_1 = 1.05^1, \ldots, x_i = 1.05^i, \ldots \}.$$ 而后，假设你每年存入 100 元，于是有冲激序列 $$y[n] = \{ \ldots, y_{-1} = 0, y_0 = 100, y_1 = 100, \ldots, y_i = 100, \ldots \}.$$ 于是，任意时刻的账户余额 $z[n] \overset{\text{def}}{=} (x*y)[n]$ 是卷积。 time $0$ $1$ $2$ $3$ $4$ $y_0 = 100$ $100$ $100\times 1.05^1$ $100\times 1.05^2$ $100\times 1.05^3$ $100\times 1.05^4$ $y_1 = 100$ $0$ $100$ $100\times 1.05^1$ $100\times 1.05^2$ $100\times 1.05^3$ $y_2 = 100$ $0$ $0$ $100$ $100\times 1.05^1$ $100\times 1.05^2$ $y_3 = 100$ $0$ $0$ $0$ $100$ $100\times 1.05^1$ $y_4 = 100$ $0$ $0$ $0$ $0$ $100$ 接下来，我们回过头观察 $\sum_{m = -\infty}^{+\infty}x[m]\cdot y[n - m]$ 这个式子。 若以 $m$ 为「自变量」，则 $y[n - m]$ 相当于把 $y[m]$ 的图像左右翻转（这即是翻转的来源），然后再向右移动 $n$ 个单位。而当 $n$ 增大时，相当于 $x$ 不动而 $y$ 沿着轴线向右滑动。当 $x$ 和 $y$ 重叠时，计算重叠部分的乘积，然后加和得到最终结果。这个加和的过程，放在连续函数的情景下，就是积分了。将这个过程，制作成动态图如下。 怎样卷？通过观察 $\sum_{m = -\infty}^{+\infty}x[m]\cdot y[n - m]$，我们已经知道了卷积是怎样翻转的，也知道卷积的积分从何而来。现在我们讨论关于卷积的终极问题：究竟要怎样才能「卷起来」？ 我们来看这张图。它的横轴和纵轴被替换成了 $m$ 和 $n - m$，恰好对应 $\sum_{m = -\infty}^{+\infty}x[m]\cdot y[n - m]$ 中的 $x[m]$ 和 $y[n - m]$。途中有两条斜线，斜线经过的整数交点上画着小黑点。这些小黑点代表相应位置的 $x[m]\cdot y[n - m]$；而斜线则代表将这条斜线上所有小黑点的值相加。 不难发现，$m(n-m)$-二维平面上斜率为 $-1$ 的斜线族，其中每条这样的斜线（包括没有画出来的），都表示了一个卷积。特别地，斜线上每一个整数点的横纵坐标相加（即是 $m + (n - m)$）都是 $n$。因此，斜线对应的卷积是 $(x * y)[n]$。这样，我们就建立了斜线与卷积值之间的对应关系。 现在，把 $m(n-m)$-二维平面想象成一块无限薄的地毯。接下来，我们沿着斜率为 $-1$ 的直线方向，把地毯卷起来。这样，我们就将地毯卷成了一条直线。而这条直线上的每个点，都对应了原平面上的一条直线。也就是说，在「卷地毯」的过程中，原平面的直线纷纷坍缩成了一系列的点。而这些轴线与其上的点，正可作为是卷积 $(x*y)[n]$ 中 $n$ 所在的数轴。 这就是为什么我们说，卷积它真的可以「卷」了。 二问卷积至此，一维离散卷积相关的内容，我们就介绍完了。现在我们回过头来看看，在介绍一维离散卷积的过程中，卷积表现出了哪些特点。 我们是通过线性时不变的信号系统引出卷积的概念的。若仍以信号系统的说辞为例，则不难发现： 一个脉冲激励可以影响到信号系统在若干时刻的输出； 从另一个角度，这也就是说，信号系统任意时刻的输出，取决于相关的多个冲激输入。 也就是说，和一般的函数不同，信号系统的输入和输出不是「一对一」的关系，而是「多对多」的关系。我们在后续介绍卷积神经网络的时候，会看到这一特点的作用。 此外，仍以信号系统的说辞为例，我们也不难发现，系统的最终输出，一方面取决于输入的激励信号长什么样子，另一方面取决于冲激响应的模式。这两方面相互作用（就是卷积），最终决定了信号系统的输出。 在后续对一维离散卷积的观察中，我们发现，连续地求解多个卷积值的时候（即，求解 $n = 0, 1, 2, \ldots$ 的卷积值时），我们实际上做的事情可以归纳成： 翻转输入信号； 输入信号沿轴线向前滑动； 输入信号与冲激响应叠加的部分分别求积，然后相加。 而实际上我们发现，在卷积的定义中，$x$ 和 $y$ 是地位等同的。这就是说，我们也完全可以选择翻转而后滑动冲激响应的模式，再去求积、叠加。此时，我们通常会把冲激响应称为「卷积核」，而把整个过程形象地称之为：滑动卷积核。 二维离散卷积定义恭喜你，现在我们进入「高维宇宙」。 首先，让我们回顾一下一维离散卷积的定义。 $$(x*y)[n] \overset{\text{def}}{=} \sum_{m = -\infty}^{+\infty}x[m]\cdot y[n - m].$$ 二维卷积的定义，在形式上和一维卷积完全一致——只需要将一维卷积中的变量 $m$, $n$ 从标量变成向量即可。当然，你也可以将向量的两个分量展开，记成标量形式。 $$ \begin{aligned} (x*y)[\vec n] \overset{\text{def}}{=}{}&amp; \sum_{\vec m = (-\infty, -\infty)}^{(+\infty, +\infty)}x[\vec m]\cdot y[\vec n - \vec m] \\ (x*y)[n_1, n_2] \overset{\text{def}}{=}{}&amp; \sum_{m_1 = -\infty}^{+\infty}\sum_{m_2 = -\infty}^{+\infty}x[m_1, m_2]\cdot y[n_1 - m_1, n_2 - m_2]. \end{aligned} $$ 类似地，你可以定义更高维的卷积。 若仔细观察公式，不难发现，我们在二维卷积中遇到的问题，和在一维卷积中遇到的问题完全一致。二维卷积具有和一维卷积几乎完全相同的性质、特点、作用。和一维卷积一样，二维卷积也可以看做是加权平均的推广：以 $x$ 为权，以 $(n_1, n_2)$ 位中心，将 $y$ 距离中心 $(-m_1, -m_2)$ 位置的值乘上 $x$ 距离中心 $(m_1, m_2)$ 的值，最后加到一起。 图像的滤镜在实际应用中，卷积核 $x$ 的有效部分总是有限的。例如，下图展示了一个 $3\times 3$ 的卷积核，在图像上的滑动。 值得一提的是，对于图像来说，这个过程实际就是 PhotoShop 等图像处理软件中的「滤镜」效果。比如，假设我们有一个 $3\times 3$ 的卷积核 $$ \begin{bmatrix} 1/9 &amp; 1/9 &amp; 1/9 \\ 1/9 &amp; 1/9 &amp; 1/9 \\ 1/9 &amp; 1/9 &amp; 1/9 \end{bmatrix}, $$ 从直觉上分析，它将中心点附近的共 9 个点的像素值，平均到输出图像的中心像素点上；这实际上就是模糊效果对应的滤镜（box-blur）。又比如，假设我们有这样的卷积核 $$ \begin{bmatrix} 0 &amp; -1 &amp; 0 \\ -1 &amp; 5 &amp; -1 \\ 0 &amp; -1 &amp; 0 \\ \end{bmatrix}, $$ 从直觉上分析，它加强了中心像素点的作用，同时减小了位于其上下左右的四个像素点对它的干扰；这实际上就是锐化效果对应的滤镜（sharpen）。又比如，假设我们有这样的卷积核 $$ \begin{bmatrix} -1 &amp; -1 &amp; -1 \\ -1 &amp; 8 &amp; -1 \\ -1 &amp; -1 &amp; -1 \\ \end{bmatrix}, $$ 从直觉上分析，只有当中心像素点原本的像素值和周围 8 个像素点的值差距很大时，这个卷积核的输出，才会明显地不等于 0；因此，这实际上就是边缘检测对应的滤镜（edge detect）。 我们将上述三个矩阵以 Python 实现出来，就能看到它们的效果了。（参见：PIL 简明教程 - 像素操作与图像滤镜）其效果如下图所示。 三问卷积又到了思考问题的贤者时间。 在介绍一维卷积的过程中，我们已经讨论了卷积本身具有的特点。但是，也留下了一个问题：卷积在抽象上，到底有什么意义呢？ 站在人类的角度，我们先入为主地将上面 3 个示例的卷积核当做了「滤镜」。然而，事情真的是这样吗？如果我们忘记「滤镜」这一先验知识，那么我们可能会把这件事情，简单地以更抽象的方式描述为「卷积核处理图形」。没错，这仅仅是一个「处理」过程而已。现在我们回想一下，环境中的真实景象，也是经过我们的大脑处理之后，在脑海里形成实际的画面的。若然你知道，同一个真实景象，在不同生物的眼里是不一样的。那么你就不难发现，不同的生物，因其进化路径不同，大脑对环境真实景象的处理也不同，因而脑海中看到的景象也就不同。这与我们用不同的滤镜处理图像，得到不同的滤镜结果，何其相似？ 刚才我们说到不同生物眼里的世界是不一样的。那么，更深入地理解一下这份不同，我们会否领会到更多的东西呢？ 比如，我们可以思考：为什么自然选择会让不同的生物看到不同的景象？答案其实很简单：因为适者生存。蛇类的眼睛，按照人类的意识，几乎不能视物；然而因为经常需要夜间活动，所以蛇能够以红外的方式「看到」这个世界。青蛙的眼睛，难以察觉到静止的事物；然而因为它只对「会动的虫子」感兴趣，所以青蛙具有奇佳的动态视觉。站在更广的时间维度上，我们可以这样回答这个问题：对于具体的某种生物来说，因其生存需要，它只对某种形式的视觉效果感兴趣，因而其视觉处理系统进化成了当前的模样。简而言之，不同的生物，看待世界的方式，有不同的侧重点，因而将同一个真实景象处理成了不同的模样。 这里我们对生物的视觉效果进行了展开分析。这不是我要「跨界」当「神棍」，而是想以一种直觉的方式，以普遍的现象为对比，试着能够更好地理解卷积的意义。 至此，我们可以比较容易地制作出一张对应的表格。 卷积 生物视觉 机器学习领域的意义 滑动卷积核 视觉系统处理外界光信号 读入并处理结构化的特征 卷积核处理的结果 脑海中形成的视觉成像 卷积处理的结果 不同的卷积核 观察世界的不同方式、不同侧重点 不同角度的高维特征信号 这也就是说，特定的卷积核，能够从若干相关特征信号（通常是相邻位置的特征信号）中以特定的方式抽取新的高维特征。 卷积神经网络有了这些关于卷积的知识基础，现在我们可以讨论卷积神经网络了。我们假设你已经对神经网络有所了解，因此就不去从感知机开始，逐步地介绍了。 图片识别任务 这个例子，来自于 YJango的卷积神经网络——介绍。 在介绍二维离散卷积的时候，我们以图片为例。这是因为，图片是天然的二维像素矩阵组成的数据形式（RBG 三通道即是 3 个矩阵）。因此，专业里我们也以图片识别任务为例，展开对卷积神经网络的介绍。 如上图。每一个 $4 \times 4$ 的方块，都表示一张图片。在我们的表示中，黄色的圆圈表示空无一物的底色；黑色的圆圈，表示有内容的笔画。现在，我们要识别上图顶部的「横折」这一笔画。显而易见，上图下半部分的 6 张图片，内里都包含了横折。 前馈神经网络对于这样的图片识别任务，使用深度前馈神经网络来解决，当然是可以的。 如上图。为了解决这样的问题，我们首先需要将原始图片制成一个能用向量表示出来的数据形式。最简单的办法，就是将二维的图像，逐行地展开。如此，我们就从 object 得到了输入层 input。接下来，我们就可以把输入层链接到隐藏层当中，经过逐层地全连接，得到最终输出 output。通常来说，这个最终输出，是神经网络给出的概率。这个概率描述，神经网络认为当前图片中，包含「横折」的概率。 经过大量的训练，这样的神经网络可以很好地完成识别任务。然而，这样的网络设计，也可能存在一些问题。 如上图。假设左侧的 4 张图片，是我们标注好的训练样本。经过训练之后，我们的神经网络应当已经具有一定的能力，尝试识别图片中是否存在「横折」这一笔画。然而，由于训练神经网络时的输入样本十分有限，我们的神经网络可能并不认得右侧的样本。特别地，在我们的神经网络示意图中，左上角的横折和位于中间的横折是完全不同的两个向量。因此，我们得到的神经网络模型，很可能无法给出对右侧未知样本的准确预测。 那么，怎么办呢？ 最最简单容易想到的办法，就是增加训练时的训练样本。若然我们能够让样本覆盖所有情况，那么训练得到的神经网络自然就可以识别所有的情况，并给出结论了。不过，最简单容易想到的解法，往往暗含各种各样的问题。首先，我们的图片识别任务中，图片都是 $4 \times 4$ 的小型图片。对这类图片，穷举所有可能，其总数也只有 $2^{16}$ 张。对于这种类型的问题，穷举所有情况，大致是没有问题的。然而，实际生产中，我们遇到的问题，其复杂度要远远高于现在我们所言的「玩具问题」。在实际问题中，我们不可能让样本覆盖所有情形。另一方面，若是简单粗暴地扩增样本容量，就失去了模型「预测」的意义了。换而言之，这就不是我们追求的高可泛化的模型了。 表意的平移不变性——对问题的深入思考扩大训练集的解法，当然也是一个办法。在实际生产中，有些时候也确实需要扩大训练集，以解决一些欠拟合的问题。然而，正如任何定理都有其适用范围，我们也需要斟酌扩大训练集在当前任务中是否合适。显然，有上面的分析，在当前任务中，这不是个好办法。 那么，问题出在哪里呢？或者说，我们应当在哪个方向前进，以便解决这个问题呢？在上面的分析中，我们有提到一句话：「在我们的神经网络示意图中，左上角的横折和位于中间的横折是完全不同的两个向量」。我想，若你足够敏感，应该能意识到什么。 不好。这很不好。在表意上，位于图片左上角的横折之于位于图片中间的横折没有什么差别。也就是说，在图片上任意平移横折的位置，其表意不发生变化。我们称之为表意的平移不变性。然而，在我们的神经网络中，这两个横折在输入层的表现居然没有什么共同点。显而易见，这是不合理的。因此，在遇到的这个问题中，我们首先应该考虑的，不是扩增训练集，而是应当考虑我们神经网络是否足够好地适应当前的问题。 那么，我们的神经网络中，问题出在哪里呢？ 首先，我们的神经网络是针对每个像素的具体情况进行训练的。其次，图片上的区域各自为政，没有关联。也就是说，我们的神经网络，很难捕捉到相邻区域中几个像素点（特征值）的结构信息。另一方面，我们的神经网络，也没有以一种一致地视角，去看待每一个局部的结构。这样一来，我们的神经网络就可能会把位于左上角的横折与位于中间的横折，当成两个完全没有关联的图形。这显然是不合适的。 引入卷积至此，就轮到卷积出场拯救世界了。 我们回顾一下简单的前馈神经网络在当前任务中遇到的问题：无法一致地捕捉局部的结构信息。我们再来回想一下卷积的特点：以一个固定的卷积核，收集相邻特征信号的信息，加权平均得到卷积值。啊！卷积的这些特点，不就正好弥补了当前前馈神经网络的不足吗？ 于是，我们可以设计出这样的网络结构。 如上图。首先，我们用一个固定的 $2 \times 2$ 的卷积核作为窗口，逐个像素地扫描原图片。这样一来，我们可以得到 $3 \times 3$ 的卷积结果，称为 convolved feature。而后，和我们在前馈神经网络中做的一样，我们将 convolved feature 展开，作为输入层，链接其背后的隐藏层，并最终得到输出。 在这个过程中，神经网络的参数，除了隐藏层中的各个神经元上的参数，还有卷积核的具体内容。也就是说，卷积核的大小是固定的，但是它长什么样子，是需要具体训练的。 这样引入了卷积的神经网络，就是卷积神经网络（Convolution Neural Network, CNN）了。当然，在实际使用中，还常常引入名为池化（Pooling）的技术，这里按下不表。 不变性的讨论有了卷积，我们的神经网络就能一致地去捕捉输入信号局部的结构信息。特别地，由于卷积核在不同位置上是共享的，所以笔画的平移在神经网络看来，就不影响表意了。因此我们说，卷积神经网络满足了平移不变性。 那么，是否还有其它的不变性呢？当然是有的。 比如，我们现在的横折由 $3$ 个像素在 $2 \times 2$ 的局部中组成。那么，若是将它放大，在 $3 \times 3$ 的局部中，用 $5$ 个像素去组成横折，是否也可以呢？答案是显而易见的：大猫也是猫，大狗也是狗。这种现象，我们称之为缩放不变性。那么，当前的卷积神经网络，是否能解决这样的问题呢？我们说，不能。因为我们当前使用的卷积核是 $2 \times 2$ 的，它无法去捕捉 $3 \times 3$ 的局部结构中的完整信息。因此，当前的卷积神经网络，没有满足缩放不变性。若要满足缩放不变性，我们可以考虑用不同大小的卷积核，分别处理原图像；或者，可以考虑在卷积层的基础上，再用卷积处理一次。 又比如，假设我们不识别笔画，我们识别图片中的铅笔。在图片中，除了说铅笔可大可小，位置上可以在图片上游走，铅笔还可能以不同角度出现——横着放的、竖着放的、斜着放的。但不论铅笔如何摆放，它都是铅笔。这种现象，我们称之为旋转不变性。不过，很遗憾，由于卷积的特性所限，我们无法简单地用卷积，让神经网络满足旋转不变性。 卷积神经网络直觉上的优势上面我们讨论了卷积的特点。因此，我们不难总结卷积神经网络的一些优势。 适用于相关元素（特别是相邻元素）中存在结构特征的情况； 适用于上述结构可能出现在不同位置的情况。 现在，我们考虑一下分类问题。对于分类问题来说 在分割线（可能是超平面、超曲面）附近，样本往往存在特定的结构特征； 输入的样本，可能位于分割线的不同位置，因此上述结构也可能出现在分割线的不同位置。 分类问题的这样的特点，恰恰符合了卷积神经网络的优势。因此，人们常常偏向于认为：「卷积神经网络可以在分类问题上表现得好」。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Convolutions</tag>
        <tag>CNN</tag>
        <tag>Neural Network</tag>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 LaTeX 中同步缩放 TikZ 与其中的 node]]></title>
    <url>%2F2017%2F07%2F23%2Fglobal-scale-for-TikZ-picture%2F</url>
    <content type="text"><![CDATA[PGF/TikZ 是 Till Tantau 开发的基于 TeX 的绘图引擎。因其可以直接在 LaTeX 文稿中通过代码绘制向量图，所以是目前流行的 LaTeX 绘图解决方案之一。 在 tikzpicture 环境或者 \tikz 命令的参数中，可以通过 scale 选项来缩放绘制的图形。然而，这种缩放不会同步应用在 node 中的文字上，导致图形与 node 中的文字注解大小失衡。 我们来解决这个问题。 绘制一个函数图像现在，比如说我们绘制一个最简单的二次函数的图像。 1234567891011121314151617\begin&#123;tikzpicture&#125; \draw[gray, step = 0.5cm] (0, 0) grid (5, 5); \draw[-&gt;] (-.5, 0) -- (5.5, 0); \draw[-&gt;] (0, -.5) -- (0, 5.5); \node[anchor = north east] at (0, 0) &#123;$ o $&#125;; \node[anchor = north] at (5.5, 0) &#123;$ x $&#125;; \node[anchor = west] at (0, 5.5) &#123;$ y $&#125;; \foreach \x in &#123;1, ..., 5&#125; &#123; \node[anchor = north] at (\x, 0) &#123;$ \x $&#125;; \node[anchor = east] at (0, \x) &#123;$ \x $&#125;; &#125; \draw[domain = -0.5:2.2, smooth, variable=\x, blue] plot (&#123;\x&#125;, &#123;\x * \x&#125;) node[anchor = west] &#123;$ y = x^2 $&#125;;\end&#123;tikzpicture&#125; 放大之现在，你觉得这张图太小。于是你考虑给 tikzpicture 环境加上 scale = 2 来放大它。 1234567891011121314151617\begin&#123;tikzpicture&#125;[scale = 2] \draw[gray, step = 0.5cm] (0, 0) grid (5, 5); \draw[-&gt;] (-.5, 0) -- (5.5, 0); \draw[-&gt;] (0, -.5) -- (0, 5.5); \node[anchor = north east] at (0, 0) &#123;$ o $&#125;; \node[anchor = north] at (5.5, 0) &#123;$ x $&#125;; \node[anchor = west] at (0, 5.5) &#123;$ y $&#125;; \foreach \x in &#123;1, ..., 5&#125; &#123; \node[anchor = north] at (\x, 0) &#123;$ \x $&#125;; \node[anchor = east] at (0, \x) &#123;$ \x $&#125;; &#125; \draw[domain = -0.5:2.2, smooth, variable=\x, blue] plot (&#123;\x&#125;, &#123;\x * \x&#125;) node[anchor = west] &#123;$ y = x^2 $&#125;;\end&#123;tikzpicture&#125; 于是你发现，整个图像确实放大了。但是其中的说明注解还是老样子，没有放大。这样一来，相比整个图像，注解文字就显得比较小。也许 scale = 2 的状态，看起来还算匀称，但若是 scale = 10，那么文字部分就小弱蚊蝇了。 另一方面，有些图像，其注解文字和图像内容是匹配好的。强行缩放之后，可能破坏好这种预先设置匹配，也不完美。 因此，我们得想办法解决。 全局缩放问题的原因在于，TikZ 中的 node，其内容、样式都是单独设置的，全局的 scale 设置无法影响 node 的内容。因此，我们有必要定义一个 global scale 的参数，统一地设置两部分的缩放比例。 12345678910111213141516171819202122\tikzset&#123;global scale/.style=&#123; scale=#1, every node/.append style=&#123;scale=#1&#125; &#125;&#125;\begin&#123;tikzpicture&#125;[global scale = 2] \draw[gray, step = 0.5cm] (0, 0) grid (5, 5); \draw[-&gt;] (-.5, 0) -- (5.5, 0); \draw[-&gt;] (0, -.5) -- (0, 5.5); \node[anchor = north east] at (0, 0) &#123;$ o $&#125;; \node[anchor = north] at (5.5, 0) &#123;$ x $&#125;; \node[anchor = west] at (0, 5.5) &#123;$ y $&#125;; \foreach \x in &#123;1, ..., 5&#125; &#123; \node[anchor = north] at (\x, 0) &#123;$ \x $&#125;; \node[anchor = east] at (0, \x) &#123;$ \x $&#125;; &#125; \draw[domain = -0.5:2.2, smooth, variable=\x, blue] plot (&#123;\x&#125;, &#123;\x * \x&#125;) node[anchor = west] &#123;$ y = x^2 $&#125;;\end&#123;tikzpicture&#125; 如此一来，node 中的内容，就会同步比例地缩放了。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>TikZ</tag>
        <tag>Scale</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说说泰勒展开、lop1p 及 expm1]]></title>
    <url>%2F2017%2F07%2F23%2Ftaylor-expansion-and-lop1p-and-expm1%2F</url>
    <content type="text"><![CDATA[在数学里，泰勒展开是拉格朗日定理（微分中值定理）和牛顿迭代法在高阶可微函数的推广。在机器学习领域，我们已经见过其威力；通过应用泰勒展开，我们可以大幅降低计算的复杂度。 这里，我们会回顾一下泰勒展开相关数学定义，并说说泰勒展开在计算机科学领域的另一个应用——高精数值计算。 泰勒其人说起来，现在名气最大的「泰勒」，当属那位甩一个男友就写一首歌的当红女歌手（泰勒·斯威夫特）了。不过此处我们说的泰勒，是英国数学家布鲁克·泰勒（Brook Taylor）。 泰勒 1685 年生于英格兰米德萨斯郡，1731 年逝于英格兰伦敦。尽管后世尊其为数学家，但实际上泰勒在剑桥大学攻读的学位是法学学士和博士学位。泰勒留下的工作不多，一方面由于其从事数学工作的时间比同时期其他数学家要短，另一方面由于它写的文稿往往语焉不详，难以理解。由此可见，好好说话的重要性。 泰勒最著名的工作有两个，但都集中在 1715 年发表的著作《Methodus Incrementorum Directa et Inversa》当中。其一是，从这部著作出发，后世引出了高等数学的一个分支：有限差分方法。其二是，这部著作中，提出了对无穷可微函数的泰勒级数。后者被他的后辈，著名的法国数学家约瑟夫·拉格朗日（Joseph Lagrange）尊为「导数计算的基础」（le principal fondement du calcul différentiel）。 泰勒展开与麦克劳林展开从原始的微分定义开始按照微分定义，函数在一点的微分，是它在该点附近的最佳线性近似： $$f(a+h) = f(a) + h\cdot f’(a) + o(h).$$ 其中，$o(h)$ 表示 $h$ 的高阶无穷小。这也就是说，对于可微函数 $f(x)$ 来说，有近似 $$f(a + h) \approx f(a) + h\cdot f’(a).$$ 显而易见，$f(x)$ 与 $f(a) + (x - a)\cdot f’(a)$ 在 $a$ 附近是很接近的。以数学的语言表述，这两个表达式在 $a$ 处的零阶导数（函数自身）与一阶导数相等。由此我们可以预计，如果一个函数足够光滑（$n + 1$ 阶可微），那么若有一个多项式在 $a$ 处的前 $n$ 阶导数值与函数自身的导数值相等，那么这一多项式就可以是该函数的近似。 泰勒定理定理的描述如下。 设 $n \in \mathbb{Z}^+$ 是一个正整数；设 $f(x)$ 是定义在包含 $a$ 的区间上的函数，并且在 $a$ 处 $n+1$ 阶可微。那么，对于这个函数在定义区间内的任意 $x$，都有：$$f(x) = f(a) + \frac{f’(a)}{1!}(x - a) + \frac{f’’(a)}{2!}(x - a)^2 + \cdots + \frac{f^{(n)}}{n!}(x - a)^n + \text{Res}_n(x).$$此处的多项式，称为 $f(x)$ 在 $a$ 处的泰勒展开式，并且 $\text{Res}_n(x)$ 作为泰勒公式的余项是 $(x - a)^n$ 的高阶无穷小。 泰勒公式的余项有多种形式，在不同意义上描述了泰勒展开与原函数的接近程度。 仅只说余项是高阶无穷小，即 $\text{Res}_n(x) = o[(x - a)^n]$，则是「皮亚诺」余项； 拉格朗日余项可视作微分中值定理的推广，即 $\text{Res}_n(x) = \frac{f^{(n + 1)}(\theta)}{(n + 1)!}(x - a)^{n + 1}$，其中 $\theta \in (a, x)$； 积分余项则课视作积分基本定理的推广，即 $\text{Res}_n(x) = \int_a^x \frac{f^{(n + 1)}(t)}{n!}(x - t)^{n} \mathop{}\!\mathrm{d}t$。 泰勒级数泰勒定理描述了 $n + 1$ 阶可微函数的 $n$ 阶泰勒展开。相应的，对于在 $a$ 处无穷可微的函数，则可以有在 $a$ 处的无穷阶泰勒展开。与此同时，余项因为趋于 $0$，可以取消。 $$f(x) = \sum_{n = 0}^{\infty} \frac{f^{(n)}(a)}{n!} (x - a)^n.$$ 特别地，若 $a = 0$，则泰勒展开特化为麦克劳林展开。 泰勒级数与计算精度浮点运算的精度损失众所周知，计算机的浮点运算，由于内部表示的问题（小数的二进制表示），总是有限的。通常情况，这无关紧要，但是某些情况仍会导致不少问题。例如说，有经验的程序员都知道，不能直接用相等去比较两个不知经过何种运算的来的浮点数。因为，它们在逻辑上可能相等，但是由于多次计算的精度损失，它们在内部表示上却并不相等。 为了说明精度损失，我们看一个在机器学习任务中常见的函数。 $$f(x) = \ln(1 - \exp(-x)).$$ 这个函数的定义域是 $(0, +\infty)$。 在 $x$ 取值适中的时候，我们可以直接计算函数值。 但是，当 $x \to 0^+$ 时，$\exp(-x)$ 十分接近 $1$；因此 $1 - \exp(-x)$ 损失精度之后，可能直接变成 $0$。此时，再进行对数运算，就不合适了。 又或者，当 $x$ 较大时，$\exp(-x)$ 十分接近 $0$；因此 $1 - \exp(-x)$ 损失精度之后，可能直接变成 $1$。此时，再进行对数运算，就只能得到 $0$ 了。 1234567891011121314151617181920212223242526272829303132333435363738394041In [1]: import mathIn [2]: def f(x): ...: return math.log(1 - math.exp(-x)) ...:In [3]: f(1)Out[3]: -0.45867514538708193In [4]: f(10)Out[4]: -4.54009603704951e-05In [5]: f(100)Out[5]: 0.0In [6]: f(1000)Out[6]: 0.0In [7]: f(0.1)Out[7]: -2.3521684610440903In [8]: f(0.01)Out[8]: -4.610166019324902In [9]: f(1e-8)Out[9]: -18.420680750029838In [10]: f(1e-15)Out[10]: -34.53957599234088In [11]: f(1e-20)---------------------------------------------------------------------------ValueError Traceback (most recent call last)&lt;ipython-input-11-f08323787079&gt; in &lt;module&gt;()----&gt; 1 f(1e-20)&lt;ipython-input-2-80da3292b612&gt; in f(x) 1 def f(x):----&gt; 2 return math.log(1 - math.exp(-x))ValueError: math domain error 泰勒展开拯救世界如果是简单的计算任务，损失一些精度可能无关紧要。但是，在一些不容出错的领域——比如利息计算，少许的精度损失，可能导致成百上千的差距。然而，精度损失是计算机系统的固有问题，我们无法轻易解决。此时，就轮到泰勒展开出场，去拯救世界了。 我们观察两个函数的泰勒展开， $$\begin{aligned}g(x) ={}&amp; \ln(1 + x) = x - \frac{x^2}{2} + \frac{x^3}{3} - \cdots \\h(x) ={}&amp; \exp(x) - 1 = x + \frac{x^2}{2!} + \frac{x^3}{3!} + \cdots\end{aligned}$$ 并且注意到以下事实， $$\begin{aligned}f(x) ={}&amp; g(-\exp(-x)) \\f(x) ={}&amp; \ln(-h(-x)).\end{aligned}$$ 因此，计算机在计算 $g(x)$ 和 $h(x)$ 时，可以借助泰勒展开，将对数函数、指数函数，转换成精度更高的幂函数计算，以此提高精度。另一方面，利用上述变形，我们就可以借助 $g(x)$ 和 $h(x)$ 去计算 $f(x)$ 了。特别地，在 $x \to 0^+$ 时，使用 $\ln(-h(-x))$ 的效果好；在 $x \to \infty$ 时，使用 $g(-\exp(-x))$ 的效果好。 实际实现看看$g(x)$ 和 $h(x)$ 在计算领域是两个重要的函数，多数语言的标准库中，都提供了这两个函数的泰勒展开实现。通常 $g(x)$ 的名字叫做 log1p 而 $h(x)$ 的名字叫做 expm1。我们用 log1p 和 expm1 重新实现目标函数看看。 123456789101112131415161718192021222324252627282930In [12]: def f(x, boundary = math.log(2)): ...: if x &lt;= boundary: ...: return math.log(-math.expm1(-x)) ...: else: ...: return math.log1p(-math.exp(-x)) ...:In [13]: f(1)Out[13]: -0.45867514538708193In [14]: f(10)Out[14]: -4.5400960370489214e-05In [15]: f(100)Out[15]: -3.720075976020836e-44In [16]: f(1000)Out[16]: -0.0In [17]: f(0.1)Out[17]: -2.3521684610440907In [18]: f(1e-8)Out[18]: -18.420680748952364In [19]: f(1e-15)Out[19]: -34.538776394910684In [20]: f(1e-20)Out[20]: -46.051701859880914 可以看到，新版本的目标函数，能够区分出自变量取值 $x = 100$ 和 $x = 1000$ 之间的差异了；另外，原本提示定义域错误的 $x = 1e-20$ 现在也能计算出正确的值了。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Taylor Expansion</tag>
        <tag>lop1p</tag>
        <tag>expm1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 中的黑暗角落（三）：模块与包]]></title>
    <url>%2F2017%2F07%2F23%2Fmodules-and-packages-of-python%2F</url>
    <content type="text"><![CDATA[如果你用过 Python，那么你一定用过 import 关键字加载过各式各样的模块。但你是否熟悉 Python 中的模块与包的概念呢？或者，以下几个问题，你是否有明确的答案？ 什么是模块？什么又是包？ from matplotlib.ticker import Formatter, FixedLocator 中的 matplotlib 和 ticker 分别是什么？中间的句点是什么意思？ from matplotlib.pyplot import * 中，import * 的背后会发生什么？ 鲁迅先生说：「于无声处听惊雷」，讲的是平淡时却有令人惊奇、意外的事情。import 相关的模块、包的概念也是如此。如果你对上面几个问题存有疑问，那么这篇就是为你而作的。 模块为什么要有模块众所周知，Python 有一个交互式的解释器。在解释器中，你可以使用 Python 的所有功能。但是，解释器是一次性的。也就是说，如果你关掉解释器，那么先前定义、运行的一切东西，都会丢失不见。另一方面，在解释器中输入代码是一件很麻烦的事情；这是因为在解释器中复用代码比较困难。 为此，人们会把相对稳定、篇幅较长的代码保存在一个纯文本文件中。一般来说，我们把这样扩展名为 .py 的文件称为 Python 脚本。为了提高代码复用率，我们可以把一组相关的 Python 相关的定义、声明保存在同一个 .py 文件中。此时，这个 Python 脚本就是一个 Python 模块（Module）。我们可以在解释器中，或者在其他 Python 脚本中，通过 import 载入定义好的 Python 模块。 模块的识别和 Python 中的其它对象一样，Python 也为模块定义了一些形如 __foo__ 的变量。对于模块来说，最重要的就是它的名字 __name__ 了。每当 Python 执行脚本，它就会为该脚本赋予一个名字。对于「主程序」来说，这一脚本的 __name__ 被定义为 &quot;__main__&quot;；对于被 import 进主程序的模块来说，这一脚本的 __name__ 被定义为脚本的文件名（base filename）。因此，我们可以用 if __name__ == &quot;__main__&quot;: 在模块代码中定义一些测试代码。 fibonacci.py123456789101112def fib_yield(n): a, b = 0, 1 while b &lt; n: yield b a, b = b, a+bdef fib(n): for num in fib_yield(n): print(num)if __name__ == "__main__": fib(10) 我们将其保存为 fibonacci.py，而后在 Python 解释器中 import 它。 12345678910111213141516171819202122232425262728In [1]: import fibonacciIn [2]: dir(fibonacci)Out[2]:['__builtins__', '__doc__', '__file__', '__name__', '__package__', 'fib', 'fib_yield']In [3]: print(fibonacci.__name__)fibonacciIn [4]: fibonacci.fib(5)1123In [5]: for num in fibonacci.fib_yield(5): ...: print(num) ...:1123 可以观察到，fibonacci.py 在作为模块引入时，fibonacci.__name__ 被设置为文件名 &quot;fibonacci&quot;。但若在命令行直接执行 python fibonacci.py，则 if 语句块会被执行，此时 __name__ 是 &quot;__main__&quot;。 模块的内部变量和初始化Python 为每个模块维护了单独的符号表，因此可以实现类似 C++ 中名字空间（namespace）的功能。Python 模块中的函数，可以使用模块的内部变量，完成相关的初始化操作；同时，import 模块的时候，也不用担心这些模块内部变量与用户自定义的变量同名冲突。 module_var.py1234567foo = 0def show(): print(foo)if __name__ == "__main__": show() 此处我们在模块 module_var 内部定义了内部变量 foo，并且在函数 show 中引用了它。 123456789101112In [7]: import module_var ...: ...: foo = 3 ...: ...: print(foo) ...: print(module_var.foo) ...: ...: module_var.show() ...:300 值得一提的是，模块的初始化操作（这里指 foo = 0 这条语句），仅只在 Python 解释器第一次处理该模块的时候执行。也就是说，如果同一个模块被多次 import，它只会执行一次初始化。 from ... import ...模块提供了类似名字空间的限制，不过 Python 也允许从模块中导入指定的符号（变量、函数、类等）到当前模块。导入后，这些符号就可以直接使用，而不需要前缀模块名。 123456789In [8]: from fibonacci import fib_yield, fibIn [9]: fib(10)112358 值得一提的是，被导入的符号，如果引用了模块内部的变量，那么在导入之后也依然会使用模块内的变量，而不是当前环境中的同名变量。 123456In [11]: from module_var import showIn [12]: foo = 3In [13]: show()0 也有更粗暴的方式，导入模块内的所有公开符号（没有前缀 _ 的那些）。不过，一般来说，除了实验、排查，不建议这样做。因为，通常你不知道模块定义了哪些符号、是否与当前环境有重名的符号。一旦有重名，那么，这样粗暴地导入模块内所有符号，就会覆盖掉当前环境的版本。从而造成难以排查的错误。 模块搜索路径之前我们都在讨论模块的好处，但是忽略了一个问题：Python 怎样知道从何处找到模块文件？ 如果你熟悉命令行，那么这个问题对你来说就不难理解。在命令行中执行的任何命令，实际上背后都对应了一个可执行文件。命令行解释器（比如 cmd, bash）会从一个全局的环境变量 PATH 中读取一个有序的列表。这个列表包含了一系列的路径，而命令行解释器，会依次在这些路径里，搜索需要的可执行文件。 Python 搜寻模块文件，也遵循了类似的思路。比如，用户在 Python 中尝试导入 import foobar，那么 首先，Python 会在内建模块中搜寻 foobar； 若未找到，则 Python 会在当前工作路径（当前脚本所在路径，或者执行 Python 解释器的路径）中搜寻 foobar； 若仍未找到，则 Python 会在环境变量 PYTHONPATH 中指示的路径中搜寻 foobar； 若依旧未能找到，则 Python 会在安装时指定的路径中搜寻 foobar； 若仍旧失败，则 Python 会报错，提示找不到 foobar 这个模块。 1234567In [14]: import foobar---------------------------------------------------------------------------ImportError Traceback (most recent call last)&lt;ipython-input-14-909badd622c0&gt; in &lt;module&gt;()----&gt; 1 import foobarImportError: No module named foobar pyc 文件和 LaTeX 中遇到的问题一样：装载大量文本文件是很慢的。因此 Python 也采用了类似 LaTeX 的解决方案：将模块编译成容易装载的文件，并保存起来（相当于 LaTeX 中的 dump 格式文件 .fmt）。这些编译好并保存起来的文件，有后缀名 .pyc。 当 Python 编译好模块之后，下次载入时，Python 就会读取相应的 .pyc 文件，而不是 .py 文件。而装载 .pyc 文件会比装载 .py 文件更快。 值得一提的是，对于 .pyc，很多人一直有误解。事实上，从运行的角度，装载 .pyc 并不比装载 .py 文件更快。此处的加速，仅只在装载模块的过程中起作用。因此 .pyc 中的 C 更多地可以理解为 cache。 包包（package）是 Python 中对模块的更高一级的抽象。简单来说，Python 允许用户把目录当成模块看待。这样一来，目录中的不同模块文件，就变成了「包」里面的子模块。此外，包目录下还可以有子目录，这些子目录也可以是 Python 包。这种分层，对模块识别、管理，都是非常有好处的。特别地，对于一些大型 Python 工具包，内里可能有成百上千个不同功能的模块。若是逐个模块发布，那简直成了灾难。 科学计算领域，SciPy, NumPy, Matplotlib 等第三方工具，都是用包的形式发布的。 目录结构Python 要求每一个「包」目录下，都必须有一个名为 __init__.py 的文件。从这个文件的名字上看，首先它有 __ 作为前后缀，我们就知道，这个文件肯定是 Python 内部用来做某种识别用的；其次，它有 init，我们知道它一定和初始化有关；最后，它有 .py 作为后缀名，因此它也是一个 Python 模块，可以完成一些特定的工作。 现在假设你想编写一个 Python 工具包，用来处理图片，它可能由多个 Python 模块组成。于是你会考虑把它做成一个 Python 包，内部按照功能分成若干子包，再继续往下分成不同模块去实现。比如会有这样的目录结构。 1234567891011121314151617picture/ Top-level package __init__.py Initialize the picture package formats/ Subpackage for file format conversions __init__.py jpgread.py jpgwrite.py pngread.py pngwrite.py bmpread.py bmpwrite.py ... filters/ Subpackage for filters __init__.py boxblur.py gaussblur.py sharpen.py ... 此处 picture 目录下有 __init__.py，因此 Python 会将其作为一个 Python 包；类似地，子目录 formats 和 filters 就成了 picture 下的子包。这里，子包的划分以功能为准。formats 下的模块，设计用于处理不同格式的图片文件的读写；而 filters 下的模块，则被设计用于实现各种滤镜效果。 使用 Python 包Python 包的使用和模块的使用类似，是很自然的方式。以我们的 picture 包为例，若你想使用其中具体的模块，可以这样做。 1import picutre.filters.gaussblur 如此，你就导入了 picture 包中 filters 子包中的 gaussblur 模块，你就能使用高斯模糊模块提供的功能了。具体使用方式，和使用模块也保持一致。 1picture.filters.gaussblur.gaussblur_filter(input, output) 这看起来很繁琐，因此你可能会喜欢用 from ... import ... 语句，脱去过多的名字限制。 1from picture.filters import gaussblur 这样一来，你就可以直接按如下方式使用高斯模糊这一滤镜了。 1gaussblur.gaussblur_filter(input, output) __init__.py之前简单地介绍了 __init__.py 这个特殊的文件，但未展开。这里我们展开详说。 首先的问题是，为什么要设计 __init__.py，而不是自动地把任何一个目录都当成是 Python 包？这主要是为了防止重名造成的问题。比如，很可能用户在目录下新建了一个子目录，名为 collections；但 Python 有内建的同名模块。若不加任何限制地，将子目录当做是 Python 包，那么，import collections 就会引入这个 Python 包。而这样的行为，可能不是用户预期的。从这个意义上说，设计 __init__.py 是一种保护措施。 接下来的问题是，__init__.py 具体还有什么用？ 首先来说，__init__.py 可以执行一些初始化的操作。这是因为，__init__.py 作为模块文件，会在相应的 Python 包被引入时首先引入。这就是说，import picture 相当于是 import picture.__init__。因此，__init__.py 中可以保留一些初始化的代码——比如引入依赖的其他 Python 模块。 其次，细心的你可能发现，上一小节中，我们没有介绍对 Python 包的 from picture import * 的用法。这是因为，从一个包中导入所有内容，这一行为是不明确的；必须要由包的作者指定。我们可以在 __init__.py 中定义名为 __all__ 的 Python 列表。这样一来，就能使用 from picture import * 了。 具体来说，我们可以在 picture/__init__.py 中做如下定义。 __init__.py123import collections # import the built-in package__all__ = ["formats", "filters"] 此时，若我们在用户模块中 from picture import *，则首先会引入 Python 内建的 collections 模块，而后引入 picture.formats 和 picture.filters 这两个 Python 子包了。 在包内使用相对层级引用其他模块细心的你应该已经发现，在引入 Python 包中的模块时，我们用句点 . 代替了斜线（或者反斜线）来标记路径的层级（实际上是包和模块的层级）。在 Python 包的内部，我们也可以使用类似相对路径的方式，使用相对层级来简化包内模块的互相引用。 比如，在 gaussblur.py 中，你可以通过以下四种方式，引入 boxblur.py，而它们的效果是一样的。 gaussblur.py1234import boxblurfrom . import boxblurfrom ..filters import boxblurfrom .. import filters.boxblur as boxblur]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Packages</tag>
        <tag>Modules</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使斜体中的括号保持直立]]></title>
    <url>%2F2017%2F07%2F03%2Fupright-braces-in-italic-mode%2F</url>
    <content type="text"><![CDATA[在使用 \emph, \textit, \textsl 等命令时，我们往往希望西文字符倾斜，但括号保持直立。这是因为，括号并不是字母，让它们也倾斜一则没有意义，二则看起来奇怪。 Clemens 提供的 embrac 宏包解决了这个问题。 基本用法宏包的基本用法十分简单，只需要加载它就好了。默认情况下，圆括号和方括号已经设置好直立了。 123456789\documentclass&#123;article&#125;\usepackage&#123;embrac&#125;\begin&#123;document&#125;\textit&#123;[(italic)]&#125;\textsl&#123;[(slant)]&#125;\emph&#123;[(emphasis)]&#125;\end&#123;document&#125; 开关有时，我们可能需要在部分情况下，让括号也变成倾斜的。这时候，我们需要组合使用 \EmbracOff 和 \EmbracOn 两个命令。 1234567891011\documentclass&#123;article&#125;\usepackage&#123;embrac&#125;\begin&#123;document&#125;\textit&#123;[(italic)]&#125;\EmbracOff\textsl&#123;[(slant)]&#125;\EmbracOn\emph&#123;[(emphasis)]&#125;\end&#123;document&#125; 花括号宏包默认没有将花括号也设置为直立体，按文档的说法，可以通过 \AddEmph 命令设置实现。但我的尝试没有成功。 Update 2017-7-4: 下列代码在 pdfLaTeX 下能编译得到预期结果，但在 XeLaTeX 下则不然。 Update 2017-7-4: 经过反馈，作者确认这是一个 bug，并已修复。同时宏包版本号升为 0.7。在新版本中，一切正常。 1234567891011\documentclass&#123;article&#125;\usepackage&#123;embrac&#125;\AddEmph&#123;\&#123;&#125;[-.04em]&#123;\&#125;&#125;[,-.15em]\begin&#123;document&#125;\textit&#123;\&#123;[(italic)]\&#125;&#125;\textsl&#123;\&#123;[(slant)]\&#125;&#125;\emph&#123;\&#123;[(emphesis)]\&#125;&#125;\end&#123;document&#125; 注意事项embrac 是通过修改 \emph, \textit, \textsl，实现这一目的的。因此，\em, \itshape, \slshape 命令依旧保留了斜体的括号。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Emphesis</tag>
        <tag>Italic</tag>
        <tag>Brace</tag>
        <tag>Bracket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTeX 黑魔法（二）：使用 \ooalign 命令创建叠加在一起的记号]]></title>
    <url>%2F2017%2F06%2F30%2Fcreate-overlayed-symbols-by-ooalign%2F</url>
    <content type="text"><![CDATA[TeX 是强大的排版工具，尤其以其数学排版而出名。然而，数学无有止境，有时候我们会需要特别的记号来表达一个新的概念。这些记号，TeX 可能默认没有提供。此时，我们就要自己创造符号了。 创造符号的办法有很多，其中之一就是让两个已经存在的符号「叠加」起来。这篇文章讲讲如何用 \ooalign 命令创造这样叠加的符号。 \ooalign 命令\ooalign 命令是一个 plain TeX 级别的命令。同级别类似的命令还有 \halign, \ialign 等。 顾名思义，见到命令中的 align 字样，就知道这个命令是用来将元素按照某种方式对齐的。用 LaTeX 用户比较好理解的方式来说，\ooalign{...} 相当于创建了一个表格： 123\begin&#123;tabular&#125;[t]&#123;@&#123;&#125;l@&#123;&#125;&#125; ...\end&#123;tabular&#125; 只不过有两点主要的不同： 在 tabular 环境中，换行使用 \\，而在 \ooalign 中使用 \cr； \ooalign 中，每一行都复写在上一行之上。 为了避免奇怪的问题，应当养成习惯，总是把 \ooalign 包在一个分组中。 \hidewidth 命令\hidewidth 也是一个 plain TeX 级别的命令。它的定义是 \hskip -1000pt plus 1fill。也就是说，它是一个 TeX 水平 skip，其默认长度是 -1000pt（一个非常大的负向距离），加上一个可以无限延伸的正向距离。 考虑到「无穷大减常数还是无穷大」，所以若将 \hidewidth 放在某个东西的左边，那么起作用相当于 \hfill。 另一方面，考虑到 -1000pt 是一个很大的负向距离，正常文档的宽度远小于这个距离。因此，若将 \hidewidth 放在某个东西的右边，那么从显示效果上看相当于在其右侧加上了一个 \hfill。同时，在各类 \align 命令计算宽度时，当前单元格的宽度会被忽略成 0pt。 小试身手12345678910\documentclass&#123;article&#125;\begin&#123;document&#125;&#123;\ooalign&#123;$\bigcup$\cr\hidewidth$\bullet$\hidewidth\cr&#125;&#125;&#123;\ooalign&#123;% $\bigcap$\cr \hidewidth$\bullet$\hidewidth\cr \hidewidth$\bigtriangleup$\hidewidth\cr&#125;%&#125;\end&#123;document&#125; 这里我们创造了两个符号。第一个符号由 $\bigcup$ 和 $\bullet$ 叠加组成。第二个符号由 $\bigcap$, $\bullet$ 和 $\bigtriangleup$ 三个符号组成。 照着上面的讲解，这些记号是如何组成的，应该不难理解。你可以编译试试看效果，同时看看去掉各个 \hidewidth 会有什么效果。 进阶实践：定义一个带点状虚线的组合数符号amsmath 宏包提供了名为 \genfrac{左定界符}{右定界符}{分数线粗细}{缩放}{分子}{分母} 的宏；它是 amsmath 系所有类似 \frac 效果的母版。例如，组合数 \binom 的定义是 \newcommand{\binom}[2]{\genfrac{(}{)}{0pt}{}{ #1 }{ #2 }}。它表示组合数符号的左右定界符分别是左右圆括号，分数线的粗细为 0pt（也就是不画分数线），大小随着行间公式或者行内公式自动缩放。 为了将分数线替换为点状虚线，首先我们要获得一个形如分式但没有分数线的表达。 1\newcommand&#123;\nolinebinom&#125;[2]&#123;\genfrac&#123;(&#125;&#123;)&#125;&#123;0pt&#125;&#123;0&#125;&#123;#1&#125;&#123;#2&#125; &#125; 而后，我们要定义一个点状引导线。 1234\newcommand&#123;\dotover&#125;&#123;% \leavevmode\kern1ex \cleaders\hb@xt@.22em&#123;\hss$\cdot$\hss&#125;\hfill \kern1ex&#125; 这里 \leavevmode 确保离开 TeX 的垂直模式，进入水平模式；左右的 \kern1ex 表示左右各空出 1ex 的空白；中间的 \cleaders\hb@xt@.22em{\hss$\cdot$\hss}\hfill 则表示用若干个水平盒子 \hbox to .22em{\hss$\cdot$\hss} 填充 \hfill 代表的最终长度。因此，\dotover 会根据允许的长度，绘制一条点状的引导线。 至此，我们可以用 \ooalign 把它们拼起来。 123\newcommand&#123;\dotbinom&#125;[2]&#123;% \ooalign&#123;$\nolinebinom&#123;#1&#125;&#123;#2&#125;$\cr\dotover\cr&#125;%&#125; 完整的代码如下。 123456789101112131415161718192021\documentclass&#123;article&#125;\usepackage&#123;amsmath&#125;\makeatletter\newcommand&#123;\nolinebinom&#125;[2]&#123;\genfrac&#123;(&#125;&#123;)&#125;&#123;0pt&#125;&#123;0&#125;&#123;#1&#125;&#123;#2&#125; &#125;\newcommand&#123;\dotover&#125;&#123;% \leavevmode\kern1ex \cleaders\hb@xt@.22em&#123;\hss$\cdot$\hss&#125;\hfill \kern1ex&#125;\newcommand&#123;\dotbinom&#125;[2]&#123;% \ooalign&#123;$\nolinebinom&#123;#1&#125;&#123;#2&#125;$\cr\dotover\cr&#125;%&#125;\makeatother\begin&#123;document&#125;\[ \dotbinom&#123;\text&#123;numerator&#125;&#125;&#123;\text&#123;denominator&#125;&#125;\]\end&#123;document&#125;]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>align</tag>
        <tag>leaders</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 中的黑暗角落（二）：生成器协程的调度问题]]></title>
    <url>%2F2017%2F06%2F30%2Fgenerator-coroutine-in-python-basic-topics%2F</url>
    <content type="text"><![CDATA[前作介绍了 Python 中的 yield 关键字。此篇介绍如何使用 yield 表达式，在 Python 中实现一个最基本的协程调度示例，避免 I/O 操作占用大量 CPU 计算时间。 协程及其特点协程是一种特殊的子程序，它可以在特定的位置暂停/恢复（而不是像普通函数那样在逻辑上顺序执行）；并且每当协程暂停时，调用者可以从协程中获取状态，决定调用者接下来的走向；以及每当协程恢复时，调用者可以传递信息给协程，影响协程的行为。 从「可以暂停/恢复」来看，协程类似于 Python 中的迭代器。不过，迭代器仅只是将值返回给调用者，其内部的逻辑是确定的，无法与调用者做更多的交互。 因为协程可以暂停/恢复，所以，我们可以在多个协程中分别执行不同的任务；然后由调度器管理协程之间的执行，实现多任务并发。 此外，协程和调用者在同一线程中执行；考虑到线程是操作系统进行任务调度的最小单元，协程和调用者之间的切换，没有 CPU 上下文切换的开销。因此，相对使用多线程、多进程实现多任务并发，协程在这方面的开销非常小。 同样由于协程之间共享线程，所以使用协程实现的多任务并发，无法实现真正的并行。因此，显而易见，协程适合 I/O 密集型的任务并发，而不适合 CPU 密集型的任务并发。 协程调度基础最简单的协程的例子，我们实际上已经见过了。在「使用 send() 方法与生成器函数通信」一节中，func 就扮演了协程函数的角色。每当协程函数在 yield 表达式处暂停，调用者就收到上一步计算的结果；每当协程函数自 yield 表达式处恢复，协程函数就用接收到的数进行下一轮计算。 在见识过最简单的协程示例之后，我们试着看看在调度协程的过程中，需要怎样处理。 coroutine_basic.py1234567891011121314151617181920212223242526from collections import deque # 1.class Dispatcher(object): # 2. def __init__(self, tasks): self.tasks = deque(tasks) # 3. def next(self): return self.tasks.pop() # 4. def run(self): while len(self.tasks): # 5. task = self.next() try: next(task) # 6. except StopIteration: pass # 7. else: self.tasks.appendleft(task) # 8.def greeting(name, times): # 9. for i in range(times): yield # 10. print("Hello, %s.%d!" % (name, i))dispatcher = Dispatcher([greeting('Liam', 5), greeting('Sophia', 4), greeting('Cancan', 6)])dispatcher.run() 这段代码中，有两个主要角色：调度器 (2) 和任务 (9)。 从调度器的角度来说，我们自 collections 模块引入了 deque 容器 (1)，用于在 (3) 处保存任务。而后，我们在 (4) 定义了调度器 Dispatcher 的轮询函数 next()，它返回下一个尚未终止的任务。在调度器的 run() 函数中，(5) 和 (8) 保证了循环处理所有尚未完成的任务并清理已完成的任务，(6) 和 (7) 则负责触发每个任务的下一步动作。 从任务的角度来说，greeting 是一个生成器函数，是具体的协程任务。在 (10) 处，yield 表达式标记了函数暂停/恢复的位置；它将逻辑上连续的任务，在时间上切分成了若干段。 这段代码执行起来结果大致是这样： 123456789101112131415Hello, Cancan.0!Hello, Sophia.0!Hello, Liam.0!Hello, Cancan.1!Hello, Sophia.1!Hello, Liam.1!Hello, Cancan.2!Hello, Sophia.2!Hello, Liam.2!Hello, Cancan.3!Hello, Sophia.3!Hello, Liam.3!Hello, Cancan.4!Hello, Liam.4!Hello, Cancan.5! 看起来和多线程那种乱七八糟的输出顺序有点像，不是吗？当然，此处由于使用 deque.pop() 轮询任务队列，所以输出顺序大致是有迹可循的。不过，这并不影响我们将其作为协程调度的示例。 在这个例子中，尽管调用者和协程之间没有其他的通信，协程函数内也没有真正意义上的 I/O 操作，但我们仍可以进行一些总结。 首先，生成器函数充当了协程函数，实现了协程。 其次，协程任务在逻辑上是连续的，但是我们可以用 yield 表达式在时间上把协程任务分成若干部分。 再次，用 yield 分割的任务，需要有一个机制控制器暂停/恢复。这个机制此处由调度器提供。 再者，对于调度器来说，它需要知道「有哪些协程任务需要恢复」。因此，它必然直接或间接地维护一个事件队列。此处，我们用 Dispatcher.tasks 完成了这一工作。 最后，对于每个协程（任务）来说，一旦被暂停，其恢复就必须依赖主动唤起。因此，调度器必须「恰到好处」地反复唤起线程——不能多也不能少：多则浪费执行时间，甚至抛出异常；少则留下未能完成的任务。因此，调度器必须恰当地维护上述队列，确定何时从队列中移除已完成的任务。在我们的例子中，(6) 和 (7) 协同完成了这一工作。 异步 I/O 任务模拟回顾一下刚才的协程任务。 1234def greeting(name, times): for i in range(times): yield print("Hello, %s.%d!" % (name, i)) 在这个任务里，yield 表达式将原本在逻辑上连续的循环，人为地在时间上切分成了若干份。然而，除了用于演示暂停/恢复的携程调度之外，这个例子实际上没有必要使用协程实现。这是因为，在协程任务中，去掉 yield 表达式之后，所有的操作都是立即完成的；不存在需要阻塞以等待 I/O 的空耗 CPU 的情况。 下列代码模拟了一个需要阻塞等待 I/O 的任务。 1234567from time import sleepfrom random import random as rddef greeting(name, times, duration = 1): # 1. for i in range(times): sleep(2 * duration * rd()) # 2. print("Hello, %s.%d!" % (name, i)) 此处，新定义的 greeting 函数 (1) 有一个新的参数：duration。而后，在每次循环打印招呼信息的之前，会现行阻塞一段时间 (2)。这一阻塞就模拟了实际情况中的 I/O 类操作：空占 CPU 资源，但不进行任何计算。阻塞的时间是 2 * duration * rd()，这是一个一 duration 为期望的随机变量，用来模拟预计阻塞 duration 秒但实际情况会有波动的 I/O 任务。 假设 duration 设置为定值 1 而 times 设置为定值 3，那么执行一次 greeting 函数，平均需要耗时 3 秒。如若顺序执行 3 个这样的函数，平均下来，一共需要耗费 9 秒的时间。而这 9 秒之中，大多数时间 CPU 都仅只在空耗，没有执行实际的计算任务。因此，我们可以考虑用协程将它们并发起来执行，降低总的空耗的时间。为此，我们有如下思路。 将每个 I/O 任务理解为一个事件； 维护一个队列，用于记录尚在进行中的事件，以便后续操作； 当事件生成时，向上述队列注册（即将事件添加进队列）； 使用轮询（polling）等方式，捕获完成的事件； 对已完成的事件，进行后续操作（特别地，恢复协程函数），而后从队列中删除该事件。 现在，我们开始逐步在这一思路的指导下，实现协程并发。 引出休眠事件（SleepEvent）回顾一下新版的 greeting 函数。若要通过生成器实现协程，就必然要添加 yield 表达式。 1234567from time import sleepfrom random import random as rddef greeting(name, times, duration = 1): for i in range(times): yield sleep(2 * duration * rd()) # 1. print("Hello, %s.%d!" % (name, i)) 简单粗暴地以 (1) 的方式加上 yield 表达式是不行的。这是因为，yield 表达式会对 sleep 函数求值，而后将该值返回给调用者并暂停。但是，对 sleep 函数求值的过程，就是模拟的 I/O 操作，会阻塞执行线程。在阻塞完毕之后，再通过 yield 暂停，这就没有意义了。 1234567def coroutine_sleep(duration): # 1. return SleepEvent(duration) # 2.def greeting(name, times, duration = 1): for i in range(times): yield coroutine_sleep(duration) # 3. print("Hello, %s.%d!" % (name, i)) 因此，我们需要定义新的 coroutine_sleep 函数 (1)。这个函数会生成一个事件（SleepEvent），然后不阻塞地立即返回 (2)。因此，在 (3) 处，yield 表达式会将 coroutine_sleep 返回的 SleepEvent 对象传递给协程函数的调用者，并暂停当前协程函数。 定义事件框架接下来，我们需要定义事件框架。在实际动手之前，我们应该先分析一下一个事件类需要有哪些功能。 首先，事件应该有能力让外部知道自身存在。因此事件类应该伴随一个队列；并且在生成事件对象时，将自身注册进这个队列。 其次，事件应该有能力让外部知道自身状态，以便检查事件状态，进而进行下一步操作。因此，事件类应该是一个闭包，保存生成事件时的一些状态；并提供一个接口，利用这些状态检查事件是否完成。 最后，事件应当提供一个接口，记录在事件完成之后应当做什么；并且在事件完成之后执行这些操作。 据此，我们应该有如下代码。 12345678910111213events_list = list() # 1.class Event(object): def __init__(self, *args, **kwargs): events_list.append(self) # 2. self._callback = lambda:None # 3. def is_ready(self): # 4. ready = self._is_ready() if ready: self._callback() # 5. return ready def set_callback(self, callback): # 6. self._callback = callback 这里，(1) 处我们定义了一个全局的队列，用于记录尚在进行中的事件；与此同时，每当生成事件类对象时，(2) 会将当前事件对象注册到队列中。(3) 则定义了回调函数，用于记录事件完成之后执行什么操作。 (4) 和 (6) 分别是对外的接口。(4) 让外部有能力知道自身状态，其中 _is_ready() 需要在子类中实现；而 (6) 允许外部记录在事件完成之后应当做什么。(5) 则保证了当事件完成之后，(6) 中的设置会被正确执行。 至此，我们可以定义出 SleepEvent 类。 12345678910from time import time as current_timefrom random import random as rdclass SleepEvent(Event): # 1. def __init__(self, duration): super(SleepEvent, self).__init__(duration) self._duration = 2 * rd() * duration # 2. self._start_time = current_time() # 3. def _is_ready(self): return (current_time() - self._start_time &gt;= self._duration)# 4. 这里，(1) 处定义了 SleepEvent 事件类，用来模拟 I/O 事件；模拟的核心在于 (2) 处定义的睡眠时长。(3) 则记录了事件诞生时的状态，用在 (4) 处确认事件是否已完成。 至此，协程函数这一侧的代码我们已经完成了，接下来我们看看调度器一侧的代码如何实现。 用轮询捕捉已完成的事件因为我们在 events_list 中保存了所有尚在执行中的事件。这是相当简单的工作，所以不作过多的解释。 12345while len(events_list): for event in events_list: if event.is_ready(): events_list.remove(event) break 唤醒逻辑在 Event 类的定义中，is_ready() 函数会在事件完成后调用 _callback 函数。而对于协程函数来说，一个事件完成后，需要做的事情无非是：唤醒，恢复执行到下一个暂停点。因此可以有这样的唤醒逻辑。 123456def _next(gen_task): try: yielded_event = next(gen_task) # 1. yielded_event.set_callback(lambda: _next(gen_task)) # 2. except StopIteration: pass # 3. 这里，(1) 调用 Python 内建的 next 函数，唤醒协程函数，执行到下一个暂停点，并接受其返回值，保存在 yielded_event 当中。而后，在 (2) 处将该 Event 对象设置为 Lambda 函数 lambda: _next(gen_task)。显然，这是一个递归调用 _next 函数自身的闭包——捕获了需要继续唤醒的生成器 gen_task。若生成器执行完毕，则无需继续唤醒。因此在 (3) 处，直接 pass 即可。 完整实验将上述代码整合起来，就可以做实验了。 coroutine_async.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#!/usr/bin/env python3from time import time as current_timefrom random import random as rdevents_list = list()class Event(object): def __init__(self, *args, **kwargs): events_list.append(self) self._callback = lambda:None def is_ready(self): ready = self._is_ready() if ready: self._callback() return ready def set_callback(self, callback): self._callback = callbackclass SleepEvent(Event): def __init__(self, duration): super(SleepEvent, self).__init__(duration) self._duration = 2 * rd() * duration self._start_time = current_time() def _is_ready(self): return (current_time() - self._start_time &gt;= self._duration)class Dispatcher(object): def __init__(self, tasks): self.tasks = tasks self._start() def _next(self, gen_task): try: yielded_event = next(gen_task) yielded_event.set_callback(lambda: self._next(gen_task)) except StopIteration: pass def _start(self): for task in self.tasks: self._next(task) def polling(self): while len(events_list): for event in events_list: if event.is_ready(): events_list.remove(event) breakdef coroutine_sleep(duration): return SleepEvent(duration)def greeting(name, times, duration = 1): for i in range(times): yield coroutine_sleep(duration) print("Hello, %s.%d!" % (name, i))if __name__ == '__main__': def test(): dispatcher = Dispatcher([greeting('Liam', 3), greeting('Sophia', 3), greeting('Cancan', 3)]) dispatcher.polling() import timeit timeit_times = 10 avg_cost = timeit.timeit(lambda: test(), number = timeit_times) / timeit_times print('%.3f' % (avg_cost)) 可能的执行结果是： 123456789101112131415161718192021$ python coroutine_async.pyHello, Liam.0!Hello, Liam.1!Hello, Liam.2!Hello, Cancan.0!Hello, Sophia.0!Hello, Cancan.1!Hello, Sophia.1!Hello, Cancan.2!Hello, Sophia.2!......Hello, Liam.0!Hello, Sophia.0!Hello, Sophia.1!Hello, Cancan.0!Hello, Liam.1!Hello, Sophia.2!Hello, Liam.2!Hello, Cancan.1!Hello, Cancan.2!3.400 可以看到，平均下来，使用协程并发地执行三个 greeting 任务（times = 3, duration = 1）只需要 3.4 秒；耗时远低于顺序执行所需的 9 秒。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Yield</tag>
        <tag>Coroutine</tag>
        <tag>Generator</tag>
        <tag>Asynchronism</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 中的黑暗角落（一）：理解 yield 关键字]]></title>
    <url>%2F2017%2F06%2F30%2Funderstanding-yield-in-python%2F</url>
    <content type="text"><![CDATA[Python 是非常灵活的语言，其中 yield 关键字是普遍容易困惑的概念。 此篇将介绍 yield 关键字，及其相关的概念。 迭代、可迭代、迭代器迭代（iteration）与可迭代（iterable） 迭代是一种操作；可迭代是对象的一种特性。 很多数据都是「容器」；它们包含了很多其他类型的元素。实际使用容器时，我们常常需要逐个获取其中的元素。逐个获取元素的过程，就是「迭代」。 1234# iterationa_list = [1, 2, 3]for i in a_list: print(i) 如果我们可以从一个对象中，逐个地获取元素，那么我们就说这个对象是「可迭代的」。 Python 中的顺序类型，都是可迭代的（list, tuple, string）。其余包括 dict, set, file 也是可迭代的。对于用户自己实现的类型，如果提供了 __iter__() 或者 __getitem__() 方法，那么该类的对象也是可迭代的。 迭代器（iterator） 迭代器是一种对象。 迭代器抽象的是一个「数据流」，是只允许迭代一次的对象。对迭代器不断调用 next() 方法，则可以依次获取下一个元素；当迭代器中没有元素时，调用 next() 方法会抛出 StopIteration 异常。迭代器的 __iter__() 方法返回迭代器自身；因此迭代器也是可迭代的。 迭代器协议（iterator protocol） 迭代器协议指的是容器类需要包含一个特殊方法。 如果一个容器类提供了 __iter__() 方法，并且该方法能返回一个能够逐个访问容器内所有元素的迭代器，则我们说该容器类实现了迭代器协议。 Python 中的迭代器协议和 Python 中的 for 循环是紧密相连的。 123# iterator protocol and for loopfor x in something: print(x) Python 处理 for 循环时，首先会调用内建函数 iter(something)，它实际上会调用 something.__iter__()，返回 something 对应的迭代器。而后，for 循环会调用内建函数 next()，作用在迭代器上，获取迭代器的下一个元素，并赋值给 x。此后，Python 才开始执行循环体。 生成器、yield 表达式生成器函数（generator function）和生成器（generator） 生成器函数是一种特殊的函数；生成器则是特殊的迭代器。 如果一个函数包含 yield 表达式，那么它是一个生成器函数；调用它会返回一个特殊的迭代器，称为生成器。 1234567891011def func(): return 1def gen(): yield 1print(type(func)) # &lt;class 'function'&gt;print(type(gen)) # &lt;class 'function'&gt;print(type(func())) # &lt;class 'int'&gt;print(type(gen())) # &lt;class 'generator'&gt; 如上，生成器 gen 看起来和普通的函数没有太大区别。仅只是将 return 换成了 yield。用 type() 函数打印二者的类型也能发现，func 和 gen 都是函数。然而，二者的返回值的类型就不同了。func() 是一个 int 类型的对象；而 gen() 则是一个迭代器对象。 yield 表达式如前所述，如果一个函数定义中包含 yield 表达式，那么该函数是一个生成器函数（而非普通函数）。实际上，yield 仅能用于定义生成器函数。 与普通函数不同，生成器函数被调用后，其函数体内的代码并不会立即执行，而是返回一个生成器（generator-iterator）。当返回的生成器调用成员方法时，相应的生成器函数中的代码才会执行。 123456def square(): for x in range(4): yield x ** 2square_gen = square()for x in square_gen: print(x) 前面说到，for 循环会调用 iter() 函数，获取一个生成器；而后调用 next() 函数，将生成器中的下一个值赋值给 x；再执行循环体。因此，上述 for 循环基本等价于： 1234genitor = square_gen.__iter__()while True: x = geniter.next() # Python 3 是 __next__() print(x) 注意到，square 是一个生成器函数；作为它的返回值，square_gen 已经是一个迭代器；迭代器的 __iter__() 返回它自己。因此 geniter 对应的生成器函数，即是 square。 每次执行到 x = geniter.next() 时，square 函数会从上一次暂停的位置开始，一直执行到下一个 yield 表达式，将 yield 关键字后的表达式列表返回给调用者，并再次暂停。注意，每次从暂停恢复时，生成器函数的内部变量、指令指针、内部求值栈等内容和暂停时完全一致。 生成器的方法生成器有一些方法。调用这些方法可以控制对应的生成器函数；不过，若是生成器函数已在执行过程中，调用这些方法则会抛出 ValueError 异常。 generator.next()：从上一次在 yield 表达式暂停的状态恢复，继续执行到下一次遇见 yield 表达式。当该方法被调用时，当前 yield 表达式的值为 None，下一个 yield 表达式中的表达式列表会被返回给该方法的调用者。若没有遇到 yield 表达式，生成器函数就已经退出，那么该方法会抛出 StopIterator 异常。 generator.send(value)：和 generator.next() 类似，差别仅在与它会将当前 yield 表达式的值设置为 value。 generator.throw(type[, value[, traceback]])：向生成器函数抛出一个类型为 type 值为 value 调用栈为 traceback 的异常，而后让生成器函数继续执行到下一个 yield 表达式。其余行为与 generator.next() 类似。 generator.close()：告诉生成器函数，当前生成器作废不再使用。 举例和说明如果你看不懂生成器函数如果你还是不太能理解生成器函数，那么大致上你可以这样去理解。 在函数开始处，加入 result = list()； 将每个 yield 表达式 yield expr 替换为 result.append(expr)； 在函数末尾处，加入 return result。 关于「下一个」yield 表达式介绍「生成器的方法」时，我们说当调用 generator.next() 时，生成器函数会从当前位置开始执行到下一个 yield 表达式。这里的「下一个」指的是执行逻辑的下一个。因此 12345678910111213141516def f123(): yield 1 yield 2 yield 3for item in f123(): # 1, 2, and 3, will be printed print(item)def f13(): yield 1 while False: yield 2 yield 3for item in f13(): # 1 and 3, will be printed print(item) 使用 send() 方法与生成器函数通信12345678910def func(): x = 1 while True: y = (yield x) x += ygeniter = func()geniter.next() # 1geniter.send(3) # 4geniter.send(10)# 14 此处，生成器函数 func 用 yield 表达式，将处理好的 x 发送给生成器的调用者；与此同时，生成器的调用者通过 send 函数，将外部信息作为生成器函数内部的 yield 表达式的值，保存在 y 当中，并参与后续的处理。 这一特性是使用 yield 在 Python 中使用协程的基础。 yield 的好处Python 的老用户应该会熟悉 Python 2 中的一个特性：内建函数 range 和 xrange。其中，range 函数返回的是一个列表，而 xrange 返回的是一个迭代器。 在 Python 3 中，range 相当于 Python 2 中的 xrange；而 Python 2 中的 range 可以用 list(range()) 来实现。 Python 之所以要提供这样的解决方案，是因为在很多时候，我们只是需要逐个顺序访问容器内的元素。大多数时候，我们不需要「一口气获取容器内所有的元素」。比方说，顺序访问容器内的前 5 个元素，可以有两种做法： 获取容器内的所有元素，然后取出前 5 个； 从头开始，逐个迭代容器内的元素，迭代 5 个元素之后停止。 显而易见，如果容器内的元素数量非常多（比如有 10 ** 8 个），或者容器内的元素体积非常大，那么后一种方案能节省巨大的时间、空间开销。 现在假设，我们有一个函数，其产出（返回值）是一个列表。而若我们知道，调用者对该函数的返回值，只有逐个迭代这一种方式。那么，如果函数生产列表中的每一个元素都需要耗费非常多的时间，或者生成所有元素需要等待很长时间，则使用 yield 把函数变成一个生成器函数，每次只产生一个元素，就能节省很多开销了。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Yield</tag>
        <tag>Coroutine</tag>
        <tag>Iterator</tag>
        <tag>Generator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员的自我修养（六）：保护线程间的共享数据]]></title>
    <url>%2F2017%2F06%2F10%2Fprotecting-data-sharing-between-threads%2F</url>
    <content type="text"><![CDATA[进入到系列文章的第六篇。 我们在前文中提到，多进程和多线程最本质的区别在于共享和隔离的程度不同。对于多进程方式来说，因为隔离程度高，所以程序员很少需要去担心进程空间的数据被破坏；但是并发任务之间共享数据就变得很困难了。对于多线程方式来说，因为隔离程度低，所以共享数据非常容易；但是，相应地，程序员需要更多地考虑如何在线程之间安全地共享数据。这就引出了所谓的「线程安全」问题。 此篇，我们讨论如何在线程之间安全地共享数据。 在线程间共享数据的问题引子让我们先来看一个有味道的例子。 假设你邀请朋友到家里来派对。这个派对有些特殊，需要各自准备好食材，而后烹饪成美味——大家比比手艺。朋友 A 准备做辣椒炒肉，而朋友 B 决定用韭菜炒蛋一展身手——他们都已经备好了菜等待下锅。 不幸的是，你家只有一口锅，但是朋友 A 和 B 两不相让。他们在几乎同一时间，分别把自己手头备好的菜下了油锅： 朋友 A 把切好的辣椒下了油锅——嘶~ 朋友 B 把打好的蛋液下了油锅——哗~ 于是，厨房里传出了辣椒炒蛋的香味…… 在这个例子里，最终朋友 A 和朋友 B 合作了一盘「辣椒炒蛋」。虽然这不是他们预期的结果，但好歹没有引起灾难性的后果。不过，这种「好结果」并不是每次都能发生；更多的时候，可能会做出一堆奇奇怪怪的黑暗料理。 这件事情和我们今天要讨论的问题很是相像，我们看看下面这张表。 美食派对 线程间数据共享 厨房 进程空间 油锅 可在线程间共享的数据 朋友 A 和朋友 B 两个线程 对于没事派对中的这个小插曲，显而易见地，作为主人需要定下一些规矩。对于这个问题，主人需要规定：别人使用完毕之前，其他人不能用锅子（当然也包括锅铲、煤气灶之类的）。在线程间共享数据也是如此。程序员在设计多线程并发程序时，需要协调好多个线程对数据的操作：应当在何时，如何操作数据，并与其它线程进行通信。 不变量在具体讨论之前，我们先了解一下「不变量」这个概念。 所谓不变量，指的是对于某个数据结构，当其合法可用时，总是成立的一个命题。在编程时引入不变量，可以帮助程序员正确地处理数据。为了更好地理解不变量，我们来看一下下面这个简单的例子。 1234567int sum&#123;0&#125;;constexpr size_t times&#123;100&#125;;// invariant: `i` is the number of integer that we have added to `sum`.for (size_t i&#123;0&#125;; i != times; ++i) &#123; sum += i + 1;&#125;// some use of `sum` 这是一个非常简单的例子，此处仅用于说明不变量。 在注释中，我已经注明了此处用到的不变量：i 是已经累加的次数。对于 i 来说，它在循环开始前、每次循环迭代之后、循环结束的瞬间，都应该是合法可用的。因此，作为不变量，应该在这三种情形下都成立。若不然，则说明循环写错了。 开始前：在循环开始前，我们尚未进行过累加，因此 i == 0 成立； 迭代过后：每迭代一次，++i 保证了不变量成立； 循环结束：由于 i 自 0 开始自增，直到第一次满足 i != times 的条件终止循环，因此在循环终止时，i == times 成立。 经过这样的验证，我们应当很有信心地说：我的代码是正确的。 注 1：应当写明显没有错误的代码，比如这个例子。注 2：在这个例子中，之所以将循环条件记为 i != times 而不是 i &lt; times，正式因为有不变量的存在。若是记作 i &lt; times，那么循环中止时，应有 i &gt;= times；对应到不变量上，就是「至今为止，已经累加了不小于 times 次」，而这与代码的意图是不一致的。故而，对 C++ 程序员来说，建议写作 i != times 而不是 i &lt; times。注 3：此外，C++ 对 STL 容器引入了「迭代器」的概念。迭代器重载了 == 和 != 等符号，但并不一定重载了了 &lt; 号。事实上，对两个迭代器进行「大小比较」是没有意义的。为了保证一致性，从迭代器的角度说，也不建议 C++ 程序员将此类循环条件写作 i &lt; times。 回过头，再来看一下这个简短的例子。我们不难发现，在执行完 sum += i + 1 的一瞬间，事实上不变量并不成立。比如，当 i == 30 时，我们执行完毕上述赋值表达式时，已经进行了 31 次累加。这告诉我们：在对操作数据时，有可能会破坏不变量。这样一来，循环迭代后，对 i 的自增操作，就可以理解为是「维护不变量」了。这件事情告诉我们：不变量不成立，预示着数据不可用（通常表示数据操作进行到一半）；操作数据后，需要维护不变量。 我们再来看一个稍微复杂一些的例子。 1234567891011121314151617181920212223// invariant: suppose we have two nodes `A` and `B`,// then if `A-&gt;next_ == B`, then we must have `B-&gt;perv_ == A`.template&lt;typename DataType&gt;class Node &#123; private: Node* prev_ = nullptr; Node* next_ = nullptr; DataType data; public: // ... void Delete() &#123; auto prev = this-&gt;prev_; auto next = this-&gt;next_; if (nullptr != prev) &#123; prev-&gt;next_ = next; // 1. &#125; if (nullptr != next) &#123; next-&gt;prev_ = perv; // 2. &#125; this-&gt;Destroy(); return; &#125;&#125;; 这是一个双链表中结点的简单示例。同样，我在代码注释中已经标明了不变量，即在双链表可用时，对两个合法结点来说，应当有 A-&gt;next_-&gt;perv_ == A。然而，在删除结点时（更新数据结构时），不变量会被破坏。比如，当 (1) 已经执行完毕，但 (2) 尚未执行时，上述不变量就是不成立的。 假设现在有两个线程，在对同一个双链表进行操作。其中之一尝试从前向后遍历双链表；另一则在删除其中某一个结点。我们之前说，删除结点会临时破坏不变量，而不变量被破坏则表示数据结构是不可用的。那么正在执行删除操作的线程，就可能导致正在遍历的线程出错甚至崩溃。 线程 1 线程 2 注释 if (nullptr != curr-&gt;next()) 此时检查成功 prev-&gt;next_ = next next 有可能是 nullptr 注意此时不变量被破坏了 work = curr-&gt;next() 现在 work 可能是 nullptr data = work-&gt;data() 解引用 nullptr，段错误 上表展现了两个线程同时操作一个双链表时，可能出现的情况。在这种情况下，线程 1 可能因为解引用空指针，而引发段错误，导致整个进程崩溃。 竞争状态我们再看一个有小情绪的例子。 对于国人来说，「春运」总是很头疼的问题。在春运期间，火车票总是不够的。基本上，任何一次买票行为，其结果（能不能买到火车票），都取决于你下手的时机——是否足够快。对于你来说，同样是「点击鼠标确认」这个动作，其结果实际上是不确定的。具体是何种结果，取决于你的行为与其他人行为的相对顺序。 在计算机世界中，我们把结果取决于多个线程执行指令的相对顺序的情形，称为「竞争状态」。若是竞争状态发生在多个线程对同一个数据结构的修改上，则称其为「数据竞争」。因为竞争状态的结果是不确定的，所以数据竞争可能导致未定义行为（Undefined Behavior, 缩写 UB，读作「有病」）。 结合不变量的概念，不难理解。如果一个行为可能在其中间状态破坏不变量，则由此行为引发的竞争状态，可能导致灾难后果。而若要破坏不变量，通常来说意味着该操作需要更新多个变量，而这些更新操作无法在单个指令完成——因而有被打断的可能。由数据竞争导致的问题通常难以排查。这是因为，尽管这些操作可能被打断，但并不是每次都会打断。通常来说，只有当系统负载很高，CPU 需要频繁地切换上下文时，数据竞争的可能性才会增大。因此，排查由数据竞争导致的问题，一般来说是非常困难的。 避免恶性数据竞争既然数据竞争通常可能会招致 UB，那么我们就要想办法避免它。通常来说，避免恶性数据竞争有几个思路。 保护数据结构，确保在数据结构更新过程中，其不变量被破坏的中间状态只有一个线程能够看到。 修改数据结构的实现，确保任何对数据结构的更新，在外界看来不变量都是成立的。 将所有对数据结构的修改，都交给第三方串行执行。 对于第三种方案，以之前购买火车票的例子来说，可以实现为：当你点击确认按钮后，购票网站将你的请求发送给服务器，服务器将请求加入一个队列，并返回一个状态。例如：「当车次剩余车票 1000 张，在您之前有 800 个尚未处理的请求」。这样一来，通常来说，购票行为的结果就是确定的了。 然而，C++ 标准库并没有实现上述第三种方案。故此，此处我们不做更深入的讨论。 使用互斥量保护数据保护数据的最基本方法是使用所谓的「互斥量」（mutual exclusion, mutex）。 互斥量的基本逻辑是这样的。 访问某个数据结构时，首先检查互斥量。 若互斥量被锁住，则等待，直到互斥量解锁。 若互斥量没有被锁住，则锁住互斥量，而后更新数据，再解锁。 听起来是个挺美好的事情，若能实现，那么数据竞争就能被解决。然而，所谓「没有银弹」，并不是说引入互斥量就能完美解决所有问题。 首先，互斥量起作用是有前提的。 所有可能引发数据竞争的数据结构都被保护起来了； 所有可能引发数据竞争的操作，都正确地使用了互斥量。 其次，互斥量可能引发所谓的「死锁」问题。 最后，若互斥量过多或过少地保护了数据，都可能出现问题。 在 C++ 中使用互斥量在 C++ 中，标准库提供的互斥量是 std::mutex，它被定义在 mutex 这个头文件中。 互斥量是「锁」的一种，按照我们在 C++ 的几个基本原理和技术中的介绍，锁也是一种资源。因此为了保证资源被正确释放（正确使用互斥量的条件之一），我们最好是用 RAII 技术将其包装起来。C++ 标准库直接提供了这样的封装，名为 std::lock_guard，它也定义在 mutex 这个头文件当中。 我们来看一个简单的例子。 123456789101112131415161718#include &lt;list&gt;#include &lt;mutex&gt;#include &lt;algorithm&gt;typedef std::lock_guard&lt;std::mutex&gt; guarded_mutex;std::list&lt;int&gt; data_list; // 1.std::mutex data_mutex; // 2.void add_to_list(int new_value) &#123; guarded_mutex guard&#123;data_mutex&#125;; // 3. data_list.push_back(new_value);&#125;bool list_contains(int value_to_find) &#123; guarded_mutex guard&#123;data_mutex&#125;; // 4. return (data_list.end() != std::find(data_list.begin(), data_list.end(), value_to_find));&#125; 例中，(1) 和 (2) 分别定义了全局变量。此处，我们意图用 (2) 定义的全局互斥量保护对 (1) 定义的链表进行保护。(3) 和 (4) 通过 RAII 容器 std::lock_guard 在构造时，对传入的互斥量 data_mutex 上锁，并在 guard 销毁时自动解锁。 在这个例子中，若是 add_to_list 和 list_contains 分别在不同线程中执行，则他们都会尝试锁上 data_mutex 这个互斥量。显而易见，同一时刻，只能有一个函数能成功锁上它；于是该函数正常执行，而另外一个函数则会陷入等待。这样一来，data_list 更新期间，不变量被破坏的中间状态，就只有修改它的线程能看到。而对于其他线程来说，data_list 要么没有被修改，要么已经修改完成，因而总是可用的。 在这个简单的例子里，被保护的数据和互斥量都是全局变量。显而易见，这是不好的。首先，使用全局变量，意味着任何函数都有可能修改它。其次，除了 data_list 和 data_mutex 的定义连在一起，它们之间在代码上没有其他的联系。因此，很可能出现程序员使用 data_mutex 来保护其他数据；或者使用其他互斥量来保护 data_list 的现象。这样一来，保护就不完整了。因此，在实际使用中，通常我们会选择将 data_list 和 data_mutex 封装在同一个类当中。 限制被保护数据的使用范围上一节，我们了解了如何使用互斥量保护数据。此外，谈到了「正确使用」的要求之一：锁上互斥量之后必须解锁（否则其他线程永远无法上锁，就可能陷入无休止的等待）。这一节讨论正确使用的另一个要求：必须限制被保护数据的使用范围。简单来说，就是不要将被保护数据的指针或引用通过返回值、函数参数的方式，传到无法控制的范围内。这个约定，是基于一个简单的假设：你无法保证在你无法控制的范围内，其他程序员是否按照约定使用互斥量保护这份数据。 我们看一个不好的例子。 1234567891011121314151617181920212223242526272829template&lt;typename DataType&gt;class Container &#123; private: typedef std::lock_guard&lt;std::mutex&gt; guarded_mutex; std::mutex mtx_; // 1. DataType* data_; // 2. public: // ... template&lt;typename FuncType&gt; void process_data(FuncType func) &#123; // 3. guarded_mutex l(this-&gt;mtx_); func(this-&gt;data); // 4. return; &#125;&#125;;std::list* unprotected;void malicious_function(std::list* protected_data) &#123; unprotected = protected_data; // 5. return;&#125;Container&lt;std::list&gt; ctn;void foo () &#123; ctn.process_data(malicious_function); unprotected-&gt;clear(); // 6.&#125; 在这个例子当中，Container 使用 (1) mtx_ 保护 (2) data_。但需要注意的是，(3) 接收的函数 func 是一个外部函数。由于在写 Container 这段代码时，你无法与之以后的用户，会传递何种 func 进来。所以对于 Container 的作者来说，func 是不可控的。但是，(4) 将内部被保护的数据的指针，作为参数传递给了 func。接下来的事情就变得糟糕了。首先我们定义了一个恶意函数 malicious_function，在其中 (5) 将传递进来的指针赋值给了一个没有任何保护的全局指针变量 unprotected。而最后，在没有任何保护的情况下，(6) 清空了整个链表。这个操作是非常危险的。 因此，在使用互斥量保护数据的时候，需要注意： 不能将被保护数据的指针或引用以函数返回值的形式，返回给外部不可控的调用者； 不能将被保护数据的指针或引用意函数参数的形式，传递给外部不可控的调用者。 死锁及其解法回到我们最开始有味道的例子。 假设现在你给锅、铲都加上了互斥量。这样一来，你希望朋友 A 和朋友 B 不会在同一时间共用锅铲，避免未定义的行为。然而，新的问题又来了。 朋友 A 朋友 B 注释 给锅铲上锁 给锅子上锁 开始使用锅子 开始使用锅铲 尝试获取锅子的锁 朋友 A 开始等待 尝试获取锅铲的锁 朋友 B 开始等待 现在，因为有锁的保护，所以朋友 A 和朋友 B 不会再同时使用锅或铲了，避免了「辣椒炒蛋」的闹剧。但是，现在朋友 A 和朋友 B 来到你的面前，向你哭诉：「我的心在等待，永远在等待」。 朋友 A 期待使用锅子，然而因为锅子对应的锁被朋友 B 锁上，所以朋友 A 不得不等待朋友 B 使用完毕之后才行；另一方面，朋友 B 需要使用锅铲，对应的锁却被朋友 A 锁上了。这样一来，由于朋友 A 和朋友 B 互相等待，但各自又什么都做不了。于是两人只能大眼瞪小眼，永远「耗下去」。 在并发编程领域中，我们把这种现象称之为「死锁」。对于由「锁」引起的「死锁」，它有几个特点： 完成一个任务，需要获取多把锁； 存在数据竞争； 各自持有一部分数据对应的锁，互相等待，永不释放。 为了解决死锁问题，前辈们曾经提出了很多方案。其中最基本的一个方案是说：在操作需要获取多把锁时，总是以固定的顺序获取这些锁。比如，在我们的例子里，如果要求必须先获取锅铲对应的锁，再去获取锅子对应的锁；那么由于锅铲对应的锁被朋友 A 首先持有，那么朋友 B 就只能等待 A 做好菜之后，才能一展身手。这样一来，死锁的问题就解决了。 然而，这样的建议并不能解决所有问题。所谓「固定顺序」的前提是我们能够以某种方式定义出稳定的顺序关系。然而，有时候我们无法在代码中定义这样的顺序。比如，假设有两个对象，它们是同一个类的两个实例。现在，我们希望在某个线程里，交换二者的内容。显而易见，我们应该要用对应的锁分别保护两个对象，避免被并发的其他线程破坏。然而，在此二者之间，你很难定义具体的顺序。索性，C++ 标准库提供了 std::lock() 函数，用于同时锁住多个互斥量，并且没有死锁的风险。 以下示例展示了如何用 std::lock() 函数同时锁住两个互斥量。 123456789101112131415161718template&lt;typename DataType&gt;void swap(DataType&amp; lhs, DataType&amp; rhs);template&lt;typename DataType&gt;class Container &#123; private: typedef std::lock_guard&lt;std::mutex&gt; guarded_mutex; std::mutex mtx_; DataType data_; public: friend void swap(Container&lt;DataType&gt;&amp; lhs, Container&lt;DataType&gt;&amp; rhs) &#123; if (&amp;lhs == &amp;rhs) &#123; return; &#125; // 1. std::lock(lhs.mtx_, rhs.mtx_); // 2. guarded_mutex g_lhs(lhs.mtx_, std::adopt_lock); // 3. guarded_mutex g_rhs(rhs.mtx_, std::adopt_lock); // 4. swap(lhs.data_, rhs.data_); &#125;&#125;; 例子中，首先我们在 (1) 处判断传入的两个容器是否不同。这是因为，对同一个 std::mutex 在线程中反复上锁是未定义行为。而后我们在 (2) 处使用 std::lock() 函数，同时锁住 lhs 和 rhs 的互斥量。之后，我们在 (3) 和 (4) 处使用 RAII 容器接管已经上锁的互斥量。主意，这里传入的 std::adopt_lock 表示该互斥量已经上锁，std::lock_guard 只需要接管互斥量的所有权即可，不需要再次上锁。在此之后，我们就可以安心地调用 swap 函数交换两个 DataType 中的内容了。 当 std::lock 解决不了死锁的时候对于死锁，std::lock 函数能够保证一次性锁住多把锁，从而在一定程度上解决了问题。之所以说它只是在一定程度上解决问题，是因为还有很多情况，是无法使用 std::lock 的。比如，有一些情况必须要在不同的位置，分别锁上不同的锁。这时候，std::lock 就不适用了。此外，死锁问题并不仅仅是发生在和互斥量相关的情形中，此时使用 std::lock 也解决不了问题——因为根本不存在锁的问题。 对于 std::lock 解决不了的死锁情况，想要写出不会死锁的代码，就需要靠一些规玄矩学来保证了。对于这些规矩，我们简单罗列如下。 避免需要获取多个锁的情况：从根本上避免死锁的可能； 持有锁的时候，不要调用不可控的用户函数：因为你不知道用户函数会做什么，比如它可能会锁上另一把锁； 如果必须获取多个锁，那么按顺序上锁：从而避免竞争； 使用层次锁，强制要求上锁的顺序：这是在上一条规矩的基础上衍生而来的。 奇行种，以及一些其他问题层次锁首先我们看一个名为层次锁的奇行种。 层次锁是为了保证上锁顺序而设计出来的奇怪物种。当一个线程尝试对一个层次锁上锁时，需要检查当前已经上锁的锁的层次，从而保证当前尝试上锁的层次低于已经上锁的层次。以下是对层次锁的一个简单实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class hierarchial_mutex &#123; private: typedef size_t level; typedef std::lock_guard&lt;std::mutex&gt; guarded_mutex; static constexpr level max_level = std::numeric_limits&lt;std::size_t&gt;::max(); private: std::mutex mtx_; const level mtx_level_ = 0; level prev_mtx_level_ = 0; static thread_local level thread_mtx_level; inline void check_level() &#123; if (not(mtx_level_ &lt; thread_mtx_level)) &#123; throw std::logic_error("mutex hierarchy violated!"); &#125; return; &#125; inline void update_level() &#123; prev_mtx_level_ = thread_mtx_level; thread_mtx_level = mtx_level_; return; &#125; inline void recover_level() &#123; thread_mtx_level = prev_mtx_level_; return; &#125; hierarchial_mutex(const hierarchial_mutex&amp;) = delete; hierarchial_mutex&amp; operator=(const hierarchial_mutex&amp;) = delete; public: hierarchial_mutex() : mtx_level_&#123;0&#125;, prev_mtx_level_&#123;0&#125; &#123;&#125; hierarchial_mutex(const level&amp; value) : mtx_level_&#123;value&#125;, prev_mtx_level_&#123;0&#125; &#123;&#125; void lock() &#123; check_level(); mtx_.lock(); update_level(); &#125; void unlock() &#123; recover_level(); mtx_.unlock(); &#125; bool try_lock() &#123; check_level(); if (not(mtx_.try_lock())) &#123; return false; &#125; else &#123; update_level(); return true; &#125; &#125;&#125;;thread_local hierarchial_mutex::levelhierarchial_mutex::thread_mtx_level&#123;hierarchial_mutex::max_level&#125;; 在接口上，hierarchial_mutex 基本上完整地实现了 std::mutex 的接口。不同的是，首先，每个 hierarchial_mutex 都有一个自己的等级 mtx_level_；在 lock(), unlock() 和 try_lock() 时，hierarchial_mutex 需要对 thread_mtx_level 以及 prev_mtx_level_ 进行维护。其中，thread_mtx_level 是 static thread_local 的，这意味着，同一个线程的不同 hierarchial_mutex 公用一个 thread_mtx_level，而不同线程之间则是不同的 thread_mtx_level。 允许额外上锁的 RAII 容器：std::unique_lock前文提到了 RAII 容器 std::lock_guard。它会在构造时对传入的互斥量上锁（如果没有 std::adopt_lock 标志的话），并在销毁时解锁。然而，std::lock_guard 实例没有 lock(), unlock() 以及 try_lock() 函数，因此一旦锁上，就必须等待实例销毁才能解锁互斥量。若是在锁住互斥量的过程中，有一些不必上锁但特别耗时的外部 I/O 操作，那么 std::lock_guard 的这一特性就会降低并发效率。 std::unique_lock 和 std::lock_guard 一样，都是对互斥量的 RAII 容器。不同的是，std::unique_lock 提供了 lock(), unlock() 和 try_lock() 函数，能够通过 RAII 容器锁住/解锁内部的互斥量。除此之外，std::unique_lock 还能保证在销毁时正确解锁内部的互斥量。 之前的 swap 示例，若使用 std::unique_lock 则应是如下光景。 123456789101112131415161718template&lt;typename DataType&gt;void swap(DataType&amp; lhs, DataType&amp; rhs);template&lt;typename DataType&gt;class Container &#123; private: typedef std::unique_lock&lt;std::mutex&gt; guarded_mutex; std::mutex mtx_; DataType data_; public: friend void swap(Container&lt;DataType&gt;&amp; lhs, Container&lt;DataType&gt;&amp; rhs) &#123; if (&amp;lhs == &amp;rhs) &#123; return; &#125; guarded_mutex g_lhs(lhs.mtx_, std::defer_lock); // 1. guarded_mutex g_rhs(rhs.mtx_, std::defer_lock); // 2. std::lock(lhs.mtx_, rhs.mtx_); swap(lhs.data_, rhs.data_); &#125;&#125;; 此处，我们在 (1) 和 (2) 中提供了对互斥量的封装，并声明 std::defer_lock，以在后面使用 std::lock 一次性锁住两个互斥量。当然，在这个例子中，std::unique_lock 相对 std::lock_guard 的优势并没有体现出来，仅只是一个示例。 锁的粒度多线程提高执行效率的根源，在于多个线程可以同时执行不同的指令。然而，锁的存在会破坏这一特性。当多个线程同时尝试访问被互斥量保护的数据时，除了成功获取锁的线程，其它线程都被阻塞住，等待锁被释放。当然，为了线程安全，这种阻塞是不可避免的；然而，另一方面，过多的阻塞，必然降低并发效率，「吃掉」并发带来的性能提升。 这样一来，使用合适的粒度，减少不必要的等待就显得很有必要了。一般来说，锁的粒度可以定义为：被锁保护的数据的量在时间上的累积。 $$ \text{锁的粒度} \overset{\small\text{def}}{=} \text{被保护的数据量}\times \text{因持有锁而阻塞其他线程的时间}. $$ 显而易见，如果一个锁保护的数据量很大，那么其它线程获取相应的锁的次数就会相应增加；另一方面，如果某个线程长时间持有锁，那么其他线程因此阻塞等待的时间就会很长。因此，在保证线程安全的情况下，我们应该尽可能降低锁的粒度。 为了减小锁的粒度，一方面我们可以减少锁保护的数据量，另一方面则可以降低线程持有锁的时间。前者需要具体问题具体分析地进行竞答细算；后者则相对容易分析。 对于数据结构的操作，大体可以分为以下三个步骤： 读取数据（可能是其中一部分）； 处理数据； 回写处理结果。 通常来说，对数据进行处理，这件事情本身不会破坏数据结构的不变量，因而不用加锁；而读取和写入数据是需要用锁保护的。因此，如果粗犷地用锁将上述整个过程保护起来，而处理数据的时间很长（例如有网络 I/O），那么这样无疑效率是很低的。因此，我们可以考虑在处理数据的过程中，释放锁；而仅用锁保护对数据的读取和回写过程。 12345678void get_process_write() &#123; std::unique_lock&lt;std::mutex&gt; lk(a_mutex); // 1. Data chunk = get_data_chunk(); lk.unlock(); // 2. Result res = process_data_chunk(chunk); lk.lock(); // 3. write_back(chunk, res);&#125; 代码简单展现了应用 std::unique_lock 管理互斥量 (1) 的过程。在读操作完成之后，解锁互斥量 (2)，而在写操作之前，再次锁住互斥量 (3)。这样一来，在 process_data_chunk 的过程中，当前线程并不持有锁，因而降低了锁的粒度。 读写锁与 std::shared_mutex 和 std::shared_lock在进一步探讨锁的粒度之前，我们回顾一下在介绍竞争状态的时候，我们讲到，线程安全需要解决的本质问题，是保证不变量被破坏的中间状态，数据结构仅只对修改它的那个线程可见。从此出发，我们不难理解以下两个推论。 因为仅仅「读取」数据不会破坏不变量，所以多个线程同时读取某个数据结构是安全的。 但是，另一方面，如果有一个线程尝试对数据进行修改，那么若有其他线程在访问该数据结构（不论读写），都可能是不安全的。 这样一来，不难发现，对于「读」和「写」两类操作，数据结构所需的「保护」，其程度是不一样的。 若一个线程仅只是读取一个数据结构，那么只需保证没有其他线程同时写入即可，但其它线程对数据结构的读操作是安全的。 若一个线程尝试修改一个数据结构（写操作），那么其它线程对该数据结构的读写操作都是不安全的，因而应该被禁止。 对一个频繁进行写操作的数据结构来说，按照读写操作，区分保护程度意义不大。这是因为，区分两种程度的保护，必然带来额外的开销。而若是某个数据结构的读操作的频率远远大于写操作，那么进行这样的区分，从而降低锁的粒度，收益就很客观了。 为此，我们引入 std::shared_mutex 的概念。除了和一般的 std::mutex 一样提供 lock(), try_lock() 和 unlock() 之外，std::shared_mutex 还提供了 lock_shared(), try_lock_shared() 和 unlock_shared() 三个操作。 阻塞情况表 自由 被共享锁住 被独占锁住 lock() 以独占方式锁住 阻塞 阻塞 lock_shared() 以共享方式锁住 以共享方式锁住 阻塞 std::shared_mutex 直到 C++17 才被引入。若你的编译器不支持 C++17，请升级你的编译器，或者使用 boost::shared_mutex 代替。 于是，我们可以使用 std::shared_mutex 保护频繁读取而甚少写入的数据结构，并在读取时使用 lock_shared() 锁住互斥量，而在写入时使用 lock() 锁住互斥量。 与 std::unique_lock 对应，标准库也提供了 std::shared_lock 容器。它会在构造时，尝试以 lock_shared() 锁住传入的共享互斥量，并在销毁时，确保以 unlock_shared() 的方式释放共享互斥量。同时，std::shared_lock 也提供了 lock() 和 unlock() 接口，用于以共享的方式锁住或者解锁构造时关联的共享互斥量。 std::shared_lock 直到 C++14 才被引入。若你的编译器不支持 C++14，请升级你的编译器，或者使用 boost::shared_lock 代替。 读写锁的一个典型应用场景是线程共享的数据缓存。对于缓存来说，存在于缓存内的条目（entry）通常会被频繁读取，而写操作则相对来说低频很多。比如，DNS 服务器上的缓存就是这样的情况。DNS 解析记录一般来说是非常稳定的——频繁更换解析结果的域名总是少数。这里以 DNS 缓存作为读写锁的简单示例。 12345678910111213141516171819202122232425262728#include &lt;unordered_map&gt;#include &lt;string&gt;#include &lt;mutex&gt;#include &lt;shared_mutex&gt;class DNSEntry;class DNSCache &#123; public: typedef std::unordered_map&lt;std::string, DNSEntry&gt; RecMap; private: RecMap entries_; mutable std::shared_mutex entry_mutex_; // 1. public: DNDEntry find_entry(const std::string&amp; domain) const &#123; std::shared_lock&lt;std::shared_mutex&gt; slk(entry_mutex_); // 2. const RecMap::const_iterator target = entries_.find(domain); const bool found = (target !+ entries_.end()); return found ? target-&gt;second : DNSEntry(); &#125; void update_one_entry(const std::string&amp; domain, const DNSEntry&amp; entry) &#123; std::unique_lock&lt;std::shared_mutex&gt; ulk(entry_mutex_); // 3. entries_[domain] = entry; return; &#125;&#125;; 此处 (1) 为保护 RecMap 引入了一个共享互斥量，它是 mutable 的，因而允许在 const 成员函数中做修改。(2) 通过 std::shared_lock 容器，以共享的方式锁住互斥量，保证读操作的稳定；(3) 则通过 std::unique_lock 容器，以独占的方式锁住互斥量，保证写操作的安全。 保护数据的初始化过程我们在前作中，介绍了一个 GetInstance 函数。通常，这种用法适用于构造过程开销很大，而使用过程本身是线程安全的情况（比如连接数据库的过程）。在线程中使用 GetInstance 函数获取数据的指针，而不是在进程启动时构造数据，可以加快程序的启动速度，减少总体的等待时间。为了避免额外的获取锁的操作，前作首先使用了两次指针检查的方式。 1234567891011volatile T* pInst = nullptr;T* GetInstance() &#123; if (nullptr == pInst) &#123; lock(); if (nullptr == pInst) &#123; pInst = new T; &#125; unlock(); &#125; return pInst;&#125; 然而，由于 CPU 的动态调度，这样的代码可能引发严重的问题。于是，前作引入了基于操作系统架构的解决方案。 1234567891011121314#define barrier() __asm__ volatile("mfence")volatile T* pInst = nullptr;T* GetInstance() &#123; if (nullptr == pInst) &#123; lock(); if (nullptr == pInst) &#123; T* temp = new T; barrier(); pInst = temp; &#125; unlock(); &#125; return pInst;&#125; 然而，mfence 是 i386 架构特有的指令。因此，这份代码在别的架构上无法正确执行。为了保证通用性，C++11 引入了 std::once_flag 和 std::call_once 解决这类问题。 12345678910111213#include &lt;mutex&gt;volatile T* pInst = nullptr;std::once_flag flag_T; // 1.void ConstructInstance() &#123; // 2. pInst = new T;&#125;T* GetInstance() &#123; std::call_once(flag_T, ConstructInstance); // 3. return pInst;&#125; 此处，(1) 初始化了一个对于类型 T 的哨兵变量，用于标记 T 类型的实例是否已经初始化。(2) 则是对实例初始化的封装。在 (3) 处，我们使用 std::call_once 确保 ConstructInstance 有且只有一次调用，从而返回正确的实例对象的指针。 锁解决不了的竞争状态接口固有的竞争状态使用锁保护数据，通过阻塞其它线程的方式，可以避免一些竞争状态。因此，在一些数据结构中，使用锁可以保证数据结构对外的几个接口互相之间是线程安全的。然而，这并不意味着在外部调用这些接口就一定是线程安全的。事实上，这些接口本身可能存在固有的竞争状态，因而在其内部使用锁保护数据不能完全解决问题。 举例来说，对于一个标准的栈，除去其构造函数和交换函数 swap()，还有五个接口： push(): 将新元素压栈； pop(): 弹出栈顶元素； top(): 返回栈顶元素； empty(): 判断栈是否为空； size(): 返回栈的大小。 这五个接口中，隐含了两类固有的竞争状态。 第一类：通过 empty() 或 size() 判断栈状态，而后对栈做其他操作。这是竞争状态的原因在于，在多线程环境中，empty() 和 size() 的返回值是不可信的。比如，在 A 线程调用 empty() 并返回 false 之后，B 线程可能紧接着清空了整个栈，而后 A 线程基于上述 false 判断调用 top() 函数就会产生不可描述不符合预期的结果。 第二类：首先通过 top() 获取栈顶元素，而后通过 pop() 弹栈该元素。之所以这也是竞争状态，是因为在 top() 和 pop() 之间，其它线程可能进行额外的 push() 或者 pop() 操作，于是当前线程弹出的元素不一定是通过 top() 获取的那个元素。 不难发现，因为这两类固有的竞争状态，不论栈的内部如何实现，外部使用栈时，都可能有线程不安全的情况。 top() 和 pop() 分离的原因上述两类固有的竞争状态源自栈的接口设计。对于第一类竞争状态来说，如此设计似乎情有可原。但是，为什么要将 top() 和 pop() 分离开呢？ 简单来说，top() 将栈顶元素返回给调用者的过程意味着存在一次元素的拷贝。如果栈顶元素体积很大，比如是一个非常长的 std::vector&lt;int&gt;，那么在拷贝的过程中，可能因为系统负载相对资源过高，而抛出 std::bad_alloc 异常。对于现有的实现来说，即使抛出异常，栈内的元素还是完整的。但若是将 pop() 实现在弹栈之后将被弹栈的栈顶元素返回给调用者，则在上述异常可能发生在栈已经被修改之后。若是前一种情况（即当前的实现），调用者在收到异常时，可以尝试进行一些处理；但是，在后一种情况下，即使调用者尝试做了一些内存清理工作，栈中的目标元素也已经被销毁了。 修改接口，实现线程安全以下是一个线程安全的栈的简单实现，分析后附。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;exception&gt;#include &lt;memory&gt;#include &lt;mutex&gt;#include &lt;stack&gt;struct empty_stack : public std::exception &#123; // 1. const char* what() const throw();&#125;;template&lt;typename T&gt;class threadsafe_stack &#123; private: std::stack&lt;T&gt; stack_; // 2. mutable std::mutex mtx_; // 3. public: threadsafe_stack() &#123;&#125; explicit threadsafe_stack(const threadsafe_stack&amp; source) &#123; std::lock_guard&lt;std::mutex&gt; slk(source.mtx_); stack_ = source.stack_; &#125; threadsafe_stack&amp; operator=(const threadsafe_stack&amp; source) &#123; std::lock_guard&lt;std::mutex&gt; slk(source.mtx_); stack_ = source.stack_; &#125; bool empty() const &#123; // 4. std::lock_guard&lt;std::mutex&gt; slk(mtx_); return stack_.empty(); &#125; size_t size() const &#123; std::lock_guard&lt;std::mutex&gt; slk(mtx_); return stack_.size(); &#125; void push(T element) &#123; std::lock_guard&lt;std::mutex&gt; ulk(mtx_); stack_.push(element); &#125; std::shared_ptr&lt;T&gt; pop() &#123; // 5. std::lock_guard&lt;std::mutex&gt; ulk(mtx_); if (stack_.empty()) &#123; throw empty_stack(); &#125; std::shared_ptr res&#123;std::make_shared&lt;T&gt;(stack_.top())&#125;; stack_.pop(); return res; &#125; void pop(T&amp; ref_holder) &#123; // 6. std::lock_guard&lt;std::mutex&gt; ulk(mtx_); if (stack_.empty()) &#123; throw empty_stack(); &#125; ref_holder = stack_.top(); stack_.pop(); &#125;&#125;; 此处我们实现了名为 threadsafe_stack 的模板类。其中，显而易见，我们的线程安全栈的实现是基于标准库中的栈的 (2)，并且为了实现线程安全，我们使用了一个互斥量来保护栈对象 (3)。此外，尽管存在一些只读的公开成员函数 (4)；但是，考虑到实际使用中，大量的栈操作都是写操作，因此 (3) 没有使用读写锁。 为了解决第一类固有竞争状态，我们首先在 (1) 处定义了空栈异常——我们让对空栈进行的 pop() 操作 (5, 6) 抛出空栈异常。如此，在调用处使用 try ... catch ... 语句块，就能实现预期的行为，同时避免接口竞争。 为了避免第二类固有竞争状态，我们取消了 top() 函数，而将它的功能合并入 pop() 函数。同时，为了避免在抛出 std::bad_alloc 时元素已弹栈导致的数据丢失的问题，我们在内部栈对象弹栈之前，尝试将目标元素拷贝 (5) 或赋值 (6) 到其它地方。最后，我们返回拷贝的结果的指针 (5) 或引用 (6) 传给调用者。如此，就避免了第二类竞争。 小结如我们在前作最后提到的，「线程安全」是一个烫手山芋，不存在放之四海而皆准的解决方案（所谓「没有银弹」）。因此，为了写出线程安全的代码，我们必须在理解问题之起因的基础上，具体问题具体分析。 为此，此篇从「不变量」开始，引出在线程中共享数据的「竞争状态」——线程安全问题的根源。而后就如何解决问题展开了一系列的讨论。首先，我们介绍了如何使用标准库提供的「锁」来保护共享数据结构，并介绍了和锁相关的一些话题（如死锁问题、锁的粒度等）。而后，我们通过实现线程安全的栈，讨论了锁无法解决问题时，应当怎么办。 此篇无法穷尽所有和线程安全、锁、死锁相关的话题和技术。但是，建立在理解的基础上，读者应该能对线程安全有直观的认识。我想这应该是有益的。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>C++11</tag>
        <tag>Multithread</tag>
        <tag>Race Conditions</tag>
        <tag>Lock</tag>
        <tag>Mutex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GDB 入门教程：调试 ncurses 相关 bug 的完整范例]]></title>
    <url>%2F2017%2F05%2F27%2Ftutorial-to-GDB-taking-ncurses-as-an-example%2F</url>
    <content type="text"><![CDATA[这是一篇由 Liam Huang 翻译的译文，原文是 Brendan Gregg 所作的 gdb Debugging Full Example (Tutorial): ncurses。转载请保留本段文字，尊重作者和译者的权益。The author of this work is Brendan Gregg and this work was firstly posted on gdb Debugging Full Example (Tutorial): ncurses. This is the translation of the original work, by Liam Huang. Please keep this information at the very top of your reprint, for the rights of the author and the translator. 当我尝试在网上寻找「GDB 范例」时，我发现大多数文章只是贴出了命令，而没有讲解相关输出。GDB 是 GNU 调试器（GNU Debugger），亦是 Linux 系统上的标准调试器。在听 Greg Law 在 CppCon 2015 上关于 GDB 的演讲时（Give me 15 minutes and I’ll change your view of GDB），我发现 Law 给出了相关输出，从而意识到了上述不足。 Law 的演讲，也让我意识到应该分享一个使用 GDB 解决问题的完整范例：包括命令输出、各个步骤，以及一些死胡同。也就是说，这篇文章将分享使用 GDB 调试查错的一般步骤，而不是其他特别的东西。这篇文章介绍了 GDB 的基本使用方法，因此可以作为教程使用。不过，还有很多东西没有介绍，请谨记在心。 以下命令，均是以 root 权限执行的。这是因为，我调试的程序，目前需要以 root 权限执行。在实际使用中，并不是所有所需的命令都需要 root 权限。此外，本文罗列了解决问题的每一个步骤，你可以只浏览你感兴趣的部分。 一 · 问题来了bcc 工具集是 BPF 工具箱的一部分。有人提起了一个 PR (Pull Request)，修改了其中的 cachetop 以使用 top-like display 显示 page cache 的统计。当我对这个 PR 进行测试时，程序提示段错误（segfault） 12# ./cachetop.pySegmentation fault 需要注意的是，Linux 提示程序遇到「段错误 Segmentation fault」，而不是「段错误（核心已转储）Segmentation fault (Core Dumped)」。而此处，我希望能通过核心转储文件，对错误进行调试。（核心转储文件是进程内存空间的拷贝，因此可以用于调试；这个术语源自早年的磁性核心记忆体） 分析核心转储文件，是调试查错的手段之一。不过，也有其他的调试办法。比如，在程序执行时，使用 GDB 检查问题；又或者使用外部工具，收集段错误发生时的数据和堆栈信息。不过，此处我们从核心转储文件的分析开始。 二 · 获得核心转储文件首先，我需要检查一下关于核心转储的设置。 1234# ulimit -c0# cat /proc/sys/kernel/core_patterncore ulimit -c 是 Linux 的系统设置之一，用于限制生成核心转储文件的最大体积。此处，提示不允许转储进程内存。 另一方面，/proc/sys/kernel/core_pattern 的内容是 core。这意味着，发生核心转储时，Linux 会将进程内存空间转储到当前目录下名为 core 的文件当中。对于解决当前问题，这样的设置没什么问题。不过，我会希望将其存在某个固定的目录中。 123# ulimit -c unlimited# mkdir /var/cores# echo "/var/cores/core.%e.%p" &gt; /proc/sys/kernel/core_pattern 你也可以进一步调整 core_pattern。比如说，%h 表示机器名称，%t 表示转储发生的时间。这些 Linux 内核参数的文档在这里。 如果想要永久更改 core_pattern 的设置，你可以修改 /etc/sysctl.conf 文件中的 kernel.core_pattern。 如此，再试试看。 12345678# ./cachetop.pySegmentation fault (core dumped)# ls -lh /var/corestotal 19M-rw------- 1 root root 20M Aug 7 22:15 core.python.30520# file /var/cores/core.python.30520/var/cores/core.python.30520: ELF 64-bit LSB core file x86-64, version 1 (SYSV), SVR4-style, from 'python ./cachetop.py'That's better: we have our core dump. 这样一来，我们就有核心转储文件了。 三 · 启动 GDB现在，我可以启动 GDB，调试目标程序和核心转储文件了。（这里使用了 `which python` 的方式获取系统中 python 的绝对路径） 1234567891011121314151617181920212223242526# gdb `which python` /var/cores/core.python.30520GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1Copyright (C) 2016 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or laterThis is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type "show copying"and "show warranty" for details.This GDB was configured as "x86_64-linux-gnu".Type "show configuration" for configuration details.For bug reporting instructions, please see:.Find the GDB manual and other documentation resources online at:.For help, type "help".Type "apropos word" to search for commands related to "word"...Reading symbols from /usr/bin/python...(no debugging symbols found)...done.warning: core file may not match specified executable file.[New LWP 30520][Thread debugging using libthread_db enabled]Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".warning: JITed object file architecture unknown is not compatible with target architecture i386:x86-64.Core was generated by `python ./cachetop.py'.Program terminated with signal SIGSEGV, Segmentation fault.#0 0x00007f0a37aac40d in doupdate () from /lib/x86_64-linux-gnu/libncursesw.so.5 最后两行包含有趣的信息：它告诉我们，段错误发生在 libncursesw 库的 doupdate() 函数中。这类问题，可以考虑在网上检索，看看是否是已知问题。当然，我遇到的这个问题，没有其他人报告过。 对我来说，我大概能猜到 libncursesw 是做什么的。不过，如果对你来说这很陌生的话，首先你应该知道 /lib 开头并以 *.so 结尾说明它是一个共享对象（动态库）。接下来，你可以尝试通过 man 命令、网页、软件包说明等方式，弄清楚它是做什么的。 123# dpkg -l | grep libncurseswii libncursesw5:amd64 6.0+20160213-1ubuntu1 amd64 shared libraries for terminal handling (wide character support) 我这里是在 Ubuntu 上调试，不过，在其他 Linux 发行上调试也基本没差。 四 · 逆向追溯逆向追溯调用栈，能让我们知道程序是如何一步步调用直到出现问题的。对于一般的问题，逆向追溯调用栈，就足够定位出问题了。因此，我在 GDB 中都会首先尝试使用这一命令：bt（backtrace 的缩写）。 12345678910111213141516171819202122(gdb) bt#0 0x00007f0a37aac40d in doupdate () from /lib/x86_64-linux-gnu/libncursesw.so.5#1 0x00007f0a37aa07e6 in wrefresh () from /lib/x86_64-linux-gnu/libncursesw.so.5#2 0x00007f0a37a99616 in ?? () from /lib/x86_64-linux-gnu/libncursesw.so.5#3 0x00007f0a37a9a325 in wgetch () from /lib/x86_64-linux-gnu/libncursesw.so.5#4 0x00007f0a37cc6ec3 in ?? () from /usr/lib/python2.7/lib-dynload/_curses.x86_64-linux-gnu.so#5 0x00000000004c4d5a in PyEval_EvalFrameEx ()#6 0x00000000004c2e05 in PyEval_EvalCodeEx ()#7 0x00000000004def08 in ?? ()#8 0x00000000004b1153 in PyObject_Call ()#9 0x00000000004c73ec in PyEval_EvalFrameEx ()#10 0x00000000004c2e05 in PyEval_EvalCodeEx ()#11 0x00000000004caf42 in PyEval_EvalFrameEx ()#12 0x00000000004c2e05 in PyEval_EvalCodeEx ()#13 0x00000000004c2ba9 in PyEval_EvalCode ()#14 0x00000000004f20ef in ?? ()#15 0x00000000004eca72 in PyRun_FileExFlags ()#16 0x00000000004eb1f1 in PyRun_SimpleFileExFlags ()#17 0x000000000049e18a in Py_Main ()#18 0x00007f0a3be10830 in __libc_start_main (main=0x49daf0 &lt;main&gt;, argc=2, argv=0x7ffd33d94838, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7ffd33d94828) at ../csu/libc-start.c:291#19 0x000000000049da19 in _start () 这里，自底向上的方向即是调用者 -&gt; 被调用的方向。其中 ?? 表示符号转义失败。遍历调用栈生成栈回溯记录的过程也有可能失败。这种情况下，你可能会看到一个地址值很小的栈帧，当然，这个地址通常是错误的。如果这些问题很严重，那么就要考虑修复这些问题：安装相应软件包的调试信息包（为 GDB 提供更多符号，且允许 GDB 做基于 DWARF 的遍历），或是在编译程序时禁止编译器优化栈帧指针并包含调试信息（-fno-omit-frame-pointer -g）。这里的 ?? 在安装 python-dbg 软件包之后，大都都能解决。 仅从调用栈来看，信息似乎不太够：#5 至 #17 是在 Python 内部，而后经由 _curses 库调用进入 libncursesw。在 libncursesw 中，wgetch()-&gt;wrefresh()-&gt;doupdate() 调用顺序看起来进行了一次窗口刷新。但是，为什么这会引发核心转储呢？ 五 · 反汇编接下来，我要反汇编导致段错误的函数 doupdate()。 123456789101112131415161718192021222324(gdb) disas doupdateDump of assembler code for function doupdate: 0x00007f0a37aac2e0 &lt;+0&gt;: push %r15 0x00007f0a37aac2e2 &lt;+2&gt;: push %r14 0x00007f0a37aac2e4 &lt;+4&gt;: push %r13 0x00007f0a37aac2e6 &lt;+6&gt;: push %r12 0x00007f0a37aac2e8 &lt;+8&gt;: push %rbp 0x00007f0a37aac2e9 &lt;+9&gt;: push %rbx 0x00007f0a37aac2ea &lt;+10&gt;: sub $0xc8,%rsp[...]---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---[...] 0x00007f0a37aac3f7 &lt;+279&gt;: cmpb $0x0,0x21(%rcx) 0x00007f0a37aac3fb &lt;+283&gt;: je 0x7f0a37aacc3b &lt;doupdate+2395&gt; 0x00007f0a37aac401 &lt;+289&gt;: mov 0x20cb68(%rip),%rax # 0x7f0a37cb8f70 0x00007f0a37aac408 &lt;+296&gt;: mov (%rax),%rsi 0x00007f0a37aac40b &lt;+299&gt;: xor %eax,%eax=&gt; 0x00007f0a37aac40d &lt;+301&gt;: mov 0x10(%rsi),%rdi 0x00007f0a37aac411 &lt;+305&gt;: cmpb $0x0,0x1c(%rdi) 0x00007f0a37aac415 &lt;+309&gt;: jne 0x7f0a37aac6f7 &lt;doupdate+1047&gt; 0x00007f0a37aac41b &lt;+315&gt;: movswl 0x4(%rcx),%ecx 0x00007f0a37aac41f &lt;+319&gt;: movswl 0x74(%rdx),%edi 0x00007f0a37aac423 &lt;+323&gt;: mov %rax,0x40(%rsp)[...] 这里的输出做了适当的截断。（我也可以直接输入 disas，以查看当前函数的汇编代码） =&gt; 箭头标注的位置，即是产生段错误的指令地址。该指令中（mov 0x10(%rsi),%rdi），%rsi 寄存器保存了一个内存地址，之前的 0x10 表示在这个内存地址的基础上做 0x10 的偏移；%rdi 则是另一个寄存器。该指令的作用，是将上述偏移过的内存地址中保存的内容，拷贝到 %rdi 寄存器当中。接下来，我们要看看寄存器的状态。 六 · 查看寄存器状态使用命令 i r（info registers 的缩写）可以打印寄存器状态。 12345678910111213141516171819202122232425(gdb) i rrax 0x0 0rbx 0x1993060 26816608rcx 0x19902a0 26804896rdx 0x19ce7d0 27060176rsi 0x0 0rdi 0x19ce7d0 27060176rbp 0x7f0a3848eb10 0x7f0a3848eb10 &lt;SP&gt;rsp 0x7ffd33d93c00 0x7ffd33d93c00r8 0x7f0a37cb93e0 139681862489056r9 0x0 0r10 0x8 8r11 0x202 514r12 0x0 0r13 0x0 0r14 0x7f0a3848eb10 139681870703376r15 0x19ce7d0 27060176rip 0x7f0a37aac40d 0x7f0a37aac40d &lt;doupdate+301&gt;eflags 0x10246 [ PF ZF IF RF ]cs 0x33 51ss 0x2b 43ds 0x0 0es 0x0 0fs 0x0 0gs 0x0 0 好吧，%rsi 这个寄存器中，保存的是一个空指针（0x0）。这就怪不得要出问题了。解引用一个未初始化的指针，或是解引用空指针，是段错误的常见原因。 七 · 内存映射你可以再确认一下此时 0x0 是否是有效的地址。在 GDB 中使用 i proc m（info proc mappings 的缩写）可以查看内存映射状态。 123456789101112131415161718192021(gdb) i proc mMapped address spaces: Start Addr End Addr Size Offset objfile 0x400000 0x6e7000 0x2e7000 0x0 /usr/bin/python2.7 0x8e6000 0x8e8000 0x2000 0x2e6000 /usr/bin/python2.7 0x8e8000 0x95f000 0x77000 0x2e8000 /usr/bin/python2.7 0x7f0a37a8b000 0x7f0a37ab8000 0x2d000 0x0 /lib/x86_64-linux-gnu/libncursesw.so.5.9 0x7f0a37ab8000 0x7f0a37cb8000 0x200000 0x2d000 /lib/x86_64-linux-gnu/libncursesw.so.5.9 0x7f0a37cb8000 0x7f0a37cb9000 0x1000 0x2d000 /lib/x86_64-linux-gnu/libncursesw.so.5.9 0x7f0a37cb9000 0x7f0a37cba000 0x1000 0x2e000 /lib/x86_64-linux-gnu/libncursesw.so.5.9 0x7f0a37cba000 0x7f0a37ccd000 0x13000 0x0 /usr/lib/python2.7/lib-dynload/_curses.x86_64-linux-gnu.so 0x7f0a37ccd000 0x7f0a37ecc000 0x1ff000 0x13000 /usr/lib/python2.7/lib-dynload/_curses.x86_64-linux-gnu.so 0x7f0a37ecc000 0x7f0a37ecd000 0x1000 0x12000 /usr/lib/python2.7/lib-dynload/_curses.x86_64-linux-gnu.so 0x7f0a37ecd000 0x7f0a37ecf000 0x2000 0x13000 /usr/lib/python2.7/lib-dynload/_curses.x86_64-linux-gnu.so 0x7f0a38050000 0x7f0a38066000 0x16000 0x0 /lib/x86_64-linux-gnu/libgcc_s.so.1 0x7f0a38066000 0x7f0a38265000 0x1ff000 0x16000 /lib/x86_64-linux-gnu/libgcc_s.so.1 0x7f0a38265000 0x7f0a38266000 0x1000 0x15000 /lib/x86_64-linux-gnu/libgcc_s.so.1 0x7f0a38266000 0x7f0a3828b000 0x25000 0x0 /lib/x86_64-linux-gnu/libtinfo.so.5.9 0x7f0a3828b000 0x7f0a3848a000 0x1ff000 0x25000 /lib/x86_64-linux-gnu/libtinfo.so.5.9[...] 如此可以看到，虚存空间有效地址的最低位是 0x400000。因此，显而易见 0x0 此时是一个非法的地址，所以使用它会导致段错误。 至此为止，继续深入进行调试的方法有多重。我将从指令的角度继续深入。 八 · 断点回到刚才的反汇编的结果。 1234 0x00007f0a37aac401 &lt;+289&gt;: mov 0x20cb68(%rip),%rax # 0x7f0a37cb8f70 0x00007f0a37aac408 &lt;+296&gt;: mov (%rax),%rsi 0x00007f0a37aac40b &lt;+299&gt;: xor %eax,%eax=&gt; 0x00007f0a37aac40d &lt;+301&gt;: mov 0x10(%rsi),%rdi 从汇编指令来看，代码似乎首先从栈上将某个信息拷贝到 %rax 寄存器当中。而后解引用 %rax 寄存器里的内容，并拷贝到 %rsi 寄存器。而后通过 xor 将 %eax 寄存器中的内容置零。最后执行到产生段错误的代码。在这里，%eax 有可能提供更多的信息。（译注：原作者写的是 %rax，这应该是手误）但是在段错误之前，它已经被置零了，因此我们看不到更多的信息。 我可以将断点设置在 doupdate+298 处，而后顺着指令单步调试，看看各个寄存器的值是如何变化的。为此，首先我得启动 GDB，以便在其中实时执行程序。 12345678910111213141516# gdb `which python`GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1Copyright (C) 2016 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or laterThis is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type "show copying"and "show warranty" for details.This GDB was configured as "x86\_64-linux-gnu".Type "show configuration" for configuration details.For bug reporting instructions, please see:.Find the GDB manual and other documentation resources online at:.For help, type "help".Type "apropos word" to search for commands related to "word"...Reading symbols from /usr/bin/python...(no debugging symbols found)...done. 而后，使用 b 命令（break 的缩写）设置断点。 12(gdb) b *doupdate + 289No symbol table is loaded. Use the "file" command. 啊，出错了……这是我有意呈现的错误。通常，我们会将断点首先设置在 main 处，因为彼时符号应该都加载完毕了。而后，在程序遇到断点并暂停时，我们可以设置其他断点。此处，我需要关注 doupdate 函数，因此，我将断点首先设置在这个函数被调用的地方。 1234567891011121314151617(gdb) b doupdateFunction "doupdate" not defined.Make breakpoint pending on future shared library load? (y or [n]) yBreakpoint 1 (doupdate) pending.(gdb) r cachetop.pyStarting program: /usr/bin/python cachetop.py[Thread debugging using libthread_db enabled]Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".warning: JITed object file architecture unknown is not compatible with target architecture i386:x86-64.Breakpoint 1, 0x00007ffff34ad2e0 in doupdate () from /lib/x86_64-linux-gnu/libncursesw.so.5(gdb) b *doupdate + 289Breakpoint 2 at 0x7ffff34ad401(gdb) cContinuing.Breakpoint 2, 0x00007ffff34ad401 in doupdate () from /lib/x86_64-linux-gnu/libncursesw.so.5 如此，我们就来到了目标断点位置。 这里，r (run) 命令将参数传给被 GDB 跟踪的程序（这里是 python），以便执行目标 Python 脚本。因此，这里相当于执行了 python cachetop.py。 ⑨ · 单步调试至此，我使用 si (stepi) 命令，让程序单步地向前执行一条指令，而后检查寄存器状态。 1234567891011121314151617181920212223242526272829(gdb) si0x00007ffff34ad408 in doupdate () from /lib/x86_64-linux-gnu/libncursesw.so.5(gdb) i rrax 0x7ffff3e8f948 140737285519688rbx 0xaea060 11444320rcx 0xae72a0 11432608rdx 0xa403d0 10748880rsi 0x7ffff7ea8e10 140737352732176rdi 0xa403d0 10748880rbp 0x7ffff3e8fb10 0x7ffff3e8fb10 &lt;SP&gt;rsp 0x7fffffffd390 0x7fffffffd390r8 0x7ffff36ba3e0 140737277305824r9 0x0 0r10 0x8 8r11 0x202 514r12 0x0 0r13 0x0 0r14 0x7ffff3e8fb10 140737285520144r15 0xa403d0 10748880rip 0x7ffff34ad408 0x7ffff34ad408 &lt;doupdate+296&gt;eflags 0x202 [ IF ]cs 0x33 51ss 0x2b 43ds 0x0 0es 0x0 0fs 0x0 0gs 0x0 0(gdb) p/a 0x7ffff3e8f948$1 = 0x7ffff3e8f948 &lt;cur_term&gt; 新的线索出现了。看起来，我们对空指针解引用的操作，发生在一个名为 cur_term 的符号当中。（p/a 是 print/a 的缩写，其中 /a 表示随后传入的是一个内存地址）考虑到这是在调试 ncurses，那么，是不是我们的 TERM 环境设置有问题呢？ 12# echo $TERMxterm-256color 我尝试将其设为 vt100，但是执行程序依旧得到了相同的段错误。 注意，此处我检查的是 doupdate 函数第一次被调用的情形，但实际上它可能被多次调用，而且问题可能出在后续的调用中。为此，我们可以让程序持续执行（c 命令），直到撞见我们期待的那次调用。然而，调用次数少的话，可能还好。若是调用多次，这就不好办了。（第 15 节将讨论这个问题） 十 · 单步回退单步回退是 GDB 的重要特性之一，Law 在它的演讲中也有提到。我们看一个例子。 我会重启整个 GDB 会话，从头开始演示。 12345678910111213141516# gdb `which python`GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1Copyright (C) 2016 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or laterThis is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type "show copying"and "show warranty" for details.This GDB was configured as "x86\_64-linux-gnu".Type "show configuration" for configuration details.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at:&lt;http://www.gnu.org/software/gdb/documentation/&gt;.For help, type "help".Type "apropos word" to search for commands related to "word"...Reading symbols from /usr/bin/python...(no debugging symbols found)...done. 而后，我将断点设置在 doupdate 函数上；当遇到之后，我会打开记录功能，直到进程崩溃。这种记录功能，对系统影响是很大的。所以，最好不要从 main 函数就开始记录。 1234567891011121314151617(gdb) b doupdateFunction "doupdate" not defined.Make breakpoint pending on future shared library load? (y or [n]) yBreakpoint 1 (doupdate) pending.(gdb) r cachetop.pyStarting program: /usr/bin/python cachetop.py[Thread debugging using libthread_db enabled]Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".warning: JITed object file architecture unknown is not compatible with target architecture i386:x86-64.Breakpoint 1, 0x00007ffff34ad2e0 in doupdate () from /lib/x86_64-linux-gnu/libncursesw.so.5(gdb) record(gdb) cContinuing.Program received signal SIGSEGV, Segmentation fault.0x00007ffff34ad40d in doupdate () from /lib/x86_64-linux-gnu/libncursesw.so.5 至此，我就可以在代码行或者指令的意义上单步回退了。单步回退的原理，是从记录中，回放寄存器的状态。此处，我回退两个指令，而后打印寄存器状态。 12345678910111213141516171819202122232425262728293031(gdb) reverse-stepi0x00007ffff34ad40d in doupdate () from /lib/x86_64-linux-gnu/libncursesw.so.5(gdb) reverse-stepi0x00007ffff34ad40b in doupdate () from /lib/x86_64-linux-gnu/libncursesw.so.5(gdb) i rrax 0x7ffff3e8f948 140737285519688rbx 0xaea060 11444320rcx 0xae72a0 11432608rdx 0xa403d0 10748880rsi 0x0 0rdi 0xa403d0 10748880rbp 0x7ffff3e8fb10 0x7ffff3e8fb10 &lt;SP&gt;rsp 0x7fffffffd390 0x7fffffffd390r8 0x7ffff36ba3e0 140737277305824r9 0x0 0r10 0x8 8r11 0x302 770r12 0x0 0r13 0x0 0r14 0x7ffff3e8fb10 140737285520144r15 0xa403d0 10748880rip 0x7ffff34ad40b 0x7ffff34ad40b &lt;doupdate+299&gt;eflags 0x202 [ IF ]cs 0x33 51ss 0x2b 43ds 0x0 0es 0x0 0fs 0x0 0gs 0x0 0(gdb) p/a 0x7ffff3e8f948$1 = 0x7ffff3e8f948 &lt;cur_term&gt; 这次确定无疑，我们又一次定位到了 cur_term 这条线索。此时，我很想读读源码，但是首先我会试着看到更多的调试信息。 十一 · 调试信息这里，我们需要（在 Ubuntu 上）安装 libncursesw 的调试信息包。 12345678910111213141516171819202122# apt-cache search libncurseswlibncursesw5 - shared libraries for terminal handling (wide character support)libncursesw5-dbg - debugging/profiling libraries for ncurseswlibncursesw5-dev - developer's libraries for ncursesw# dpkg -l | grep libncurseswii libncursesw5:amd64 6.0+20160213-1ubuntu1 amd64 shared libraries for terminal handling (wide character support)# apt-get install -y libncursesw5-dbgReading package lists... DoneBuilding dependency treeReading state information... Done[...]After this operation, 2,488 kB of additional disk space will be used.Get:1 http://us-west-1.ec2.archive.ubuntu.com/ubuntu xenial/main amd64 libncursesw5-dbg amd64 6.0+20160213-1ubuntu1 [729 kB]Fetched 729 kB in 0s (865 kB/s)Selecting previously unselected package libncursesw5-dbg.(Reading database ... 200094 files and directories currently installed.)Preparing to unpack .../libncursesw5-dbg_6.0+20160213-1ubuntu1_amd64.deb ...Unpacking libncursesw5-dbg (6.0+20160213-1ubuntu1) ...Setting up libncursesw5-dbg (6.0+20160213-1ubuntu1) ...# dpkg -l | grep libncurseswii libncursesw5:amd64 6.0+20160213-1ubuntu1 amd64 shared libraries for terminal handling (wide character support)ii libncursesw5-dbg 6.0+20160213-1ubuntu1 amd64 debugging/profiling libraries for ncursesw 赞~！此处的调试信息包与动态库的版本是一致的。现在的段错误看起来是怎样的呢？ 12345678910111213141516171819202122232425262728293031323334# gdb `which python` /var/cores/core.python.30520GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1[...]warning: JITed object file architecture unknown is not compatible with target architecture i386:x86-64.Core was generated by `python ./cachetop.py'.Program terminated with signal SIGSEGV, Segmentation fault.#0 ClrBlank (win=0x1993060) at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/tty/tty_update.c:11291129 if (back_color_erase)(gdb) bt#0 ClrBlank (win=0x1993060) at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/tty/tty_update.c:1129#1 ClrUpdate () at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/tty/tty_update.c:1147#2 doupdate () at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/tty/tty_update.c:1010#3 0x00007f0a37aa07e6 in wrefresh (win=win@entry=0x1993060) at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/base/lib_refresh.c:65#4 0x00007f0a37a99499 in recur_wrefresh (win=win@entry=0x1993060) at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/base/lib_getch.c:384#5 0x00007f0a37a99616 in _nc_wgetch (win=win@entry=0x1993060, result=result@entry=0x7ffd33d93e24, use_meta=1) at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/base/lib_getch.c:491#6 0x00007f0a37a9a325 in wgetch (win=0x1993060) at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/base/lib_getch.c:672#7 0x00007f0a37cc6ec3 in ?? () from /usr/lib/python2.7/lib-dynload/_curses.x86_64-linux-gnu.so#8 0x00000000004c4d5a in PyEval_EvalFrameEx ()#9 0x00000000004c2e05 in PyEval_EvalCodeEx ()#10 0x00000000004def08 in ?? ()#11 0x00000000004b1153 in PyObject_Call ()#12 0x00000000004c73ec in PyEval_EvalFrameEx ()#13 0x00000000004c2e05 in PyEval_EvalCodeEx ()#14 0x00000000004caf42 in PyEval_EvalFrameEx ()#15 0x00000000004c2e05 in PyEval_EvalCodeEx ()#16 0x00000000004c2ba9 in PyEval_EvalCode ()#17 0x00000000004f20ef in ?? ()#18 0x00000000004eca72 in PyRun_FileExFlags ()#19 0x00000000004eb1f1 in PyRun_SimpleFileExFlags ()#20 0x000000000049e18a in Py_Main ()#21 0x00007f0a3be10830 in __libc_start_main (main=0x49daf0 &lt;main&gt;, argc=2, argv=0x7ffd33d94838, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7ffd33d94828) at ../csu/libc-start.c:291#22 0x000000000049da19 in _start () 调用栈看起来稍微有些不一样了。发生段错误的地方，实际是在 ClrBlank() 函数当中。它首先被内联到 ClrUpdate() 当中，最后内联到 doupdate() 当中。 至此，我真的要读读代码了。 十二 · 源代码有了调试信息包，GDB 可以将源代码和汇编码打印在一起。 123456789101112131415161718192021222324252627282930(gdb) disas/sDump of assembler code for function doupdate:/build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/tty/tty_update.c:759 &#123; 0x00007f0a37aac2e0 &lt;+0&gt;: push %r15 0x00007f0a37aac2e2 &lt;+2&gt;: push %r14 0x00007f0a37aac2e4 &lt;+4&gt;: push %r13 0x00007f0a37aac2e6 &lt;+6&gt;: push %r12[...] 0x00007f0a37aac3dd &lt;+253&gt;: jne 0x7f0a37aac6ca &lt;doupdate+1002&gt;1009 if (CurScreen(SP_PARM)-&gt;_clear || NewScreen(SP_PARM)-&gt;_clear) &#123; /* force refresh ? */ 0x00007f0a37aac3e3 &lt;+259&gt;: mov 0x80(%rdx),%rax 0x00007f0a37aac3ea &lt;+266&gt;: mov 0x88(%rdx),%rcx 0x00007f0a37aac3f1 &lt;+273&gt;: cmpb $0x0,0x21(%rax) 0x00007f0a37aac3f5 &lt;+277&gt;: jne 0x7f0a37aac401 &lt;doupdate+289&gt; 0x00007f0a37aac3f7 &lt;+279&gt;: cmpb $0x0,0x21(%rcx) 0x00007f0a37aac3fb &lt;+283&gt;: je 0x7f0a37aacc3b &lt;doupdate+2395&gt;1129 if (back_color_erase) 0x00007f0a37aac401 &lt;+289&gt;: mov 0x20cb68(%rip),%rax # 0x7f0a37cb8f70 0x00007f0a37aac408 &lt;+296&gt;: mov (%rax),%rsi1128 NCURSES_CH_T blank = blankchar; 0x00007f0a37aac40b &lt;+299&gt;: xor %eax,%eax1129 if (back_color_erase)=&gt; 0x00007f0a37aac40d &lt;+301&gt;: mov 0x10(%rsi),%rdi 0x00007f0a37aac411 &lt;+305&gt;: cmpb $0x0,0x1c(%rdi) 0x00007f0a37aac415 &lt;+309&gt;: jne 0x7f0a37aac6f7 &lt;doupdate+1047&gt; 好，依旧有 =&gt; 作为出问题指令的标记，以及指令对应的代码打印在其上。那么，程序产生段错误，是因为 if(back_color_erase) 这一行代码吗？看起来似乎不太可能。段错误产生的原因是对指向非法地址的指针进行解引用，例如 a-&gt;b 或者 *a。但在此处，back_color_erase 仅只是普通地访问变量，没有解引用的动作，是不会引起段错误的。 为此，我反复检查了调试信息包的版本是否匹配，而后重新在 GDB 里执行程序，但无有收获——段错误发生在同一位置。 那么，是不是 back_color_erase 本身有什么特别之处呢？现在我们在 ClrBlank 函数中，我试着列出它的源代码。 1234567891011(gdb) list ClrBlank11241125 static NCURSES_INLINE NCURSES_CH_T1126 ClrBlank(NCURSES_SP_DCLx WINDOW *win)1127 &#123;1128 NCURSES_CH_T blank = blankchar;1129 if (back_color_erase)1130 AddAttr(blank, (AttrOf(BCE_BKGD(SP_PARM, win)) &amp; BCE_ATTRS));1131 return blank;1132 &#125;1133 呃……back_color_erase 在函数里是未定义的，看起来是一个全局变量？ 十三 · TUITUI 是 text user interface（文本用户界面）的缩写。这一界面我甚少使用，我也是听过 Law 的讲座之后受到的启发。 为此，你需要在 GDB 启动的时候，传入 --tui 参数。 12345678910111213141516171819202122232425# gdb --tui `which python` /var/cores/core.python.30520 ┌───────────────────────────────────────────────────────────────────────────┐ │ │ │ │ │ │ │ │ │ │ │ │ │ [ No Source Available ] │ │ │ │ │ │ │ │ │ │ │ │ │ └───────────────────────────────────────────────────────────────────────────┘None No process In: L?? PC: ??GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1Copyright (C) 2016 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or laterThis is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type "show copying"and "show warranty" for details.This GDB was configured as "x86_64-linux-gnu".---Type to continue, or q to quit--- GDB 抱怨说没能找到 Python 的源代码。诚然，我可以去解决这个问题，然而，现在进程崩溃的位置是在 libncursesw，费劲去解决这个问题就没必要了。因此，按下回车，使其继续加载，并读入 libncursesw 的调试信息。 123456789101112131415161718192021222324 ┌──/build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/tty/tty_update.c──────┐ │1124 │ │1125 static NCURSES_INLINE NCURSES_CH_T │ │1126 ClrBlank(NCURSES_SP_DCLx WINDOW *win) │ │1127 &#123; │ │1128 NCURSES_CH_T blank = blankchar; │ &gt;│1129 if (back_color_erase) │ │1130 AddAttr(blank, (AttrOf(BCE_BKGD(SP_PARM, win)) &amp; BCE_ATTRS)│ │1131 return blank; │ │1132 &#125; │ │1133 │ │1134 /* │ │1135 ** ClrUpdate() │ │1136 ** │ └───────────────────────────────────────────────────────────────────────────┘multi-thre Thread 0x7f0a3c5e87 In: doupdate L1129 PC: 0x7f0a37aac40dwarning: JITed object file architecture unknown is not compatible with target architecture i386:x86-64.---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---Core was generated by `python ./cachetop.py'.Program terminated with signal SIGSEGV, Segmentation fault.#0 ClrBlank (win=0x1993060) at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/tty/tty_update.c:1129(gdb) 棒呆！ 箭头 &gt; 指向的代码就是程序崩溃的位置。使用 layout split 命令，可以让汇编指令和源代码分开显示。 123456789101112131415161718192021222324252627 ┌──/build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/tty/tty_update.c──────┐ &gt;│1129 if (back_color_erase) │ │1130 AddAttr(blank, (AttrOf(BCE_BKGD(SP_PARM, win)) &amp; BCE_ATTRS)│ │1131 return blank; │ │1132 &#125; │ │1133 │ │1134 /* │ │1135 ** ClrUpdate() │ └───────────────────────────────────────────────────────────────────────────┘ &gt;│0x7f0a37aac40d &lt;doupdate+301&gt; mov 0x10(%rsi),%rdi │ │0x7f0a37aac411 &lt;doupdate+305&gt; cmpb $0x0,0x1c(%rdi) │ │0x7f0a37aac415 &lt;doupdate+309&gt; jne 0x7f0a37aac6f7 &lt;doupdate+1047&gt; │ │0x7f0a37aac41b &lt;doupdate+315&gt; movswl 0x4(%rcx),%ecx │ │0x7f0a37aac41f &lt;doupdate+319&gt; movswl 0x74(%rdx),%edi │ │0x7f0a37aac423 &lt;doupdate+323&gt; mov %rax,0x40(%rsp) │ │0x7f0a37aac428 &lt;doupdate+328&gt; movl $0x20,0x48(%rsp) │ │0x7f0a37aac430 &lt;doupdate+336&gt; movl $0x0,0x4c(%rsp) │ └───────────────────────────────────────────────────────────────────────────┘multi-thre Thread 0x7f0a3c5e87 In: doupdate L1129 PC: 0x7f0a37aac40dchitecture i386:x86-64.Core was generated by `python ./cachetop.py'.Program terminated with signal SIGSEGV, Segmentation fault.---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---#0 ClrBlank (win=0x1993060) at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/tty/tty_update.c:1129(gdb) layout split Law 在单步回退中展示了如何使用 TUI。你可以想象一下，在代码执行的过程中，同时呈现汇编码和源代码是怎样的光景。 十四 · 外部工具：cscope我依然需要搞清楚 back_color_erase 到底发生了什么。当然，我可以在 GDB 中使用 search 命令，查找 back_color_erase 是在哪里定义的。不过，我更偏好使用名为 cscope 的外部工具。这是一个贝尔实验室在上世纪 80 年代发明的基于文本的代码浏览器。如果你有喜欢的现代 IDE 工具，那么就用你喜欢的就好。 首先，设置 cscope。 123456# apt-get install -y cscope# wget http://archive.ubuntu.com/ubuntu/pool/main/n/ncurses/ncurses_6.0+20160213.orig.tar.gz# tar xvf ncurses_6.0+20160213.orig.tar.gz# cd ncurses-6.0-20160213# cscope -bqR# cscope -dq 此处 cscope -bqR 创建了查找数据库，而 cscope -dq 则启动之。 搜索 back_color_erase 的定义： 1234567891011121314151617181920212223Cscope version 15.8b Press the ? key for helpFind this C symbol:Find this global definition: back_color_eraseFind functions called by this function:Find functions calling this function:Find this text string:Change this text string:Find this egrep pattern:Find this file:Find files #including this file:Find assignments to this symbol: 敲回车。 12345678[...]#define non_dest_scroll_region CUR Booleans[26]#define can_change CUR Booleans[27]#define back_color_erase CUR Booleans[28]#define hue_lightness_saturation CUR Booleans[29]#define col_addr_glitch CUR Booleans[30]#define cr_cancels_micro_mode CUR Booleans[31][...] 好吧……这是一个用 #define 定义的宏变量。（就不能大写吗？摔！） 那么，CUR 又是什么呢？我们继续搜索。 1#define CUR cur_term-&gt;type. 好嘛，至少这个 #define 定义的宏是大写的。 碰见 cur_term 了——之前我们在单步调试汇编指令和检查寄存器状态的时候有看到过它。那么它是啥咧？ 12345678#if 0 &amp;&amp; !0extern NCURSES_EXPORT_VAR(TERMINAL *) cur_term;#elif 0NCURSES_WRAPPED_VAR(TERMINAL *, cur_term);#define cur_term NCURSES_PUBLIC_VAR(cur_term())#elseextern NCURSES_EXPORT_VAR(TERMINAL *) cur_term; // &lt;- here#endif cscope 在 /usr/include/term.h 中找到了它。我在我认为真正起作用的定义处，用注释做了标记。为什么会有 if 0 &amp;&amp; !0 ... elif 0 这种那奇怪的写法，我也不知道……（但总之要阅读更多的代码）有时，程序员会使用 #if 0 使调试用代码在生产环境中不生效。但这部分代码，看上去是自动生成的。 继续搜索 NCURSES_EXPORT_VAR，会有新的发现。 1# define NCURSES_EXPORT_VAR(type) NCURSES_IMPEXP type 以及 NCURSES_IMPEXP…… 12345678typedef struct term &#123; /* describe an actual terminal */ TERMTYPE type; /* terminal type description */ short Filedes; /* file description being written to */ TTY Ottyb, /* original state of the terminal */ Nttyb; /* current state of the terminal */ int _baudrate; /* used to compute padding */ char * _termname; /* used for termname() */&#125; TERMINAL; 哈！这回 TERMINAL 是大写的了。在这坨宏当中，这算是容易追踪的了。 好了，现在到底是谁设置了 cur_term 呢？想想看，我们遇到的问题，是因为 cur_term 被设置为 0x0，这可能是没有初始化导致的，也有可能是显式设置导致的。顺着代码检查，可能会有新的线索。 12345Find this C symbol: cur_termFind this global definition:Find functions called by this function:Find functions calling this function:[...] 按下回车，得到结果。 12345678910111213141516NCURSES_EXPORT(TERMINAL *)NCURSES_SP_NAME(set_curterm) (NCURSES_SP_DCLx TERMINAL * termp)&#123; TERMINAL *oldterm; T((T_CALLED("set_curterm(%p)"), (void *) termp)); _nc_lock_global(curses); oldterm = cur_term; if (SP_PARM) SP_PARM-&gt;_term = termp;#if USE_REENTRANT CurTerm = termp;#else cur_term = termp; // &lt;- here#endif 同样，我对实际生效的部分做了标记。尽管函数名字被包在宏变量当中，但是我们至少知道 cur_term 是如何设置的了——通过 set_curterm() 函数。这个函数是没有被调用吗？ 十五 · 外部工具：perf-tools/ftrace/uprobes我稍后将介绍如何使用 GDB 解决这个问题，但我想试着用我的 perf-tools 工具集当中的 uprobe 工具来解决问题。它使用了 Linux 提供的 ftrace 以及 uprobes 两个工具。使用跟踪器的好处是不需要像 GDB 那样暂停目标进程——当然，在这个例子里这没所谓就是了。此外，使用跟踪器追踪一个事件和追踪成百上千个事件是一样的。 为此，我需要追踪 set_curterm 的调用，并且打印其首个参数。 12# /apps/perf-tools/bin/uprobe 'p:/lib/x86_64-linux-gnu/libncursesw.so.5:set_curterm %di'ERROR: missing symbol "set_curterm" in /lib/x86_64-linux-gnu/libncursesw.so.5 好吧，在 libncursesw 里没见着有 set_curterm。那么它在哪里呢？我们可以用 GDB 或者 objdump 查找一下。 1234567(gdb) info symbol set_curtermset_curterm in section .text of /lib/x86_64-linux-gnu/libtinfo.so.5# objdump -tT /lib/x86_64-linux-gnu/libncursesw.so.5 | grep cur_term0000000000000000 DO *UND* 0000000000000000 NCURSES_TINFO_5.0.19991023 cur_term# objdump -tT /lib/x86_64-linux-gnu/libtinfo.so.5 | grep cur_term0000000000228948 g DO .bss 0000000000000008 NCURSES_TINFO_5.0.19991023 cur_term 显而易见，在此处 GDB 更好使些。如果你足够仔细的话，你会发现，这个函数定义在 libtinfo 当中。那么，让我们尝试在 libtinfo 中去追踪 set_curterm。 1234567# /apps/perf-tools/bin/uprobe 'p:/lib/x86_64-linux-gnu/libtinfo.so.5:set_curterm %di'Tracing uprobe set_curterm (p:set_curterm /lib/x86_64-linux-gnu/libtinfo.so.5:0xfa80 %di). Ctrl-C to end. python-31617 [007] d... 24236402.719959: set_curterm: (0x7f116fcc2a80) arg1=0x1345d70 python-31617 [007] d... 24236402.720033: set_curterm: (0x7f116fcc2a80) arg1=0x13a22e0 python-31617 [007] d... 24236402.723804: set_curterm: (0x7f116fcc2a80) arg1=0x14cdfa0 python-31617 [007] d... 24236402.723838: set_curterm: (0x7f116fcc2a80) arg1=0x0^C 这会没问题了。显而易见，set_curterm 确实是有被调用的，并且被调用了 4 次。在最后一次调用时（之后进程就崩溃了），第一个参数是 0x0，看起来似乎就是问题所在了。 至于为什么要打印 %di 这个寄存器中的值，是因为我们的程序运行在 x86_64 平台。使用 man syscall 可以看到有用的信息。 12345678910111213141516171819# man syscall[...] arch/ABI arg1 arg2 arg3 arg4 arg5 arg6 arg7 Notes ────────────────────────────────────────────────────────────────── arm/OABI a1 a2 a3 a4 v1 v2 v3 arm/EABI r0 r1 r2 r3 r4 r5 r6 arm64 x0 x1 x2 x3 x4 x5 - blackfin R0 R1 R2 R3 R4 R5 - i386 ebx ecx edx esi edi ebp - ia64 out0 out1 out2 out3 out4 out5 - mips/o32 a0 a1 a2 a3 - - - See below mips/n32,64 a0 a1 a2 a3 a4 a5 - parisc r26 r25 r24 r23 r22 r21 - s390 r2 r3 r4 r5 r6 r7 - s390x r2 r3 r4 r5 r6 r7 - sparc/32 o0 o1 o2 o3 o4 o5 - sparc/64 o0 o1 o2 o3 o4 o5 - x86_64 rdi rsi rdx r10 r8 r9 -[...] 我还想去看看为什么会在调用 set_curterm 时传入 0x0 作为参数，不过当前 ftrace 不支持调用栈的查询。 十六 · 外部工具：bcc/BPF考虑到我们正在调试 bcc 工具 cachetop.py，那么使用 bcc 提供的 trace.py 来追踪函数调用是个不错的选择。它和刚才的 uprobe 工具有类似的功能。 123456# ./trace.py 'p:tinfo:set_curterm "%d", arg1'TIME PID COMM FUNC -01:00:20 31698 python set_curterm 3801841601:00:20 31698 python set_curterm 3839664001:00:20 31698 python set_curterm 3962460801:00:20 31698 python set_curterm 0 没错！我们在用 bcc 来调试 bcc。 如果你之前未曾使用过 bcc，那么我推荐你试试看。它有面向 Python 和 Lua 的接口，提供了在 Linux 4.x 系列中的 BPF 跟踪特性。简单来说，它让很多以前无法或者难以实现的性能工具变得可行。在 Ubuntu Xenial 上有我关于此的介绍。 十七 · 更多的断点我本该用 GDB 给 set_curterm 设置断点的，但是绕道去 ftrace 和 BPF 也时很有趣的事情。 回到 GDB。 1234567891011121314151617181920212223242526272829# gdb `which python`GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1[...](gdb) b set_curtermFunction "set_curterm" not defined.Make breakpoint pending on future shared library load? (y or [n]) yBreakpoint 1 (set_curterm) pending.(gdb) r cachetop.pyStarting program: /usr/bin/python cachetop.py[Thread debugging using libthread_db enabled]Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".Breakpoint 1, set_curterm (termp=termp@entry=0xa43150) at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/tinfo/lib_cur_term.c:8080 &#123;(gdb) cContinuing.Breakpoint 1, set_curterm (termp=termp@entry=0xab5870) at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/tinfo/lib_cur_term.c:8080 &#123;(gdb) cContinuing.Breakpoint 1, set_curterm (termp=termp@entry=0xbecb90) at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/tinfo/lib_cur_term.c:8080 &#123;(gdb) cContinuing.Breakpoint 1, set_curterm (termp=0x0) at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/tinfo/lib_cur_term.c:8080 &#123; 好了，在断点处，我们看到 set_curterm 被传入了参数 termp=0x0。幸好能有这些调试信息，否则，我就不得不在各个断点去打印寄存器状态了。 现在，查看逆向追溯调用栈，应当可以看到是哪个函数将 0x0 传给了 set_curterm。 12345678910111213141516171819202122232425262728293031323334353637383940414243(gdb) bt#0 set_curterm (termp=0x0) at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/tinfo/lib_cur_term.c:80#1 0x00007ffff5a44e75 in llvm::sys::Process::FileDescriptorHasColors(int) () from /usr/lib/x86_64-linux-gnu/libbcc.so.0#2 0x00007ffff45cabb8 in clang::driver::tools::Clang::ConstructJob(clang::driver::Compilation&amp;, clang::driver::JobAction const&amp;, clang::driver::InputInfo const&amp;, llvm::SmallVector&lt;clang::driver::InputInfo, 4u&gt; const&amp;, llvm::opt::ArgList const&amp;, char const*) const () from /usr/lib/x86_64-linux-gnu/libbcc.so.0#3 0x00007ffff456ffa5 in clang::driver::Driver::BuildJobsForAction(clang::driver::Compilation&amp;, clang::driver::Action const*, clang::driver::ToolChain const*, char const*, bool, bool, char const*, clang::driver::InputInfo&amp;) const () from /usr/lib/x86_64-linux-gnu/libbcc.so.0#4 0x00007ffff4570501 in clang::driver::Driver::BuildJobs(clang::driver::Compilation&amp;) const () from /usr/lib/x86_64-linux-gnu/libbcc.so.0#5 0x00007ffff457224a in clang::driver::Driver::BuildCompilation(llvm::ArrayRef&lt;char const*&gt;) () from /usr/lib/x86_64-linux-gnu/libbcc.so.0#6 0x00007ffff4396cda in ebpf::ClangLoader::parse(std::unique_ptr&lt;llvm::Module, std::default_delete&lt;llvm::Module&gt; &gt;*, std::unique_ptr&lt;std::vector&lt;ebpf::TableDesc, std::allocator&lt;ebpf::TableDesc&gt; &gt;, std::default_delete&lt;std::vector&lt;ebpf::TableDesc, std::allocator&lt;ebpf::TableDesc&gt; &gt; &gt; &gt;*, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;, bool, char const**, int) () from /usr/lib/x86_64-linux-gnu/libbcc.so.0#7 0x00007ffff4344314 in ebpf::BPFModule::load_cfile(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;, bool, char const**, int) () from /usr/lib/x86_64-linux-gnu/libbcc.so.0#8 0x00007ffff4349e5e in ebpf::BPFModule::load_string(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;, char const**, int) () from /usr/lib/x86_64-linux-gnu/libbcc.so.0#9 0x00007ffff43430c8 in bpf_module_create_c_from_string () from /usr/lib/x86_64-linux-gnu/libbcc.so.0#10 0x00007ffff690ae40 in ffi_call_unix64 () from /usr/lib/x86_64-linux-gnu/libffi.so.6#11 0x00007ffff690a8ab in ffi_call () from /usr/lib/x86_64-linux-gnu/libffi.so.6#12 0x00007ffff6b1a68c in _ctypes_callproc () from /usr/lib/python2.7/lib-dynload/_ctypes.x86_64-linux-gnu.so#13 0x00007ffff6b1ed82 in ?? () from /usr/lib/python2.7/lib-dynload/_ctypes.x86_64-linux-gnu.so#14 0x00000000004b1153 in PyObject_Call ()#15 0x00000000004ca5ca in PyEval_EvalFrameEx ()#16 0x00000000004c2e05 in PyEval_EvalCodeEx ()#17 0x00000000004def08 in ?? ()#18 0x00000000004b1153 in PyObject_Call ()#19 0x00000000004f4c3e in ?? ()#20 0x00000000004b1153 in PyObject_Call ()#21 0x00000000004f49b7 in ?? ()#22 0x00000000004b6e2c in ?? ()#23 0x00000000004b1153 in PyObject_Call ()#24 0x00000000004ca5ca in PyEval_EvalFrameEx ()#25 0x00000000004c2e05 in PyEval_EvalCodeEx ()#26 0x00000000004def08 in ?? ()#27 0x00000000004b1153 in PyObject_Call ()#28 0x00000000004c73ec in PyEval_EvalFrameEx ()#29 0x00000000004c2e05 in PyEval_EvalCodeEx ()#30 0x00000000004caf42 in PyEval_EvalFrameEx ()#31 0x00000000004c2e05 in PyEval_EvalCodeEx ()#32 0x00000000004c2ba9 in PyEval_EvalCode ()#33 0x00000000004f20ef in ?? ()#34 0x00000000004eca72 in PyRun_FileExFlags ()#35 0x00000000004eb1f1 in PyRun_SimpleFileExFlags ()#36 0x000000000049e18a in Py_Main ()#37 0x00007ffff7811830 in __libc_start_main (main=0x49daf0 &lt;main&gt;, argc=2, argv=0x7fffffffdfb8, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdfa8) at ../csu/libc-start.c:291#38 0x000000000049da19 in _start () 唔……这回有更多信息了。set_curterm 是被 llvm::sys::Process::FileDescriptorHasColors() 调用的，llvm 编译器有问题？ 十八 · 外部工具：再次使用 cscope这回，我们需要使用 cscope 看看 llvm 的代码。FileDescriptorHasColors 函数是酱婶的。 123456static bool terminalHasColors(int fd) &#123;[...] // Now extract the structure allocated by setupterm and free its memory // through a really silly dance. struct term *termp = set_curterm((struct term *)nullptr); (void)del_curterm(termp); // Drop any errors here. 在早先的版本里，该函数是这样定义的。 1234567891011static bool terminalHasColors() &#123; if (const char *term = std::getenv("TERM")) &#123; // Most modern terminals support ANSI escape sequences for colors. // We could check terminfo, or have a list of known terms that support // colors, but that would be overkill. // The user can always ask for no colors by setting TERM to dumb, or // using a commandline flag. return strcmp(term, "dumb") != 0; &#125; return false;&#125; 给 set_curterm 传入 nullptr 着实是个坏主意。 十九 · 复写内存为了确定嫌疑，同时试着看看有没有可能的临时解决方案，我会尝试在异常调用 set_curterm 时复写修改内存。 首先，我们在 GDB 里跟踪程序，并在 set_curterm 处设置断点，直到调用它时传入了 0x0 作为参数。 1234567891011121314151617181920212223242526272829# gdb `which python`GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1[...](gdb) b set_curtermFunction "set_curterm" not defined.Make breakpoint pending on future shared library load? (y or [n]) yBreakpoint 1 (set_curterm) pending.(gdb) r cachetop.pyStarting program: /usr/bin/python cachetop.py[Thread debugging using libthread_db enabled]Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".Breakpoint 1, set_curterm (termp=termp@entry=0xa43150) at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/tinfo/lib_cur_term.c:8080 &#123;(gdb) cContinuing.Breakpoint 1, set_curterm (termp=termp@entry=0xab5870) at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/tinfo/lib_cur_term.c:8080 &#123;(gdb) cContinuing.Breakpoint 1, set_curterm (termp=termp@entry=0xbecb90) at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/tinfo/lib_cur_term.c:8080 &#123;(gdb) cContinuing.Breakpoint 1, set_curterm (termp=0x0) at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/tinfo/lib_cur_term.c:8080 &#123; 此时，我要使用 set 命令，复写相关的内存：使用之前传入 set_curterm 并正确执行的参数 0xbecb90 替代 0x0——当然，希望这一地址仍旧是合法的。 警告，复写内存是十分危险的！GDB 不会向你确认，「你确定吗」。如果你搞错了，或者输入时手滑了，那么进程就会崩溃。好一点的情况，进程当时就崩溃了。糟糕的情况，可能在如果按时间后才崩溃，而谁也不知道是怎么了。 此处，我是在一台试验用机器上进行调试。因为没有敏感数据，所以我冒险一试。此处，我将用 p/x 以十六进制的形式打印寄存器 %rdi 中的内容，并用 set 命令将其设置为之前可用的值，并检查寄存器状态。 123456789101112131415161718192021222324252627282930(gdb) p/x $rdi$1 = 0x0(gdb) set $rdi=0xbecb90(gdb) p/x $rdi$2 = 0xbecb90(gdb) i rrax 0x100 256rbx 0x1 1rcx 0xe71 3697rdx 0x0 0rsi 0x7ffff5dd45d3 140737318307283rdi 0xbecb90 12503952rbp 0x100 0x100rsp 0x7fffffffa5b8 0x7fffffffa5b8r8 0xbf0050 12517456r9 0x1999999999999999 1844674407370955161r10 0xbf0040 12517440r11 0x7ffff7bb4b78 140737349634936r12 0xbecb70 12503920r13 0xbeaea0 12496544r14 0x7fffffffa9a0 140737488333216r15 0x7fffffffa8a0 140737488332960rip 0x7ffff3c76a80 0x7ffff3c76a80 &lt;set_curterm&gt;eflags 0x246 [ PF ZF IF ]cs 0x33 51ss 0x2b 43ds 0x0 0es 0x0 0fs 0x0 0gs 0x0 0 （当然，因为有调试信息，所以我本没必要直接操作寄存器 %rdi 的值，我可以直接设置函数参数 termp 的值） 现在 %rdi 的值已经更新，其他寄存器看上去也没什么问题。于是我们让程序继续执行。 12345(gdb) cContinuing.Breakpoint 1, set_curterm (termp=termp@entry=0x0) at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/tinfo/lib_cur_term.c:8080 &#123; 赞！当前对 set_curterm 的调用通过了，没有引发段错误。不过，下一次调用 set_curterm 又传入了 0x0，我们故技重施。 12345678(gdb) set $rdi=0xbecb90(gdb) cContinuing.warning: JITed object file architecture unknown is not compatible with target architecture i386:x86-64.Program received signal SIGSEGV, Segmentation fault.0x00007ffff34ad411 in ClrBlank (win=0xaea060) at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/tty/tty_update.c:11291129 if (back_color_erase) 啊哈！这次修改内存得到了另一个段错误。不过，虽然如此，当前的问题至少是解决了。 二十 · 条件断点在之前的章节中，我不得不连续使用 3 次 continue 以便到达我真正感兴趣的那次函数调用。如果相关函数被调用了上百次，那么我会考虑使用条件断点。以下是一个示例。 首先，我会如常启动程序并为 set_curterm 设置断点。 1234567891011121314# gdb `which python`GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1[...](gdb) b set_curtermFunction "set_curterm" not defined.Make breakpoint pending on future shared library load? (y or [n]) yBreakpoint 1 (set_curterm) pending.(gdb) r cachetop.pyStarting program: /usr/bin/python cachetop.py[Thread debugging using libthread_db enabled]Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".Breakpoint 1, set_curterm (termp=termp@entry=0xa43150) at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/tinfo/lib_cur_term.c:8080 &#123; 现在，我要将断点 1 转换为条件断点，使其只在 %rdi 的值为 0x0 时生效。 1234567891011(gdb) cond 1 $rdi==0x0(gdb) i bNum Type Disp Enb Address What1 breakpoint keep y 0x00007ffff3c76a80 in set_curterm at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/tinfo/lib_cur_term.c:80 stop only if $rdi==0x0 breakpoint already hit 1 time(gdb) cContinuing.Breakpoint 1, set_curterm (termp=0x0) at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/tinfo/lib_cur_term.c:80(gdb) 吼啊！通过使用 cond (conditional)，我将断点 1 设置为条件断点。因此，当断点 1 下一次生效时，就是 set_curterm 接受的第一个参数值为 0x0 的时候。此外，我用了 i b (info breakpoints) 列出了所有断点的信息。 这里需要考虑，为什么我不在设置断点后的第一时间就将其设置为条件断点。这是因为，我发现对于程序尚未执行时设置的被延迟的断点来说，这些条件不会生效——至少当前的 GDB 版本是这样。（也有可能是我搞错了） 廿一 · 直接返回我也曾尝试了另一个和复写内存类似的方案。不过，这次我不打算修改内存中的数据，而是修改指令。 警告：先前的警告在此处同样适用。 我将如先前一样，停在 set_curterm 的 0x0 调用处，而后适用 GDB 的 ret (return) 命令跳过函数的执行，直接返回。此处的考量是，如果函数未执行，则全局变量 curterm 不会被设置为 0x0。 123456789101112131415[...](gdb) cContinuing.Breakpoint 1, set_curterm (termp=0x0) at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/tinfo/lib_cur_term.c:80(gdb) retMake set_curterm return now? (y or n) y#0 0x00007ffff5a44e75 in llvm::sys::Process::FileDescriptorHasColors(int) () from /usr/lib/x86_64-linux-gnu/libbcc.so.0(gdb) cContinuing.Program received signal SIGSEGV, Segmentation fault. _nc_free_termtype (ptr=ptr@entry=0x100) at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/tinfo/free_ttype.c:5252 FreeIfNeeded(ptr-&gt;str_table); 好嘛，进程又挂了……这是进程崩掉之后的状态。 度过更多代码之后，我决定再试试看。我想试着连续执行两次 ret，以免 set_curterm 的调用者被不完整的调用搞坏了。再次强调：这只是一个非常 hacky 的实验，在生产环境中请慎重执行。 12345678910111213[...](gdb) cContinuing.Breakpoint 1, set_curterm (termp=0x0) at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/tinfo/lib_cur_term.c:8080 &#123;(gdb) retMake set_curterm return now? (y or n) y#0 0x00007ffff5a44e75 in llvm::sys::Process::FileDescriptorHasColors(int) () from /usr/lib/x86_64-linux-gnu/libbcc.so.0(gdb) retMake selected stack frame return now? (y or n) y#0 0x00007ffff45cabb8 in clang::driver::tools::Clang::ConstructJob(clang::driver::Compilation&amp;, clang::driver::JobAction const&amp;, clang::driver::InputInfo const&amp;, llvm::SmallVector const&amp;, llvm::opt::ArgList const&amp;, char const*) const () from /usr/lib/x86_64-linux-gnu/libbcc.so.0(gdb) c 这回，整个屏幕都白了，然后停住……之后显示出了如下结果。 12345678910111213141516171819202122232407:44:22 Buffers MB: 61 / Cached MB: 1246PID UID CMD HITS MISSES DIRTIES READ_HIT% WRITE_HIT% 2742 root systemd-logind 3 66 2 1.4% 95.7% 15836 root kworker/u30:1 7 0 1 85.7% 0.0% 2736 messageb dbus-daemon 8 66 2 8.1% 89.2% 1 root systemd 15 0 0 100.0% 0.0% 2812 syslog rs:main Q:Reg 16 66 8 9.8% 80.5% 435 root systemd-journal 32 66 8 24.5% 67.3% 2740 root accounts-daemon 113 66 2 62.0% 36.9% 15847 root bash 160 0 1 99.4% 0.0% 15864 root lesspipe 306 0 2 99.3% 0.0% 15854 root bash 309 0 2 99.4% 0.0% 15856 root bash 309 0 2 99.4% 0.0% 15866 root bash 309 0 2 99.4% 0.0% 15867 root bash 309 0 2 99.4% 0.0% 15860 root bash 313 0 2 99.4% 0.0% 15868 root bash 341 0 2 99.4% 0.0% 15858 root uname 452 0 2 99.6% 0.0% 15858 root bash 453 0 2 99.6% 0.0% 15866 root dircolors 464 0 2 99.6% 0.0% 15861 root basename 465 0 2 99.6% 0.0% 15864 root dirname 468 0 2 99.6% 0.0% 15856 root ls 476 0 2 99.6% 0.0%[...] 帅！炸！搞定啦！ 廿二 · 更好的方案我将调试过程的结果提交在 github 上。这是因为，一方面 BPF 的首席工程师 Alexei Starovoitov 也是 llvm 方面的专家，另一方面这个问题的根源似乎是 llvm 的一个 bug。当我在把指令和数据搞得乱七八糟时，他建议我在编译 bcc 时加入 llvm 的参数 -fno-color-diagnostics 即可绕过这一问题。搞定！这确实能解决问题。因此我将其加入了 bcc 的代码库作为暂时的解决方案，并期待 llvm 解决这个 bug。 廿三 · 关于 Python 的环境至此，我们已经解决了问题。不过，（译注：有强迫症的）你可能还想要让整个调用栈看起来完好。 为此，你需要安装 python-dbg 软件包。 12345678910111213# apt-get install -y python-dbgReading package lists... Done[...]The following additional packages will be installed: libpython-dbg libpython2.7-dbg python2.7-dbgSuggested packages: python2.7-gdbm-dbg python2.7-tk-dbg python-gdbm-dbg python-tk-dbgThe following NEW packages will be installed: libpython-dbg libpython2.7-dbg python-dbg python2.7-dbg0 upgraded, 4 newly installed, 0 to remove and 20 not upgraded.Need to get 11.9 MB of archives.After this operation, 36.4 MB of additional disk space will be used.[...] 此时，再打开 GDB 看看调用栈。 12345678910111213141516171819202122232425262728293031323334353637# gdb `which python` /var/cores/core.python.30520GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1[...]Reading symbols from /usr/bin/python...Reading symbols from /usr/lib/debug/.build-id/4e/a0539215b2a9e32602f81c90240874132c1a54.debug...done.[...](gdb) bt#0 ClrBlank (win=0x1993060) at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/tty/tty_update.c:1129#1 ClrUpdate () at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/tty/tty_update.c:1147#2 doupdate () at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/tty/tty_update.c:1010#3 0x00007f0a37aa07e6 in wrefresh (win=win@entry=0x1993060) at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/base/lib_refresh.c:65#4 0x00007f0a37a99499 in recur_wrefresh (win=win@entry=0x1993060) at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/base/lib_getch.c:384#5 0x00007f0a37a99616 in _nc_wgetch (win=win@entry=0x1993060, result=result@entry=0x7ffd33d93e24, use_meta=1) at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/base/lib_getch.c:491#6 0x00007f0a37a9a325 in wgetch (win=0x1993060) at /build/ncurses-pKZ1BN/ncurses-6.0+20160213/ncurses/base/lib_getch.c:672#7 0x00007f0a37cc6ec3 in PyCursesWindow_GetCh.lto_priv.109 (self=0x7f0a3c57b198, args=()) at /build/python2.7-HpIZBG/python2.7-2.7.11/Modules/_cursesmodule.c:853#8 0x00000000004c4d5a in call_function (oparg=&lt;optimized out&gt;, pp_stack=0x7ffd33d93f30) at ../Python/ceval.c:4350#9 PyEval_EvalFrameEx () at ../Python/ceval.c:2987#10 0x00000000004c2e05 in PyEval_EvalCodeEx () at ../Python/ceval.c:3582#11 0x00000000004def08 in function_call.lto_priv () at ../Objects/funcobject.c:523#12 0x00000000004b1153 in PyObject_Call () at ../Objects/abstract.c:2546#13 0x00000000004c73ec in ext_do_call (nk=0, na=&lt;optimized out&gt;, flags=&lt;optimized out&gt;, pp_stack=0x7ffd33d941e8, func=&lt;function at remote 0x7f0a37edcc80&gt;) at ../Python/ceval.c:4662#14 PyEval_EvalFrameEx () at ../Python/ceval.c:3026#15 0x00000000004c2e05 in PyEval_EvalCodeEx () at ../Python/ceval.c:3582#16 0x00000000004caf42 in fast_function (nk=0, na=&lt;optimized out&gt;, n=&lt;optimized out&gt;, pp_stack=0x7ffd33d943f0, func=&lt;function at remote 0x7f0a38039140&gt;) at ../Python/ceval.c:4445#17 call_function (oparg=&lt;optimized out&gt;, pp_stack=0x7ffd33d943f0) at ../Python/ceval.c:4370#18 PyEval_EvalFrameEx () at ../Python/ceval.c:2987#19 0x00000000004c2e05 in PyEval_EvalCodeEx () at ../Python/ceval.c:3582#20 0x00000000004c2ba9 in PyEval_EvalCode (co=&lt;optimized out&gt;, globals=&lt;optimized out&gt;, locals=&lt;optimized out&gt;) at ../Python/ceval.c:669#21 0x00000000004f20ef in run_mod.lto_priv () at ../Python/pythonrun.c:1376#22 0x00000000004eca72 in PyRun_FileExFlags () at ../Python/pythonrun.c:1362#23 0x00000000004eb1f1 in PyRun_SimpleFileExFlags () at ../Python/pythonrun.c:948#24 0x000000000049e18a in Py_Main () at ../Modules/main.c:640#25 0x00007f0a3be10830 in __libc_start_main (main=0x49daf0 &lt;main&gt;, argc=2, argv=0x7ffd33d94838, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7ffd33d94828) at ../csu/libc-start.c:291#26 0x000000000049da19 in _start () 此时，所有的 ?? 都不见了，然而对解决我们的问题并没有什么 X 用…… 此外，Python 调试软件包还加强了 GDB 的功能。我们现在可以看看 Python 的调用栈。 12345678(gdb) py-btTraceback (most recent call first): File "./cachetop.py", line 188, in handle_loop s = stdscr.getch() File "/usr/lib/python2.7/curses/wrapper.py", line 43, in wrapper return func(stdscr, *args, **kwds) File "./cachetop.py", line 260, in curses.wrapper(handle_loop, args) 以及，我们可以看看 Python 代码是怎样的。 123456789101112(gdb) py-list 183 b.attach_kprobe(event="mark_buffer_dirty", fn_name="do_count") 184 185 exiting = 0 186 187 while 1:&gt;188 s = stdscr.getch() 189 if s == ord('q'): 190 exiting = 1 191 elif s == ord('r'): 192 sort_reverse = not sort_reverse 193 elif s == ord('&lt;'): 这能指出，在我们的 Python 代码中，究竟是那一行触发了段错误。这看起来非常棒！ 之前我们在回溯调用栈时遇到的问题，其原因在于我们看到了 Python 内部在执行的方法（methods），但却看不到对应方法的符号。如果你在调试别的语言，类似的问题取决于它的编译选项和运行环境，以及执行代码是如何结束的。如果你在网上检索「语言名 GDB」，你可能会找到类似 python-dbg 这样的扩展。如果没有的话，坏消息是你必须自己写这样的软件包，但好消息是这样做是可行的。如果你是在调试 Python，那么请在网上检索「add new GDB commands in Pyhon」。 廿四 · 更多……看起来，我似乎是要写一个完整的 GDB 指南，但显然我不是：GDB 还有很多我没讲到的东西。你可以在 GDB 中使用 help 命令，分门别类查看 GDB 的其他功能。 123456789101112131415161718192021(gdb) helpList of classes of commands:aliases -- Aliases of other commandsbreakpoints -- Making program stop at certain pointsdata -- Examining datafiles -- Specifying and examining filesinternals -- Maintenance commandsobscure -- Obscure featuresrunning -- Running the programstack -- Examining the stackstatus -- Status inquiriessupport -- Support facilitiestracepoints -- Tracing of program execution without stopping the programuser-defined -- User-defined commandsType "help" followed by a class name for a list of commands in that class.Type "help all" for the list of all commands.Type "help" followed by command name for full documentation.Type "apropos word" to search for commands related to "word".Command name abbreviations are allowed if unambiguous. 对于具体某个命令来说，你也可以用 help 命令查看具体用法。例如说，你可以查看所有和 breakpoints 相关的命令。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798(gdb) help breakpointsMaking program stop at certain points.List of commands:awatch -- Set a watchpoint for an expressionbreak -- Set breakpoint at specified locationbreak-range -- Set a breakpoint for an address rangecatch -- Set catchpoints to catch eventscatch assert -- Catch failed Ada assertionscatch catch -- Catch an exceptioncatch exception -- Catch Ada exceptionscatch exec -- Catch calls to execcatch fork -- Catch calls to forkcatch load -- Catch loads of shared librariescatch rethrow -- Catch an exceptioncatch signal -- Catch signals by their names and/or numberscatch syscall -- Catch system calls by their names and/or numberscatch throw -- Catch an exceptioncatch unload -- Catch unloads of shared librariescatch vfork -- Catch calls to vforkclear -- Clear breakpoint at specified locationcommands -- Set commands to be executed when a breakpoint is hitcondition -- Specify breakpoint number N to break only if COND is truedelete -- Delete some breakpoints or auto-display expressionsdelete bookmark -- Delete a bookmark from the bookmark listdelete breakpoints -- Delete some breakpoints or auto-display expressionsdelete checkpoint -- Delete a checkpoint (experimental)delete display -- Cancel some expressions to be displayed when program stopsdelete mem -- Delete memory regiondelete tracepoints -- Delete specified tracepointsdelete tvariable -- Delete one or more trace state variablesdisable -- Disable some breakpointsdisable breakpoints -- Disable some breakpointsdisable display -- Disable some expressions to be displayed when program stopsdisable frame-filter -- GDB command to disable the specified frame-filterdisable mem -- Disable memory regiondisable pretty-printer -- GDB command to disable the specified pretty-printerdisable probes -- Disable probesdisable tracepoints -- Disable specified tracepointsdisable type-printer -- GDB command to disable the specified type-printerdisable unwinder -- GDB command to disable the specified unwinderdisable xmethod -- GDB command to disable a specified (group of) xmethod(s)dprintf -- Set a dynamic printf at specified locationenable -- Enable some breakpointsenable breakpoints -- Enable some breakpointsenable breakpoints count -- Enable breakpoints for COUNT hitsenable breakpoints delete -- Enable breakpoints and delete when hitenable breakpoints once -- Enable breakpoints for one hitenable count -- Enable breakpoints for COUNT hitsenable delete -- Enable breakpoints and delete when hitenable display -- Enable some expressions to be displayed when program stopsenable frame-filter -- GDB command to disable the specified frame-filterenable mem -- Enable memory regionenable once -- Enable breakpoints for one hitenable pretty-printer -- GDB command to enable the specified pretty-printerenable probes -- Enable probesenable tracepoints -- Enable specified tracepointsenable type-printer -- GDB command to enable the specified type printerenable unwinder -- GDB command to enable unwindersenable xmethod -- GDB command to enable a specified (group of) xmethod(s)ftrace -- Set a fast tracepoint at specified locationhbreak -- Set a hardware assisted breakpointignore -- Set ignore-count of breakpoint number N to COUNTrbreak -- Set a breakpoint for all functions matching REGEXPrwatch -- Set a read watchpoint for an expressionsave -- Save breakpoint definitions as a scriptsave breakpoints -- Save current breakpoint definitions as a scriptsave gdb-index -- Save a gdb-index filesave tracepoints -- Save current tracepoint definitions as a scriptskip -- Ignore a function while steppingskip delete -- Delete skip entriesskip disable -- Disable skip entriesskip enable -- Enable skip entriesskip file -- Ignore a file while steppingskip function -- Ignore a function while steppingstrace -- Set a static tracepoint at location or markertbreak -- Set a temporary breakpointtcatch -- Set temporary catchpoints to catch eventstcatch assert -- Catch failed Ada assertionstcatch catch -- Catch an exceptiontcatch exception -- Catch Ada exceptionstcatch exec -- Catch calls to exectcatch fork -- Catch calls to forktcatch load -- Catch loads of shared librariestcatch rethrow -- Catch an exceptiontcatch signal -- Catch signals by their names and/or numberstcatch syscall -- Catch system calls by their names and/or numberstcatch throw -- Catch an exceptiontcatch unload -- Catch unloads of shared librariestcatch vfork -- Catch calls to vforkthbreak -- Set a temporary hardware assisted breakpointtrace -- Set a tracepoint at specified locationwatch -- Set a watchpoint for an expressionType "help" followed by command name for full documentation.Type "apropos word" to search for commands related to "word".Command name abbreviations are allowed if unambiguous. 显而易见，GDB 还有很多功能，而我仅只是在解决问题的过程中使用了其中很小一部分。 廿五 · 结语好吧，这里我遇到的问题比较恶心：这是一个由 LLVM 的 bug 经由 ncurses 最终导致 Python 程序崩溃的例子。不过，解决问题过程中，我用到的命令和使用他们的流程基本就是调试查错的基本流程：查看调用栈、检查寄存器、设置断点、单步调试、浏览代码。 当我在几年前第一次使用 GDB 时，我真的不怎么喜欢它。它看起来又笨拙又难用。然而，GDB 已经改进了很多，同时也有了一些 GDB 调试查错的技巧之后，现在我认为它是一个强大的现代调试器。不同调试器有不同的技能，但是 GDB 必是其中最强大的文本调试器——当然 lldb 正在迎头赶上。 在此，我希望所有查找 GDB 调试范例的人会从我的例子和警示中学到东西。当然，以后有机会我也会分享更多关于 GDB 的经验——尤其是诸如 JAVA 的运行时问题。 哦对了，退出 GDB 的方法是 q (quit) 命令。（译者注：你也可以使用 Ctrl + D 来退出 GDB 调试器。）]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>GDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 中的 mutable 关键字]]></title>
    <url>%2F2017%2F05%2F25%2Fthe-mutable-keyword-in-Cxx%2F</url>
    <content type="text"><![CDATA[此篇介绍 C++ 中的 mutable 关键字。 类中的 mutablemutable 从字面意思上来说，是「可变的」之意。 若是要「顾名思义」，那么这个关键词的含义就有些意思了。显然，「可变的」只能用来形容变量，而不可能是「函数」或者「类」本身。然而，既然是「变量」，那么它本来就是可变的，也没有必要使用 mutable 来修饰。那么，mutable 就只能用来形容某种不变的东西了。 C++ 中，不可变的变量，称之为常量，使用 const 来修饰。然而，若是 const mutable 联用，未免让人摸不着头脑——到底是可变还是不可变呢？ 事实上，mutable 是用来修饰一个 const 示例的部分可变的数据成员的。如果要说得更清晰一点，就是说 mutable 的出现，将 C++ 中的 const 的概念分成了两种。 二进制层面的 const，也就是「绝对的」常量，在任何情况下都不可修改（除非用 const_cast）。 引入 mutable 之后，C++ 可以有逻辑层面的 const，也就是对一个常量实例来说，从外部观察，它是常量而不可修改；但是内部可以有非常量的状态。 当然，所谓的「逻辑 const」，在 C++ 标准中并没有这一称呼。这只是为了方便理解，而创造出来的名词。 显而易见，mutable 只能用来修饰类的数据成员；而被 mutable 修饰的数据成员，可以在 const 成员函数中修改。 这里举一个例子，展现这类情形。 123456789101112131415161718192021class HashTable &#123; public: //... std::string lookup(const std::string&amp; key) const &#123; if (key == last_key_) &#123; return last_value_; &#125; std::string value&#123;this-&gt;lookupInternal(key)&#125;; last_key_ = key; last_value_ = value; return value; &#125; private: mutable std::string last_key_ mutable std::string last_value_;&#125;; 这里，我们呈现了一个哈希表的部分实现。显然，对哈希表的查询操作，在逻辑上不应该修改哈希表本身。因此，HashTable::lookup 是一个 const 成员函数。在 HashTable::lookup 中，我们使用了 last_key_ 和 last_value_ 实现了一个简单的「缓存」逻辑。当传入的 key 与前次查询的 last_key_ 一致时，直接返回 last_value_；否则，则返回实际查询得到的 value 并更新 last_key_ 和 last_value_。 在这里，last_key_ 和 last_value_ 是 HashTable 的数据成员。按照一般的理解，const 成员函数是不允许修改数据成员的。但是，另一方面，last_key_ 和 last_value_ 从逻辑上说，修改它们的值，外部是无有感知的；因此也就不会破坏逻辑上的 const。为了解决这一矛盾，我们用 mutable 来修饰 last_key_ 和 last_value_，以便在 lookup 函数中更新缓存的键值。 Lambda 表达式中的 mutableC++11 引入了 Lambda 表达式，程序员可以凭此创建匿名函数。在 Lambda 表达式的设计中，捕获变量有几种方式；其中按值捕获（Caputre by Value）的方式不允许程序员在 Lambda 函数的函数体中修改捕获的变量。而以 mutable 修饰 Lambda 函数，则可以打破这种限制。 123int x&#123;0&#125;;auto f1 = [=]() mutable &#123;x = 42;&#125;; // okay, 创建了一个函数类型的实例auto f2 = [=]() &#123;x = 42;&#125;; // error, 不允许修改按值捕获的外部变量的值 需要注意的是，上述 f1 的函数体中，虽然我们给 x 做了赋值操作，但是这一操作仅只在函数内部生效——即，实际是给拷贝至函数内部的 x 进行赋值——而外部的 x 的值依旧是 0。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Mutable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 VIM 中切换横竖分屏]]></title>
    <url>%2F2017%2F05%2F24%2Fswitch-between-horizon-and-vertical-split-in-VIM%2F</url>
    <content type="text"><![CDATA[我们都知道，以 vimdiff 打开多个文件时，VIM 默认会以竖直分屏的方式将文件之间的差异呈现出来。而若以打开文件，我们希望对比缓冲区中的文件和磁盘上另一个文件之间的差异时，则可以在 VIM 编辑状态中，执行 VIM 命令 diffsplit &lt;filename&gt;。不过，正如 split 会以水平分屏的方式打开一个新的文件一样，diffsplit 也是以水平分屏的方式呈现两个文件的差异的。 diffsplit 的默认呈现方式，对大多数人来说，想必都是不友好的——不方便对比两个文件之间的差异。若是不想退出 VIM，又希望文件差异以竖直分屏呈现的话，就需要考虑如何切换横竖分屏了。 VIM 提供了两个快捷键，用于调整当前缓冲区在分屏模式下的位置。 Ctrl + w, Shift + h: 将当前缓冲区置于终端最左侧，并占据整个终端高度； Ctrl + w, Shift + k: 将当前缓冲区置于终端最顶部，并占据整个终端宽度。 使用这两个快捷键，我们就能在 VIM 中切换横竖分屏了。]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>VIM</tag>
        <tag>Split</tag>
        <tag>Vertical</tag>
        <tag>Horizon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使 LaTeX 文稿中的 URL 正确换行]]></title>
    <url>%2F2017%2F05%2F17%2Fhelp-the-url-command-from-hyperref-to-break-at-line-wrapping-point%2F</url>
    <content type="text"><![CDATA[大部分稍有经验的 LaTeX 用户，都知道使用 \url 命令在 LaTeX 文稿中插入 URL。更资深一些的用户，会使用 hyperref 宏包，而不是过时的 url 宏包来处理。 然而，不论是否资深，大多数用户应该都有遇到过 LaTeX 无法正确对 URL 进行折行的问题。此篇介绍一下如何处理。 TeX 对于断行和分页，是有专门的算法处理的。通常而言，如果一个单词（一整个 \url 可以看做是一个单词），TeX 不知道从何处进行分词，那么 TeX 就不会在这个单词上断行。对于很长的单词，比如一个 \url，如果 TeX 不能在此处断行，而它又处于某一行的末尾，就很容易出现 overful box。 因此，本质上，这个问题需要让 \url 命令，知道我们允许在何处断行。 hyperref 宏包提供了两个宏，\UrlBreaks 以及 \UrlBigBreaks，用于告知 TeX，用户允许在何处截断 URL 以便换行。二者有一些细微的差别，但此处按下不表——大多数读者只需要使用 \UrlBreaks 即可。 123456789101112131415161718\documentclass&#123;article&#125;\usepackage&#123;hyperref&#125;\makeatletter\def\UrlAlphabet&#123;% \do\a\do\b\do\c\do\d\do\e\do\f\do\g\do\h\do\i\do\j% \do\k\do\l\do\m\do\n\do\o\do\p\do\q\do\r\do\s\do\t% \do\u\do\v\do\w\do\x\do\y\do\z\do\A\do\B\do\C\do\D% \do\E\do\F\do\G\do\H\do\I\do\J\do\K\do\L\do\M\do\N% \do\O\do\P\do\Q\do\R\do\S\do\T\do\U\do\V\do\W\do\X% \do\Y\do\Z&#125;\def\UrlDigits&#123;\do\1\do\2\do\3\do\4\do\5\do\6\do\7\do\8\do\9\do\0&#125;\g@addto@macro&#123;\UrlBreaks&#125;&#123;\UrlOrds&#125;\g@addto@macro&#123;\UrlBreaks&#125;&#123;\UrlAlphabet&#125;\g@addto@macro&#123;\UrlBreaks&#125;&#123;\UrlDigits&#125;\makeatother\begin&#123;document&#125;\url&#123;http://foo.bar.com/documentclassarticleusepackagehyperrefbegindocumenturlenddocument&#125;\end&#123;document&#125; 在这里，\UrlOrds 里记录了一些特殊符号（例如 - 和 _），而 \UrlAlphabet 记录了 26 个英文字母的大小写，\UrlDigits 则记录了 10 个阿拉伯数字。 而后，我们使用 LaTeX 内核提供的 \g@addto@marco，依次将上述三个宏的内容，续接在 \UrlBreaks 之后。这就是说，我们允许在上述所有字符处断行。 如此，编译出的结果也是符合预期的。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>hyperref</tag>
        <tag>linebreak</tag>
        <tag>URL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员的自我修养（五）：C++ 多线程编程初步]]></title>
    <url>%2F2017%2F05%2F16%2Ffirst-step-on-multithread-programming-of-cxx%2F</url>
    <content type="text"><![CDATA[这是系列文章的第五篇。 这篇文章里，我们介绍如何使用 C++ 11 的标准库，进行多线程编程。 Babystep好吧，不管学什么编程语言，「Hello world!」总是不会少的。虽然在 C++ 中进行多线程编程依然是在使用 C++，但是迈出 babystep 总是很重要的。让我们从 Hello multithread! 开始。 首先，作为对比，我们写出 Hello world! 程序。 hello_world.cpp12345#inlcude &lt;iostream&gt;int main() &#123; std::cout &lt;&lt; "Hello world!" &lt;&lt; std::endl; return 0;&#125; 使用 C++ 11 的标准库，在程序中启动一个线程是很简单的。 hello_multithread.cpp12345678910111213#include &lt;iostream&gt;#include &lt;thread&gt; // 1.void greeting() &#123; // 2. std::cout &lt;&lt; "Hello multithread!" &lt;&lt; std::endl; return;&#125;int main() &#123; std::thread t&#123;greeting&#125;; // 3. t.join(); // 4. return 0;&#125; 在编译它的时候，需要注意链接平台相关的线程库。比如在 Linux 上，需要链接 pthread 库。 123$ g++ --std=c++11 -pthread hello_multithread.cpp$ ./a.outHello multithread! 这份代码值得注意的地方有四点。 首先，我们引入了头文件 thread。在这个头文件中，C++ 11 提供了管理线程的类和函数。 之后，我们定义了一个无返回类型的函数 greeting，这个函数除了在标准输出流中打印一行文字之外什么也不做。 而后，我们定义了一个 std::thread 类型的变量 t，并用列表初始化的方式传入了 greeting 函数（的指针，参考这里），作为 std::thread 类构造函数的参数。传入的函数，会作为新启动的子线程的入口函数。也就是说，当子线程准备就绪之后，就会开始执行这个入口函数。 从 C++ 11 开始，推荐使用列表初始化的方式，构造类类型的变量。 最后，我们调用成员函数 t.join()，确保主线程在子线程退出之后才退出。 线程管理初步上面的 Babystep 中，我们已经介绍了 C++ 11 标准库中提供的设施，并以之启动了一个线程。当然，这个线程实在是太简单了，所以在性能上没有任何的价值。这一节，我们将介绍如何使用 C++ 11 标准库提供的设施，对线程进行基本的管理 线程函数首先需要说明的概念，是线程函数。 我们讲，任何事情都有个「开始」。对于整个程序来说，我们知道，每个程序都有一个入口。当程序被装载到内存，处于内核态完成一些初始化的工作之后，控制权就转交给程序入口，并以此为标志进入用户态。这是一个程序的开始。同样地，线程也需要有「开始」的地方。作为线程入口的函数，就是线程函数。 稍微思考一下，就不难发现，线程函数必须在启动线程之前，就准备好。这是因为，哪怕线程什么也不做——等待，也需要一条指令。因此，线程函数必须在线程启动之前准备好，并在线程初始化后立即执行。 类似地，当线程函数返回时，线程也就随之终止了。 启动线程在 Babystep 一节中，我们已经可以观察到：线程随着 std::thread 类型实例的创建而创建。C++ 11 的标准库，将创建线程和创建实例两个动作统一起来，对于 C++ 的程序员来说，线程就变成了如内存、文件一样的资源，由 C++ 提供统一的接口进行管理。同时，我们也已知晓，创建线程需指定线程函数。那么，根据线程函数的不同，在 C++ 中使用 std::thread 直接创建线程，大致有三种不同的方式。 12void do_some_work();std::thread wk_thread&#123;do_some_work&#125;; 仿照 Babystep 中的介绍，这是在 C++ 中创建线程最简单的例子。如同我们在指针一文中介绍的那样，当函数的名字被当做一个值来使用的时候，实际上使用的是函数的指针。因此，我们也可以显式地传入 &amp;do_some_work，作为 wk_thread 的构造参数。 除了普通的函数之外，可调用类型的实例也可以作为线程函数，创建线程。 123456789101112class ThreadTask &#123; private: size_t count_ = 0; public: explicit ThreadTask (size_t count) : count_(count) &#123;&#125; void operator()() const &#123; do_something(this-&gt;count_); &#125;&#125;;ThreadTask task&#123;42&#125;;std::thread wk_thread&#123;task&#125;; 对于可调用类型，这里有两件事情需要特别注意。 首先，尽管可调用类型的实例看起来和函数一样，但是它毕竟是一个类类型的对象。所以，在 wk_thread 构造时，task 会被拷贝到线程的存储空间，而后再开始执行。因此，ThreadTask 类必须做好足够的拷贝控制。 其次，若是在创建线程的时候，传入的是临时构造的实例，需要注意 C++ 的语法解析规则。这种情况下，推荐使用 C++ 的列表初始化。 12std::thread wk_thread(ThreadTask()); // 1std::thread wk_thread&#123;ThreadTask&#123;&#125;&#125;; // 2 在 (1) 处，作者的本意，是想构造一个 ThreadTask 实例，作为可调用对象作为 wk_thread 线程的线程函数。但实际上，指针一文介绍过，ThreadTask() 是一个函数指针的类型——这个函数没有参数 (void)，返回值的类型是 ThreadTask。因此，整个 (1) 会被 C++ 理解为一个函数声明：参数是一个函数指针（前述），返回类型是 std::thread。显而易见，这不是作者想要的。 我们说，构造函数和普通的函数是有一些不同的。构造函数执行完毕之后，就产生了一个可用的实例。产生这样误解的本质原因，是 std::thread 的构造函数也是函数，因而采用 () 接受参数列表；这样一来，从形式上构造函数就没有任何特殊性了。C++ 11 引入了列表初始化的概念，允许程序员以花括号代替圆括号，将参数传递给构造函数。这样一来，(2) 就没有歧义了。 C++ 11 引入了 lambda-表达式（或者你可以简单地称其为 lambda-函数）。在创建线程时，我们也可以将 lambda-表达式作为线程函数，传入 std::thread 的构造函数。 123std::thread wk_thread&#123;[]()&#123; do_something();&#125;&#125;; 线程结束的控制正如申请了内存，必须主动释放一样，对线程的管理也讲究有始有终。当线程启动之后，我们必须在 std::thread 实例销毁之前，显式地说明我们希望如何处理实例对应线程的结束状态。如果上述实例销毁之时，程序员尚未显式说明如何处理对应线程的结束状态，那么在上述实例的析构函数中，会调用 std::terminate() 函数，终止整个程序。 在主线程中，我们可以选择「接合 (join)」或者「分离 (detach)」产生的子线程。具体来说，就是对 std::thread 实例调用 join() 或者 detach() 成员函数。 12345678910void do_something();std::thread join_me&#123;do_something&#125;;std::thread detach_me&#123;do_something&#125;;if (join_me.joinable()) &#123; // 1 join_me.join();&#125;if (detach_me.joinable()) &#123; // 1 detach_me.detach();&#125; 在这里，不论是接合或是分离，我们都首先调用了 joinable() 成员函数。它在尚未决定接合/分离时，返回 true；而若已经决定了接合/分离（通过调用 join()/detach()），则返回 false。 如果选择接合子线程，则主线程会阻塞住，直到该子线程退出为止。这就好像将子线程尚未执行完的部分，接合在主线程的当前位置，而后顺序执行。 如果选择分离子线程，则主线程丧失对子线程的控制权，其控制权转交给 C++ 运行时库。这就引出了两个需要注意的地方 主线程结束之后，子线程可能仍在运行（因而可以作为守护线程）； 主线程结束伴随着资源销毁，需要保证子线程没有引用这些资源。 一个会引发错误的例子1234567891011121314151617struct func &#123; size_t&amp; i_ = 0; func(int&amp; i): i_(i) &#123;&#125; // 1 void operator()() &#123; for (size_t j&#123;0&#125;; j!= 1000000; ++j) &#123; do_something(i); // 2 &#125; &#125;&#125;;void bad_reference() &#123; size_t working&#123;42&#125;; func wk_func&#123;working&#125;; std::thread wk_thread&#123;wk_func&#125;; wk_thread.detach(); // 3 return; // 4&#125; 在这里，我们定义了一个可调用的类。在循环内，我们不断尝试对外部传来的引用 (1) 进行一些操作 (2)。然而，在分离子线程之后 (3)，子线程所依赖的外部引用，随着函数的退出而销毁 (4)。这样，子线程后续使用该引用 (2) 的行为就是未定义的了，这是非常危险的。 至此，关于线程结束的控制，你已经了解大半了。你应该已经知道必须要在 std::thread 实例销毁之前，决定接合或是分离相应的线程。并且你也应该知道，对于分离的线程，要保证其数据的完整性。一般来说，「你」所能做的事情，就到此为止了。但是，总有例外的情况，需要特别处理。 对于大多数程序员来说，可能甚少处理「异常」。很多程序员，会在代码里做「防御式」编程，以规避各种可能导致异常的可能。在一些情况下，这样做无可厚非。但是，不论如何，我们应该记住「任何代码都有可能发生异常」这一原则。特别地，运行在子线程里的代码，也有可能发生异常。如果子线程里扔出的异常，没有被任何调用者处理，那么这个异常最终会导致整个程序终止。又如果子线程里扔出的异常，调用者在处理时没有决定线程的接合或分离，那么 std::thread 的销毁很可能会绕过正常逻辑中的接合或分离的逻辑，从而调用 std::terminate() 终止整个进程。 我们在前作中讲到，对于可能发生资源泄漏的情况，我们可以考虑用 RAII 的思想，将资源封装在一个 handle 或者 guard 当中，从而防止资源泄漏。同时，前文也提到，线程也是一种资源。因此，我们可以考虑构造一个 ThreadGuard 来处理这种异常安全的问题。 123456789101112131415161718192021222324struct ThreadGuard &#123; private: std::thread&amp; t_; public: explicit ThreadGuard(std::thread&amp; t) : t_(t) &#123;&#125; ~ThreadGuard() &#123; if (this-&gt;t_.joinable()) &#123; // 1 this-&gt;t_.join(); // 2 &#125; &#125; ThreadGuard (const ThreadGuard&amp;) = delete; ThreadGuard&amp; operator=(const ThreadGuard&amp;) = delete;&#125;;void do_something();void show() &#123; std::thread wk_thread; // default constructed ThreadGuard g&#123;wk_thread&#125;; wk_thread = std::thread&#123;do_something&#125;; // 3 do_domething_in_current_thread(); return; // 3&#125; 这是一个典型的利用 RAII 保护资源的例子。不论 wk_thread 对应的线程如何退出 (3)，守卫变量 g 都会在声明周期结束是，帮助 wk_thread 确认结束状态 (1)(2)。 向线程函数传递参数前一节中提到，线程函数即是作为线程入口的函数。作为函数，它自然可以接受参数；只不过此前我们举的例子，都是无参数的函数。这一节介绍如何向线程函数传递参数。 首先我们要确认：在线程启动时，向线程函数传递参数是可行的。具体做法，是 向 std::thread 的构造函数传递参数，将参数拷贝进线程的内部存储空间； 而后，由线程构造函数，将参数传递给线程函数。 预先转换格式我们来看看，如何向线程函数传参。 12void demo(int, const std::string&amp;);std::thread demo_t&#123;demo, 42, "hello thread"&#125;; 这里，我们就新建了一个线程，它调用线程函数 demo(42, &quot;hello thread&quot;)。需要注意的是构造函数的第三个参数 &quot;hello thread&quot;， 首先，它作为 const char* 被拷贝进入线程内部； 而后，它被传递给 demo 作为第二个参数； 此时，由于 demo 的第二个参数类型为 const std::string&amp;，所以会发生类型转换。 在这里，被转换的是一个字符串常量，看上去没什么问题。但是，当替换 const char* 为 char* 时，就可能引发严重的后果。 123456789void demo(int, const std::string&amp;);void bad_buffer(const int param) &#123; char buffer[2014]; // 1 sprintf(buffer, "%i", param); std::thread wk_t(demo, 42, buffer); // 2 wk_t.detach(); return; // 3&#125; 同样地，buffer 是数组名 (1)，作为值使用时被当做指针 (2)，传入 std::thread 的构造函数。而后，在调用 demo 时，尝试转换为 std::string。若 bad_buffer 函数退出 (3) 于上述转换完成之前，那么就会产生一个未定义的行为（Undefined Behavior），这是非常危险的。 因此，关于线程函数传参的铁律是：必须在参数传递给线程构造之前，就转换好格式。 也需要准备好引用、右值等由于传参给 std::thread 的过程只是简单的拷贝，当线程函数需要引用或者移动语义的时候，也可能出现问题。 123456789void update(double weight, WeightedData&amp; data); // 1void bad_update(double weight) &#123; WeightedData data; std::thread wk_t(update, weight, data); // 2 t.join(); process(data); // 3 return;&#125; 代码的意图是通过引用 (1)，在子线程中更新 data 的权值 (2)。然而，由于 (2) 对 data 的处理是简单的拷贝，因此实际上线程函数得到的引用，是对「线程存储空间中的拷贝的引用」。于是，(3) 处理的 data，实际是未有更新的数据。这种情况未必会报错，但是却埋下了难以排查的隐患。 123456789void update(double weight, WeightedData&amp; data);void bad_update(double weight) &#123; WeightedData data; std::thread wk_t(update, weight, std::ref(data)/* #include &lt;functional&gt; */); t.join(); process(data); return;&#125; 类似地，对于一些不可拷贝的类型，我们需要准备好移动语义——在传参的时候，使用 std::move() 得到右值，传递给 std::thread 的构造函数。 以非静态成员函数为线程函数类的非静态成员函数也是函数，因而也可以作为线程函数使用。不过，相比一般的函数（包括静态成员函数），将其作为线程函数使用时，有两个特殊之处。 必须显式地使用函数指针，作为 std::thread 构造函数的第一个参数； 非静态成员函数的第一个参数，实际上是类实例的指针，在创建线程时，需要显式地填入这个参数。 1234567891011class Foo &#123; public: void bar(void);&#125;;void demo() &#123; Foo baz; std::thread temp_t&#123;&amp;Foo::bar, &amp;baz&#125;; temp_t.join(); return;&#125; 此外，必须说明的是，脱离了实例的非静态成员函数是没有意义的。因此，在将非静态成员函数作为线程函数时，必须保证对应的实例可用。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>C++11</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 TikZ 给版面着色]]></title>
    <url>%2F2017%2F05%2F14%2Fmake-text-area-colored-by-TikZ%2F</url>
    <content type="text"><![CDATA[有时候，我们需要给 LaTeX 添上一些背景颜色。讲道理，大多数情况，我们只需要给整个 paper 都染色就好了。此时，我们可以用前文提到的方法来实现。 1\watermark&#123;0&#125;&#123;1&#125;&#123;\tikz\fill[cyan] (0,0) rectangle (\paperwidth, \paperheight);&#125; 但是，若希望只针对特定的区域着色——比如只给版芯着色，就需要额外的讨论了。 TeX 的版面尺寸为了确定所需着色的区域，我们首先需要了解一下 TeX 的版面尺寸。在 LaTeX 中，我们可以使用 layout 宏包，打印当前的版面尺寸。 12345\documentclass&#123;book&#125;\usepackage&#123;layout&#125;\begin&#123;document&#125; \layout\end&#123;document&#125; 输出可见： 奇数页 偶数页 仔细观察不难发现，LaTeX 中四个基本的版面区域，都是由矩形框定的。而确定对角两点，就能确定一个矩形。我们以整个纸张的左下角为原点，试着来确定一下这四个区域的位置。 首先，LaTeX 区分奇数页和偶数页。对于奇偶页来说，它们的边距是不一样的。因此，我们有必要区分 \oddsidemargin 和 \evensidemargin。 12345678% RequirePackage ifoddpage\def\currentsidemargin&#123;% \ifoddpageoroneside \oddsidemargin \else \evensidemargin \fi&#125; 同理，对于奇偶页来说，边注放置的位置也是不一样的。因此，我们有必要确定边注区域左边线相对版芯左边线的位置。 12345678% RequirePackage ifoddpage\def\currentmarginoffset&#123;% \ifoddpageoroneside \textwidth + \marginsep \else -\marginsep - \marginparwidth \fi&#125; 这样一来，我们就统一了奇偶页的边距和边注的相对位置。 纸面 左下角：(0, 0) 右上角：(\paperwidth, \paperheight) 版芯 左下角：(1in + \hoffset + \currentsidemargin, \paperheight - 1in - \voffset - \topmargin - \headheight - \headsep - \textheight) 右上角：(1in + \hoffset + \currentsidemargin + \textwidth, \paperheight - 1in - \voffset - \topmargin - \headheight - \headsep) 页眉 左下角：(1in + \hoffset + \currentsidemargin, \paperheight - 1in - \voffset - \topmargin - \headheight) 右上角：(1in + \hoffset + \currentsidemargin + \textwidth, \paperheight - 1in - \voffset - \topmargin) 页脚 左下角：(1in + \hoffset + \currentsidemargin, \paperheight - 1in - \voffset - \topmargin - \headheight - \headsep - \textheight - \footskip) 右上角：(1in + \hoffset + \currentsidemargin + \textwidth, \paperheight - 1in - \voffset - \topmargin - \headheight - \headsep - \textheight - \footskip + \headheight) 边注区域 左下角：(1in + \hoffset + \currentsidemargin + \currentmarginoffset, \paperheight - 1in - \voffset - \topmargin - \headheight - \headsep - \textheight) 右上角：(1in + \hoffset + \currentsidemargin + \currentmarginoffset + \marginparwidth, \paperheight - 1in - \voffset - \topmargin - \headheight - \headsep) 在指定区域填充底色有了四个区域的具体位置，我们就可以着手对相关区域进行填色了。比如你想要使用 TikZ 对它们进行填色，就需要就相关区域定义具体的 node。索性，tikzpagenodes 宏包已经为我们妥善定义好了相关的区域。 current page: 整个纸张区域 current page text area: 整个版芯区域 current page header area: 整个页眉区域 current page footer area: 整个页脚区域 current page marginpar area: 整个边注区域 于是，如果你想要从版芯区域的左上角开始，一直用青色填充到版芯区域右下角至纸张右边的区域，就可以这样做了。 123456789101112131415161718\documentclass&#123;book&#125;\usepackage&#123;tikz&#125;\usepackage&#123;tikzpagenodes&#125;\usepackage&#123;xcolor&#125;\newcommand*&#123;\ColorRectangle&#125;[3]&#123;% \tikz[overlay, remember picture] \fill[#1] (#2) rectangle (#3);%&#125;\usepackage&#123;blindtext&#125;\begin&#123;document&#125; \ColorRectangle&#123;cyan&#125; % left top anchor point &#123;current page text area.north west&#125; % right bottom anchor point &#123;current page text area.south east -| current page.south east&#125; \blindtext\end&#123;document&#125;]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>TikZ</tag>
        <tag>Color</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员的自我修养（四）：C++ 与并发的基本问题]]></title>
    <url>%2F2017%2F05%2F06%2Fcxx-concurrency-multithread-basic-problems%2F</url>
    <content type="text"><![CDATA[系列文章撰写至今已到了第四篇。从这篇开始，我们会在几篇文章内，集中讨论并发与多线程，以及如何在 C++ 中编写多线程的代码。对于使用其它语言的程序员，应当也能从中获取到有益的信息。 并发与并行在此，我们讨论的一系列概念中，最简单也是最基本的，是并发 (Concurrency)。并发的「并」指的是在时间上同时，而「发」指得是事件的发生。因此，所谓的并发，指的就是「两个或者多个事件同时发生」。 这是一个相当简练的定义。你可能对它有了一些理解，但是大概率，你还没有理解透彻。因此，我们尝试举几个例子看看。 在学生时代，很多同学都尝试过所谓的「一心多用」。我见过厉害的学生，可以在上数学课的时候，一边听讲，一边赶工物理作业。更普遍一些的例子，大部分人，都能一边走路一边打电话、一边吃饭一边聊天。这些事例都属于「并发」的范畴，这也是通常大家理解的并发。 实际上，还有一种类型的并发。有一个笑话，说的是：你们别看美国强大，实际上，咱们中国人在工作的时候，人家美国人在呼呼大睡。你看，在同一时间，「中国人工作」和「美国人睡觉」这两件事情，同时发生了，那么这就是并发。 上述两类例子的区别在于，第一类例子，我们说的都是「一个人」同时干不同的事情；而第二类例子，说的是「多个人」分别同时干不同的事情。当然，这都算是并发。 并行 (Parallel) 的概念则与并发稍有不同。相较于并发，并行的要求更加严格。在说明什么是并行之前，我们首先再看一些例子。 上面说到，一些厉害的学生可以在上数学课的时候，同时做物理作业。由于人们在做数学任务和物理任务时，涉及到大脑的区域是几乎重叠的，所以人们不可能真的同时处理不同的数学和物理任务。这些学生的特异功能，实际上在于他们能够快速地在两类任务之间做切换。这也就是说，实际上在具体到某一时刻，这些学生要不然在听数学课，要不然在做物理题。 与之不同的是，中国人工作和美国人睡觉，这两件事情，真真切切在同一时刻是同时发生的。 这两类例子之间的区别也就比较明确了：第一类例子，具体到某一时刻，事件并没有同时发生；而第二类例子，具体到某一时刻，事件也是同时发生的。我们说，第一类例子只能说是并发；而第二类例子则可称是并行，既是并发也是并行。 在大多数的讨论中，我们不需要严格区分并发与并行。只在少数特定的情况下，区分并发和并行才有意义。索性，这些情况根据上下文，是很容易就能判断出来的。 计算机中的并发系列文章的第二篇介绍了操作系统以及进程、线程相关的知识。其中，对于操作系统，我们说操作系统基本上就完成了两件事情： 对上提供抽象接口供调用； 对下负责硬件资源的管理。 而硬件资源特别是 CPU 的计算资源是昂贵的，所以操作系统就有责任尽可能高效地利用硬件资源。对于 CPU 资源来说，人们先后发展了多道程序、分时系统与多任务系统等任务调度方式。其中，分时系统将 CPU 的执行时间分成小片，分配给多个任务交替使用。当这些分片足够短的时候，作为操作者的人类，就无法分辨出其中的「交替」的部分了。通过这样的方式，在操作系统的层面，计算机首先有了「并发」。不过，这种并发并不是真正的并行。 稍微仔细的思考，就不难发现，真正的并行是对计算机硬件层面的要求。如果硬件不支持在同一时刻处理多个任务，那么不论操作系统如何优化，整个计算机都只能并发而不能真正意义上的并行起来。 真正的并行，要等到多处理器计算机（各种超级计算机都属此类）和单芯多核处理器装配到计算机中了。这些机器，在硬件层面可以在同一时刻处理多个任务，所以有了真正并行的可能性。与只是并发的情况相比，真正的并行可以避免任务切换过程所需上下文切换带来的开销。因此，一般来说，真正的并行，CPU 的使用效率要更高一些。 当然，这并不是说任务切换在多处理器计算机或者单芯多核处理器计算机上就不存在了。比如，在单芯双核处理器上同时处理 3 个或以上任务，那么不管任务如何调度，都会需要做上下文切换。 多进程与多线程系列第二篇文章介绍了进程和线程的概念。对于操作系统来说，一个任务可以由进程完成，也可以由线程来完成。因此，很自然地，在计算机中实现并发就有两种方式：多进程和多线程。 进程和线程最本质的区别，在于隔离与共享上的不同。对于多进程来说，各个任务之间由操作系统保证了相互隔离。若要在多进程之间进行数据的传递、共享，必须要依赖操作系统信号、套接字、文件、管道等等。对于多线程来说，各个任务实际上处在同一进程空间，大多数的资源都能在内存空间中传递、共享，十分方便。但是另一方面，由于隔离不严，所以会出现十分棘手的「线程安全」问题。 出于以下一些考虑，这篇文章及其可以预期的后续，言及「并发」都默认使用多线程来实现。 C++ 标准目前只支持了多线程，而没有支持多进程； 进程间通信的开销较大，而线程安全的问题是可以解决的。 为什么/为什么不并发当然有其好处，但也不是没有代价。从程序员的角度来说，至少编写并发的代码会复杂很多。因此，思考「为什么要用并发」和「为什么不用并发」是有意义的。 为什么：性能在 CPU 的进步过程中，基本可以把 CPU 设计者们的努力分成两个阶段。 提高时钟频率以及单指令流性能； 专注于多线程和多核结构。 在 2005 年以前，CPU 的设计者们拼命地提高 CPU 时钟频率，不断做执行优化，想方设法提高缓存的命中率。但是这些方面的提高，终究是有天花板的。因此，在 2005 年，随着 Intel 和 AMD 开始在 CPU 中引入多核技术，基本上宣告了以往通过提高始终频率以及单指令流性能的方式提高 CPU 性能的死亡。 对于程序员来说，这意味着，以往做需要坐等更加厉害的 CPU 出现，就能自动获得更好性能的日子，一去不复返了。程序员们必须学着让自己的程序，并发起来，以便充分利用多核 CPU，甚至多个 CPU 的计算能力。 对于并行来说，它提高程序性能的方式基本有两种。 将原本的任务，在算法或者数据上拆分成若干部分，并发执行； 不拆分原本的任务，但是并发地执行多份任务。 这里，前者是在更短的时间内完成了同样的任务；而后者是在同样的时间内完成了更多的任务。 为什么：关注点分离所谓关注点分离 (separation of concerns, SOC)，指的是在编写代码时，将不相关的功能对应的代码分开。对于我们的主题来说，分离关注点，可以让我们的程序在不同的线程执行不同的任务，以便使业务逻辑更加清晰。 举例来说，大家都爱使用的「网易云音乐」，至少在逻辑上可以分成两个部分。 用于响应用户交互的界面； 用于播放音乐的后台。 当然，你可以把这两个部分放在一个线程里执行。但这就意味着，你的代码，必须把这两部分内容，放在一起，以供调用。而若是将这两个部分放在分别的两个线程中执行，两部分代码就可以分开了；我们只需要做好线程之间的通信、响应就可以了。 为什么不：收益低于代价这基本上是放之四海而皆准的真理了。不过，总还会有值得分析的东西。 为了理解什么时候可能发生「收益低于代价」，我们也应该从两个方面去分析。 什么情况可能降低收益； 什么情况可能提高代价。 首先，启动线程，意味着操作系统需要为线程分配相关资源，并划定堆栈空间。因此，启动线程不可避免地会有固定的开销。于是，如果线程上执行的任务非常琐碎，执行时间与线程启动、销毁的时间可以比拟的话，那么使用多线程收益就很低了，也就不划算了。 其次，线程是有限的资源。一方面，每个线程都需要自己的堆栈空间，过多的线程可能耗尽虚存空间。（当然，对于 64 位的机器来说，这种情况基本不会遇到）另一方面，线程 ID 是有上线的，会有类似 *nix 下 fork 炸弹的问题。再者，哪怕线程可以无限制地开启，线程使用到的其他资源，也是有限制的。最后，大量的线程，意味着 CPU 需要频繁地在线程之间做上下文切换，占用 CPU 执行时间。总的来说，当前处理的线程数量，如果已经较多，那么再开启新的线程，边际收益就非常低了。此时，再使用多线程，就不划算了。 从代价的角度来说，编写和维护多线程的代码通常是困难的。使用并发的代码，通常情况下会难以理解。因此，编写和维护并发的代码，会平添很多脑力成本。此外，由于增加了代码的复杂性，出错的可能性、排查错误的难度，都会升高。 因此，综合上面这些因素，如果使用多线程带来的性能收益以及分离关注点带来逻辑清晰方面的收益比不上开发并发代码带来的成本，那么就不应该使用并发了。 C++ 与并发多线程进入 C++ 标准很多人可能会问，以前 C++ 也能写多线程的程序。为什么要把这件事单独拿出来说呢？ 是的，没错。如果 C++ 以前不能写多线程的程序，那么 C++ 可能在十年前就会被逐渐淘汰了。但是，在多线程进入 C++ 标准之前，人们使用 C++ 编写多线程的程序，只能依赖操作系统提供的 API。比如，在 POSIX 环境下，就只能使用 pthread 库，实现多线程；在 Windows 下，又得换成 CreateThread 了。 也许你已经发现了，C++ 标准收容多线程最大的意义就在于「承认」。在以前，C++ 标准是不承认有多线程这么回事的。因此，人们若是想要实现多线程，就不得不依赖于平台相关的 API。这也就给代码的跨平台移植带来了很大的困难。而在 C++ 11 收容多线程之后，使用标准库提供的多线程设施，C++ 程序员就可以很简单地编写出多线程的程序，而无需担心底层平台如何。 多线程标准库的效率标准库所作的工作，实际上是在各个平台上，将平台提供的接口抽象出来，成为统一的方案。所谓抽象就有代价，因此使用多线程的标准库编写的程序，在效率上一定存在天花板。 但是，如同我们在C++ 的几个基本原理和技术中提到的那样，C++ 尝试了所谓的零开销地抽象机制（zero-overhead abstraction mechanism）。也就是说，C++ 在提供统一的抽象接口时，尽可能地避免了抽象带来的性能损失。换用更加通俗的话来说 不存在在任何情况下，效率都比标准库设施高的实现； 因为，如果存在这种实现，它就会成为新的标准库。 因此，在主流平台上使用 C++ 进行并发编程，我们应该首先考虑使用标准库提供的设施。 下一篇开始，我们将介绍如何使用 C++ 提供的标准库，进行并发编程，以及避免一些常见的「坑」。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Concurrency</tag>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 LaTeX 中使用微分算子的正确姿势]]></title>
    <url>%2F2017%2F05%2F01%2Fthe-correct-way-to-use-differential-operator%2F</url>
    <content type="text"><![CDATA[此篇讨论很小的「一点」——关于如何正确排版微分算子。 所谓微分算子，其英文名字叫做 differential operator，也就是 $\mathrm{d} x$ 中的 $\mathrm{d}$。由于微分算子，形式上就是拉丁字母 d；并且中国人读起来也就是简单粗暴的「滴埃克斯」。所以，在书写 LaTeX 手稿时，很多人简单粗暴地将微分算子写作 dx，例如不定积分 \int f(x)dx。 我们说，数学算式是精美而珍贵的。在排版数学算式时，你不能马虎，应该小心谨慎。这也是为什么 Knuth 在设计 TeX 时，将数学式子都包含在美元符号 $ 之间的原因。对待微分算子，我们也应该有这样的心态。 粗话说：「如果没有标准，那所有的争执都是瞎扯淡」。正如单位制有所谓的 ISO 国际单位制一样，数学符号也有对应的 ISO 标准。数学符号的标准，首先是定义在 ISO 31-11 当中；而后这个标准被 ISO 80000-2:2009 取代。因此，此篇讨论的内容，都是基于 ISO 80000-2:2009 的。 在 ISO 80000-2:2009 中，微分算子被描述为 直立的拉丁字母 d； 一个右边没有间距的操作符。 对于直立的拉丁字母 d，我们可以使用 \mathrm{d} 达成效果。而若要微分算子的左边有间距，而右边没有，这个问题就值得思考了。 最简单的办法，是将微分算子做如下实现 1\newcommand*&#123;\dif&#125;&#123;\,\mathrm&#123;d&#125;&#125; 看起来，这样是没有问题的。但是，在某些情况下，就会出现尴尬的问题。比如 1关于 $x$ 的微分 $\dif x$ 是值得思考的问题。 因为在 \dif 的定义中，\mathrm{d} 之前有不可省略的铅空 \,。于是，这份代码中 \dif x 与前后正文之间的距离就不一致了。为了解决这个问题，更有经验的人可能会选择这样定义 1\newcommand*&#123;\dif&#125;&#123;\mathop&#123;\mathrm&#123;d&#125;&#125;\!&#125; 这份代码，试图利用 \mathop，只在必要的时候于左边插入空白，修复了上面的问题。不过，这样一来也带来了一些副作用——在 \mathop 的作用下，\mathrm{d} 的基线发生了改变，不再与正常的数学变量保持在同一个基线上。这也是不好的。 最终解决问题，应该对微分算子有这样的定义 1\newcommand*&#123;\dif&#125;&#123;\mathop&#123;&#125;\!\mathrm&#123;d&#125;&#125; 在这个定义中，拉丁字母 d 本身的特点得到了保留（比如基线是正常的）。此外，在 \mathrm{d} 的左边，插入了一个空白的 \mathop{}；其左边的空白保留，而右边与 \mathrm{d} 之间的距离，则由 \! 抑制。这样就达成了我们的目标。 参考：http://www.tug.org/TUGboat/Articles/tb18-1/tb54becc.pdf#page=8]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Operator</tag>
        <tag>Differential</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTeX 中的浮动体：浮动算法]]></title>
    <url>%2F2017%2F04%2F30%2Ffloats-in-LaTeX-the-positioning-algorithm%2F</url>
    <content type="text"><![CDATA[这是系列文章的第三篇，系列文章的前两篇分别是 基础篇；以及 处理超宽问题。 此篇将讨论 LaTeX 中的浮动算法。在此之后，读者应该有能力理解 LaTeX 中浮动体各种「乱跑」的现象的由来，并且知道关于 LaTeX 中浮动体一些最佳实践。 浮动体相关的术语浮动体类型每个浮动体都从属于一种浮动体类型。默认情况下，LaTeX 定义了两种浮动体类型，即 figure 和 table。文档类和宏包的作者，可以在其中定义额外的浮动体类型（比如 listings 宏包定义了用于排版代码清单的浮动体；algorithm 宏包定义了用于排版算法的浮动体），用户也可以在导言区定义自己需要的浮动体类型（借助 float 宏包）。浮动体从属的类型，在多个方面会影响浮动体的最终位置。比如说，每个浮动体类型都有默认的位置选项，如果它们没有被浮动体本身的位置选项覆盖的话，那么就会生效。 需要特别强调的是，同一个浮动体类型中的不同浮动体，它们的相对顺序是固定的。也就是说，不管浮动体如何「乱跑」，Figure 1, Figure 2, Figure 3 这样的顺序是始终保持的。（简称「你大爷始终是你大爷」原则）不过，不同类型的浮动体之间，其顺序则可能出现穿插。比如，如果有 Table 1，则可以出现在相对上述三个图片的任意位置。 浮动区域在同一栏（column）当中，LaTeX 设置了两个浮动区域：栏的顶部和底部。对于双栏排版来说，LaTeX 还提供了额外的区域：跨过双栏的顶部。 此外，LaTeX 种也有所谓的「浮动栏」或者「浮动页」的设定。顾名思义，浮动栏和浮动页就是「只有浮动体」的栏或者页。 最后，LaTeX 也可以将浮动体放在文本内容的中间（当然，这需要显式指定）。 浮动体位置选项为了指定浮动体放置的位置，手稿作者需要给浮动体环境传入浮动体位置选项（通过环境的可选参数）。如果手稿作者没有显式提供位置选项，那么 LaTeX 则会使用浮动体所述类型所指定的位置选项。 123\begin&#123;figure&#125;[!htbp]% ...\end&#123;figure&#125; LaTeX 中默认的浮动体位置选项有五种，手稿作者可以以任意顺序组合使用这些选项。它们是 ! 表示忽略一些严格的限制条件（后文详述）； h 表示如有可能，则放在当前位置； t 表示该浮动体允许置于栏的顶部； b 表示该浮动体允许置于栏的底部； p 表示该浮动体允许置于浮动栏或浮动页。 这也就是说，如果某个字符（比如 b）没有出现在浮动体位置选项中，则 LaTeX 在尝试输出该浮动体时，就不会试着将它放在栏的底部。 需要再次强调的是，浮动体位置选项的指定是一个「组合」问题，而不是「排列问题」。因此，[tb] 和 [bt] 是等效的。并不是说 [bt] 表示首先尝试放在栏的底部。 浮动算法参数总计，大约有 20 个参数，会最终影响到 LaTeX 的浮动体算法。根本来说，这些参数限制了 某个浮动区域至多允许摆放多少个浮动体， 浮动区域的大小， 非浮动栏或非浮动页中，文字区域的最小大小， 一个浮动区域内连续浮动体之间的垂直距离，以及 浮动区域与其前后文字区域的垂直距离。 浮动体参考点显而易见，浮动体在手稿源代码中的位置，会影响最终的输出位置。因为，浮动体在手稿源代码中的位置，决定了 LaTeX 在何时第一次遇见这个浮动体。如果，浮动体在手稿的源代码中，被置于一个段落的中间，那么这个浮动体的参考点是（自源代码中观察）浮动体之后的（自最终输出文件观察）下一个断行点或者分页点。 浮动算法至此，我们可以开始探讨 LaTeX 浮动算法的行为了。 在理解浮动算法之前，我们有必要强调一下，这个算法是在 1980 年代设计出来的。其时，计算机的算力相对现在是非常有限的。因此，浮动算法的设计中有非常多的「妥协」。 基于这一原因，LaTeX 中所有的排版算法，都在尽力避免「回溯」。这也就是说，LaTeX 读入源代码之后，会试着尽可能快地将之排版出来。这样一来，算法的复杂度就可以尽量的低——当然，它依然很复杂，并因此可以尽快输出排版结果。 对于浮动体来说，这就意味着确定浮动体位置的浮动算法必须是一个贪心算法。在 LaTeX 遇见浮动体时，它就会尽可能地尝试输出它。如果 LaTeX 确定输出了一个浮动体，那么不论之后遇到什么内容，它的位置都不会发生改变。这种贪心实际上是对运行效率的妥协。因为，显而易见地，如此贪心的位置选择，可能在读入之后的数据以后，可以发现是不那么完美的。 比如说，假设一个图片允许放在栏的顶部或者底部。而后 LaTeX 可能会将其放在某一栏的顶部区域。现在假设，在这个图片之后，假设有两个表格，只允许放在栏的顶部，那么这两个表格就没地方可防了——必须放在下一页。而实际上，最好的选择是，将这两个表格放在顶部，而图片放在底部。（在这个假设中，最佳的放置办法，LaTeX 是不会去尝试的） 基本流程浮动算法的基本流程，可以大致描述如下。 当 LaTeX 遇到一个浮动体，它会根据浮动算法的规则（后文详述）尽可能快地输出该浮动体。 若成功，则该浮动体被输出，并且 LaTeX 再也不会改变它的位置。 若失败，则该浮动体被 LaTeX 放在一个等待队列中暂存，而后在下一页开始的时候尝试输出队列中的浮动体。 当一栏或者一页组装完毕，LaTeX 会检查等待队列中的浮动体，并尝试构建一个浮动栏或浮动页，输出尽可能多的浮动体。如果等待队列中的各个类型的浮动体，都不允许输出在浮动栏或浮动页中，则 LaTeX 会开始尝试将剩下的浮动体放在栏的顶部或者底部。如果当前页已无法容纳更多浮动体，则余下的浮动体又被加入等待队列，待输出下一页时再做尝试。 之后，LaTeX 开始处理当前页的文本信息。当然，在这个过程中，LaTeX 可能会遇到新的浮动体。 当 LaTeX 遇到 \clearpage/FloatBarrier 或者文档末尾时，LaTeX 会新建一个页面，而后将等待列表中的所有浮动体，都输出在浮动栏或浮动页中（而不论这些浮动体的位置选项是否指定了 p）。 浮动算法的规则不论何时，当 LaTeX 读入一个浮动体时，它都会先检查等待队列中是否有与该浮动体同属一个浮动体类型的浮动体尚未输出。若等待队列中存在这样的浮动体，则该浮动体会被直接加入等待队列，而不会尝试输出。 若等待队列中，没有当前类型的浮动体，则 LaTeX 会检查该浮动体的位置选项。 如果位置选项中包含 !，则在处理该浮动体时，LaTeX 会忽略一些严格的限制（当前浮动区域允许放置浮动体的最大数量、当前浮动区域的最大面积）。否则，这些限制条件就会执行，以期获得更加美观的效果。 下一步，LaTeX 会检查是否存在 h 选项。 如果存在，则 LaTeX 会尝试将浮动体放在当前位置。如果当前位置尚有足够的空间供放置该浮动体，则浮动体输出成功；否则，该浮动体会被加入等待队列。 如果不存在，则 LaTeX 会检查是否存在 t 选项。如果存在，并且上述限制条件没能限制该浮动体，则该浮动体会被放在栏的顶部，而后终止当前的浮动体处理。 最后，LaTeX 会检查是否存在 b 选项。同样的，如果没有限制条件约束该浮动体，则它会被放在栏的底部。 运行至此，说明当前 LaTeX 找不到适合该浮动体的位置，则它会被加入等待队列。 注意，p 选项在此是不起作用的；它仅于分页时起作用。 分页时，尝试清空等待队列当 LaTeX 分页时，会首先检查浮动体等待队列，并尽可能地清空它。为此，LaTeX 会尝试构建浮动栏或浮动页。 需要注意的是，在这个步骤中，必须有 p 指定的浮动体，才会被放在浮动栏或浮动页中；否则，它就会被留在等待队列里面。需要注意的是，如果一个浮动类型尚未输出的第一个浮动体不允许放在浮动栏或浮动页中，那么，该类型所有的浮动体，都只能待在等待列表中，以等待下一个处理步骤。 如果此时有浮动体可以输出，那么 LaTeX 会构建浮动栏或者浮动页，并尽可能多地输出这样的浮动体——直到当前浮动栏或浮动页已经「满了」，或者触发了某些限制条件为止。 生成浮动栏或浮动页的步骤，一直持续到等待列表中再无可用的浮动体（在每个类型的头部，再无指定了 p 选项的浮动体）。此时，LaTeX 会尝试将剩余的浮动体，放在下一页（或者栏）的栏的顶部或者底部。这一步骤和上一小节中介绍的基本相同，但有以下一些区别 h 选项再无作用了； 此处输出的浮动体，不再来自 LaTeX 刚从源代码中读取到的，而是从等待队列中依次读取。 浮动体算法的参数与限制条件四个计数器 totalnumber（默认为 3），在非浮动页上浮动体的最大数量。 topnumber（默认为 2），在一个栏的顶部浮动体的最大数量。 bottomnumber（默认为 1），在一个栏的底部浮动体的最大数量。 dbltopnumber （默认为 2），在双栏排版中，横跨双栏的顶部浮动体的最大数量。 五个区域比例 \topfraction（默认为 0.7），栏的顶部区域占据当前栏的最大比例。 \bottomfraction（默认为 0.3），栏的底部区域占据当前栏的最大比例。 \dbltopfraction（默认为 0.7），在双栏排版中，横跨双栏的顶部区域占据当前页的最大比例。 \textfraction（默认为 0.2），在非浮动栏或浮动页中，文字区域占据的最小比例。 \floatpagefraction（默认为 0.5），在浮动栏或浮动页中，浮动体至少应当占据的最小比例。 五个垂直距离，它们的默认值取决于文档类默认字号。 \floatsep，栏的顶部或底部区域中，连续浮动体之间的垂直距离。 \dblfloatsep，双栏排版中，横跨双栏的浮动区域中，浮动体之间的垂直距离。 \textfloatsep，栏的顶部或底部的浮动区域与文字区域之间的垂直距离。 \dbltextfloatsep，双栏排版中，横跨双栏的浮动区域与文字区域之间的垂直距离。 \intextsep，对于 h 生效的浮动体，与前后文字之间的垂直距离。 浮动算法导致的一些现象及其解释浮动体可能出现在源代码相对位置之前浮动体在源代码中的位置，决定了它在最终输出的文档中可能出现的最早的位置。这一最早位置是「当前栏的顶部区域」。如果你有认真阅读前面的部分，你就会发现，当等待列表中没有当前类型的浮动体，并且当前浮动体没有被 h 选项确定位置时，浮动体是允许放在当前栏的顶部的。因此，浮动体可能出现在源代码相对位置之前。 双栏排版中，跨栏浮动体总是被放入等待列表对于双栏排版，跨栏浮动体总是被 LaTeX 立即放入等待列表当中；也因此，跨栏浮动体最在也要输出在下一页的顶部。 产生这一效果的原因在于，如果期待跨栏浮动体放在当前页的顶部区域，则若假设 LaTeX 遇到该浮动体时，第一栏已经排版完成（正在排版第二栏），那么 LaTeX 必须回溯，破坏已经排版好的第一栏。这在效率上是得不偿失的。 双栏排版中，跨栏浮动体不可以被放在底部区域在 LaTeX 的双栏排版中，没有为跨栏浮动体设置底部区域。因此，如果你使用 \begin{figure*}[b]，那么因为它不允许放在顶部区域，所以它直到遇见 \clearpage/\FloatBarrier 或者文档末尾时，才会被输出。 h 真的只表示「如果可能的话，放在这里」如前所述，h 选项仅在一种情况下可能生效：等待列表中没有该类型的浮动体，并且当前页有足够的空间供其摆放。 如果用户希望表达「我一定要放在这里」，那么需要使用 float 宏包提供的 H 选项。 浮动体选项的顺序没有意义如前所述，浮动体选项只有组合的意义，没有排序的意义。 浮动体算法的文档参见 source2e.pdf，ltoutput.dtx 部分。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Floats</tag>
        <tag>Positioning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[支持 HTTPS 协议的分享插件]]></title>
    <url>%2F2017%2F04%2F29%2Fshare-plugin-supoort-HTTPS%2F</url>
    <content type="text"><![CDATA[常关注我博客的朋友应该已经发现，几个域名都已经换成了全站 HTTPS。我认为，使用 HTTPS 反映的是一种对读者负责的态度，时至如今没有开启全站 HTTPS 的都是没节操的。 https://liam0205.me https://cn.liam.science https://blog.liam.science 但是，并不是所有的服务都有节操，正如并不是所有的人都有节操一样。因此，对这些服务就必须寻找支持 HTTPS 的替代品，以免产生 broken HTTPS 的现象。 国内几个常见的分享插件，都不支持 HTTPS。（对，说的就是你 JiaThis）为此，我们就必须自己动手，丰衣足食。 NeedMoreShare2经过一番简单的搜索，我找到了名为 NeedMoreShare2 的项目。这个项目只有简单的 CSS 和 JS，并且可以直接部署在自己的网站上，因此就不需要依赖站外的资源，可以说是相当的方便。 此外，项目采用 MIT 协议，因此可以放心地使用。 下载、安装项目挂在 GitHub 上，因此你可以很简单地使用 GitHub 自带的功能得到 master 分支的代码。对于不熟悉 GitHub 的同学，你也可以直接点击下载链接。 使用 Hexo 等博客系统的同学，也可以为博客源代码添加一个子模块（submodule）。下面的命令，会将 GitHub 上面的仓库，克隆到 source/plugin/need-more-share2 目录，并作为主项目的一个子模块。 1git submodule add git@github.com:revir/need-more-share2.git source/plugin/need-more-share2 将来想要更新子模块，就只需要执行下面的命令就可以了。 1git submodule update --remote 接下来，我们需要引用 NeedMoreShare2 的样式表和脚本。 1234&lt;!-- Javascript file --&gt;&lt;script src="/plugin/need-more-share2/dist/needsharebutton.min.js"&gt;&lt;/script&gt;&lt;!-- CSS file --&gt;&lt;link href="/plugin/need-more-share2/dist/needsharebutton.min.css" rel="stylesheet" /&gt; 之后只需要在合适的位置，启用分享按钮就可以了。 1&lt;button class="btn btn-default need-share-button"&gt;Share&lt;/button&gt; 更多的定制NeedMoreShare2 还支持参数的传递，只需要加上以 data-share- 开头的一些属性就可以了。 NeedMoreShare2 支持的参数有以下一些 iconStyle：分享图标的形式，取值有 default, box； boxForm：分享图标的排列样式，取值有 horizontal, vertical； position：点按按钮之后，分享图标出现的位置，默认是 bottomCenter，取值可以是以下组合 top/middle/bottom + Left/Center/Right； networks：希望分享到哪些社交网络，默认是 &#39;Weibo,Wechat,Douban,QQZone,Twitter,Pinterest,Facebook,GooglePlus,Reddit,Linkedin,Tumblr,Evernote&#39;，还可以有 RenRen； url：默认是 location.href； title：默认是document.title； image：默认从 meta[property=&quot;og:image&quot;] 或 meta[name=&quot;twitter:image&quot;] 取值； description：默认从 meta[property=&quot;og:description&quot;] 或 meta[name=&quot;twitter:description&quot;] 取值。 比如我的博客的分享按钮，对应了下列代码。 123456789101112&lt;div style="text-align: center;"&gt;&lt;div id="i-share" class="btn btn-default need-share-button" data-share-position="topCenter" data-share-icon-style="default" data-share-networks="Wechat,Weibo,Renren,Twitter,Facebook,GooglePlus,Douban,QQZone,Evernote"&gt; &lt;i class="icon-next-heart fa fa-heart"&gt;&lt;/i&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; new needShareButton(document.getElementById('i-share'));&lt;/script&gt; 注意，这里我给 div 标签记录了 id = &quot;i-share&quot;。而后使用 new needShareButton(document.getElementById(&#39;i-share&#39;));，激活了按钮。这种方式可定执行高，也是官方介绍的第二种设置按钮的方式。我个人推荐使用这种方式。 好了，各位希望在 HTTPS 下使用分享按钮的朋友，愉♂悦地设置起来吧~]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Share</tag>
        <tag>HTTPS</tag>
        <tag>Plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不蒜子计数器初始化的非官方办法]]></title>
    <url>%2F2017%2F04%2F29%2Fbusuanzi-offset-setting%2F</url>
    <content type="text"><![CDATA[不蒜子是 Bruce 开发的一款轻量级的网页计数器，它的口号是（非官方） 轻量级，但好用。 如果你想尝试不蒜子计数器，可以查阅不蒜子计数器的介绍文档。 不蒜子虽好，但也有一些问题。Bruce 在文档中提到 我的网站已经运行一段时间了，想初始化访问次数怎么办？请先注册登录，自行修改阅读次数。 但因为各(qi)种(shi)原(shi)因(lan)，注册登录的功能一直没有上线。所以现在，如果用户希望修改初始值，则必须联系 Bruce，让他手工升级。这无疑违背了 geek 的原则。于是这篇文章提出一个非官方的办法，解决这个问题。我们的口号是 非官方，但好用。 分析问题不蒜子之所以被成为「geek 的计数器」，就是因为它的安装使用非常简单——只需要加载计数器 js 脚本，以及使用 span 标签显示计数器结果就可以了。其余所有的事情，都交给用户的 css 去控制。因此，自然，这个「所有的事情」也包括了最终显示的值是多少。因此，我们可以在最终显示的数字上做一些手脚。 不蒜子的站点 PV 对应的标签是这样的 1&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt; 既然如此，我们只需要在页面上用 js 取得这个标签中的值，而后加上一个偏移量作为初始值就可以了。如果使用 jQuery，可以这样做 1234567891011&lt;script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt; $(document).ready( var busuanziSiteOffset = parseInt(100000); function fixCount() &#123; if ($("#busuanzi_container_site_pv").css("display") != "none") &#123; $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + busuanziSiteOffset); &#125; &#125; );&lt;/script&gt; 余下唯一的问题，就是不蒜子的 js 代码，是通过异步的方式加载的。而在其加载完成之前，上述 span 标签会整个被隐藏起来，不可见。于是，这样的朴素的修复就会失效了。 对付「异步」，一个朴素的处理方式是定期轮询。比如这样 12345678910111213&lt;script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt; $(document).ready(function() &#123; var int = setInterval(fixCount, 100); var busuanziSiteOffset = parseInt(10000); function fixCount() &#123; if ($("#busuanzi_container_site_pv").css("display") != "none") &#123; clearInterval(int); $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + busuanziSiteOffset); &#125; &#125; &#125;);&lt;/script&gt; Hexo 的解法在上面的分析中，我们实际上已经有了完整的解法。不过，这样的解法可定制性非常差。试想，在需要修改初始值的时候，都需要深入到代码中去，而后修改 var busuanziSiteOffset = parseInt(10000); 的值。这种事情，想想就令人崩溃。 对于 Hexo 来说，在站点或主题配置中的变量，可以在主题模版中引用得到。于是，我们可以这样做。 _config.yml123# busuanzibusuanzi: truebusuanzi_site_offset: 100000 以及这样做。 hexo_footer.swig123456789101112131415161718&#123;% if theme.busuanzi %&#125;&lt;!-- 不蒜子 --&gt;&lt;script async src="//cdn.busuanzi.ibruce.info/cdn/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;&lt;!-- 不蒜子计数初始值纠正 --&gt;&lt;script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt; $(document).ready(function() &#123; var int = setInterval(fixCount, 100); var busuanziSiteOffset = parseInt(&#123;&#123; theme.busuanzi_site_offset &#125;&#125;); function fixCount() &#123; if ($("#busuanzi_container_site_pv").css("display") != "none") &#123; clearInterval(int); $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + busuanziSiteOffset); &#125; &#125; &#125;);&lt;/script&gt;&#123;% endif %&#125;]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Busuanzi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决 beamer 中列表环境无法两端切齐的问题]]></title>
    <url>%2F2017%2F04%2F11%2Fjustifying-in-beamer-s-lists%2F</url>
    <content type="text"><![CDATA[众所周知，beamer 作为一个幻灯片文档类，大多数情况是不做两端对齐的。但是，有些强（chu）迫（nv）症（zuo）宝宝总喜欢让列表环境有两端对齐的效果。 这篇文章来治一治这样的强迫症。 原因分析为了支持幻灯片的效果，beamer 重定义了 LaTeX 中常见的列表环境。对列表环境的重定义放在 beamerbaselocalstructure.sty 当中。我们截取一段对 itemize 环境的重定义看看。 1234567891011121314151617181920212223\renewcommand&#123;\itemize&#125;[1][]&#123;% \beamer@ifempty&#123;#1&#125;&#123;&#125;&#123;\def\beamer@defaultospec&#123;#1&#125;&#125;% \ifnum \@itemdepth &gt;2\relax\@toodeep\else \advance\@itemdepth\@ne \beamer@computepref\@itemdepth% sets \beameritemnestingprefix \usebeamerfont&#123;itemize/enumerate \beameritemnestingprefix body&#125;% \usebeamercolor[fg]&#123;itemize/enumerate \beameritemnestingprefix body&#125;% \usebeamertemplate&#123;itemize/enumerate \beameritemnestingprefix body begin&#125;% \list &#123;\usebeamertemplate&#123;itemize \beameritemnestingprefix item&#125;&#125; &#123;\def\makelabel##1&#123;% &#123;% \hss\llap&#123;&#123;% \usebeamerfont*&#123;itemize \beameritemnestingprefix item&#125;% \usebeamercolor[fg]&#123;itemize \beameritemnestingprefix item&#125;##1&#125;&#125;% &#125;% &#125;% &#125; \fi% \beamer@cramped% \raggedright% \beamer@firstlineitemizeunskip%&#125; 不难发现，在重定义的 \itemize 也就是 itemize 环境的前半段命令中，显式地使用了 \raggedright 命令。这个命令的作用，是在不在右侧尝试对齐文字。于是我们会看到这样的效果。 123456789\documentclass&#123;beamer&#125;\usepackage&#123;mwe&#125;\begin&#123;document&#125;\begin&#123;frame&#125; \begin&#123;itemize&#125; \item \blindtext \end&#123;itemize&#125;\end&#123;frame&#125;\end&#123;document&#125; 因此，修正这个问题，我们只需要修正 \raggedright 的效果就好了。 patchcmd我们在排版伪代码时打印垂直的缩进提示线一文中，介绍了来自 etoolbox 宏包的 \patchcmd 命令。这个命令可以在 TeX 宏中搜索特定的内容，然后替换成想要的东西。 不过，来自 etoolbox 的 \patchcmd 在对付「带有可选参数的命令」就会失效。为了解决这个问题，我们可以引入来自 xpatch 的 \xpatchcmd 命令。这个命令的用法和 \patchcmd 完全一样；并且它支持对带可选参数的命令进行补丁。 值得一提的是，xpatch 宏包里定义的命令，都有非常明确的用法，整个宏包的代码量也不多。因此，是学习 LaTeX3 的一个很好的实例。 于是，我们只需要给 \itemize 命令打个补丁就可以了。 123\usepackage&#123;ragged2e&#125;\usepackage&#123;xpatch&#125;\xpatchcmd&#123;\itemize&#125;&#123;\raggedright&#125;&#123;\justifying&#125;&#123;&#125;&#123;&#125; 这里，我们使用 \xpatchcmd 命令，将 \itemize 命令中的 \raggedright 替换成来自 ragged2e 宏包的 \justifying 命令。这个命令，会使 TeX 尝试将文字做两端切齐。我们可以看一下效果。 123456789101112\documentclass&#123;beamer&#125;\usepackage&#123;mwe&#125;\usepackage&#123;ragged2e&#125;\usepackage&#123;xpatch&#125;\xpatchcmd&#123;\itemize&#125;&#123;\raggedright&#125;&#123;\justifying&#125;&#123;&#125;&#123;&#125;\begin&#123;document&#125;\begin&#123;frame&#125; \begin&#123;itemize&#125; \item \blindtext \end&#123;itemize&#125;\end&#123;frame&#125;\end&#123;document&#125; 如果想要修正 enumerate 或者 description 环境的两端切齐问题，也可以用类似的操作。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Beamer</tag>
        <tag>Justifying</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 的几个基本原理和技术]]></title>
    <url>%2F2017%2F04%2F09%2FFoundations-of-Cpp%2F</url>
    <content type="text"><![CDATA[C++ 几乎是这个世界上最为复杂的编程语言（Programming Language）。C++ 的标准中有无数的细节，然而让人迷失在细节中，并不是 C++ 设计者/标准化委员会的本意。实际上，写好 C++ 程序，也不需要了解 C++ 的每一个细节；只需要理解语言背后的基本原理和技术就可以了。 C++ 语言之父（Bjarne Stroustrup）在 2012 年撰写过一篇 paper，其名为 Foundations of C++。在这篇 paper 中，Bjarne 通过一些例子，介绍了 C++ 背后的这些基本原理和技术。本文即脱胎于 Bjarne 的这篇 paper。 C++ 的理想化目标所谓「术业有专攻」，每个工具都有其适用范围；在适用范围内，每个工具又都有特别擅长的部分。作为工具的使用者，我们自然会期待在每一个范围，使用擅长解决这部分问题的工具。因此，如果把编程语言当做是一种工具，那么学习编程语言就应该了解其设计目的和擅长范围。 特别一提，在有此理解的基础上，就会明白，市面上诸如「PHP 是最好的语言」、「Emacs 与 Vim 之争」是多么的无聊了。 C++ 在设计之初，就着眼于特定的编程任务：在资源有限的情况下，为关键性的基础服务提供轻量级的抽象支持。我们可以认为，这就是 C++ 特别擅长的部分。为此，C++ 在语言特性和标准化的过程中，在两个方面着重下了功夫 简单直接地对硬件做映射（继承了很多来自 C 语言的特性）； 零开销地抽象机制（zero-overhead abstraction mechanism）。 在更高的层次上，这两方面的功夫，为 C++ 提供了既类型（type）丰富又类型安全的编程环境。 自然，并不是每个编程任务都落在 C++ 擅长的领域。实际上每个语言都有擅长和不擅长的领域。在这些领域，你就不能指望 C++ 程序员一定要遵循这些理想化的基本原理和技术——他们可以使用 C 风格的 C++ 去完成他们的目标。 内存与对象（Object）C++ 将内存视作一长串的字节（sequence of Bytes）。在 C++ 代码和硬件之间，C++ 没有做额外的抽象、虚拟或者其他的数学模型。这也就是说，指针、引用、数组这些概念，会直接反应在硬件上以及寻址上。 具体来说，C++ 将基本类型（char, int, double 等）直接映射到内存中的实体——比如字节（Byte）、字（Word）。有类型的对象会在内存中占据一块空间（a sequence of Bytes）；而后，这些对象的值就存储在这块空间当中。与之对应，一系列的对象，就会在内存里占据一系列的空间——这就组成了数组。对于数组中的对象，我们通常会使用指针去访问——数组的头部指针，以及数组的尾后指针限定了数组有效区域的范围（类似左闭右开的区间）。 对于用户定义的类型来说（即 C++ 中的类），其在内存中的形式，仅只是类型内成员的加和而已。在提供抽象（类）的过程中，C++ 并没有带来额外的开销。此处以 Point 类为例，进行说明。 123456789101112131415class Point &#123; private: int x; int y;&#125;;Point xy&#123;1, 2&#125;; // 对象有名字、作用域，保存在 stack 中Point* p = new Point&#123;1, 2&#125;; // 对象没有名字，需要使用指针访问，保存在 heap 中/*if (nullptr != p) &#123; delete p;&#125;p = nullptr;*/ 注意，这里我们使用了 C++11 的列表初始化（构造函数用花括号传参）。 这里，我们定义了 Point 类，其中有两个 int 类型的变量。于是，Point 类型的变量仅只是两个 int 的「组合」而已。在（栈）内存中，Point xy 占据了两倍 int 所需的内存空间；在（堆）内存中，指针 p 指向的对象，因为保存在堆中，所以有堆信息的额外开销（不可避免的）。 在继承机制里，C++ 也没有额外开销。 123456789101112class Base &#123; private: int b;&#125;;class Derived: public Base &#123; private: int d;&#125;;Base base;Derived derived; C++ 的类机制，仅只在引入虚函数时，才会带来一些开销（需要维护虚函数表）。这部分开销，是为了实现运行时多态（run-time polymorphism）所必须的，是不可避免的。因而，也没有额外的开销。 123456789101112131415161718192021class Shape &#123; public: virtual Point center() const = 0; virtual void draw() const = 0;&#125;;class Circle: public Shape &#123; private: Point c; double radius; public: Point center() const override &#123; return c; &#125; void draw() const override &#123; // draw the circle &#125;&#125;;Shape* p = new Circle&#123;Point&#123;1, 2&#125;, 3.14&#125;; 注：此图有误。虚表指针应该位于起始地址上。 至此，我们只是在「理论上」分析为什么 C++ 避免了各种额外的开销，却不知道哪些开销可称得上是额外的。当我们把自定义类型和数组结合起来时，与其它语言对比，就能看到差别了。（以某纯面向对象语言为例）。 1Point points[] = &#123;&#123;1, 2&#125;, &#123;3, 4&#125;&#125;; 复用之前 Point 的定义，在 C++ 当中，points 这个数组在内存中的存储大致如下图。 在某语言中，用户定义的类型，其对象实际保存在 heap 上，而通过 reference 访问。如此一来，同样的数组，在内存中的存储就与 C++ 的情形不太一样了。 不难发现，在 C++ 中，统共只需 4 个 int 类型变量；但是在某语言中，同样的数组，至少需要 10 个 int 类型变量占据的内存。由于增加了实际内存使用量，所以在实际运行中，可能会降低 CPU cache 命中率，最终导致运行效率降低。 总而言之，C++ 在设计之时就在尝试避免各种额外的开销。而并不是每个语言都有这样的设计。 编译时运算顾名思义，编译时运算指的是发生在编译期间（包括编译器优化）的运算。在编译时运算有以下一些好处 高效：以编译时的运算代替运行时的运算，提高运行时效率； 类型安全：在编译时就能检查表达式各部分的类型，保证类型安全； 简化并发：编译时运算得到常数，在常数上不会有数据竞争，因而能简化并发。 在 C++ 中，C++11 引入了 constexpr 这个关键字。编码时使用它，就能实现编译时运算了。下面的代码在编译时计算了北京与上海之间的距离。 12345678910111213141516class City &#123; public: double x; double y;&#125;;constexpr double csqrt(double in) &#123; /* calc square root */ &#125;constexpr double square(double in) &#123; return in * in; &#125;constexpr double dist(const City&amp; lhs, const City&amp; rhs) &#123; return csqrt(square(abs(lhs.x - rhs.x)) + square(abs(lhs.y - rhs.y)));&#125;constexpr City beijing&#123;116, 39&#125;;constexpr City shanghai&#123;121, 31&#125;;constexpr double distence = dist(beijing, shanghai); 容器容器是 C++ STL 中的一大利器，可以用来存储大量内容。vector 是其中的代表。此处我们通过事先简易版本的 Vector 来说明 C++ 的容器。 1234567891011121314151617template&lt;typename T&gt;class Vector &#123; public: Vector(); // 默认构造函数，建一个空的 vector explicit Vector(int n); // 初始化一个长度为 n 的 vector，内部元素默认初始化 Vector(initializer_list&lt;T&gt;); // 列表初始化 ~Vector(): // 析构函数，拆掉为所有元素分配的内存 int size() const; // 返回 vector 的长度 T&amp; operator[](int i) const; // 运算符重载，随机访问 vector 中的元素，返回左值引用 void push_back(const T&amp; ele); // 将 ele 追加在 vector 的末尾 T* begin(); // 返回头部元素的指针 T* end(); // 返回尾后元素的指针 private: int sz; // 记录元素的个数 T* elem; // 记录为 sz 个元素分配的内存之首地址&#125;; C++11 提供的 range-for 可以对所有提供 begin() 和 end() 的容器做循环迭代；这是容器的一个重要属性。比如说 12345Vector&lt;std::string&gt; demo(&#123;"Hello", "world"&#125;);for (auto str : demo) &#123; std::cout &lt;&lt; str &lt;&lt; ' ';&#125;std::cout &lt;&lt; '\n'; 在 Vector 类的声明中，值得注意的是使用了 public 和 private 关键字，将 Vector 的声明分为了外部接口和内部实现两个部分。在 Vector 的外部接口中，还包括了类的构造函数和析构函数——管理类实例的资源。 123456// 初始化一个长度为 n 的 vector，内部元素默认初始化template&lt;typename T&gt;Vector&lt;T&gt;::Vector(int n) : sz&#123;n&#125;, elem&#123;allocate&lt;T&gt;(sz)&#125; &#123; if (sz &lt; 0) throw std::runtime_error&#123;"negative Vector size"&#125;; std::uninitialized_fill(elem, elem + sz, T&#123;&#125;); // 默认初始化&#125; 我们首先在初始化列表中，将成员变量 sz 和 elem 初始化。其中 elem 指向了一块类型为 T 而长度为 sz 的 heap 内存空间。随后，我们在函数体中，用 std::uninitialized_fill 给 elem 上的空间，都以类型 T 的默认构造函数初始化。 注意，这里的 allocate&lt;T&gt;() 只是一个「表意」的作用，是标准的 allocator 的简化版本。 12345// 列表初始化template&lt;typename T&gt;Vector&lt;T&gt;::Vector(std::initializer_list&lt;T&gt; lst) : sz&#123;lst.size()&#125;, elem&#123;allocate&lt;T&gt;(sz)&#125; &#123; std::uninitialized_copy(lst.begin(), lst.end(), elem);&#125; 在列表初始化版本的构造函数里，构造函数接受一个用于初始化的列表。它将列表的长度初始化给 sz，而后同样地为 Vector 分配 heap 内存空间。在函数体里，使用 std::uninitialized_copy 将列表中的内容拷贝到 elem 指向的内存当中去。 12345678// 析构函数，拆掉为所有元素分配的内存template&lt;typename T&gt;Vector&lt;T&gt;::~Vector() &#123; for (auto work&#123;std::begin(elem)&#125;; work != std::end(elem); ++work) &#123; work-&gt;~T(); &#125; deallocate&lt;T&gt;(elem, sz);&#125; 在析构函数中，我们逐一析构了 elem 当中的所有元素，而后释放了 elem 这块内存空间。 同样地，deallocate&lt;T&gt;() 也只是表意用。 这个简单的 Vector 提供了对内存的高级抽象。它将存储从一连串的字节（sequence of Bytes）抽象成了对象的容器（containers of objects）。并且，在这个抽象过程中，除了必要的错误检查、内存管理和初始化工作之外，并没有额外的开销；因而是非常轻量级的。 这个示例了 C++ 的一些基础技术和特性。最浅显地，C++ 语言本身并没有定义容器和内存管理，这些工作都需要用户自己定义（当然，大多数情况标准库已经为我们准备好了）；C++ 语言本身，只是实现了对固定大小数组的支持。标准库中的 vector, map, set, list 等容器是学习 C++ 基础技术和特性非常好的示例。它们用到了以下一些技术： 接口与实现分离； 使用构造函数和析构函数管理资源（包括内存资源）； 使用模板，以便容器支持多种类型的实例； 使用左闭右开的区间（[begin():end())）构建 for 循环及相关算法； 使用标准库提供的设施（一些有用的工具库和工具函数），简化实现。 拷贝和移动 这部分内容，可以参考前作：谈谈 C++ 中的右值引用以及C++ 中类的拷贝控制。 这一节我们继续讨论容器相关的技术。 上一节中，我们初步实现了一个简单的 Vector。但是这个 Vector 还非常的不完整。考虑下面这个例子 1234Point* p1 = new Point&#123;1, 2&#125;;Point* p2 = new Point&#123;3, 4&#125;;Vector&lt;Point*&gt; points&#123;p1, p2&#125;;auto points_holder = points; 这里，我们首先列表初始化了 points。这是一个 Vector，内里的元素是 Point* 类型的对象。而后，我们尝试将 points 拷贝赋值给 points_holder。由于我们没有为 Vector 类定义「拷贝赋值」这个动作，所以编译器会为我们默认「合成」一个拷贝赋值运算符。 编译器默认合成的拷贝赋值运算符，只是简单地拷贝了类的成员变量，而不考虑成员变量的含义。具体到我们的例子中，默认合成的拷贝赋值运算符，会让 points_holder 的 sz 和 elem 分别具有和 points 中相应成员相同的值。对于 sz 来说，二者的值相同没有什么问题。但是对于 elem 来说，二者具有相同的值，意味着两个 Vector 共享了同一片内存空间。这样一来，就会出问题。比如说 向 points 中增加了一个新的元素，那么 elem 这片空间上的元素数目变成了 3，但是 points_holder.size() 依然会返回 2； 析构 points 的时候，会导致 points_holder 也不可用（访问 points_holder 内的元素会引发 segfault）。 因此，我们需要对拷贝的行为作出具体的定义。 1234567891011121314151617181920// 拷贝构造函数template&lt;typename T&gt;Vector&lt;T&gt;::Vector(const Vector&amp; orig) : sz&#123;orig.sz&#125;, elem&#123;allocate&lt;T&gt;(sz)&#125; &#123; std::uninitialized_copy(orig.begin(), orig.end(), elem);&#125;// 拷贝赋值运算符template&lt;typename T&gt;Vector&lt;T&gt;&amp; Vector&lt;T&gt;::operator=(const Vector&amp; rhs) &#123; for (auto work&#123;std::begin(this-&gt;elem); work != std::end(this-&gt;elem); ++work&#125;) &#123; work-&gt;~T(); &#125; deallocate&lt;T&gt;(this-&gt;elem, this-&gt;sz); Vector&lt;T&gt; tmp&#123;rhs&#125;; this-&gt;elem = tmp.elem; this-&gt;sz = tmp.sz; tmp.elem = nullptr; tmp.sz = 0; return *this;&#125; 这里我们分别定义了 Vector 的拷贝构造函数以及拷贝赋值运算符；其中，在拷贝赋值运算符中，我们借助了拷贝构造函数。这样一来，不论是通过构造函数进行拷贝，还是通过赋值运算符进行拷贝，我们都有了完整的定义。 值得注意的是，在拷贝构造函数以及拷贝赋值运算符中，我们都使用了诸如 orig.sz, tmp.elem 这样的用法。但是，不论是 sz 还是 elem，都是 Vector 中定义的私有成员。那么为什么我们可以通过这样的方式访问呢？需要注意的是，C++ 中的类成员访问控制，是建立在「类」这个层面的，而不是「对象」这个层面的。这也就是说，你可以在一个实例中访问同一个类的不同实例当中的私有变量。 至此，我们解决了「拷贝」的问题，可以接着去解决「移动」的问题了。对于拷贝，我们比较容易理解。对于「移动」，可能很多人就无法理解它的必要性了。这里从两个角度去解说这个问题。 对于某些容器，我们希望禁止拷贝。比如著名的智能指针 unique_ptr。因为限定了「只有当前一个只能指针指向某个资源」，所以必须禁止对 unique_ptr 的拷贝。否则的话，就可能存在多个 unique_ptr 指向同一个资源。而这就与 unique_ptr 的定义相违背了。但是，我们又不可避免地会需要在不同的变量名之间传递智能指针（比如作为参数传递，或者放入容器时有容器的拷贝）。所以，在这种情况下，我们会需要「移动」的操作。 对于某些容器对象，有时会有这样的操作：将整个对象拷贝给另一个对象，而后当前对象就要被销毁了。如果被拷贝的容器非常大，整个过程就非常耗时了。这种情况下，如果能实现「移动」操作，无意就能省去很多不必要的拷贝；提高效率。 到这里，我们能明确地说：移动操作是有必要去实现的。但是，在具体去实现移动构造函数和移动赋值运算符之前，我们还需要做一些深入的思考：被移动的对象有哪些特征。为此，我们不妨回想一下日常生活中，移动一个物体会发生什么。 最最显而易见地，将一个物体移动之后，物体出现在新的位置，而从旧的位置消失了。 在某些情况下，比如当一个物体放置很久之后，我们移动它，会在旧的位置留下一堆灰尘。 作为程序员，我们要经常从现象中抽象出统一的规律。这两个现象告诉我们几件事情： 当一个物体被移走之后，它应该完好无损地出现在新的地方； 当一个物体被一走之后，原来所处的位置，可能出现各种情况——可能只是空出了位置，也可能留下一堆垃圾。 抽象到程序设计中，就应该是：当一个对象被移动走之后，我们不应该这个对象的状态做任何假设——可能还是保持原样，也可能留下了一堆无法理解的垃圾信息。简而言之，当一个对象被移动走之后，这个对象就应该被废弃，不应该使用了。 在 C 和 C++ 中，这种「马上就要被废弃」的对象有一个名字，叫做「右值」。因此，移动构造函数和移动复制运算符的参数，应该是一个右值。 1234567891011121314151617template&lt;typename T&gt;Vector&lt;T&gt;::Vector(Vector&amp;&amp; orig) : sz&#123;orig.sz&#125;, elem&#123;orig.elem&#125; &#123; orig.elem = nullptr; orig.sz = 0;&#125;template&lt;typename T&gt;Vector&lt;T&gt;&amp; Vector&lt;T&gt;::operator=(Vector&lt;T&gt;&amp;&amp; rhs) &#123; for (auto work&#123;std::begin(this-&gt;elem); work != std::end(this-&gt;elem); ++work&#125;) &#123; work-&gt;~T(); &#125; deallocate&lt;T&gt;(this-&gt;elem, this-&gt;sz); this-&gt;elem = rhs.elem; this-&gt;sz = rhs.sz; rhs.elem = nullptr; rhs.sz = 0; return *this;&#125; 至此，我们已经实现了 Vector 类的移动和拷贝构造函数及赋值运算符，应当更新一下 Vector 类的声明。 12345678910template&lt;typename T&gt;class Vector &#123; public: // ... Vector(const Vector&amp;); // 拷贝构造函数 Vector(Vector&amp;&amp;); // 移动构造函数 Vector&amp; operator=(const Vector&amp;); // 拷贝赋值运算符 Vector&amp; operator=(Vector&amp;&amp;); // 移动赋值运算符 // ...&#125; 不难发现，拷贝构造函数及赋值运算符接受相同类型的左值引用，而移动版本的构造函数及赋值运算符接受相同类型的右值引用。 对于拷贝和移动控制，简单而粗暴的论断是：在析构函数、拷贝和移动构造和赋值运算符中，只要有一个需要手工实现（而不能依赖编译器自动合成的版本），那么就必须实现另外四个。 RAII (Resource Acquisition Is Initialization)至此，我们（看似）已经可以结束有关容器的讨论了。但是，在上述几个章节里贯穿始终的问题还需要做更进一步的讨论——资源的管理。 要讨论资源的管理，首先要明白，站在程序设计语言的角度，到底什么是资源？Bjarne 对资源作出了这样的定义：凡是程序从系统的其他部分获取，并且在使用完之后需要（显式地或者隐式地）归还的东西，都是资源。按照这个定义，内存显然是一种资源。同样地，文件、套接字、锁、线程，都可以是一种资源。 同时，Bjarne 也给出了「资源泄露」的定义：凡是使用完应当归还而没有归还的资源，就是被泄露的资源；而这个现象叫做「资源泄漏」。资源的获取与释放，这两件事情本身并不值得长篇大论。但是防不胜防的资源泄漏，则需要好好讨论。 稍有经验的程序员，就不会对「资源泄漏」感到陌生。Java 程序员可能会感到轻松，因为 Java 有自带的垃圾回收机制，能避免大多数的内存泄露问题。然而，垃圾回收并不是解决资源泄漏的银弹；因为，垃圾回收只解决了「内存泄漏」的问题，但是还有其他形式的资源。此外，资源泄漏之所以令人感到棘手，还有一个原因就是它的隐蔽性： 有一些资源，看起来就不是个资源。比如在 C 程序中打开一个文件，其实获得的是一个指针 FILE*。调用 fclose() 本身就显得比较怪异（关闭一个指针，这是什么鬼）。 有一些资源，获取和释放的方式有很多种。于是，经常性地，程序员可能无法完美地给他们对应上。 及时程序员非常小心，在使用完了资源都主动释放，也有可能在出发释放动作之前，遇到函数返回、异常处理等问题，而跳过释放动作。 所谓解决问题的最好方法，是让问题发生的前提消失。 对此可以举一个生动的例子。我们知道，在飞机、高铁等运输工具上，卫生间都采用一种名为「真空集便器」的装置来收集排泄、排遗产生的垃圾。身形瘦的人大约不会有这样的困惑，但是，如果一个大胖子一屁股坐到坐便器上，然后上完厕所，按下身前的冲洗按钮，可能就会引发悲剧——大胖子整个人被吸在坐便器上动弹不得。解决这个问题最好的办法，就是将冲洗按钮设计在坐便器之后——这样，人们必须站起来而后按下冲洗按钮。这是因为，「被吸住」的前提是有一个大胖子「坐在」坐便器上按下冲洗按钮；将按钮设计在身后，破坏了「坐在」坐便器上这个前提，因而一劳永逸地解决了这个问题。 对于资源，我们希望的是当使用完毕之后释放。而出现资源泄露的根本问题在于，我们很难穷举所有「使用完毕」的情形；而但凡有一种情形我们没有处理好，那么在这种情形下，就可能出现资源泄漏。如果想要一劳永逸地解决这个问题，我们就有必要仔细思考：在 C++ 中，有哪些东西是天然地在使用完毕之后，就会被释放的。对于任何一个稍有 C++ 经验的程序员来说，答案都是呼之欲出的：局部变量。 保存在 stack 上的局部变量，由系统维护。当局部变量的生存期完结，它就会被自动销毁。因此，若是将资源的获取与局部变量的初始化绑定在一起（此即 RAII），我们就能放心地使用资源，而不必担心资源泄漏问题。（智能指针就是这样做的）例如，对于文件指针来说，我们可以有这样的定义 12345678910111213141516171819202122232425262728293031323334class FileHandle &#123; private: FILE* p; public: FileHandle(const char* path, const char* r) : p&#123;nullptr&#125; &#123; p = fopen(path, r); if (nullptr == p) &#123; throw file_error&#123;path, r&#125;; &#125; &#125; FileHandle(const std::string&amp; path, const char* r) : p&#123;nullptr&#125; &#123; p = fopen(path.c_str(), r); if (nullptr == p) &#123; throw file_error&#123;path.c_str(), r&#125;; &#125; &#125; FileHandle(FileHandle&amp;&amp; orig) : p&#123;orig.p&#125; &#123; orig.p = nullptr; &#125; FileHandle&amp; operator=(FileHandle&amp;&amp; rhs) &#123; this-&gt;p = rhs.p; rhs.p = nullptr; &#125; ~FileHandle() &#123; fclose(p); &#125; FILE const* p() const &#123; return this-&gt;p; &#125; // ... private: FileHandle(const FileHandle&amp;) = delete; FileHandle&amp; operator=(const FileHandle&amp;) = delete;&#125;; 至此，我们就能放心地使用 FileHandle 来管理文件资源了（其他类型的资源也可以类似地定义）。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Foundations</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Python 中使用 wbdata 库获取世界银行的数据]]></title>
    <url>%2F2017%2F04%2F04%2Fget-data-from-World-Bank-in-Python-within-the-wbdata-module%2F</url>
    <content type="text"><![CDATA[世界银行（英语：World Bank）是为发展中国家资本项目提供贷款的联合国系统国际金融机构。它是世界银行集团的组成机构之一，同时也是联合国发展集团（UNDP）的成员。世界银行的官方目标为消除贫困。根据其有关协定规定（修订并于1989年2月16日生效），其所有决定都必须旨在推动外商直接投资和国际贸易，以及为资本投资提供便利。 为了方便世界各国的研究人员，世界银行免费公开了世界各国的发展数据。应当说，这是一份详实而权威的数据。 此篇介绍如何在 Python 中使用 wbdata 库获取世界银行的数据。 安装对于 Python，我们假设你已经安装好。不过，这里还是要多嘴一句，对于科学研究特别是数据科学的研究者，我们推荐使用 Anaconda 作为你的发行版。 若安装好了 Python，那么只需要在系统命令行执行下列命令，即可安装所需的 wbdata 库。 1pip install wbdata 数据库介绍世界银行的公开数据库，允许用户从几个维度进行浏览： 国家（contry）：世界银行的各个成员体，并不严格限于「国家」的概念，还包括各种经济体。 指标（indicator）：世界银行提供了国家发展层面的各个指标。 专题（topic）：世界银行将数据库分成了几个专题（比如：农业、经济与增长、贸易……）。 来源（source）：世界银行将数据库从来源分类（比如：非洲发展指标、世界范围内的统治指标……）。 wbdata 库在以上四个层面，提供了 get 函数，用以列出世行提供的所有条目；同时在国家和指标层面，提供了 search 函数，用以检索所需的国家和指标。 一个典型的交互过程从这里开始，我们将在 Python 的交互模式下做实验。我们推荐使用 iPython 作为交互模式，并假设你已经 import 了相关的 Python 库（wbdata, pandas, datetime 等等）。 如前所述，我们可以使用几个 get 函数查看世行提供的数据类别。默认情况下，这些函数会直接将结果打印在标准输出上。如果希望将返回的数据储存在一个数据结构里，我们可以传入 display = False 参数。 12345678910111213141516171819202122232425262728293031323334353637383940In [13]: wbdata.get_source()11 Africa Development Indicators36 Statistical Capacity Indicators31 Country Policy and Institutional Assessment (CPIA)41 Country Partnership Strategy for India26 Corporate Scorecard1 Doing Business...43 Wealth accounting2 World Development Indicators3 Worldwide Governance IndicatorsIn [14]: wbdata.get_country()...UZB UzbekistanVCT St. Vincent and the GrenadinesVEN Venezuela, RBVGB British Virgin IslandsVIR Virgin Islands (U.S.)VNM VietnamVUT VanuatuWLD WorldWSM SamoaXKX KosovoXZN Sub-Saharan Africa excluding South Africa and NigeriaYEM Yemen, Rep.ZAF South AfricaZMB ZambiaZWE ZimbabweIn [20]: topics = wbdata.get_topic(display = False)In [21]: type(topics)Out[21]: listIn [22]: type(topics[0])Out[22]: dictIn [23]: print topics[0]&#123;u'id': u'1', u'value': u'Agriculture &amp; Rural Development', u'sourceNote': u"For the 70 percent of the world's poor who live in rural areas, agriculture is the main source of income and employment. But depletion and degradation of land and water pose serious challenges to producing enough food and other agricultural products to sustain livelihoods here and meet the needs of urban populations. Data presented here include measures of agricultural inputs, outputs, and productivity compiled by the UN's Food and Agriculture Organization."&#125; 这些代码，展现了世行数据库的冰山一角，但已足见世行数据库的强大了。 接下来，我们看看 serach 函数如何使用。比如我们想检索和中国以及美国相关的数据，特别关注的是人均 GDP。首先我们试着检索中国和美国在世行数据库里的缩写。 12345678910In [27]: wbdata.search_countries('china')CHN ChinaHKG Hong Kong SAR, ChinaMAC Macao SAR, ChinaTWN Taiwan, ChinaIn [28]: wbdata.search_countries('united')ARE United Arab EmiratesGBR United KingdomUSA United States 通过 search_countries 函数，我们很容易地就能找到中国和美国对应的缩写分别为 CHN 和 USA。如果你希望查询其他国家的数据，在这里也可以很简单地检索到。 接下来，我们希望查询人均 GDP 的相关情况。我们知道人均 GDP 的英文写法是 GDP per capita（如果你不知道，那么你应该补补课了），我们试着在世行的数据库里检索和人均 GDP 相关的指标。 1234567891011121314In [29]: wbdata.search_indicators('GDP per capita')GDPPCKD GDP per Capita, constant US$, millionsGDPPCKN Real GDP per Capita (real local currency units, various base years)NV.AGR.PCAP.KD.ZG Real agricultural GDP per capita growth rate (%)NY.GDP.PCAP.CD GDP per capita (current US$)NY.GDP.PCAP.KD GDP per capita (constant 2000 US$)NY.GDP.PCAP.KD.ZG GDP per capita growth (annual %)NY.GDP.PCAP.KN GDP per capita (constant LCU)NY.GDP.PCAP.PP.CD GDP per capita, PPP (current international $)NY.GDP.PCAP.PP.KD GDP per capita, PPP (constant 2005 international $)NY.GDP.PCAP.PP.KD.ZG GDP per capita, PPP annual growth (%)SE.XPD.PRIM.PC.ZS Expenditure per student, primary (% of GDP per capita)SE.XPD.SECO.PC.ZS Expenditure per student, secondary (% of GDP per capita)SE.XPD.TERT.PC.ZS Expenditure per student, tertiary (% of GDP per capita) 我们注意到，其中有一个名为 NY.GDP.PCAP.PP.CD 的指标。它的含义是：人均 GDP 占比按实际购买力折算之后以美元计价的值。听起来是一个高大上的指标，不是吗？我们试着以它为例，获取所需的数据。 wbdata 提供了 get_data 函数，用以获取数据。 12345678910In [50]: res = wbdata.get_data('NY.GDP.PCAP.PP.CD', country = ['CHN', 'USA'])In [51]: type(res)Out[51]: listIn [52]: type(res[0])Out[52]: dictIn [53]: print res[0]&#123;u'date': u'2016', u'country': &#123;u'id': u'CN', u'value': u'China'&#125;, u'indicator': &#123;u'id': u'NY.GDP.PCAP.PP.CD', u'value': u'GDP per capita, PPP (current international $)'&#125;, u'decimal': u'1', u'value': None&#125; Pandas 是 Python 里处理数据表格常用的库，wbdata 提供了对 Pandas 良好的支持。 1234567891011121314151617181920212223242526272829303132333435363738394041424344In [56]: countries = ['CHN', 'USA'] ...: indicators = &#123;'NY.GDP.PCAP.PP.CD' : 'GDP per capita, PPP (current international $)'&#125; ...: dt = (datetime.datetime(2000, 1, 1), datetime.datetime(2017, 1, 1)) ...: df = wbdata.get_dataframe(indicators, country = countries, convert_date = False, data_date = dt) ...:In [57]: dfOut[57]: GDP per capita, PPP (current international $)country dateChina 2016 NaN 2015 14450.174744 2014 13439.907642 2013 12367.965864 2012 11351.062843 2011 10384.367317 2010 9333.124882 2009 8374.432850 2008 7635.073139 2007 6863.982229 2006 5883.719784 2005 5092.560189 2004 4455.205330 2003 3961.274167 2002 3551.663897 2001 3226.848680 2000 2933.315020United States 2016 NaN 2015 56115.718426 2014 54539.665575 2013 52749.911240 2012 51433.047090 2011 49781.800656 2010 48374.086793 2009 47001.555350 2008 48401.427340 2007 48061.537661 2006 46437.067117 2005 44307.920585 2004 41921.809762 2003 39677.198348 2002 38166.037841 2001 37273.618103 2000 36449.855116 接下来，我们可以使用 matplotlib 将中美两国的指标绘制出来。 12345678In [63]: dfu = df.unstack(level = 0) ...: dfu.plot() ...: plt.legend(loc = 'best') ...: plt.title('GDP per capita, PPP (current international $)') ...: plt.xlabel('Year') ...: plt.ylabel('GDP per capita, PPP (current international $)') ...: plt.show() ...: 如此我们得到图像。 小结上一节中，我们介绍了人们使用 wbdata 与世行数据库交互的典型步骤。据此，你应该能获取到大多数你想要的数据。 关于 wbdata 更多的介绍，你可以参考它的官方文档。 关于 matplotlib，你可以在前作中找到相关用法的介绍。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>World Bank</tag>
        <tag>wbdata</tag>
        <tag>Pandas</tag>
        <tag>Matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[100 行代码实现 PageRank 算法]]></title>
    <url>%2F2017%2F04%2F04%2FPython-100-lines-of-PageRank%2F</url>
    <content type="text"><![CDATA[搜索引擎是现代互联网的基础设施之一，而 ranking 则是搜索引擎的需要解决的核心问题。 最早尝试对搜索结果进行 ranking 的应该是 Yahoo 公司，但最终革命性突破的是 Google 公司的 Larry Page 与 Sergey Brin 发明的 PageRank 算法。 简介PageRank 算法的表述很简单，大体上只需要几句话就能表述清楚（不包含一些细微的修正）： 将整个互联网，看做一张有向图 网页是图上的点 链接是图上的有向边 每个网页都有一个权威性得分，称作 PageRank，可以把它当做是一种「投票权」 将每一个超链接作为一次「投票」 每个网页的 PageRank 等于所有具有指向该网页超链接的网页的 PageRank 的加权和 这些权值等于这些网页各自向外链接数目的倒数 PageRank 算法的高明之处，我认为有两点： 在表述上清晰明了，所谓简单就是美； 将互联网作为一个整体来对待，暗合系统论的观点。 按照《数学之美》（吴军）的说法，PageRank 的算法思想主要来自于 Larry Page，而 Sergey Brin 则将其转化为矩阵的迭代运算并证明其收敛性（解决了鸡生蛋生鸡的悖论）。 Python 实现以下是用 Python 实现的 PageRank 算法——当然，没有做任何计算上的优化，仅用于展现算法本身。 原始数据下载：https://course.ccs.neu.edu/cs6200f14/wt2g_inlinks；需要预处理。 PageRank.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100class Vertex: def __init__(self): self.in_degree = 0 self.out_degree = 0 self.pagerank = 0.0class Edge: def __init__(self, start, end): self.start_id = start self.end_id = enddef addVertex(vertex_name, vtx_map): ''' return the id of vertex_name if exists in vtx_map, return directly if not exists, add it, and then return vertex_name: string, the url of a web page vtx_map: dict, the map from url to id ''' res_id = 0 if vertex_name in vtx_map: return vtx_map[vertex_name] else: res_id = len(vtx_map) vtx_map[vertex_name] = res_id return res_iddef readTable(fname, vtx_map, edge_list): ''' read fname line by line, update the vtx_map and edge_list fname: string, the file name of the table vtx_map: dict, the map from url to id edge_list: list, the list of all edges ''' with open(fname, 'r') as fin: for line in fin.readlines(): tmp = line.strip().split('\t') assert(len(tmp) == 2) start = addVertex(tmp[0], vtx_map) end = addVertex(tmp[1], vtx_map) edge_list.append(Edge(start, end)) return Nonedef initialize(vtx_map, edge_list, vtx_list): ''' initialize the data structures vtx_map: dict, the map from url to id edge_list: list, the list of all edges vtx_list: list, the list of all vertices ''' vtx_num = len(vtx_map) assert(vtx_num &gt; 0) vtx_list = [Vertex() for _ in range(vtx_num)] for i in range(vtx_num): vtx_list[i].pagerank = 1.0 / vtx_num for edge in edge_list: vtx_list[edge.start_id].out_degree += 1 vtx_list[edge.end_id].in_degree += 1 return Nonedef calcPagerank(alpha, num_iter, vtx_map, edge_list): ''' calc PageRank for all vertices return: vtx_list, list, the list of all vertices alpha: float, damping factor num_iter: int, the upper limitation of calculation vtx_map: dict, the map from url to id edge_list: list, the list of all edges ''' vtx_list, pr_list = list(), list() initialize(vtx_map, edge_list, vtx_list) vtx_num = len(vtx_list) assert(vtx_num &gt; 0) alpha = float(alpha) for _ in range(num_iter): pr_list = [alpha / vtx_num for _ in range(vtx_num)] # calc for edge in edge_list: pr_list.append((1 - alpha) * vtx_list[edge.start_id].pagerank / \ vtx_list[edge.start_id].out_degree) # revise revise = sum(map(lambda vtx: (1 - alpha) * vtx.pagerank / vtx_num, \ filter(lambda vtx:(vtx.out_degree == 0), vtx_list))) # update for i in range(vtx_num): vtx_list[i].pagerank = pr_list[i] + revise return vtx_listdef doCalcPageRank(fname = 'wt2g_inlinks.source', alpha = 0.15, num_iter = 30): vtx_map = dict() edge_list = list() readTable(fname, vtx_map, edge_list) return calcPagerank(alpha, num_iter, vtx_map, edge_list)if __name__ == '__main__': print doCalcPageRank()]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PageRank</tag>
        <tag>Ranking</tag>
        <tag>Search Engine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么不能在动态库里静态链接？]]></title>
    <url>%2F2017%2F04%2F03%2Fnot-to-link-libstdc-statically-and-why%2F</url>
    <content type="text"><![CDATA[因为各种复杂的原因，工作中遇到了某个模块当中的一个动态库（Linux Dynamic Shared Object，我们称其为 A.so）需要使用与整个模块不同版本的 gcc 进行编译。由于 A.so 使用了高版本 libstdc++.so 中提供的接口；因此，如果让 A.so 与整个模块运行在同一个环境（即，依赖同一个低版本的 libstdc++.so），那么，整个程序运行时将会由动态链接器提示「找不到符号」的错误。 一个「看似」可行的解决办法，是在编译 A.so 的时候，将对应的高版本的 libstdc++ 以静态的方式链接到 A.so 里面。这样，如果能把来自高版本 libstdc++.a 的符号隐藏起来（不暴露给动态链接器，避免符号冲突），那么就可以解决问题了。 然而，这个解决办法，实际上是不可行的。本文将分析为什么不可行。 静态链接的优缺点总结起来，静态链接有如下优点 得到单一的文件，可以拷贝到所有体系结构相同的操作系统上运行； 对环境的依赖少，在缺少相应动态库的环境里也可以运行； 因为减少了动态链接的步骤，所以运行起来会快一些（某些情况下）； 因为在链接时，链接器可以看到所有符号，并进行符号解析，所以链接器可以硬编码函数的入口地址，故而函数调用会快一些； 因为在链接时，链接器可以看到所有的符号，所以链接器可以优化删除一些没有被引用的符号，一定程度上减小编译出的文件的体积； 能够明确地知道程序使用的依赖库的版本，而无需担心 LD_LIBRARY_PATH/LD_PATH 的影响。 当然，静态链接也会有缺点（反过来就是动态链接的优点） 因为要把所有的符号都打包在一个文件当中，所以文件的体积会显著增大； 对于依赖的动态库，不论内存中是否有已经载入的副本（特别是 .text 段），对于静态链接的程序，这部分指令都必须重复载入内存，因此内存会消耗得很快； 对于依赖的动态库，但凡有任何更新，升级程序都必须整个编译、发布走一圈，无法简单地替换 .so 升级。 对装载的影响上述优缺点，实际是站在一个非常 general 的角度对静态链接和动态链接的讨论。在本篇开头处提及的问题，实际上就是希望用到最后一条优点，让 A.so 引用指定版本的 libstdc++。 但是，在链接生成动态链接库的时候，静态链接依赖另一个静态库，是一种非常规的方法。实际上，这是一种不可行的方法。 为了说明这个问题，我们需要对程序装载进内存的过程做一个简单的梳理。 当我们在 Linux bash 当中执行命令启动一个进程的时候，bash 实际上会先做一个 fork() 系统调用，而后在子进程里做一个 execve() 系统调用执行指定的 ELF 可执行文件，原先的进程则返回等待。GLIBC 对 execve() 系统调用做了封装，提供了诸如 execlp() 的函数；但这些函数内里都会去执行 execve() 系统调用。 以下代码实现了一个简单的 minibash，模拟展示了启动一个进程的过程。 minibash.c1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;const size_t buf_size = 1024;int main () &#123; char buf[buf_size] = &#123;0&#125;; pid_t pid; while (1) &#123; printf("minibash $ "); scanf("%s", buf); pid = fork(); if (0 == pid) &#123; if (execlp(buf, 0) &lt; 0) &#123; printf("exec error\n"); &#125; &#125; else if (pid &gt; 0) &#123; int status; waitpid(pid, &amp;status, 0); &#125; else &#123; pritnf("fork error %d\n", pid); &#125; &#125; return 0;&#125; 当执行到 execve() 系统调用时，就会进入到对应的 sys_execve() 入口。这标志着由用户态向内核态的转变，同时也标志着装载的开始。对于 ELF 可执行文件，之后的调用顺序是 sys_execve() - 进行参数检查； do_execve() - 找到可执行文件，读取头部的 128 字节（用以判断可执行文件的类型，例如 ELF 可执行文件的前两个字节是 0x7F，即 ELF）； load_elf_binary() 检查文件格式 寻找 .interp 段，设置动态链接器的路径 设置 ELF 各个段（section）对 VMA 的段（segment）的映射关系 初始化 ELF 的进程环境 返回入口地址（静态链接程序：e_entry，动态链接程序：动态链接器） 之后，系统将从内核态转回用户态，并且将控制权交给上述入口地址的指令。对于静态链接的程序来说，e_entry 记录的是整个程序的入口；从内核态转回到用户态之后，进程就从此开始执行。对于动态链接的程序来说，它们的入口是系统提供的动态链接器；从内核态转回到用户态之后，系统将控制权交给动态链接器，由动态链接器完成动态链接过程，而后再跳转到整个程序的真正入口。动态链接器大致完成这些工作： 启动动态链接器本身，完成自举（Bootstrap）； 装载所有依赖的动态库（通常是广度优先遍历，但也可以是深度优先遍历）； 处理全局符号表，完成重定位和初始化； 将系统控制权交给程序的真正入口。 关于链接、装载的详细内容，可以期待「程序员的自我修养」系列文章。 注意到，我们的模块依赖了 A.so。那么，毫无疑问，这是一个动态链接的程序。我们应该注意到，在进程装载的过程中，首先会完成所有可执行 ELF 文件本身的装载（ELF 到虚存空间的映射），而后才会进入到动态链接库的装载。此外，在动态链接库的装载过程中，动态链接库只会处理以来的动态库（Dynamic Shared Objects，即各种 .so 文件）。也就是说，动态链接程序的装载过程可以分成两个步骤： 装载可执行 ELF 文件静态链接的部分； 装载所有依赖的 .so 部分。 我们注意到，被 .so 依赖的静态库 .a 是没有机会被装载进内存的。因此，在生成 A.so 的过程中，将 libstdc++.a 静态链接进去，是不可行的。因为，这部分静态链接的指令永远没有机会被装载进进程空间执行。因此，若要解决这个问题，就只有将 libstdc++.a 解包成各个普通的目标文件 .o，而后使用链接器 ld 将这些目标文件链接打包进 A.so 当中。 符号冲突现在，我们将 libstdc++ 的各个目标文件都链接进了 A.so。那么，A.so 当中会包含 libstdc++ 中的所有符号。 现在的问题是，几乎所有的使用 C++ 编写的可执行程序，都会直接或者间接地依赖 libstdc++.so。因此，当动态链接器尝试装载 libstdc++.so 和 A.so 的时候，就会有大量来自 libstdc++ 的符号重复了。这就牵扯到了所谓全局符号调解（Global Symbol Interpose）的问题。 对于 Linux 下的动态链接器，全局符号调解的策略很简单：先读入全局符号表的符号生效，后读入的符号被直接忽略丢弃。 因此，在这种情况下，我们无法预见整个模块使用的 libstdc++ 究竟是来自于系统环境，还是来自于 A.so 中包含的那些部分。因为，这取决于动态链接器装载动态库的顺序。 为此，我们需要在链接生成 A.so 的时候，将 libstdc++ 所含的那些符号隐藏起来。 全局变量更新导致的运行时问题我们回顾一下，至此我们做了这些事情： 将 libstdc++.a 解包成各个 .o 文件； 将来自 libstdc++ 的各个 .o 文件，编译进 A.so，并隐藏这些符号。 至此，我们的程序在链接和装载的过程中，不会遇到任何问题——系统能够正常地将控制权交给模块真正的入口了。但是，如此解决方案仍然有问题。 众所周知，诸如 libstdc++/libpthread 这些库，会在进程空间自行维护一套全局变量和数据结构，用于维护和记录当前的运行状态。很多第三方库，也会有类似的全局变量和数据结构。现在，我们为了使得两个版本的 libstdc++（来自系统环境的，以及来自 A.so 的）在符号的层面上得以共存，就引起了这样的问题：整个进程空间里，这些全局变量和数据结构存在了两份。比如 文件描述符（FD，File Description)； 内存边界； 错误码 errorno； libpthread 的定时器等。 这样一来，在这些全局变量和数据结构的角度，进程在运行时就会出现很多自相矛盾的状态；甚至直接引起运行时异常。而因为全局变量和数据结构存在两份，这些问题在追查的过程中会极其困难。 回顾整个过程，我们不难发现，这样的需求会产生很多问题。尽管从编译、链接、装载的角度，我们可以用一些很 tricky 的方法解决问题；但是，等到程序执行过程中，仍然可能会隐藏各种难以发现、解决的问题。因此，我们说不应该尝试向动态库静态编译标准库或第三方库。 附录：如何将依赖的库静态链接进可执行程序我们先来看一个耳熟能详的 Hello world! 程序。 hello.cpp123456789#include &lt;iostream&gt;using std::cout;using std::endl;int main() &#123; cout &lt;&lt; "Hello world!" &lt;&lt; endl; return 0;&#125; 众所周知，如果要将它编译为可执行程序，只需要执行 g++ hello.cpp -o hello 就可以了。在这个过程中，g++ 这个命令，隐藏了编译、链接的细节。我们在这里把步骤拆开，依次进行。 首先，我们对其进行编译。 1$ g++ -c hello.cpp -o hello.o 在这里，-c 参数告知 g++ 命令，我们只希望编译就可以了，之后的链接不要自动执行。 我们知道，编译器会将代码中的函数、变量等，翻译成一个个的符号（symbol）。我们可以用 nm 命令，查看 hello.o 当中包含了哪些符号。而后可以用 c++filt 命令，查看符号背后对应的函数签名或者变量名。 12345678910111213141516171819$ nm hello.o | wc -l14$ nm hello.o000000000000003e t _GLOBAL__I_main0000000000000000 t _Z41__static_initialization_and_destruction_0ii U _ZNSolsEPFRSoS_E U _ZNSt8ios_base4InitC1Ev U _ZNSt8ios_base4InitD1Ev U _ZSt4cout U _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_0000000000000000 b _ZSt8__ioinit U _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc U __cxa_atexit U __dso_handle U __gxx_personality_v00000000000000054 t __tcf_0000000000000006c T main$ c++filt _Z41__static_initialization_and_destruction_0ii__static_initialization_and_destruction_0(int, int) 我们看到，hello.o 当中，只有 14 个符号。并且，在这些符号中，有很多是未定义的符号——第二列提示 U 表示未定义。这表明，hello.o 用到了这些符号，但是这些符号对应的函数、变量，定义在其他目标文件当中。 接下来我们执行链接这一步。 1234567891011121314151617$ g++ hello.o -o hello$ ./helloHello world!$ nm hello | wc -l49$ nm hello0000000000600ae8 d _DYNAMIC0000000000600cb0 d _GLOBAL_OFFSET_TABLE_0000000000400816 t _GLOBAL__I_main0000000000400958 R _IO_stdin_used w _Jv_RegisterClasses00000000004007d8 t _Z41__static_initialization_and_destruction_0ii U _ZNSolsEPFRSoS_E@@GLIBCXX_3.4 U _ZNSt8ios_base4InitC1Ev@@GLIBCXX_3.4 U _ZNSt8ios_base4InitD1Ev@@GLIBCXX_3.4...0000000000400844 T main 经过链接之后，可执行文件 hello 当中的符号多了不少：从 14 个增加到了 49 个。这说明，经过链接之后，可执行文件补充了一些执行过程中需要的符号。但是我们也看到，在 hello 当中，仍然存在被标记为 U 的未定义的符号。这说明，hello 在运行时仍旧会动态地依赖系统中的动态库。我们可以用 ldd 命令查看一个 ELF 文件依赖的动态库。 1234567$ ldd hello linux-vdso.so.1 =&gt; (0x00007fffb3bfd000) libstdc++.so.6 =&gt; /opt/gcc/lib64/libstdc++.so.6 (0x00002ada4968e000) libm.so.6 =&gt; /lib64/libm.so.6 (0x0000003576c00000) libgcc_s.so.1 =&gt; /opt/gcc/lib64/libgcc_s.so.1 (0x00002ada49996000) libc.so.6 =&gt; /lib64/libc.so.6 (0x0000003576000000) /lib64/ld-linux-x86-64.so.2 (0x0000003575c00000) 这里 linux-vdso.so.1 是 Linux 的一个内核模块； libstdc++.so.6 是 C++ 标准库对应的动态库； libm.so.6/libgcc_s.so.1/libc.so.6 都是 gcc 相关的动态库； /lib64/ld-linux-x86-64.so.2 则是动态链接器对应的动态库（实际上也是一个可执行的 ELF）。 如果想要将这些依赖的动态库对应的符号，都静态链接到可执行文件中的话，则需要在链接的时候加上 -static 参数。 123456789$ g++ hello.o -o hello -static$ ./helloHello world!$ nm hello | wc -l4425$ ldd hello not a dynamic executable$ nm hello | grep " U " U __tls_get_addr 我们看到，相对不加 -static 参数的版本，新的 hello 多出了四千多个符号；并且，以 ldd 查看 hello 依赖的动态库，命令提示 hello 没有依赖其他的动态库；最后，我们发现，hello 的所有符号中，仅有 __tls_get_addr 是未定义的。 tls 是 Thread Local Storage 的缩写，__tls_get_addr() 接收一个参数（数据结构 tls_index 的起始地址），返回一个 Thread Local Variable 的在当前段的偏移量和长度。这个函数是专为动态链接器设计的，在静态链接时这个符号对应的函数无意义（参见 ELF/SymbolTable.cpp）。 因此，我们说，对于静态链接版本的 hello 来说，它已经包含了运行所需的所有符号。 若是想要静态链接 libstdc++，其他的部分依然保留动态链接，则可以使用 g++ 的参数 -static-libstdc++。 123456789101112$ g++ hello.o -o hello -static-libstdc++$ ./helloHello world!$ ldd hello linux-vdso.so.1 =&gt; (0x00007fffcd5fd000) libm.so.6 =&gt; /lib64/libm.so.6 (0x0000003576c00000) libgcc_s.so.1 =&gt; /opt/gcc/lib64/libgcc_s.so.1 (0x00002b6ccb401000) libc.so.6 =&gt; /lib64/libc.so.6 (0x0000003576000000) /lib64/ld-linux-x86-64.so.2 (0x0000003575c00000)$ nm hello | wc -l3022$ nm hello | grep " U " | grep -v GLIBC | grep -v GCC 可以看到，使用 -static-libstdc++ 之后，hello 不再依赖 libstdc++.so 了。同时，其中包含的符号相比动态链接 libstdc++ 的版本要多出不少，而相对完全静态链接的版本又少了不少；介于二者之间。此外，我们也验证了，hello 中包含的未定义的符号，除开 GLIBC 和 GCC 相关的符号之外，就没有了。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Linking</tag>
        <tag>Loading</tag>
        <tag>Static</tag>
        <tag>Dynamic</tag>
        <tag>Shared Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈 L1 与 L2-正则项]]></title>
    <url>%2F2017%2F03%2F30%2FL1-and-L2-regularizer%2F</url>
    <content type="text"><![CDATA[在前作里，我们讨论了机器学习里的偏差-方差权衡。机器学习里的损失函数（代价函数）可以用来描述模型与上帝真相（ground truth）之间的差距，因此可以解决「偏差」的问题。但是仅有损失函数时，我们无法解决方差的问题，因而会有过拟合风险。 今次我们讨论损失函数的反面——正则项，看看 $L_1$-正则项和 $L_2$-正则项是如何使机器学习模型走出过拟合的泥沼的。 损失函数与目标函数机器学习的目标，实际上就是找到一个足够好的函数 $F^{*}$ 用以预测真实规律。因此，首先我们要定义什么叫做「好」。 对于样本 $(\vec x, y)$ 来说，在机器学习模型 $F$ 的作用下，有预测值 $\hat y = F(\vec x)$。我们可以定义损失函数 $l(y, \hat y)$，来描述预测值 $\hat y$ 与上帝真相 $y$ 之间的差距。 $$l(y, \hat y) = l(y, F(\vec x)).$$ 一般来说，损失函数 $l: \mathbb R\times\mathbb R\mapsto \mathbb R$ 是一个有下确界的函数。当预测值 $\hat y$ 与上帝真相 $y$ 相差不多时，则损失函数的值能接近这个下确界；反之，当预测值 $\hat y$ 与上帝真相 $y$ 差距甚远时，损失函数的值会显著地高于下确界。 因此，在整个训练集上，我们可以把机器学习任务转化为一个最优化问题。我们的目标是在泛函空间内，找到能使得全局损失 $L(F)$ 最小的模型 $F$，作为最终模型 $F^{*}$。 $$ F^{*} = \mathop{\text{arg min}}_{F} E_{y,\,\vec x}\Bigl[l\bigl(y,\,F(\vec x)\bigr)\Bigr] = \mathop{\text{arg min}}_{F}L(F). $$ 这样的最优化问题解决了机器学习的大半任务，但是它只考虑了对数据的拟合，而忽视了模型本身的复杂度。因此，它留下了一个显而易见的问题：如何防止模型本身的复杂度过高，导致过拟合？为此，我们需要引入正则项（regularizer）$\gamma\Omega(F),\,\gamma &gt; 0$，用来描述模型本身的复杂度。于是我们的最优化目标变为 $$ F^{*} = \mathop{\text{arg min}}_{F}\text{Obj}(F) = \mathop{\text{arg min}}_{F}L(F) + \gamma\Omega(F). $$ 其中，$\text{Obj}(F)$ 称为目标函数（Objective Function）。 范数与正则项所谓范数，就是某种抽象的长度。范数满足通常意义上长度的三个基本性质： 非负性：$ \lVert\vec x\rVert\geqslant 0 $； 齐次性：$ \lVert c\cdot\vec x\rVert = \lvert c\rvert \cdot \lVert\vec x\rVert$； 三角不等式：$ \lVert \vec x + \vec y\rVert \leqslant \lVert\vec x\rVert + \lVert\vec y\rVert$。 在这里，我们需要关注的最主要是范数的「非负性」。我们刚才讲，损失函数通常是一个有下确界的函数。而这个性质保证了我们可以对损失函数做最优化求解。如果我们要保证目标函数依然可以做最优化求解，那么我们就必须让正则项也有一个下界。非负性无疑提供了这样的下界，而且它是一个下确界——由齐次性保证（当 $c = 0$ 时）。 因此，我们说，范数的性质使得它天然地适合作为机器学习的正则项。而范数需要的向量，则是机器学习的学习目标——参数向量。 机器学习中有几个常用的范数，分别是 $ L_0 $-范数：$ \lVert\vec x\rVert_0 = \#(i),\; \text{with }i\neq 0 $； $ L_1 $-范数：$ \lVert\vec x\rVert_1 = \sum_{i = 1}^{d}\lvert x_i\rvert $； $ L_2 $-范数：$ \lVert\vec x\rVert_2 = \Bigl(\sum_{i = 1}^{d}x_i^2\Bigr)^{1/2} $； $ L_p $-范数：$ \lVert\vec x\rVert_p = \Bigl(\sum_{i = 1}^{d}x_i^p\Bigr)^{1/p} $； $ L_\infty $-范数：$ \lVert\vec x\rVert_\infty = \lim_{p\to+\infty}\Bigl(\sum_{i = 1}^{d}x_i^p\Bigr)^{1/p} $。 在机器学习中，如果使用了 $\lVert\vec w\rVert_p$ 作为正则项；则我们说，该机器学习任务引入了 $L_p$-正则项。 $L_0$ 与 $L_1$-正则项（LASSO regularizer）在机器学习里，最简单的学习算法可能是所谓的线性回归模型 $$ F(\vec x; \vec w, b) = \sum_{i = 1}^{n} w_i\cdot x_i + b. $$ 我们考虑这样一种普遍的情况，即：预测目标背后的真是规律，可能只和某几个维度的特征有关；而其它维度的特征，要不然作用非常小，要不然纯粹是噪声。在这种情况下，除了这几个维度的特征对应的参数之外，其它维度的参数应该为零。若不然，则当其它维度的特征存在噪音时，模型的行为会发生预期之外的变化，导致过拟合。 于是，我们得到了避免过拟合的第一个思路：使尽可能多的参数为零。为此，最直观地我们可以引入 $L_0$-范数。令$$ \Omega\bigl(F(\vec x;\vec w)\bigr) \overset{\text{def}}{=} \ell_0\frac{\lVert\vec w\rVert_0}{n},\;\ell_0 &gt; 0, $$这意味着，我们希望绝大多数 $ \vec w $ 的分量为零。 通过引入 $L_0$-正则项，我们实际上引入了一种「惩罚」机制，即：若要增加模型复杂度以加强模型的表达能力降低损失函数，则每次使得一个参数非零，则引入 $\ell_0$ 的惩罚系数。也就是说，如果使得一个参数非零得到的收益（损失函数上的收益）不足 $\ell_0$；那么增加这样的复杂度是得不偿失的。 通过引入 $L_0$-正则项，我们可以使模型稀疏化且易于解释，并且在某种意义上实现了「特征选择」。这看起来很美好，但是 $L_0$-正则项也有绕不过去坎： 非连续； 非凸； 不可求导。 因此，$L_0$-正则项虽好，但是求解这样的最优化问题，难以在多项式时间内找到有效解（NP-Hard 问题）。于是，我们转而考虑 $L_0$-范数最紧的凸放松（tightest convex relaxation）：$L_1$-范数。令$$ \Omega\bigl(F(\vec x;\vec w)\bigr) \overset{\text{def}}{=} \ell_1\frac{\lVert\vec w\rVert_1}{n},\;\ell_1 &gt; 0, $$ 我们来看一下参数更新的过程，有哪些变化。考虑目标函数$$ \text{Obj}(F) = L(F) + \gamma\cdot\ell_1\frac{\lVert\vec w\rVert_1}{n}, $$有对参数 $ w_i $ 的偏导数$$ \frac{\partial\text{Obj}}{\partial w_i} = \frac{\partial L}{\partial w_i} + \frac{\gamma\ell_1}{n}\text{sgn}(w_i). $$因此有参数更新过程$$ w_i\to w&#39;_i \overset{\text{def}}{=} w_i - \eta\frac{\partial L}{\partial w_i} - \eta\frac{\gamma\ell_1}{n}\text{sgn}(w_i). $$因为 $\eta\frac{\gamma\ell_1}{n} &gt; 0$，所以多出的项 $ \eta\frac{\gamma\ell_1}{n}\text{sgn}(w_i) $ 使得 $ w_i \to 0 $，实现「稀疏化」。 $L_2$-正则项（Ridge Regularizer）让我们回过头，考虑前作中出现过的多项式模型的例子。它的一般形式是$$ F = \sum_{i = 1}^{n} w_i\cdot x^{i} + b. $$ 我们注意到，当多项式模型过拟合时，函数曲线倾向于「靠近」噪声点。这意味着，函数曲线会在噪声点之间来回扭曲跳跃。这也就是说，在某些局部，函数曲线的切线斜率非常高——函数导数的绝对值非常大。对于多项式模型来说，函数导数的绝对值，实际上就是多项式系数的一个线性加和。这也就是说，过拟合的多项式模型，它的参数的绝对值会非常大（至少某几个参数分量的绝对值非常大）。因此，如果我们有办法使得这些参数的值，比较稠密均匀地集中在零附近，就能有效地避免过拟合。 于是我们引入 $L_2$-正则项，令$$ \Omega\bigl(F(\vec x;\vec w)\bigr) \overset{\text{def}}{=} \ell_2\frac{\lVert\vec w\rVert_2^2}{2n},\;\ell_2 &gt; 0, $$因此有目标函数$$ \text{Obj}(F) = L(F) + \gamma\cdot\ell_2\frac{\lVert\vec w\rVert_2^2}{2n}, $$对参数 $ w_i $ 的偏导数，有$$ \frac{\partial\text{Obj}}{\partial w_i} = \frac{\partial L}{\partial w_i} + \frac{\gamma\ell_2}{n}w_i. $$再有参数更新$$ \begin{aligned} w_i\to w&#39;_i &amp;{}\overset{\text{def}}{=} w_i - \eta\frac{\partial L}{\partial w_i} - \eta\frac{\gamma\ell_2}{n}w_i\\ &amp;{}= \biggl(1 - \eta\frac{\gamma\ell_2}{n}\biggr)w_i - \eta\frac{\partial L}{\partial w_i}. \end{aligned} $$ 考虑到 $ \eta\frac{\gamma\ell_2}{n} &gt; 0 $，因此，引入 $ L_2 $-正则项之后，相当于衰减了（decay）参数的权重，使参数趋近于零。 $L_1$-正则项与 $L_2$-正则项的区别现在，我们考虑这样一个问题：为什么使用 $L_1$-正则项，会倾向于使得参数稀疏化；而使用 $L_2$-正则项，会倾向于使得参数稠密地接近于零？ 这里引用一张来自周志华老师的著作，《机器学习》（西瓜书）里的插图，尝试解释这个问题。 为了简便起见，我们只考虑模型有两个参数 $w_1$ 与 $w_2$ 的情形。 在图中，我们有三组「等值线」。位于同一条等值线上的 $w_1$ 与 $w_2$，具有相同的值（平方误差、$L_1$-范数或$L_2$-范数）。并且，对于三组等值线来说，当 $(w_1, w_2)$ 沿着等值线法线方向，像外扩张，则对应的值增大；反之，若沿着法线方向向内收缩，则对应的值减小。 因此，对于目标函数 $\text{Obj}(F)$ 来说，实际上是要在正则项的等值线与损失函数的等值线中寻找一个交点，使得二者的和最小。 对于 $L_1$-正则项来说，因为 $L_1$-正则项的等值线是一组菱形，这些交点容易落在坐标轴上。因此，另一个参数的值在这个交点上就是零，从而实现了稀疏化。 对于 $L_2$-正则项来说，因为 $L_2$-正则项的等值线是一组圆形。所以，这些交点可能落在整个平面的任意位置。所以它不能实现「稀疏化」。但是，另一方面，由于 $(w_1, w_2)$ 落在圆上，所以它们的值会比较接近。这就是为什么 $L_2$-正则项可以使得参数在零附近稠密而平滑。 幻灯片两篇文章对应的幻灯片可在这里下载。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Regularization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈 Bias-Variance Tradeoff]]></title>
    <url>%2F2017%2F03%2F25%2Fbias-variance-tradeoff%2F</url>
    <content type="text"><![CDATA[准确是两个概念。准是 bias 小，确是 variance 小。准确是相对概念，因为 bias-variance tradeoff。——Liam Huang 在机器学习领域，人们总是希望使自己的模型尽可能准确地描述数据背后的真实规律。通俗所言的「准确」，其实就是误差小。在领域中，排除人为失误，人们一般会遇到三种误差来源：随机误差、偏差和方差。偏差和方差又与「欠拟合」及「过拟合」紧紧联系在一起。由于随机误差是不可消除的，所以此篇我们讨论在偏差和方差之间的权衡（Bias-Variance Tradeoff）。 定义数学上定义首先需要说明的是随机误差。随机误差是数据本身的噪音带来的，这种误差是不可避免的。一般认为随机误差服从高斯分布，记作 $\epsilon\sim\mathcal N(0, \sigma_\epsilon)$。因此，若有变量 $y$ 作为预测值，以及 $X$ 作为自变量（协变量），那么我们将数据背后的真实规律 $f$ 记作 $$y = f(X) + \epsilon.$$ 偏差和方差则需要在统计上做对应的定义。 偏差（bias）描述的是通过学习拟合出来的结果之期望，与真实规律之间的差距，记作 $\text{Bias}(X) = E[\hat f(X)] - f(X)$。 方差（variance）即是统计学中的定义，描述的是通过学习拟合出来的结果自身的不稳定性，记作 $\text{Var}(X) = E\Bigl[\bigl(\hat f(X) - E[\hat f(X)]\bigr)^{2}\Bigr]$。 以均方误差为例，有如下推论 \begin{equation} \begin{aligned} \text{Err}(X) &amp;{}= E\Bigl[\bigl(y - \hat f(X)\bigr)^2\Bigr] \\ &amp;{}= E\Bigl[\bigl(f(X) + \epsilon - \hat f(X)\bigr)^2\Bigr] \\ &amp;{}= \left(E[\hat{f}(X)]-f(X)\right)^2 + E\left[\left(\hat{f}(X)-E[\hat{f}(X)]\right)^2\right] +\sigma_\epsilon^2 \\ &amp;{}= \text{Bias}^2 + \text{Variance} + \text{Random Error}. \end{aligned} \label{eq:err-comp} \end{equation} 直观的图示下图将机器学习任务描述为一个「打靶」的活动：根据相同算法、不同数据集训练出的模型，对同一个样本进行预测；每个模型作出的预测相当于是一次打靶。 http://scott.fortmann-roe.com/docs/BiasVariance.html 左上角的示例是理想状况：偏差和方差都非常小。如果有无穷的训练数据，以及完美的模型算法，我们是有办法达成这样的情况的。然而，现实中的工程问题，通常数据量是有限的，而模型也是不完美的。因此，这只是一个理想状况。 右上角的示例表示偏差小而方差大。靶纸上的落点都集中分布在红心周围，它们的期望落在红心之内，因此偏差较小。另外一方面，落点虽然集中在红心周围，但是比较分散，这是方差大的表现。 左下角的示例表示偏差大二方差小。显而易见，靶纸上的落点非常集中，说明方差小。但是落点集中的位置距离红心很远，这是偏差大的表现。 右下角的示例则是最糟糕的情况，偏差和方差都非常大。这是我们最不希望看到的结果。 举个栗子现在我们做一个模拟实验，用以说明至此介绍的内容。 首先，我们生成了两组 array，分别作为训练集和验证集。这里，x 与 y 是接近线性相关的，而在 y 上加入了随机噪声，用以模拟真实问题中的情况。 12345678910111213import numpy as npnp.random.seed(42) # the answer to life, the universe and everythingreal = lambda x:x + x ** 0.1x_train = np.linspace(0, 15, 100)y_train = map(real, x_train)y_noise = 2 * np.random.normal(size = x_train.size)y_train = y_train + y_noisex_valid = np.linspace(0, 15, 50)y_valid = map(real, x_valid)y_noise = 2 * np.random.normal(size = x_valid.size)y_valid = y_valid + y_noise 现在，我们选用最小平方误差作为损失函数，尝试用多项式函数去拟合这些数据。 1234prop = np.polyfit(x_train, y_train, 1)prop_ = np.poly1d(prop)overf = np.polyfit(x_train, y_train, 15)overf_ = np.poly1d(overf) 这里，对于 prop，我们采用了一阶的多项式函数（线性模型）去拟合数据；对于 overf，我们采用了 15 阶的多项式函数（多项式模型）去拟合数据。如此，我们可以把拟合效果绘制成图。 12345678910111213141516171819202122232425import matplotlib.pyplot as plt_ = plt.figure(figsize = (14, 6))plt.subplot(1, 2, 1)prop_e = np.mean((y_train - np.polyval(prop, x_train)) ** 2)overf_e = np.mean((y_train - np.polyval(overf, x_train)) ** 2)xp = np.linspace(-2, 17, 200)plt.plot(x_train, y_train, '.')plt.plot(xp, prop_(xp), '-', label = 'proper, err: %.3f' % (prop_e))plt.plot(xp, overf_(xp), '--', label = 'overfit, err: %.3f' % (overf_e))plt.ylim(-5, 20)plt.legend()plt.title('train set')plt.subplot(1, 2, 2)prop_e = np.mean((y_valid - np.polyval(prop, x_valid)) ** 2)overf_e = np.mean((y_valid - np.polyval(overf, x_valid)) ** 2)xp = np.linspace(-2, 17, 200)plt.plot(x_valid, y_valid, '.')plt.plot(xp, prop_(xp), '-', label = 'proper, err: %.3f' % (prop_e))plt.plot(xp, overf_(xp), '--', label = 'overfit, err: %.3f' % (overf_e))plt.ylim(-5, 20)plt.legend()plt.title('validation set') 以训练集上的结果来说，线性模型的误差要明显高于多项式模型。站在人类观察者的角度来说，这似乎是显而易见的：数据是围绕一个近似线性的函数附近抖动的，那么用简单的线性模型，自然就无法准确地拟合数据；但是，高阶的多项式函数可以进行各种「扭曲」，以便将训练集的数据拟合得更好。 这种情况，我们说线性模型在训练集上欠拟合（underfitting），并且它的偏差（bias）要高于多项式模型的偏差。 但这并不意味着线性模型在这个问题里，要弱于多项式模型。我们看到，在验证集上，线性模型的误差要小于多项式模型的误差。并且，线性模型在训练集和验证集上的误差相对接近，而多项式模型在两个数据集上的误差，差距就很大了。 这种情况，我们说多项式模型在训练集上过拟合（overfitting），并且它的方差（variance）要高于线性模型的偏差。此外，因为线性模型在两个集合上的误差较为接近，因此我们说线性模型在训练过程中未见的数据上，泛化能力更好。因为，在真实情况下，我们都需要使用有限的训练集去拟合模型，而后工作在无限的真实样本中，而这些真实样本对于模型训练过程都是不可见的。所以，模型的泛化能力，是非常重要的指标。 考虑到两个模型在验证集上的表现，在这个任务上，我们说线性模型表现得较好。 权衡之术克服 OCD对于很多人来说，不可避免地会有这样的强迫症：希望训练误差降至 0。 我们说，人想要过得快乐，首先要接纳自己，与自己和解。做机器学习相关的任务也是一样，首先要理解和接受机器学习的基本规律，克服自己的强迫症。 首先，对于误差，在公式 \ref{eq:err-comp} 中，我们得知误差中至少有「随机误差」是无论如何不可避免的。因此，哪怕有一个模型在训练集上的表现非常优秀，它的误差是 0，这也不能说明这个模型完美无缺。因为，训练集本身存在的误差，将会被带入到模型之中；也就是说，这个模型天然地就和真实情况存在误差，于是它不是完美的。 其次，由于训练样本无法完美地反应真实情况（样本容量有限、抽样不均匀），以及由于模型本身的学习能力存在上限，也意味着我们的模型不可能是完美的。 因此，我们需要克服强迫症，不去追求训练误差为 0；转而去追求在给定数据集和模型算法的前提下的，逼近最优结果。 最佳平衡点的数学表述在实际应用中，我们做模型选择的一般方法是： 选定一个算法； 调整算法的超参数； 以某种指标选择最合适的超参数组合。 也就是说，在整个过程中，我们固定训练样本，改变模型的描述能力（模型复杂度）。不难理解，随着模型复杂度的增加，其描述能力也就会增加；此时，模型在验证集上的表现，偏差会倾向于减小而方差会倾向于增大。而在相反方向，随着模型复杂度的降低，其描述能力也就会降低；此时，模型在验证集上的表现，偏差会倾向于增大而方差会倾向于减小。 考虑到，模型误差是偏差与方差的加和，因此我们可以绘制出这样的图像。 http://scott.fortmann-roe.com/docs/BiasVariance.html 图中的最优位置，实际上是 total error 曲线的拐点。我们知道，连续函数的拐点意味着此处一阶导数的值为 0。考虑到 total error 是偏差与方差的加和，所以我们有，在拐点处： \begin{equation} \newcommand{\dif}{\mathop{}\!\mathrm{d}} \frac{\dif\text{Bias}}{\dif\text{Complexity}} = - \frac{\dif\text{Variance}}{\dif\text{Complexity}} \label{eq:sweet} \end{equation} 公式 \ref{eq:sweet} 给出了寻找最优平衡点的数学描述。若模型复杂度大于平衡点，则模型的方差会偏高，模型倾向于过拟合；若模型复杂度小于平衡点，则模型的偏差会偏高，模型倾向于过拟合。 过拟合与欠拟合的外在表现尽管有了上述数学表述，但是在现实环境中，有时候我们很难计算模型的偏差与方差。因此，我们需要通过外在表现，判断模型的拟合状态：是欠拟合还是过拟合。 同样地，在有限的训练数据集中，不断增加模型的复杂度，意味着模型会尽可能多地降低在训练集上的误差。因此，在训练集上，不断增加模型的复杂度，训练集上的误差会一直下降。 因此，我们可以绘制出这样的图像。 http://www.learnopencv.com/bias-variance-tradeoff-in-machine-learning/ 因此， 当模型处于欠拟合状态时，训练集和验证集上的误差都很高； 当模型处于过拟合状态时，训练集上的误差低，而验证集上的误差会非常高。 处理欠拟合与过拟合有了这些分析，我们就能比较容易地判断模型所处的拟合状态。接下来，我们就可以参考 Andrew Ng 博士提供的处理模型欠拟合/过拟合的一般方法了。 欠拟合当模型处于欠拟合状态时，根本的办法是增加模型复杂度。我们一般有以下一些办法： 增加模型的迭代次数； 更换描述能力更强的模型； 生成更多特征供训练使用； 降低正则化水平。 过拟合当模型处于过拟合状态时，根本的办法是降低模型复杂度。我们则有以下一些武器： 扩增训练集； 减少训练使用的特征的数量； 提高正则化水平。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Tradeoff</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTeX 中的浮动体：处理超宽问题]]></title>
    <url>%2F2017%2F03%2F22%2Ffloats-in-LaTeX-handle-overfull-floats%2F</url>
    <content type="text"><![CDATA[前文说了，浮动体主要是处理高度比较大，又不方便分割的内容：比如图片和表格。实际上，此类内容除了在高度上可能很高，它们也可能很宽。LaTeX 在水平方向，会贴着版芯的左边边界，开始排列内容。因此，如果一张图片或者表格的宽度超过了版芯的宽度，那么看起来就像是没有居中，而是偏右。 此篇我们讲一下如何处理此类情况。 缩小对付内容过大，最直接的办法，就是把它们缩小。对于图片，如果使用了 graphicx 宏包，我们可以使用 width = \linewidth 的参数将图片缩放到正好填满页面宽度的大小，避免「超宽」。对于表格等其他内容，我们可以使用 graphicx 提供的 \resizebox 命令来处理。 12345678910111213141516171819202122\documentclass&#123;article&#125;\usepackage&#123;showframe&#125;\usepackage&#123;graphicx&#125;\begin&#123;document&#125;\begin&#123;table&#125;[!htb]\centering\caption&#123;Oh, this table is overfull!&#125;\label&#123;tab:overfull&#125;\rule&#123;1.1\linewidth&#125;&#123;3cm&#125;\end&#123;table&#125;\begin&#123;table&#125;[!htb]\centering\caption&#123;Imagine that this is a table.&#125;\label&#123;tab:resized&#125;\resizebox&#123;\linewidth&#125;&#123;!&#125;&#123;\rule&#123;1.1\linewidth&#125;&#123;3cm&#125;&#125;\end&#123;table&#125;\begin&#123;figure&#125;[!htb]\centering\includegraphics[width = \linewidth]&#123;example-image&#125;\caption&#123;A fit figure.&#125;\label&#123;fig:example-image&#125;\end&#123;figure&#125;\end&#123;document&#125; 想办法居中上述通过缩小解决问题，是一种办法。但是，在很多情况下，也会存在问题；比如 表格内容缩小之后，就看不清了； \verb 之类的内容，不能放在大多数 box 之内。 为此，我们需要用别的办法，尝试解决这些问题。 实际上，大多数用户对于这类问题最大的诉求在于：为什么这些超宽的图表不局中了？所以，我们只要解决「居中」的问题，可能就覆盖了绝大部分用户的需求。而这些内容无法居中的原因，我们在介绍部分也说过了：LaTeX 在水平方向，会贴着版芯的左边边界，开始排列内容。因此，如果我们能让 LaTeX 不从版芯的最左边开始排列内容，就有可能解决这个问题。 决定 LaTeX 从何处开始排列内容的，是 \leftskip 这个宏。在 LaTeX2e 中，它被默认定义为 \z@。也就是说，从版芯的左边边界处开始排列内容。我们可以修改这个宏，比如改为 \setlength{\leftskip}{-20pt}，那么 LaTeX 将从版芯左边边界左边的 20pt 的位置开始排列内容。 1234567891011\documentclass&#123;article&#125;\usepackage&#123;showframe&#125;\usepackage&#123;graphicx&#125;\begin&#123;document&#125;\begin&#123;table&#125;[!htb]\centering\caption&#123;Oh, this table is overfull!&#125;\label&#123;tab:overfull&#125;\setlength&#123;\leftskip&#125;&#123;-20pt&#125;\rule&#123;1.1\linewidth&#125;&#123;3cm&#125;\end&#123;table&#125;\end&#123;document&#125; 同理，我们有 \rightskip，用于确定水平方向排版的终止位置与版芯右边界之间的距离。 我们知道，TeX 的 skip 是所谓的「弹簧」，允许在一定程度上进行缩放；而所谓的居中，实际上就是在版芯两侧，有两个力量相等的无限弹簧，同时向中间挤压内容。因此，我们不难得到对 \leftskip 和 \rightskip 的几个要求： 默认情况，应该贴着两侧边界； 最差的情况，应该允许内容向左右两侧延伸，超过版芯但不超过纸张宽度； 同时具有让内容居中的能力。 因此，我们可以将它们设置为（粗略地）： 12\setlength&#123;\leftskip&#125;&#123;0pt plus 1fil minus \marginparwidth&#125;\setlength&#123;\rightskip&#125;&#123;\leftskip&#125; 为了让它更好用，我们可以把他们收纳在一个新的命令当中（包含了一些额外的工作）： 1234567891011121314151617\documentclass&#123;article&#125;\usepackage&#123;showframe&#125;\usepackage&#123;graphicx&#125;\makeatletter\newcommand*&#123;\centerfloat&#125;&#123;% \parindent \z@ \leftskip \z@ \@plus 1fil \@minus \marginparwidth \rightskip \leftskip \parfillskip \z@skip&#125;\makeatother\begin&#123;document&#125;\begin&#123;table&#125;[!htb]\centerfloat\caption&#123;Oh, this table is adjusted!&#125;\label&#123;tab:adjusted&#125;\rule&#123;1.1\linewidth&#125;&#123;3cm&#125;\end&#123;table&#125;\end&#123;document&#125; 当然，你也可以通过 \makebox 命令来达成目标，不过这样依然无法容纳含有类似 \verb 的内容： 12345678910\documentclass&#123;article&#125;\usepackage&#123;showframe&#125;\usepackage&#123;graphicx&#125;\begin&#123;document&#125;\begin&#123;table&#125;[!htb]\centering\caption&#123;Oh, this table is adjusted!&#125;\label&#123;tab:adjusted&#125;\makebox[0pt][c]&#123;\rule&#123;1.1\linewidth&#125;&#123;3cm&#125;&#125;\end&#123;table&#125;\end&#123;document&#125; 使用 adjustbox 宏包Martin Scharrer 有发布名为 adjustbox 的宏包，提供了类似 graphicx 宏包中 \includegraphics 命令的 key-value 参数，用以实现各类 box 效果。值得一提的是，宏包提供的几个宏、环境，都可以容纳 \verb 之类的内容。很是好用。 12345678910\documentclass&#123;article&#125;\usepackage&#123;showframe&#125;\usepackage&#123;adjustbox&#125;\begin&#123;document&#125;\begin&#123;table&#125;[!htb]\centering\caption&#123;Oh, this table is adjusted by the package adjustbox!&#125;\label&#123;tab:adjusted&#125;\adjustbox&#123;center&#125;&#123;\rule&#123;1.1\linewidth&#125;&#123;3cm&#125;&#125;\end&#123;table&#125;\end&#123;document&#125; 效果和使用我们定义的 \centerfloat 命令类似，这里就不重复贴图了。 倘若把它倒过来……上面的介绍，基本都仅限于处理 overfull 程度不大、超出版芯程度不多的情形。如果你有一个大胖娃娃，他/她使得版芯宽度严重超载，那么你可能要考虑把它旋转九十度了。 rotating 宏包提供了 sidewaystable 和 sidewaysfigure 环境（以及带 * 的版本，用于在双栏模式下通栏排版），分别作为对应 table 和 figure 的工具。使用这些环境，能使图表旋转 90° 摆放。 12345678910\documentclass&#123;article&#125;\usepackage&#123;showframe&#125;\usepackage&#123;rotating&#125;\begin&#123;document&#125;\begin&#123;sidewaystable&#125;[!htb]\centering\caption&#123;Let's rock!&#125;\label&#123;tab:rotated&#125;\rule&#123;0.8\linewidth&#125;&#123;3cm&#125;\end&#123;sidewaystable&#125;\end&#123;document&#125; 需要注意的是，当旋转过来之后，「长宽」就交换了。因此，我们这里使用 0.8\linewidth 实际上是相对版芯的高度的 0.8 倍。此外，rotating 宏包默认将内容逆时针旋转了 90°，你也可以在调用宏包时传入 clockwise 参数，得到顺时针旋转的版本。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Floats</tag>
        <tag>Overfull</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 C++ 中读取字符串中成对定界符中的子串]]></title>
    <url>%2F2017%2F03%2F13%2Fread-substrings-from-paired-delimiters-in-Cpp%2F</url>
    <content type="text"><![CDATA[这篇文章是一个简单的记录，解决类似这样的问题。 假设有一个字符串 1std::string = "&lt;foo:bar&gt; &lt;baz:qux&gt;"; 要怎样才能读出其中的 foo:bar 以及 baz:qux 呢？使用 regex 正则库当然是一个办法，不过在规整的情况下，我们还有更优雅的选择。 std::getlinestd::getline 函数来自头文件 string。因此，显而易见它是一个和字符串相关的函数。它有四个重载版本，具体如下： 1234istream&amp; getline (istream&amp; is, string&amp; str, char delim);istream&amp; getline (istream&amp;&amp; is, string&amp; str, char delim);istream&amp; getline (istream&amp; is, string&amp; str);istream&amp; getline (istream&amp;&amp; is, string&amp; str); 其中第 2 个和第 4 个版本，分别是第 1 个和第 3 个版本对应的右值引用版本。函数基本的作用，是自输入流读入内容，直至遇见定界符（带 delim 的版本）或者换行符 \n（不带 delim 的版本），并将读入的内容写入字符串 str（不包括定界符本身）。 值得注意的是，函数会修改输入流 is 本身，并且返回它的左值引用。这一特性意味着 std::getline 函数可以「串行」执行。 实际解析看看请看代码。 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;int main() &#123; const char LEFT_DELIM = '&lt;'; const char RIGHT_DELIM = '&gt;'; const char MID_DELIM = ':'; const std::string test = "&lt;foo:bar&gt; &lt;baz:qux&gt;"; std::istringstream iss(test); std::string skip, value; while (std::getline(std::getline(iss, skip, LEFT_DELIM), value, RIGHT_DELIM)) &#123; std::cout &lt;&lt; "-----" &lt;&lt; '\n'; std::istringstream iss(value); std::string key, value; while (std::getline(std::getline(iss, key, MID_DELIM), value)) &#123; std::cout &lt;&lt; key &lt;&lt; '\t' &lt;&lt; value &lt;&lt; '\n'; &#125; &#125; return 0;&#125; 在这里，我们将 test 与字符串输入流 iss 绑定。 而后用 std::getline 从 iss 中先后将内容读入 skip 和 value。在这里，内层的 std::getline(iss, skip, LEFT_DELIM) 首先执行，将 LEFT_DELIM 之前的内容（实际上是空字符串）读入 skip 变量，而后修改 iss 的状态，并返回它的左值引用作为外层 std::getline 的第一个参数。而后，外层的 std::getline 将第一次遇到 RIGHT_DELIM 之前的内容 foo:bar 读入 value 变量。如此循环。 进入到外层 while 循环的内部，我们采用了类似的策略，分别将冒号前后的内容，存入 key 和 value 两个变量。读者可以自行分析。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>Delimiters</tag>
        <tag>Substring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTeX 中的浮动体：基础篇]]></title>
    <url>%2F2017%2F03%2F11%2Ffloats-in-LaTeX-basic%2F</url>
    <content type="text"><![CDATA[此篇介绍一下 LaTeX 中的浮动体基本概念，以及最常见的几个问题。 浮动体是什么在实际撰写文稿的过程中，我们可能会碰到一些占据篇幅较大，但同时又不方便分页的内容。（比如图片和表格，通常属于这样的类型）此时，我们通常会希望将它们放在别的地方，避免页面空间不够而强行置入这些内容导致 overfull vbox 或者大片的空白。此外，因为被放在别的地方，所以，我们通常需要对这些内容做一个简单的描述，确保读者在看到这些大块的内容时，不至于无从下手去理解。同时，因为此类内容被放在别的地方，所以在文中引述它们时，我们无法用「下图」、「上表」之类的相对位置来引述他们。于是，我们需要对它们进行编号，方便在文中引用。 注意到，使用浮动体的根本目的是避免不合理的分页或者大块的空白，为此，我们需要将大块的内容移至别的地方。与之相辅相成的是浮动体的一些特性： 是一个容器，包含某些不可分页的大块内容； 有一个简短的描述，比如图题或者表题； 有一个编号，用于引述。 在 LaTeX 中，默认有 figure 和 table 两种浮动体。（当然，你还可以自定义其他类型的浮动体）在这些环境中，可以用 \caption{} 命令生成上述简短的描述。至于编号，也是用 \caption{} 生成的。这类编号遵循了 TeX 对于编号处理的传统：它们会自动编号，不需要用户操心具体的编号数值。 至于「别的地方」是哪里，LaTeX 为浮动体启用了所谓「位置描述符」的标记。基本来说，包含以下几种 h - 表示 here。此类浮动体称为文中的浮动体（in-text floats）。 t - 表示 top。此类浮动体会尝试放在一页的顶部。 b - 表示 bottom。此类浮动体会尝试放在一页的底部。 p - 表示 float page，浮动页。此类浮动体会尝试单独成页。 LaTeX 会将浮动体与文本流分离，而后按照位置描述符，根据相应的算法插入 LaTeX 认为合适的位置。 一个简单的实例123456789\documentclass&#123;article&#125;\begin&#123;document&#125;Figure \ref&#123;fig:dummy&#125; is a dummy figure to show the use of basic floats in \LaTeX&#123;&#125;.\begin&#123;figure&#125;[htb]\rule&#123;4cm&#125;&#123;3cm&#125; % a black box, treat it as a dummy figure\caption&#123;Dummy figure&#125;\label&#123;fig:dummy&#125;\end&#123;figure&#125;\end&#123;document&#125; 限制浮动效果有些强（chu）迫（nv）症（zuo）宝宝希望保留浮动体的标题以及编号的功能，但是希望浮动体「乖乖待在插入的位置」。 对于这些小朋友，老夫必须说：「这是病，得治」。 说它是「病」，是因为浮动效果本身是好的；相反，禁止浮动效果，可能导致页面出现大片的空白。另一方面，这些小朋友希望浮动体待在原地，很可能是习惯了「下图」、「上表」这样的引述方式；而没有使用科技论文标准的「图 1」、「表 2」的因数方式。 因此，老夫墙裂建议各位小朋友，不要管它，随它浮动去吧。 当然，在一些极端的情况，也会出现 LaTeX 无法很好地处理浮动体放置位置的情况。这时候需要我们做一些辅助工作，帮助和限制 LaTeX 的浮动算法。 如果希望避免浮动体跨过 \section 等章节标题，可以使用 placeins 宏包。它能在章节标题前，强制输出上一章节中尚未输出的浮动体。 1\usepackage[section]&#123;placeins&#125; 如果希望彻底禁止某个浮动体的浮动效果，可以使用 float 宏包提供的 H 位置选项。 123456\usepackage&#123;float&#125;% ...\begin&#123;figure&#125;[H]% ...\begin&#123;table&#125;[H]% ... 浮动体过多报错LaTeX 是有底线的上限的。LaTeX 会把所有尚未确定位置的浮动体，放入 \@freelist 中暂存。而 \@freelist 默认情况下，最多能处理 18 个浮动体。因此，在某些极端情况下，如果 LaTeX 暂时无法处理的浮动体数目超过 18 个时，就会报错。 1! LaTeX Error: Too many unprocessed floats. 此时有两种解决问题的思路： 强制输出所有尚未确定位置的浮动体，清空 \@freelist； 增强 LaTeX 的处理能力。 对于第一种思路，我们可以用 \clearpage，或者 placeins 宏包提供的 \FloatBarrier 命令。两个命令都会输出所有尚未输出的浮动体。不同的是，\clearpage 会做一些额外的工作，比如另起一页，继续排版。个人建议使用 \FloatBarrier 命令，遵循「一个命令只做好一件事」的原则。 如果使用了 \FloatBarrier 命令，还是经常会报错提示未处理的浮动体过多，那么就要考虑第二种思路了。对于第二种思路，我们可以使用 morefloats 宏包。\usepackage[morefloats = 18]{morefloats}，来增加 18 个槽位，以便能够向 \@freelist 放入更多的浮动体。 在 2015 年，David Carlisle 在新版的 LaTeX2e (2015) 中实现了 \extrafloats 命令，可以方便地新增更多的槽位。具体用法只需在导言区执行该命令即可：\extrafloats{500}。 浮动体上下的垂直距离最近总有人不爽 LaTeX 浮动体与周围文本的默认间距。LaTeX 浮动体相关的定义都可以在 source2e 当中找到，这里罗列重要的间距如下。 \floatsep - 相邻两个浮动体之间的垂直距离。 \textfloatsep - 页面中最后一个 t 模式的浮动体与文本的间距；页面中第一个 b 模式的浮动体与文本的间距。 \intextsep - 页面中共 h 模式的浮动体上下与文本的间距。 因此，你可以通过 \setlength 命令修改上述三个垂直距离，以便调整浮动体与前后文本的距离了。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Vertical</tag>
        <tag>Floats</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为 Git 仓库切换远程仓库]]></title>
    <url>%2F2017%2F02%2F23%2Fswitch-remote-repo-for-git%2F</url>
    <content type="text"><![CDATA[悲剧！ 如题图，GitHub 在北京时间 2017 年 2 月 23 日晚在中国大陆地区大部无法正常访问。那么，你挂在 GitHub 上的仓库们还好吗？ 此篇介绍如何为 Git 仓库重新设置远程仓库。 分布式版本控制Git 是一个分布式的版本控制系统。也就是说，它没有一个所谓的中心，事实上每一个副本都是地位等同的。比如说，你在 GitHub 上保存了一个仓库，同时你本机也有一个仓库的副本。那么你本机的仓库所存储的内容，和 GitHub 上的内容是完全一致的。这也就是说，你可以很轻易地在另一个地方部署你的仓库。 远程仓库设置Git 的远程仓库设置，需要用到 git remote 命令。 12345$ git remoteorigin$ git remote -vorigin git@github.com:&lt;username&gt;/&lt;repository&gt; (fetch)origin git@github.com:&lt;username&gt;/&lt;repository&gt; (push) 以上命令，展示了一个挂靠在 GitHub 上的仓库的一般状态。git remote 命令在终端上打印当前本地仓库关联的远程仓库的列表；git remote -v 中的参数 -v 表示 verbose，将详细的信息也打印出来了。 我们可以使用 git remote add 命令来增加一个远程仓库，或者用 git remote rm 来删除一个远程仓库。 12345678910$ git remote add test git@coding.net:&lt;username&gt;/&lt;repository&gt;$ git remote -vorigin git@github.com:&lt;username&gt;/&lt;repository&gt; (fetch)origin git@github.com:&lt;username&gt;/&lt;repository&gt; (push)test git@coding.net:&lt;username&gt;/&lt;repository&gt; (fetch)test git@coding.net:&lt;username&gt;/&lt;repository&gt; (push)$ git remote rm test$ git remote -vorigin git@github.com:&lt;username&gt;/&lt;repository&gt; (fetch)origin git@github.com:&lt;username&gt;/&lt;repository&gt; (push) 迁移到 Coding.NetCoding.Net 和 GitHub 一样，也提供基于 Git 的代码托管服务。你可以注册一个账号（获取 &lt;username&gt;），并建立一个仓库（获取 &lt;repository&gt;），然后在本地仓库执行下列代码，完成迁移 123$ git remote rm origin$ git remote add origin git@coding.net:&lt;username&gt;/&lt;repository&gt;$ git push origin master:master]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
        <tag>CodingNet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 git diff 查看差异]]></title>
    <url>%2F2017%2F02%2F20%2Fgit-diff-with-cached-files%2F</url>
    <content type="text"><![CDATA[这是一篇简单的记录。 在 git 中 使用 git diff 命令可以查看工作区与暂存区之间的差异。 使用 git diff &lt;gitreversion&gt; 命令可以查看工作区与指定版本之间的差异。 使用 git diff --cached 命令可以查看暂存区与当前 HEAD 指针指向版本之间的差异。 使用 git diff --cached &lt;gitreversion&gt; 命令可以查看暂存区与指定版本之间的差异。 使用 git diff -- &lt;file&gt; 可以查看特定文件在工作区与暂存区之间的差异。 使用 git diff &lt;gitreversion&gt; -- &lt;file&gt; 可以查看特定文件在工作区与指定版本之间的差异。 使用 git diff --cached -- &lt;file&gt; 可以查看特定文件在暂存区与当前 HEAD 指针指向版本之间的差异。 使用 git diff --cached &lt;gitreversion&gt; -- &lt;file&gt; 可以查看特定文件在暂存区与指定版本之间的差异。 图片来自：http://365git.tumblr.com/post/3464927214/getting-a-diff-between-the-working-tree-and-other]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Diff</tag>
        <tag>Cached</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在类模板定义的头文件之外实现类模板的成员函数]]></title>
    <url>%2F2017%2F02%2F19%2Fimplement-template-class-out-of-the-declaration-of-it%2F</url>
    <content type="text"><![CDATA[模板是一个 C++ 的高级特性，它使得程序员可以编写一个类或者函数，以相同的方式处理不同类型的数据。 前段时间在网上看到，有人认为类模板的成员函数必须实现在类模板的定义当中。这与我一直以来的认知是冲突的——我认为类模板和普通的类其实没有什么差别，除了它需要做额外的实例化之外。于是，我翻看了 C++ Primer，并检索了一些资料，就有了这篇文章。 模板编译C++ 中的模板，是一个很有意思的概念。说它有意思，是因为这个模板的概念，和现实生活中的模板非常相似。因此，实际上只需要理解了现实生活中的模板，理解 C++ 中的模板的一些特殊性就容易了。 学生在写论文的时候，经常会去网上检索「LaTeX 论文模板」。下载下来之后，论文模板实际上只有一个简单的骨架。学生们需要在这个骨架的基础上，书写、构建自己的内容，才能变成实际的论文。这个过程，我们称其为「实例化」；这是一个从一般到特殊的过程——从一个一般化的模板，填入自己的内容，变成自己的论文。 C++ 中的模板也是一样。当程序员定义了一个模板后，它只是一个骨架。而只有当编译器知道用户需要传入的模板类型参数之后，编译器才会给出一个「有血有肉」的函数（对应函数模板）或者类（对应类模板）。因此，对于模板的编译，我们需要知道：当我们使用模板时（具体来说，是实例化时），编译器才会根据模板的定义生成具体的代码。这个特性，决定了涉及到模板的错误检测时机可能与一般的代码有所差异。 类模板的特殊性对于普通的类，当我们使用这个类时，编译器必须能够知道类的定义。但是，类中的成员函数，则不必在编译时就能被编译器读到——可以在链接的过程中，再确定具体的类成员函数。因此，一个通常的做法是：在头文件中进行类的定义和类成员函数的声明；而在源文件中实现类的成员函数。 对于类模板来说，当我们使用这个类模板时，会传入模板类型参数，而后编译器会根据类模板和传入的类型参数生成类对应的代码。因此，此时编译器必须能够知道类的定义，也必须知道类中成员函数的实现。类模板的这一特殊性，使得在处理类模板相应的实现的时候，通常会把类模板的定义和成员函数的实现都放在头文件里。 在类模板的定义之外实现成员函数与普通的类相同，程序员既可以在类定义的内部实现成员函数，此时这些成员函数会被隐式地声明为 inline 的；程序员也可以在类定义的外部实现成员函数。不过，对于后者，会有需要注意的地方。 类模板的成员函数必然是函数模板 这是因为，类模板的成员函数和类模板共享模板参数；并且，类模板的每个实例，其成员函数都是互相独立的。因此，哪怕类模板的某个成员函数，完全不会用到模板参数，它也必须是一个函数模板，并且模板参数和类模板的参数保持一致。 在类模板实例化时，类模板的成员函数必须是可见的 这个原因，在上一节已经讲过了。 两种做法至此，我们可以讨论一下，在类模板定义的头文件之外实现其成员函数，具体要怎么做了。一般来说，有两种做法。 在头文件末尾引入实现源文件这样一来，成员函数的实现会被 #include 包含进头文件，实际上在编译器看来和写在头文件内没有本质的差别了。 foo.h12345678910#ifndef FOO_#define FOO_template&lt;typename T&gt;class Foo &#123; T val; void doSomething(T param);&#125;;#include "foo.tpp"#endif foo.tpp1234template&lt;typename T&gt;void Foo&lt;T&gt;::doSomething(T param) &#123; // do something&#125; 在实现时显示地实例化类模板这种情况下，只有实例化的版本才能被使用——因为只有它们真正被编译成了类代码；其它未实例化的版本，实际是没有定义的类。 bar.h12345678#ifndef BAR_#define BAR_template&lt;typename T&gt;class Bar &#123; T val; void doSomething(T param);&#125;;#endif bar.cpp12345678#include "bar.h"template&lt;typename T&gt;void Bar&lt;T&gt;::doSomething(T param) &#123; // do something&#125;template class Bar&lt;int&gt;;template class Bar&lt;double&gt;; 当编译过 bar.cpp 之后，其它包含头文件 bar.h 并与其目标文件链接的源文件，就可以使用 Bar&lt;int&gt; 和 Bar&lt;double&gt; 这两个类了。而使用其它版本，则会报错。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Template Class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C 和 C++ 中的指针]]></title>
    <url>%2F2017%2F02%2F05%2Fpointer-in-C-and-Cpp%2F</url>
    <content type="text"><![CDATA[指针是 C 语言的精髓。——无名氏指针是学业不精的程序员的大杀器。——Liam Huang C 和 C++ 中的指针，是语言中相当犀利的工具。但是它也是一把双刃剑，用得不好，就是毁灭整个工程的大杀器。此篇老调重弹，讲一讲 C 和 C++ 中的指针。 此篇别名：可能是中文网络中关于 C 和 C++ 指针最好的文章。 数据、指令和内存在冯诺依曼体系中，程序的数据和指令，是存放在同一空间中的。在 Linux 中，它们存放在进程的虚拟内存空间中。（相关内容可以关注「程序员的自我修养」系列文章，目前有：一/二/三）因此，对于进程来说，数据和指令其实没有本质的差别；其区别仅在于如何理解和使用虚存空间中的内容——如果读取虚存空间某个位置的值来使用，这块内容就是数据，如果执行虚存空间某个位置的代码，这块内容就是指令。决定如何理解和使用虚存空间中的内容的因素，是类型。具体到 C 和 C++ 语言来说，对应数据的那部分内存，当中存储的自然就是数据；对应函数的那部分内存，当中存储的就是指令。 因此，对于虚存空间中的内容来说，有两个关键要素： 它在哪里（内存地址是多少）； 它具有哪些属性、能做哪些事情（它的类型是什么）。 指针是对内存区域的抽象C 和 C++ 中的指针，是一种特殊的复合类型。指针变量中存放着目标对象的内存地址，而与指针相符合的类型，则说明了相应内存区域中的内容具有哪些属性，以及能做什么事情。也就是说，在内存空间某块区域中的内容，原本可以是不可解读的；但是，如果有一个描述这块内存区域的指针存在，我们就能找到它（地址的作用），并且合理地使用它（类型的作用）。因此，我们说：指针是对内存区域的抽象。 定义和使用指针指针的定义在 C 和 C++ 中定义指针变量是很简单的，和定义普通的变量基本是一样的。所有的区别，仅在于我们需要在变量名称前使用解引用符号 * 来标记这是一个指针。 12int *ip1, *ip2; // ip1 和 ip2 都是指向 int 类型变量的指针变量double d, *dp; // d 是 double 类型变量，dp 是指向 double 类型变量的指针变量 在上述定义中，我们看到，ip1, ip2, dp 是三个指针——因为在它们之前用 * 号标记处他们是指针；而 d 是一个普通的 double 类型变量。同时，我们注意到，ip1 和 ip2 在定义之时，就确定了他们是指向 int 类型的变量。这意味着，被 ip1 和 ip2 指向的内存，在使用 ip1 和 ip2 进行访问的时候，将被当做是 int 类型的对象来对待。同理，dp 指向的内存，在使用 dp 进行访问的时候，将被当做是 double 类型的对象来对待。 回顾一下，我们在第一节中提到，内存空间中的内容有两个关键要素：地址和类型。在上述定义过程中，我们通过类型与解引用符号 * 相结合，已经确定了类型。如果要正确使用指针，我们还应该让指针记录一个地址。 获取对象的地址上面说到，我们应该在定义指针之后，记录一个地址。在 C 和 C++ 中，我们需要使用取地址符号 &amp; 来获取对象的地址。 12int val = 42;int *p = &amp;val; // &amp;val 返回变量 val 的地址，记录在指向 int 类型变量的指针里 （绝大多数情况下，）指针的类型和对象的类型需要严格匹配。例如，你不能用一个指向 int 类型的指针变量，保存一个 double 类型的对象的地址。 123456double dval = 0.0;double *pd1 = &amp;dval; // 正确：pd1 保存 double 类型变量 dval 的地址double *pd2 = pd1; // 正确：pd1 是 double 类型的指针，可以赋值初始化同样类型的 pd2int *pi1 = &amp;dval; // 错误：不能用指向 int 类型变量的指针保存 double 类型变量的地址int *pi2 = pd1; // 错误：pd1 是 double 类型的指针，不能将其赋值给 int 类型的指针 访问指针指向的对象在下例中，指针 p 记录了变量 val 的地址。因此，我们可以通过解引用指针 p 来访问变量 val。 1234567int val = 42;int *p = &amp;val; // &amp;val 返回变量 val 的地址，记录在指向 int 类型变量的指针里cout &lt;&lt; *p &lt;&lt; endl; // 通过指针 p 访问变量 val，输出 val 的值：42*p = 360; // 通过指针 p 改变变量 val 的值cout &lt;&lt; *p &lt;&lt; endl; // 通过指针 p 访问变量 val，输出 val 的值：360cout &lt;&lt; val &lt;&lt; endl; // 输出 val 的值：360 空指针和空类型的指针空指针是不指向任何对象的指针，在实际编程中，通常使用空指针作为指针变量有效性的判断标准。 C 语言和老版本 C++ 的空指针字面值是 NULL，它定义在 stdlib 当中；新版本的 C++ 使用 nullptr 作为空指针字面值。C++ 还支持用字面值常量 0 初始化指针变量，被这样初始化的指针变量会是一个空指针。 1234567int *p1 = NULL; // C 风格的空指针初始化int *p2 = nullptr; // C++ 风格的空指针初始化int *p3 = 0; // 使用字面值常量 0 初始化空指针if (nullptr == p1) &#123; // 思考一下为什么不是 p1 == nullptr ; // do something&#125; 空类型的指针，指的是形如 void *pv 的指针。这是一类特殊的指针；这里的空类型，不是说没有类型，而是说空类型的指针，可以用于存储任意类型对象的地址。 1234567double pi = 3.14;void *pv = &amp;pi; // 使用 void * 存放了一个 double 类型对象的地址double *pd = &amp;pi;pd = pv; // 错误：不能将空类型的指针赋值给其他类型的指针pv = pd; // 正确：空类型的指针可以接受任意类型的指针赋值pd = (double *)pv; // 正确：C 风格的强制类型转换pd = reinterpret_cast&lt;double *&gt;(pv); // 正确：C++ 风格的强制类型转换 让我们回顾一下指针的两个要素：地址和类型。由于空类型的指针可以接受任意类型对象的地址，所以，当编译器拿到一个空类型的指针的时候，它无法知道应该按照何种方式解释和使用指针中记录地址中的内容。因此，空类型指针能够做的事情非常有限：做指针之间的比较、作为函数的输入或输出、赋值给另外一个空类型指针。 理解指针的定义再探变量声明在 C 和 C++ 中，变量的声明包括一个基本数据类型（或者类类型），以及一组声明符。定义指针使用的解引用符号 * 是类型修饰符，它是声明符的一部分。因此，在下列语句中，int 是基本数据类型，*p 是声明符，* 是类型修饰符作为声明符的一部分存在。 1int *p; 在同一个变量定义语句中，基本数据类型只能有一个，但是可以有多个形式相同或不同的声明符。这也就是说，同一个语句可以定义出不同类型的变量。 123// pi 是指向 int 型变量的指针；val 是 int 型变量int *pi = nullptr, val = 1024; 理解稍微复杂的指针定义因为指针本身也是变量，所以它当然也是存储在虚存空间里的。因此，我们当然也可以定义一个指向这一指针的指针。比如： 123int val = 1024;int *p = &amp;val;int **pp = &amp;p; 我们需要仔细理解一下 pp 的定义。理解这类稍微复杂的定义语句，一个基本的办法就是：从最靠近变量名字的地方开始，一层一层剖析变量的类型。我们来看 距离 pp 最近的是一个解引用符 *，这预示着 pp 是一个指针，它指向 int * 类型的变量； 再来看 int *，距离 *pp 最近的，依然是一个解引用符，这意味着 *pp 也是一个指针，它指向 int 类型的变量； 因此 pp 是一个指向指向 int 类型变量的指针的指针。 你可以仔细斟酌一下这段内容。 const 与指针常量的值在生存期内不允许改变。这一特性经常是有用的：可以定义一个常量，然后在多个地方使用；当认为这个常量的值不合适的时候，修改它的定义，即可在所有使用到它的地方生效（而无需依次手工修改）；此外，还可以防止程序意外修改这个值。定义常量，只需要在基本类型前，加上 const 关键字即可；它是 constant 的缩写，意为常量。 1const double pi = 3.141592653580793; 当 const 与指针牵扯到一起，就有些复杂了。至少有以下几种情况： 123456789101112131415161718192021int val = 0; // int 型变量const int cnst = 1; // int 型常量int *pi = &amp;val; // pi 本身是变量，通过 pi 访问的也是变量 // 正确：将变量地址赋值给变量的指针pi = &amp;cnst; // 错误：不允许将常量的地址赋值给变量的指针const int *pci = &amp;cnst; // pci 本身是变量，通过 pci 访问的是常量 (point to const) // 正确：将常量地址赋值给常量的指针pci = &amp;val; // 正确：允许将变量地址赋值给常量的指针int *const cpi = &amp;val; // cpi 本身是常量，通过 cpi 访问的是变量 // 正确：允许将变量地址赋值给变量的指针int fake = 2; // int 型变量cpi = &amp;fake; // 错误：cpi 本身是常量，不能在定义之外赋值const int *const cpci = &amp;val; // cpci 本身是常量，通过 cpci 访问的也是常量 // 正确：允许将变量地址赋值给常量的指针cpci = &amp;fake; // 错误：cpci 本身是常量，不能在定义之外赋值cpci = &amp;cnst; // 错误：cpci 本身是常量，不能在定义之外赋值，哪怕是常量的地址 因为变量可以是常量，而指针本身也可以是常量。因此在变量和指针两个维度，都可以选择是否为常量。这样一来，就像上面代码展示的那样，当 const 与指针牵扯在一起的时候，就有 4 中可能性。为了区分这两个维度，我们引入顶层 const 和底层 const 的概念： 顶层 const：指针本身是常量。此时，指针在定义初始化之外，不能被赋值修改。称指针为指针常量。 底层 const：指针指向的变量是常量。此时，不能通过解引用指针的方式，修改变量的值。称指针为常量的指针。 指针与数组数组的名字被当做指针使用在 C 和 C++ 中，指针与数组有非常紧密的联系。实际上，使用数组的时候，编译器通常都是在操作指针。这里我们从两个角度说明数组名在很多时候被当做是一个指针。 123456789int nums[] = &#123;1, 2, 3&#125;;int *p = &amp;(nums[0]);if (p == nums) &#123; printf("true!\n");&#125;size_t i = 0;for (i = 0; i != 3; ++i) &#123; printf("%d\n", p[i]);&#125; 如果你执行这一小段代码，那么，不出意外的话，程序会在终端上打印 true!，以及 nums 中的三个数字。这预示着，指针变量 p 保存的内容（也就是 nums[0] 的地址）和 nums 保存的内容是完全一样的；同时，编译器以相同的方式去解释 p 和 nums。显然 p 是一个指向 int 型变量的指针，那么 nums 也就是一个指针了。 C++11 标准引入了 auto 关键字，它能够在定义变量时，探测初始值的类型，并为新定义的变量设置合适的类型。我们看看 auto 关键字作用于数组名字的时候，会发生什么。 1234int nums[] = &#123;1, 2, 3&#125;;auto what = nums;int val = 42;what = &amp;val; 这份代码在 C++11 标准中，可以顺利通过。这说明 what 的类型，经由 auto 检测，是 int *。 这两个例子，足以说明：当数组名字被当做是一个值来使用的时候，它就相当于是一个指针。 也不是全部时候当然，也不是全部时候，数组名字都被当做是简单的指针。比如，前作中的使用方式表明，在数组名字被传入 sizeof() 运算符的时候，它会被当做是一个真实的数组来看待。 数组指针可以自增数组的指针，可以像 C++ 中 std::vector 的迭代器那样进行自增操作。这句话不是太严谨，因为，实际上是先有数组的指针，再有 std::vector 的迭代器；迭代器实际上是仿造数组的指针设计的功能。 前文提到，数组的指针，实际上是一个指向数组元素类型的对象的指针。数组的指针进行自增、自减运算，实际是将指针所指的位置，沿着数组向后或者向前移动一个元素。 123456int nums[] = &#123;0,1,2,3,4,5&#125;;size_t len = sizeof(nums) / sizeof(nums[0]);int *iter, end = nums[len]; // end 是尾后指针for (iter = nums; iter != end; ++iter) &#123; printf("%d\n", *iter);&#125; 像这样的用法，就和 std::vector 的迭代器几乎没有差别了。 数组指针可以进行加减运算数组的指针还可以进行加减运算。比如，在上述例子中 iter += 2，就是将 iter 指针沿着数组向后移动 2 个元素。 两个指针如果指向同一个数组中的元素，那么它们可以做差。做差得到的结果是两个指针之间的距离，这个结果可以是负数（实际类型是 ptrdiff_t）。例如，在上述例子中在循环体末尾处，如果进行 end - iter 计算，则其结果表示当前尚未打印的元素的数量。 数组下标与指针加减上面提到，数组指针可以进行加减运算：数组指针与整数的加减，实际是将指针沿着数组进行移动，得到的结果还是一个指针。既然结果是指针，那么就可以解引用，访问数组中的元素。因此有 123456789int nums[] = &#123;0,1,2,3,4&#125;;size_t len = sizeof(nums) / sizeof(nums[0]);int *p = nums;size_t i = 0;for (i = 0; i != len; ++i) &#123; if (nums[i] == *(p + i)) &#123; printf("true!\n"); &#125;&#125; 不出意外的话，这一小段代码会连续打印五行 true!。这提供了另一种访问数组内元素的方法；而事实上，在使用下标访问数组元素的时候，编译器都会转换成类似 *(nums + i) 的形式。也就是说，通过指针运算和解引用来访问数组元素，其实是更加本质的方式。 函数与指针函数与指针，基本上是指针相关的话题中，最复杂的一个了。 让函数返回一个数组的指针我们知道，函数在返回的过程中，会对返回值进行拷贝。因此，一个无法拷贝的对象，是无法被函数返回的。（也可以参考此篇）数组是不能被拷贝的，所以函数无法直接返回数组。为了达到返回数组的目的，我们只能寄希望于让函数返回数组的指针（在 C++ 中还可以返回数组的引用）。 为此，我们需要了解，如何定义一个返回数组指针的函数。 首先，我们看一组数组的定义： 1234int arr[10]; // arr 是一个数组，长度是 10，元素类型是 int 型int *parr[10]; // parr 是一个数组，长度是 10，元素类型是 int *，也就是数组中存的是指针int (*p)[10] = &amp;arr; // p 是一个指针，它指向一个长度是 10 元素类型是 int 型的数组 这样一来，就不难构造返回数组的指针的函数定义了。 12345678int *(func(param_list))[10]; // 错误：func 是一个函数，param_list 是它的参数 // 它尝试返回一个长度为 10，元素类型为 int * 的数组 // 而数组是无法返回的int (*func(param_list))[10]; // 正确：func 是一个函数，param_list 是它的参数 // 它返回的是一个指针 // 这个指针指向了一个长度为 10 元素类型是 int 型的数组 于是，我们得到了此类函数定义的一般形式： 1element_type (*func(param_list))[dimension] 函数的指针 终于到这个话题了，呼…… 上文提到，无论是数据（变量）还是指令（函数），都是存放在虚存空间的。因此，既然有变量的指针，那么也一定会有函数的指针。这就是我们这一小节需要讨论的函数指针；这会逐渐引出本文最复杂的话题。 一个函数的类型，取决于它的输入和输出。这也就是说，一个函数的类型，应当包含它的返回值类型和参数列表。比如下面定义的函数，用于比较两个 int 型数据是否相等（这是一个仅用于示例而没有实际用处的函数）： 1bool isEqual(int, int); 对于一个函数来说，如果你能拿到它的定义，就很容易能取得它的类型：只需要去掉函数名字就可以了。因此，定义一个指向该类型的函数指针，并不困难。 123bool isEqual(int, int);bool (*pfunc)(int, int) = &amp;isEqual; // 定义了一个函数指针，指向 isEqualbool (*pfunc)(int, int) = isEqual; // 一个等价定义 在这里，pfunc 就是一个函数指针，它指向一个 bool (int, int) 类型的函数。也就是说，这类函数接收两个 int 型的参数，并返回一个 bool 类型的值。 值得一提的是，当函数名字作为值使用时，它会自动地转换成指针（有点像数组名字，不是吗）。因此，在函数指针的初始化或者复制的过程中，取值运算符是可选的。于是，上述两个定义语句是等价的。另一方面，函数指针作为函数调用使用时，它会自动转换成函数名（有点像数组指针，不是吗）。因此，这种情况下，解引用运算符是可选的。请看下例： 123456bool isEqual(int, int);bool (*pfunc)(int, int) = isEqual;bool res1 = isEqual(1, 2); // 通过原函数名调用bool res2 = (*pfunc)(1, 2); // 一个等价调用：通过函数指针，解引用调用bool res3 = pfunc(1, 2); // 另一个等价调用：函数指针自动转换成函数名 值得一提的是，不同类型的函数的指针之间，不存在任何的类型转换：你不能期待一个接受两个 int 型参数并返回 bool 值的函数的指针，经过类型转换，就能接受三个 int 型的参数。因此，对于重载的同名函数，他们的函数类型是不一样的，因此函数指针也不能是同一个。 将函数指针作为参数传入另一个函数在传参的过程中（除了 C++ 的传引用），也是伴随着拷贝的过程。因此，一个对象如果不能拷贝，那么它就不能作为参数传入函数。无疑，函数是不能拷贝的，因此你无法将函数作为参数直接传给另一个函数。但是，指针是可以拷贝的，因此，你可以将函数指针作为参数，传给另一个函数。 12345void addIfEqual(int lhs, int rhs, bool pfunc(int, int)); // addIfEqual 的第三个参数是一个函数定义 // 它会自动地转换成一个函数指针的参数void addIfEqual(int lhs, int rhs, bool (*pfunc)(int, int)); // 一个等价定义：显式地注明第三个参数是函数指针 于是，你可以这样使用这个函数： 1addIfEqual(1, 1, isEqual); 此时，函数名 isEqual 作为引数被传入，它起到的是「值」的作用。因此，isEqual 被自动地转换成指向该函数的指针。 让函数返回一个函数的指针同样地，与数组类似，虽然我们无法返回一个函数，但是我们可以返回一个函数指针。我们回到 isEqual 的函数指针的定义上来： 1bool (*pfunc)(int, int) = isEqual; 在这里，pfunc 是一个指针，它指向了一个函数；该函数接收两个 int 型参数，并返回一个 bool 值。因此，仿造之前「返回数组指针的函数的定义形式」，我们不难得出： 1outer_return_type (*func(param_list))(outer_param_list) 这里，func(param_list) 是当前需要定义的函数；outer_return_type 和 outer_param_list 分别是当前定义的函数返回的函数指针对应函数的返回值类型和参数列表。 登峰造极的 (*(void(*)())0)();这恐怕是一个会令所有 C/C++ 程序员战栗不已的函数调用语句。因此，在解释这个语句之前，我愿意先给出它的含义，安抚读者战栗的心灵。它表示：访问内存地址 0，将它作为一个参数列表和返回类型均为空的函数，并执行函数调用。（这是一个特殊场景下的函数调用，不用纠结为什么会调用 0 位置上的函数） 类型定义与 C 风格的类型强制转换符C 风格的类型强制转换符应该不是个稀罕玩意儿。比如 (double)a 就能将变量 a 强制转换为 double 类型。在这个简单的例子里，我们希望能够找到一些朴素的规律，破解这一登峰造极而又令人战栗的函数调用语句。 同样以 double 类型及相关指针类型为例，我们首先看下面的代码： 12345double a; // 定义了一个 double 型的变量double *b; // 定义了一个 double * 型的变量（double 型的指针）(double) c; // 将变量 c 强制转换为 double 类型(double *) d; // 将变量 d 强制转换为 double * 类型 我们不难发现，类型转换和对应类型的变量定义，有着千丝万缕的联系：首先去掉变量定义语句末尾的分号，然后去掉变量定义语句中的变量名，最后给剩余的部分加上括号——一个 C 风格的类型强制转换符，就得到了。 破解谜题我们知道 void(*pfunc)(); 定义了一个函数指针 pfunc，它指向的函数参数列表为空、返回值类型也为空。因此，(void(*)()) 就是一个 C 风格的类型转换符。 因此，(void(*)())0 会将 0 转换成一个函数指针，然后交给 * 解引用，最后传入参数（空的参数列表 ()），执行函数调用。 在 C++ 中，这个函数调用应该写作1(*reinterpret_cast&lt;void(*)()&gt;(0))(); 显而易见，这个写法，相较 C 风格的类型强制转换符，要清晰明朗得多。因此，请不要再吐槽 C++ 风格的强制转换是「语法盐」了。 谨以此文，作为献给自己的生日礼物。:)]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>C</tag>
        <tag>Pointer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记 C 语言词法分析中的贪心法]]></title>
    <url>%2F2017%2F01%2F31%2Ftraps-in-lexical-analysis-of-C%2F</url>
    <content type="text"><![CDATA[很早以前就知道，编译器做的工作，首先就是读入源码，而后进行词法分析（有预处理的语言，还要先经过预处理器）。但是，一直没有对 C 语言的词法分析过程进行过深入了解。今天又拿起 Koenig 的《C 陷阱与缺陷》，才又读到相关的说明。 说明所谓词法分析，就是编译器将源码中的字符串切分，变成一个个记号（token）的过程。所谓的记号，就相当于是英文中单词的地位；因此也有翻译将它译作单词。这个过程，其实很简单：无非就是顺序读入源码文件，而后挨个切分就好了。但是，看似简单的问题，往往就会有意料之外的事情发生。 举一个简单的例子。在 C 语言中，- 是一个记号，它表示「负号」或者「减号」；同时 &gt; 也是一个记号，它表示「大于号」。麻烦之处在于，-&gt; 也是一个记号，它是「成员运算符」；那么，当编译器遇到 -&gt; 的时候，是将它作为一个记号 -&gt; 呢？还是作为两个记号 - 和 &gt; 呢？回答这个问题，应当是不难的。答案显而易见，它应当被看做是一个完整的成员运算符，而不是一个减号紧接着一个大于号。 然而，这个答案背后的原理，值得思考：编译器遇到此类可能存在歧义的情况，适用怎样的规则，以保证行为的一致性呢？C 编译器采用了所谓的贪心法（或者，大嘴法）来处理这些情况： 读入一个字符： 如果它是一个单字符记号，并且不能与其它字符组成记号，那么将它作为记号加入队列，继续读入下一个字符； 如果它是一个单字符记号，而且可能与其它字符组成记号，那么先读入下一个字符： 如果它能与先前读入的字符组成记号，那么将它们一起作为记号加入队列，继续读入下一个字符； 如果它不能与先前读入的字符组成记号，那么： 如果至今为止尚未组成记号的字符，也不能作为其他记号的组成部分，则将先前读入的字符作为单字符记号加入队列，并依先例，继续处理当前字符； 否则，继续读入下一个字符，尝试拼接更长的符号。 或者，简单来说就是如果输入流截至某个字符，之前的字符都已经被分解为一个个记号，那么下一个记号，应该是从这个字符起可能组成记号的最长字符串对应的记号。 例子 a---b 表示 (a--) - b； y = x/*p 表示 y = x[注释开始]p，而不是 y = x / (*p)。 启发这个来自编译器词法分析器的陷阱应当引起注意，对于程序员来说，写代码应该养成良好的习惯：合理使用空格、括号，以避免可能的歧义造成难以排查的错误。 不好好些空格、括号的程序员，都应该拉出去打屁屁。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Lexical Analysis</tag>
        <tag>Traps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员的自我修养（三）：fork() 安全]]></title>
    <url>%2F2017%2F01%2F17%2Ffork-safe%2F</url>
    <content type="text"><![CDATA[这个系列的文章，已有两篇（一、二）。本文将接着第二篇的叙述，探讨一个与多进程、多线程相关的问题：fork()-安全。 抛出异常首先我们来看这样的代码 mutex_deadlock.cpp1234567891011121314151617181920212223242526272829// compile: g++ ‐‐std=c++11 ‐lpthread mutex_deadlock.cpp// execute: ./a.out#include &lt;pthread.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;using namespace std;pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;void* doit(void*) &#123; pthread_mutex_lock(&amp;mutex); struct timespec ts = &#123;20, 0&#125;; nanosleep(&amp;ts, 0); pthread_mutex_unlock(&amp;mutex); return 0;&#125;int main(void) &#123; pthread_t t; pthread_create(&amp;t, nullptr, doit, nullptr); if (fork() == 0) &#123; doit(nullptr); return 0; &#125; pthread_join(t, 0); return 0;&#125; 在代码里，我们首先用 pthread_create() 创建了一个子线程。在子线程里，doit() 工作函数会持有一把互斥锁，然后睡 20 秒后再释放这把锁。而后，与子线程同时进行的，在主线程中，我们调用 fork() 函数，创建一个子进程。并且，在子进程里，我们也调用 doit() 函数，尝试获取互斥锁。 捕获异常现在我们观察一下，这个程序的运行状态。 1234$ ./a.out$ ps ‐ef | grep "a.out" | grep ‐v grep 16629 10449 340 0 11:25 pts/90 00:00:00 ./a.out 16629 10451 10449 0 11:25 pts/90 00:00:00 ./a.out 可以看到，等到我们有机会查看程序的运行状态时，子进程已经被创建出来了。显而易见，10449 是主进程，而 10451 是子进程。我们用 strace 跟踪主进程试试看。 12345678910$ strace -p 10449 -fProcess 10449 attached with 2 threads - interrupt to quit[pid 10450] restart_syscall(&lt;... resuming interrupted call ...&gt; &lt;unfinished ...&gt;[pid 10449] futex(0x41c279d0, FUTEX_WAIT, 10450, NULL &lt;unfinished ...&gt;[pid 10450] &lt;... restart_syscall resumed&gt; ) = 0[pid 10450] _exit(0) = ?Process 10450 detached&lt;... futex resumed&gt; ) = 0exit_group(0) = ?Process 10449 detached 不难发现，strace 提示主进程里有 2 个线程，其中主线程正在等待子线程释放互斥锁。待子线程释放互斥锁并退出后，主线程就获取到锁，而后退出了。这表明，主进程运行正常。 现在看看子进程的状态。 12345$ ps -ef | grep "a.out" | grep -v grep16629 10451 1 0 11:25 pts/90 00:00:00 ./a.out$ strace -p 10451 -fProcess 10451 attached - interrupt to quitfutex(0x600e20, FUTEX_WAIT_PRIVATE, 2, NULL 这里有几处值得注意的地方 执行 ps -ef 的时候，主进程已经退出了，但是子进程依然存活。这时候，子进程变为孤儿，过继给 1 号进程 init。 执行 strace 发现，子进程只有一个线程（而不是 2 个线程）。 并且，子进程的线程，在不断尝试获取互斥锁而不得，陷入了死锁状态。 异常分析子进程陷入死锁，因而等主进程退出后就变成孤儿进程。这件事情符合逻辑，不需要做额外的探讨。但是不符合逻辑的地方有两处： 主进程显而易见有两个线程，为什么经由其 fork() 得到的子进程却只有 1 个线程？ 既然子进程只有 1 个线程，为什么会陷入死锁？ 为了解答这两个疑惑，我们需要更加深入地了解一下 fork() 函数的行为。阅读 fork() 函数的说明，我们可以发现有这样一段话： The child process is created with a single thread — the one that called fork(). The entire virtual address space of the parent is replicated in the child, including the states of mutexes, condition variables, and other pthreads objects; the use of pthread_atfork() may be helpful for dealing with problems that this can cause. 翻译过来就是：经由 fork() 创建的子进程，其中只有一个线程。子进程里仅存的线程，对应着主进程里调用 fork() 函数的线程。此外，主进程的整个虚存空间都被复制到了子进程。因而，包括互斥锁、条件变量、其余线程的内部对象等，都保持着原样。由此引发的问题，可以考虑用 pthread_atfork() 函数解决。 打住！我们似乎发现了什么…… 回过头来看代码。在 fork() 执行时，子线程还持有着 mutex 互斥锁。而当 fork() 执行之后，子进程里的子线程就蒸发掉了，但是 mutex 互斥锁依然保持着被持有的状态。而子进程里仅存的线程，马上就进入 doit() 函数，尝试获取锁——它在尝试获取一个永远不会被释放的锁，形成死锁。 这是一个刻意构造的例子，说明当子线程持有锁的时候，由主线程进行 fork() 操作是不安全的。在生产实际中，这种现象不总是发生，但是在概率的意义上是必然发生的。因此，我们有必要考虑怎样解决这个问题。好在，fork() 的文档中给出了提示：使用 pthread_atfork() 函数。 pthread_atfork() 函数pthread_atfork() 和 phread_create() 函数一样，由 pthread 库提供。它的原型是 1int pthread_atfork (void (*prepare) (void), void (*parent) (void), void (*child) (void)); 它接收三个参数，分别是 prepare: 将在 fork() 之前执行； parent: 将在父进程 fork() 即将 return 的地方执行； child: 将在子进程 fork() 即将 return 的地方执行。 这个函数实际上是一个注册机，它可以被执行多次，而后将诸多 prepare 函数压入堆栈中，在 fork() 之前依次弹栈执行（执行顺序与注册的顺序相反）；将诸多 parent 和 child 函数分别填入队列中，在 fork() 函数即将 return 的地方依次执行（执行顺序与注册顺序相同）。按照设计的意图，程序员可以在 fork() 之前，做好清理工作，以便 fork() 能够安全地调用；并且在 fork() 返回之前，对函数做初始化，以便后续代码能够顺利执行。 据此，对上面的代码，我们可以有这样的修改 mutex_deadlock_fix.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243// compile: g++ ‐‐std=c++11 ‐lpthread mutex_deadlock_fix.cpp// execute: ./a.out#include &lt;pthread.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;using namespace std;pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;void* doit(void*) &#123; pthread_mutex_lock(&amp;mutex); struct timespec ts = &#123;20, 0&#125;; nanosleep(&amp;ts, 0); pthread_mutex_unlock(&amp;mutex); return 0;&#125;void prepare(void) &#123; pthread_mutex_lock(&amp;mutex);&#125;void parent(void) &#123; pthread_mutex_unlock(&amp;mutex);&#125;void child(void) &#123; pthread_mutex_unlock(&amp;mutex);&#125;int main(void) &#123; pthread_atfork(prepare, parent, child); pthread_t t; pthread_create(&amp;t, nullptr, doit, nullptr); if (fork() == 0) &#123; doit(nullptr); return 0; &#125; pthread_join(t, 0); return 0;&#125; 不难验证，死锁的问题已经解决。 没有银弹不幸的是，pthread_atfork() 函数并不是解决此类问题的银弹。事实上，pthread_atfork() 本身就可能造成死锁的问题。 实际上，因为库作者不可能知道其它第三方库对锁的使用，因此每个库必须自己调用 pthread_atfork() 来处理自己的环境。然而，在实际环境中，各个 pthread_atfork() 函数调用的时机是不确定的；也因此，各个 prepare 函数的调用顺序是不确定的。这有可能会造成问题，例如可能有下面的情况发生 Thread 1 调用 fork() 函数。 Thread 1 执行 libc 中注册的 prepare 函数，获取 libc 中的 mutex。 Thread 2 中，第三方库 A 获取了它自己的互斥锁 AM；接下来 Thread 2 尝试获取 libc 的 mutex 以便继续清理环境；而此时 mutex 已经在 Thread 1 中被持有，因此 Thread 2 进入等待状态。 Thread 1 现在尝试清理第三方库 A 的环境，于是它要去获取 AM；然而 AM 在 Thread 2 手里，于是 Thread 1 进入等待状态。 产生死锁。 这件事情的不可解之处在于，死锁的产生和程序员自身的编码没有任何关系：使用任何第三方库，在多线程的环境下执行 fork()，都可能死锁。由此，我们得出结论：在多线程环境下，执行 fork() 函数是不安全的。也因此，必须慎重使用多进程和多线程混搭的模型。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Process</tag>
        <tag>Thread</tag>
        <tag>Fork</tag>
        <tag>Fork Safe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员的自我修养（二）：操作系统、进程与线程]]></title>
    <url>%2F2017%2F01%2F17%2Flayers-and-operation-system%2F</url>
    <content type="text"><![CDATA[前作简单介绍了计算机硬件的发展历史和当前计算机硬件的基本结构。我们知道，作为软件开发者，我们几乎只需要知道计算机硬件由 CPU、内存和 I/O 设备组成就可以了，其他细节不一定要详细地了解。 本文我们将简单介绍计算机的层次化结构和操作系统；而后讨论 Linux 中的进程与线程。 层次化的好处都有啥？ 层次化的好处都有啥？谁说对了就给他！——Liam Huang 说起层次化结构，计算机领域内最负盛名的可能是 TCP/IP 协议栈了。TCP/IP 的设计者，将整个网络通信协议，进行了层次化的设计：下面的层次为上层提供接口和功能，上面的层次负责调用接口完成新的工作。下层的服务对上层来说是透明的，只需要保证层次之间的接口不变，就能实现或者增强各种功能（比如 VPN）。 计算机科学领域的任何问题，都可以通过增加一个间接的中间层来解决。Any problem in computer science could be solved by another layer of indirection. 这句话的出处已经不可考，但是它非常有名，并且道出了整个计算机系统软件体系结构的要点。 计算机系统软件的体系结构就遵循了层次化的体系结构，不仅如此，操作系统本身也遵循着这样的结构。计算机系统软件的体系结构大体如下图所示。 层次化结构之中，层次之间的通信规则被称为接口（interface）。在图中，方框框起来的是层次中的内容，虚线中间的就是接口。接口由下层定义，由上层调用；在这种框架下，上层通过调用下层提供的借口，使用下层提供的服务。正如上面所说，只要保证接口稳定不变，由于透明性，接口下方的每个层次都可以做修改甚至替换，这是兼容性的重要保障。 从图中，我们可以看出操作系统对上提供系统调用（system call）接口，对下根据硬件规格（Hardware Specification）实现对硬件的操作（具体来说，是由操作系统中的各种驱动来完成）。这就是为什么我们说，操作系统基本上就完成了两件事情：对上层提供抽象接口、对下层硬件资源进行管理。 操作系统都干啥？操作系统对上层提供的系统调用，我们这里按下不表，主要看看操作系统在管理硬件资源方面做了哪些努力。 计算机硬件的能力是有限的。特别地，在计算机刚刚起步的阶段，计算机硬件通常是昂贵的。所以，为了充分发掘计算机的存储、运算能力，或者邪恶点说是榨干计算机的硬件资源，使得计算机在尽可能段的时间内处理更多的事情。 交给计算机的任务，大致可以分为两类：I/O 密集型任务和 CPU 密集型任务。顾名思义，CPU 密集型任务，在执行过程中，需要大量的 CPU 资源。对于这种任务，我们可以大胆地将 CPU 资源交给它来调用——反正总是要占用 CPU 资源的。大体上，涉及到磁盘 I/O、网络存取的任务，就都是 I/O 密集型任务；此类任务往往不需要太多 CPU 资源，对于 CPU 来说，大多数时间被空耗在等待 I/O 完成上了。当人们认识到交给计算机的任务可以分为这两类的时候，人们就开始考虑如何做 CPU 的任务调度。在任务调度上，人们经历了多道程序、分时系统与多任务系统等阶段。 在多任务系统中，操作系统接管了所有硬件资源并持有对硬件控制的最高权限。在操作系统中执行的程序，都以进程的方式运行在更低的权限中。所有的硬件资源，由操作系统根据进程的优先级以及进程的运行状况进行统一的调配。 进程和线程这里提到，「在操作系统中执行的程序，都以进程的方式运行在更低的权限中」。事实上，操作系统是以进程为单位去分配空间和执行的。但是，进程和程序有什么不同呢？我们说 程序是一组指令的集合，它静态存储于诸如磁盘之类的存储器里； 当一个程序被操作系统执行时，它就会被载入内存空间，并在逻辑上产生一个独立的实例，这就是进程。 这就好像是说，程序是一道菜谱，其中的指令，就是指挥你开火加盐的步骤；进程则是烹饪的过程，操作系统按照指令一丝不苟地烹饪，得到的结果就是我们的菜肴。 随着 CPU 频率增长逐渐停滞，CPU 开始向多核的方向发展。为了让多个 CPU 核心同时为我们工作，并行地执行任务，就需要涉及线程的概念。线程的英文是 Thread，有时也称为轻量级进程 (Lightweight Process)，它是操作系统进行任务调度的最小单元。线程存活于进程之中；同一个进程中的线程，共享一个虚拟内存空间，以及其中的资源；线程之间各自持有自己的线程 ID、当前指令的指针（PC）、寄存器集合以及栈。 通常来说，使用多线程会带来一下一些优势： 将等待 I/O 操作的时间，调度到其他线程执行，提高 CPU 利用率； 将计算密集型的操作留给工作线程，预留线程保持与用户的交互； 在多 CPU/多核计算机下，有效吃干计算能力； 相比多进程的程序，更有效地进行数据共享（在同一个进程空间）。 Linux 中的进程与线程在 Windows 中，有明确的 API：CreateProcess 和 CreateThread 来创建进程和线程。但是，在 Linux 中，不管是进程还是线程，都以任务（Task）视之。也就是说，在 Linux 中，实际上并不存在概念上严格的线程和进程的区别。不过，这并不是说在 Linux 里就无法实现多线程了。由于 Linux 支持在进程之间共享物理内存空间，因而在实际意义上，支持了多线程。 为了说明 Linux 中进程与线程的概念，这里要引入三个 Linux 中的运行时库函数：fork(), exec 和 clone()。 fork() 函数fork() 是 Linux 中的一个运行时库函数。它会调用 syscall_clone()，也就是系统调用 clone，复制一个与当前进程一模一样的进程，并且新进程与原进程以写时复制（Copy on Write）的方式共享同一份内存空间。 每当 fork() 函数被调用时，都会产生两次函数返回： 在父进程中返回一次，返回值是子进程的 PID； 在子进程中返回一次，返回值是 0。 这使得我们可以分别控制父进程和子进程的执行过程。 fork_test.c1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;void doSomethingInFather(int working);void doSomethingInChild(int working);int main () &#123; const int index = 42; pid_t pid = fork(); if (pid &lt; 0) &#123; perror("Fork error: "); &#125; else if (pid == 0) &#123; doSomethingInChild(index); &#125; else &#123; doSomethingInFather(index); &#125; return EXIT_SUCCESS;&#125;void doSomethingInFather(int working) &#123; printf("I'm the father, and I have %d apple(s).\n", working); return;&#125;void doSomethingInChild(int working) &#123; printf("I'm the child, and I have %d orange(s).\n", working); return;&#125; 它的执行结果是 12I&apos;m the father, and I have 42 apple(s).I&apos;m the child, and I have 42 orange(s). exec 函数事实上，exec 是一系列函数，它至少包括： 12345int execl(const char *path, const char *arg, ...);int execlp(const char *file, const char *arg, ...);int execle(const char *path, const char *arg, ..., char * const envp[]);int execv(const char *path, char *const argv[]);int execvp(const char *file, char *const argv[]); 这些函数内部都会调用库函数 int execve(const char *filename, char *const argv[],char *const envp[]);，该函数会将当前进程空间清空，而后根据传入的参数装载指定的可执行文件（二进制或者脚本）来执行。 say_yes.sh1234#!/usr/bin/env bashecho "Yes, $0 is running!"exit 0 execl_test.c12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;void doSomethingInFather(int working);void doSomethingInChild(int working);int main () &#123; const int index = 42; pid_t pid = fork(); if (pid &lt; 0) &#123; perror("Fork error: "); &#125; else if (pid &gt; 0)&#123; doSomethingInFather(index); &#125; else &#123; doSomethingInChild(index); &#125; return EXIT_SUCCESS;&#125;void doSomethingInFather(int working) &#123; printf("I'm the father, and I have %d apple(s).\n", working); sleep(2); return;&#125;void doSomethingInChild(int working) &#123; execl("/home/liam/test/say_yes.sh", NULL); printf("Something that will never be printed.\n"); return;&#125; 执行结果 12I&apos;m the father, and I have 42 apple(s).Yes, /home/liam/test/say_yes.sh is running! 这里我们可以看出，在父进程中，「我有 42 个苹果」顺利被执行；同时在子进程中，我们使用了 execl 函数调用了外部可执行脚本，它成功地打印了预期的内容。值得注意的是，printf(&quot;Something that will never be printed.\n&quot;); 并没有执行。这是因为，在子进程执行到 execl 之后，进程空间中的内容就被清空了，execl 之后的指令永远不会有机会执行。 可见：使用 fork() 函数可以创建子进程；使用 fork() 函数以及 exec 函数则可以在子进程里执行新的任务。 clone() 函数这里介绍的 clone() 是一个库函数；与之同名的，还有系统调用 clone——我们在介绍 fork() 函数的时候已经见过它了。 clone() 函数的原型是 1int clone(int (fn)(void ), void *child_stack, int flags, void *arg); clone() 函数会创建一个子进程，从指定位置开始执行，并有选择地继承父进程的资源。具体而言 fn 是一个函数指针，子进程将会从这里开始执行； child_stack 是指向一片内存空间的指针，它会被子进程用作栈内存，并且需要在父进程里分配好空间； flags 是标志位，它会改变 clone 函数创建的子进程对父进程资源继承之行为； arg 是一个可变长的参数，这些参数会被传递给 fn，并且应当以显式的 NULL 指针作为结尾； 当 fn 函数在新的进程中执行完毕（或者显式地调用 exit() 函数退出时），子进程被销毁。 这里可用的标志位有很多，详细地可以去查阅 clone() 函数的手册。我们重点关注的是 CLONE_VM 这个标志位。当它被传给 clone() 函数的时候，新进程和老进程共享同一内存空间：新进程和老进程对内存的写入操作，在另一个进程里是可见的；并且使用 mmap() 和 munmap() 操作也是互通的。 我们来看一个示例。 clone_test.c12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sched.h&gt;int doSomething(void*);int main() &#123; void* stack = NULL; int index = 0; const size_t STACK_SIZE = 10240; stack = malloc(STACK_SIZE); if (NULL == stack) &#123; printf("Malloc stack for new process failed.\n"); exit(-1); &#125; printf("In the calling thread: getpid[%d], getppid[%d].\n", getpid(), getppid()); int tid = clone(&amp;doSomething, stack + STACK_SIZE, CLONE_VM, (void*) &amp;index, NULL); sleep(1); printf("Now, have a look at our index: %d.\n", index); sleep(1.5); free(stack); return EXIT_SUCCESS;&#125;int doSomething(void* p_idx) &#123; printf("In the new thread: getpid[%d], getppid[%d].\n", getpid(), getppid()); ++(*(int*)p_idx); printf("In the new thread, we've stepped the index var.\n"); sleep(2); return;&#125; 它的输出是 1234In the calling thread: getpid[142059], getppid[119147].In the new thread: getpid[142060], getppid[142059].In the new thread, we&apos;ve stepped the index var.Now, have a look at our index: 1. 这个例子说明了几个问题 传给 clone() 函数的新进程的栈地址，是栈顶的地址；这是因为栈总是从上向下扩张使用的。 执行 clone() 之后，原进程会继续执行（而不会阻塞）；因此我们需要等待一些时间再释放分配给新进程作为栈使用的内存空间，否则会引发 core dumped。 在新进程里对 index 变量的修改，在原进程里是可见的，这说明新进程实际上是一个线程。 尽管实际上它是一个线程，但是仍然占据了一个进程号（PID），并且以原进程为父进程。 你也可以试着在执行 clone() 函数的时候，将传入的标记设置为 CLONE_SIGHAND|CLONE_VM|CLONE_THREAD，再看看结果会怎样。 这里，我们介绍了三个与多进程/多线程相关的库函数，并以 clone() 函数真正在进程中创建了一个线程。但是，在 Linux 里进行多线程的编程，我们通常会使用 pthread 库来创建新的线程。这里只给出最简单的例子，不做深入探讨。 pthread_test.c12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;void* doSomething();int main() &#123; printf("In the calling thread: getpid[%d], getppid[%d].\n", getpid(), getppid()); pthread_t tid; pthread_create(&amp;tid, NULL, doSomething, NULL); sleep(1); return EXIT_SUCCESS;&#125;void* doSomething() &#123; printf("In the new thread: getpid[%d], getppid[%d].\n", getpid(), getppid()); return NULL;&#125; 执行结果 12In the calling thread: getpid[10000], getppid[119147].In the new thread: getpid[10000], getppid[119147]. 线程安全浅说首先，我们回顾一下线程的特点： 每个线程有自己独立的栈； 同时多个线程共享进程空间中的数据。 竞争如果每个线程对共享部分数据都是只读的，那么大概不会出现什么问题。但是，如果同时有多个线程尝试对同一份数据进行写入操作，那么最终的结果可能会是不可预期的。考虑这一经典的例子： 共享数据 int i = 0;； 线程 1 试图执行 ++i； 线程 2 试图执行 --i。 首先考虑 ++i 背后的意义（--i 类似）。在大多数体系结构上，++i 在编译出的汇编代码中，会被翻译为 123X &lt;- i # 将 i 的值读入某个寄存器，比如 X 或者 YX++ # 增加寄存器中的值i &lt;- X # 将寄存器中的值写入变量 i 由于这一句代码会被翻译成多条指令，那么必然存在这样的情况：线程 1 在执行三条指令的过程中被中断，系统调度线程 2 继续执行。这样，在两边线程执行完毕之后，变量 i 的值可能是 0, 1, -1；而具体取值多少是不可预期的。这种因为多个线程竞争对同一变量进行操作导致不可预期后果的过程，称为线程不安全。 原子性回顾刚才的分析，线程不安全的根本原因，是线程中多条指令连续执行的过程可能会被系统调度中断，而现场恢复之后共享变量的值可能已经被修改。因此，如果我们能保证指令的执行不被打断，那么自然就能保证线程安全了。这种特性被称作原子性。 显然，单条指令是不可打断的。那么对应单条指令的代码，都是具有原子性的。例如 i386 架构中，有一个 inc 指令，可以直接增加内存某个区域的值。这样一来，自增操作就是原子的了。 由单条指令提供的原子性，显然有非常大的局限性——这是因为单条指令能够达成的效果总是有限的。在实际生产中，我们会需要保证连续多条指令的原子性。这就需要引入同步和锁的概念。 同步与锁在这里，同步是一种规则，而锁则是实现这种规则的具体方法。 所谓同步，指的是多线程程序里，多个线程不得同时对某一共享变量进行访问。锁是实现同步的一种具体方案——准确地说，这是一种非常强的方案。锁有多种形式，最符合直觉的锁是所谓的互斥量（Mutex）。具体来说，线程在访问某个共享变量的时候，必须先获取锁；如果获取不到锁，那么就必须等待（或者进行其他操作，总之不许访问这个变量）；在结束对这个变量的访问之后，持有锁的线程应当释放。 值得一提的是，所作为一种同步手段，是非常强的。但是，这种强，仅限于逻辑层面。在实际情况中，编译器优化、CPU 动态调度，都有可能打破锁对于同步的保护。这时候，这些优化就变成了过度优化。 过度优化对线程安全的破坏这一小节我们会举 2 个例子，说明在某些情况下锁也是不靠谱的。 编译器优化12345int x = 0;Thread 1 Thread 2lock(); lock();++x; ++x;unlock(); unlock(); 对于共享的变量 x，我们在线程 1 和线程 2 中并发地尝试访问它。为了保证线程安全，我们在对它的访问前后加上了锁。在逻辑上，这已经做到了线程安全，于是在执行完毕之后，x 的值应当必然是 2。但是，编译器优化可能会破坏逻辑上的线程安全：如果线程 1 在这之后会多次使用变量 x，那么编译器可能会将 x 自增后的值存放在寄存器中，暂不写回。于是，在线程 2 中尝试自增 x 的时候，获取到的 x 的值，可能是尚未从线程 1 的寄存器中更新值的 x。整个流程如下： 线程 1：获取锁 线程 1：从 x 中读取数据，写入寄存器 X 线程 1：X++ 线程 1：释放锁 线程 2：获取锁 线程 2：从 x 中读取数据，写入寄存器 Y 线程 2：Y++ 线程 2：从寄存器 Y 中读取数据，写入 x 线程 2：释放锁 线程 1：（很久之后）从寄存器 X 中读取数据，写入 x 显而易见，最终 x 的值，取决于寄存器中 X 的值；而在这个例子中，它是 1。 对于这种情况，我们可以用 C 语言关键字 volatile。这个关键字能在两种情况下组织编译器优化： 为了提高速度，将一个变量缓存到寄存器而不写回； 调整操作该变量的指令的顺序。 因此，在这个例子里，我们只需要使用 volatile int x = 0，就能保证 x 变量总是能得到即时的更新了。 CPU 动态调度程序在执行的过程中，出于效率的考量，两个（在当前线程中）没有依赖的指令可能会调换顺序执行。对于 CPU 来说，这已经是几十年的老技术了。我们来看这段 C++ 代码 1234567891011volatile T* pInst = nullptr;T* GetInstance() &#123; if (nullptr == pInst) &#123; lock(); if (nullptr == pInst) &#123; pInst = new T; &#125; unlock(); &#125; return pInst;&#125; 在单例模式中，这是一段典型的 double-check 的代码。双层的 if 各有作用： 外层 if 确保仅在 pInst 是空指针的情况下才去获取锁并尝试构造对象； 内侧 if 则是为了防止这样一种可能，避免重复操作和内存泄露：在外层 if 检测是，pInst 尚为空，但是，待 lock() 执行完毕后，别的线程已经为 pInst 赋值。 这段代码，乍一看是没有问题的；但仍需小心揣摩。我们看 pInst = new T; 这一行代码，它基本完成了三件事情 为 T 类型的对象分配内存； 在这片内存上执行 T 的构造函数； 将这片内存的起始地址赋值给 pInst。 由于构造函数的执行和指针的赋值是互不依赖的，所以 CPU 可能会交换这两个步骤的顺序。因此，在线程执行的过程中，可能存在这样一种情况：nullptr != pInst，但是它指向的对象尚未构造成功。于是，如果在这一时刻，当前线程被中断，并且其它线程调用 GetInstance 函数，那么函数在外层 if 执行之后，会直接返回 pInst 的值。而此时 pInst 实际上指向的是一片尚未初始化的内存。如果线程代码对 pInst 进行访问，那么程序很有可能就会崩溃。 为了解决这类 CPU 动态调度导致的问题，我们需要有在某些情况下阻止指令换序执行的能力。然而遗憾的是，由于动态调度是 CPU 的功能，所以在高级语言的层次，我们没有通用的解决办法——只能依赖具体的 CPU 架构，对代码进行调整。对于 i386 架构的 CPU 来说，它提供了一条指令 mfence（memory fence 的缩写），可以阻止这种换序执行。 1234567891011121314#define barrier() __asm__ volatile("mfence")volatile T* pInst = nullptr;T* GetInstance() &#123; if (nullptr == pInst) &#123; lock(); if (nullptr == pInst) &#123; T* temp = new T; barrier(); pInst = temp; &#125; unlock(); &#125; return pInst;&#125; 在这里，我们用 barrier() 保证了在 pInst 被赋值之前，相关内存区域已经正确地初始化了。 可见，线程安全是个烫手山芋。为了写出线程安全的程序，程序员们都需要好好学习一个。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Architecture</tag>
        <tag>Process</tag>
        <tag>Thread</tag>
        <tag>Operation System</tag>
        <tag>Thread Safe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Times New Roman 与 LaTeX]]></title>
    <url>%2F2017%2F01%2F10%2FTimes-New-Roman-and-LaTeX%2F</url>
    <content type="text"><![CDATA[本文又名：你对真正的 Times 字体一无所知。 Times New Roman 在很长时间内是 Windows 平台上 M$ Word 的默认西文字体。所以，很多机构要求作者在文章中使用 Times New Roman 作为西文字体，于是这些作者就开始到处问：怎样在 LaTeX 中使用 Times New Roman 字体。 各种版本这是一个最早由 Stanley Morison、Starling Burgess 和 Victor Lardent 共同创造的衬线字体，由 Monotype 公司于1932年发表，并为英国的《泰晤士报》首次采用。这是一个经典的、中规中矩的字体，所以经常被选为西文的标准字体之一。 Windows 中使用的 Times New Roman 是 Monotype 在最初字形上稍加修改（字宽方面）得到的。macOS 系统中使用的 Times Roman 是 Linotype 公司出品的，它与 Monotype 家的 Times New Roman 除了个别字形稍有区别之外（相信你看不出来），几乎完全相同。开源系统中对应的字体，则是 URW 的 Nimbus Roman No9 L 字体，它在 GPL 许可下发布。 简单来说，你在 Windows 里接触最多的 Times 字体是 Monotype 出品的 Times New Roman；在 macOS 里接触的是 Linotype 家的 Times Roman；开源环境你能见到最多的是 URW 的 Nimbus Roman No9 L 字体。而它们几乎没有差别。 在 LaTeX 里使用在 LaTeX 里使用 Times 字体，有几种方式。值得一提的是在这里没有介绍的方式，基本都是过时的方式（或者不方便初学者使用的方式）。 使用 fontspec 系列宏包fontspec 系列宏包是为 XeLaTeX 和 LuaLaTeX 设计的。借由它，用户可以直接选取系统中的字体。因此，你可以准确而直接地选择 Times New Roman 而不是其他近似（在 macOS 下只能用 Times Roman 了）。这是最推荐的方法。 123456789\documentclass&#123;article&#125;\usepackage&#123;mathspec&#125;\setmainfont&#123;Times New Roman&#125;\setmathsfont&#123;Times New Roman&#125;\begin&#123;document&#125;This is the typeface Times New Roman.Enjoy!\end&#123;document&#125; 使用 mathptmx 宏包mathptmx 是一个为 LaTeX 设计的字体宏包，它会将默认 rmfamily 设置为 Nimbus Roman No9 L；而将数学字体设置为对应的 Italic 字形（不足的部分使用了 CM/RSFS/Adobe Symbol 等字体）。这是同时修改默认文本字形和默认数学字形为 Times 字形最干净的宏包。 使用它可能需要借助 fontenc 宏包来辅助设置字体编码。 12345678\documentclass&#123;article&#125;\usepackage[T1]&#123;fontenc&#125;\usepackage&#123;mathptmx&#125;\begin&#123;document&#125;This is the typeface Nimbus Roman No9 L, and fontface for mathematics has been modified to the Italic counterpart.Enjoy!\end&#123;document&#125; 使用 newtx 系列宏包本质上，newtx 系列宏包是为了代替陈旧的 txfonts 宏包而设计的。它最大的特色是分为两部分——分别改变文本字体和数学字体，而不需要同时使用： newtxtext， newtxmath。 和 mathptmx 宏包类似，newtx 系列宏包也使用 Nimbus Roman No9 L 及其 Italic 字形。不过，他们还会做额外的工作： 将正文 Sans Serif 字体设置为 Helvetica（的开源近似版）； 将正文 Monospace (Typewriter) 字体设置为 Times 的等宽版本。 123456789\documentclass&#123;article&#125;\usepackage[T1]&#123;fontenc&#125;\usepackage&#123;newtxtext, newtxmath&#125;\begin&#123;document&#125;This is the typeface Nimbus Roman No9 L, and fontface for mathematics has been modified to the Italic counterpart.\textsf&#123;The sans serif family is Helvetica&#125; and \texttt&#123;the monospace family is also Times&#125;.Enjoy!\end&#123;document&#125;]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Font</tag>
        <tag>Times</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为阿拉伯数字和小写字母实现类似 \mathbb 的效果]]></title>
    <url>%2F2017%2F01%2F08%2Farabic-numbers-or-lowercase-letters-in-blackboard-bold-doublestroke-font%2F</url>
    <content type="text"><![CDATA[在 LaTeX 中，我们可以用 \mathbb{R} 输出表示实数集合的字母 $\mathbb{R}$。这一命令来自 amsfonts 宏包。那么如果我们希望输出类似效果的阿拉伯数字或者小写字母，应该怎么办呢？ amsfonts 中的 \mathbb 命令翻看 amsfonts 说明书（texdoc amsfonts），我们可以在其中第 3.3 节找到这样的描述： The amsfonts package defines a “math alphabet” command \mathbb for printing letters of the blackboard bold alphabet that resides in the msbm font. This alphabet is restricted to uppercase only (no lowercase, no numerals). The suggested method for defining a \R command to print a blackboard bold $\mathbb R$ is as follows: 12\usepackage&#123;amsfonts&#125;\newcommand&#123;\R&#125;&#123;\mathbb&#123;R&#125;&#125; 首先，我们知道了 \mathbb 样式字体的正式名称：blackboard bold，即黑板粗体。其次，我们知道了，定义在 amsfonts 宏包中的 \mathbb 命令只支持大写字母，不支持小写字母或者阿拉伯数字。 因此，如果你在 LaTeX 中输入 \mathbb{1}，虽然不会有任何报错提示，但是输出的字符是错误的（如下）。 bbm 字体既然 AMS 系的宏包不支持，那么我们就只能另辟蹊径了。实际上，我们只需要找到含有正确小写字母和阿拉伯数字的黑板粗体字体就可以了。索性，在 TeX Live 中有 bbm 系列字体，它提供了更完整的黑板粗体字符。不过，对于阿拉伯数字的支持，也只有数字 1 和 2。使用起来很简单 1234567\documentclass&#123;article&#125;\usepackage&#123;bbm&#125;\begin&#123;document&#125;\[ \mathbbm&#123;1234567890&#125;\mathbbm&#123;abcdefghijklmnopqrstuvwxyz&#125;\]\end&#123;document&#125;]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Font</tag>
        <tag>mathbb</tag>
        <tag>Blackboard Bold</tag>
        <tag>Doublestroke</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XGBoost 在计算 NDCG 时的特殊处理]]></title>
    <url>%2F2016%2F12%2F21%2FXGBoost-idealDCG-and-NDCG%2F</url>
    <content type="text"><![CDATA[XGBoost 是陈天奇（怪）领衔开发的一套 Gradient Boost 算法实现，比如我会用到它做 LambdaMART 的实验。如果要给它一个评价，那应该是：好用、耐操。 不过，也有甜蜜的烦恼。XGBoost 在每轮迭代后，能够贴心地给出模型在数据集上的指标。比如我会关心 NDCG 指标。然而，这里列印出来的指标，会比事后用标准算法计算出来的值要高不少。 最后，经检查（这里包含了血与泪），是 XGBoost 对 idealDCG 为 0 时的默认处理方式与标准算法不同导致的。标准算法，当 idealDCG 为 0 时，当前 NDCG 给 0；而 XGBoost 给 1，于是 XGBoost 计算出的最终 NDCG 要比标准算法计算得到的大不少。这件事情在 XGBoost 的文档里没有说明，所以称其为一个坑。 解决方法也很简单，在传参的时候，修改一下即可。 1234# before'eval_metric': 'ndcg@10'# after'eval_metric': 'ndcg@10-' 没错，只需要加一个减号就行了…… 并附链接： XGBoost：https://github.com/dmlc/xgboost 陈天奇怪：http://weibo.com/u/2397265244 LambdaMART: LambdaMART 不太简短之介绍]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>XGBoost</tag>
        <tag>Gradient Boosting</tag>
        <tag>LambdaMART</tag>
        <tag>NDCG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串匹配：KMP 算法]]></title>
    <url>%2F2016%2F12%2F20%2FKMP-Algorithm%2F</url>
    <content type="text"><![CDATA[所谓字符串匹配，就是拿着一个字符串（也称为模式串），去到另一个字符串（母串）里去查找完全相同的子串的过程。显然，只要能定义相等关系，那么字符串匹配算法可以扩展到任意的序列匹配算法。因此，这会是一类用途很广的算法。 解决字符串匹配问题，最朴素的办法就是拿着模式串逐字符地沿着待匹配的串去比对，每次向前移动一个字符，直到完全匹配或者找不到匹配。显然，这个算法的复杂度是 $O(n\cdot m)$（$n$ 表示母串的长度，$m$ 表示模式串的长度），是比较高的。 这里介绍的 KMP 算法，能够在 $O(n)$ 时间内完成任务，它是由 Donald Knuth/James H. Morris/Vaughan Pratt 发明的。当然，你也可以称之为「看毛片算法」——你高兴就好。 从朴素算法开始为了体现 KMP 算法的优势，也为了更容易地说明问题，我们先从最朴素的算法开始。 假设有 母串 S: ababaababc 模式串 P: ababc 现在我们的任务是在母串中找到与模式串完全相同的子串。朴素地算法是这样的： 将母串与模式串从头对齐； 从模式串的头部开始与母串对比a. 若字符相同，则继续对比；b. 若字符相同，且当前字符是模式串的最后一个字符，则匹配成功；c. 若字符不同，则将模式串沿着母串向后移动一位，再从头开始匹配；d. 若字符不同，且当前字符是母串的最后一个字符，则匹配失败。 在我们的示例里，具体的操作流程是这样的。 12345678910111213141516171819-&gt; # 从头开始匹配abab|aababcabab|c-&gt; # 匹配失败，移动一位，继续尝试匹配a|babaababc |ababc-&gt; # 匹配失败，移动一位，继续尝试匹配ababa|ababc aba|bc-&gt; # 匹配失败，移动一位，继续尝试匹配aba|baababc |ababc-&gt; # 匹配失败，移动一位，继续尝试匹配ababa|ababc a|babc-&gt; # 匹配失败，移动一位，继续尝试匹配ababaababc| ababc|-&gt; # 匹配成功，返回子串在母串中的位置 对多余工作的分析优化算法一个很重要的方法，就是寻找重复/多余的工作，然后用合适的方法去除它们。因此，我们应该试着分析上述朴素算法，看看有哪些工作是多余的，或者是重复的。 123456-&gt; # 从头开始匹配abab|aababcabab|c-&gt; # 匹配失败，移动一位，继续尝试匹配a|babaababc |ababc 我们来观察第一次匹配失败，沿着母串移动模式串的位置的过程。匹配失败，是因为 S[0:4] == P[0:4] 但是 S[4] != P[4]。于是我们将 P[0] 对齐 S[1]，继续尝试匹配。但是，实际上在验证 S[0:4] == P[0:4] 的过程中，我们已经知道了 S[0] == P[0] and S[0] != S[1]。因此，如果将 P[0] 与 S[1] 对齐，那么必然是匹配失败的。 既然在匹配的过程中，我们获得的信息，已经足够说明仅仅移动一位，必然匹配失败。那么这就是多余的工作，我们应该想办法规避掉这些多余的工作。那么，我们应该怎么办呢？ 注意，在第一次尝试匹配的过程中，我们确定了 S[0:4] == P[0:4]，又容易观察，对于模式串 P 来说，有 P[0:2] == P[4 - 2:4]；即模式串 P 成功匹配的部分中，它的首两个字符与末两个字符完全相同。于是，因为 S[0:4] == P[0:4]，所以我们有 S[4 - 2:4] == P[4 - 2:4] == P[0:2]。这也就是说，如果将模式串对齐 S[4 - 2] 位置，我们天然就能确认两个位置的匹配，只需要接着向后尝试匹配就可以了——KMP 算法就是这样做的。 总结起来就是： 123if S[i:i + j] == P[0:j] and S[i + j] != P[j]: # i + j &lt; n and j &lt; m k = argmax(k)&#123;P[0:k] == P[j - k:j]&#125; # 0 &lt;= k &lt; j align P[0] to S[i + j - k] 在这个优化中，我们让模式串尽可能快地沿着母串向前跳跃；同时尽可能多地保留了已匹配的信息，避免接下来重复匹配。这一优化的关键，就是对每一个 j，在模式串中寻找最大的 k，使得 P[0:k] == P[j - k:j]。显然，对于给定的模式串 P，k 的取值只与 j 有关；我们记作 $k = f(j;P)$，并称之为模式串 P 的部分匹配函数。接下来，我们要看看如何快速地得到这个部分匹配函数。 部分匹配函数根据定义，不难发现 $$ \begin{aligned} f(1) &amp;{}= 0. \end{aligned} $$ 接下来我们看一个稍微复杂一点的模式串 P = ababacb。 123j: 0 1 2 3 4 5 6P: a b a b a c bf(j): 0 0 1 2 3 ? 我们来验证一下 1234j == 2: P[0:0](None) == P[j - 0:j](None) and P[0:1](a) != P[j - 1:j](b)j == 3: P[0:1](a) == P[j - 1:j](a) and P[0:2](ab) != P[j - 2:j](ba)j == 4: P[0:2](ab) == P[j - 2:j](ab) and P[0:3](aba) != P[j - 3:j](bab)j == 5: P[0:3](aba) == P[j - 3:j](aba) and P[0:4](abab) != P[j - 4:j](baba) 很好，没有问题。接下来我们看 $f(6)$ 是多少。遇到这样的问题，我们就会想，$f(j)$ 组成的序列，后项是否会与前项有关，存在某种递推关系呢？因此我们会做这样的分析。 首先，因为 $f(5) = 3$，所以我们知道 P[0:3] == P[5 - 3:5] == P[2:5]。现在，如果有 P[3] == P[5]，也就是 P[f(5)] == P[5]，那么 $f(6) = f(5) + 1$。但是现在 P[3] == b != P[5] == c，因此 $f(6) = f(5) + 1$ 不成立。 接下来，我们考虑 $f(f(5)) = f(3) = 1$。为什么考虑 $f(3)$ 而不是 $f(4)$ 呢？这是因为，我们已知 $f(5) = 3$，所以有 P[0:3] == P[2:5]；同时已知 $f(3) = 1$，就有 P[0:1] == P[2:3] == P[4:5]。而 P[4:5] 与当前待考虑的字符 P[5] 是紧挨着的。于是，如果我们有 P[f(3)] == P[5]，那么 $f(6) = f(3) + 1$。但是现在 P[1] == b != P[5] == c，因此 $f(6) = f(3) + 1$ 也不成立。 按照同样的分析，我们接下来应该考虑 $f(f(f(5))) = f(1) = 0$。但显然，P[0] == a != P[5] == c，因此 $f(6) = f(1) + 1$ 也不成立；于是只能是 $f(6) = 0$ 了。 也就是说，对于已经求得前 $k$ 项部分匹配的模式串 P 来说，起第 $k + 1$ 项的部分匹配函数的值可以这样计算： 123456p_table = [-1, 0, ...]ptr = kwhile ptr &gt; 0 and pattern[k] != pattern[res[ptr]]: ptr = p_table[ptr]else: p_table.append(p_table[ptr] + 1) 这样一来，我们就能快速地计算任意的模式串 P 的部分匹配表了。 KMP 算法的实现示例经过上面的分析，我们很自然地就能得到 KMP 算法（以下是一个用 Python 的实现）。 1234567891011121314151617181920212223242526272829303132333435363738def getPartialTable(pattern): if not pattern: return None lp = len(pattern) res = [-1, 0] if lp &gt; 1: for curr in xrange(1, lp): ptr = curr while ptr &gt; 0 and pattern[curr] != pattern[res[ptr]]: ptr = res[ptr] else: res.append(res[ptr] + 1) return resdef matchPatternKMP(string, pattern): if not string or not pattern: return None p_table = getPartialTable(pattern) start, matched = 0, 0 ls, lp = len(string), len(pattern) stop = ls - lp + 1 res = list() while True: while matched == lp or string[start + matched] != pattern[matched]: if matched == lp: res.append(start) start += matched - p_table[matched] matched = max(0, p_table[matched]) if not start &lt; stop: return res else: matched += 1if __name__ == '__main__': string = 'abababaababacbababacb' pattern = 'aaa' print 'string:\t\t%s\npattern:\t%s' % (string, pattern) print matchPatternKMP(string, pattern) 复杂度分析好了，现在我们知道为什么 KMP 算法很快，也有了具体的实现。但是，它到底有多快呢？换句话说，它的时间复杂度是怎样的呢？ 我们先来看算法的主体部分： 12345678910while True: while matched == lp or string[start + matched] != pattern[matched]: if matched == lp: res.append(start) start += matched - p_table[matched] matched = max(0, p_table[matched]) if not start &lt; stop: return res else: matched += 1 首先注意到，在 while 循环内部，算法执行的操作数目是固定的；同时，每次循环失败，都可能执行最多 $m - 1$ 次 matched += 1。因此，整个算法的总体复杂度，就取决于 while 循环会被执行多少次。而要确定循环执行的次数，就要观察循环变量的初始值、中间变化和终止条件。 无疑，循环的终止条件与 start 有关：它从 0 开始，每次进入循环体都会自增，直到 start &lt; stop 的条件被破坏。因此，整个循环最多被执行 stop 次；整个算法最多有 $(n - m)\cdot m$ 次操作。看起来，这是一个复杂度为 $O(n\cdot m)$ 的算法。然而这是一个足够严格的渐进界限吗？答案是否定的，我们需要使用摊还分析来处理这个算法。 所谓摊还分析，就是抓住某一个变量（或者函数）的性质和行为，对零散、杂乱或不规则的执行进行累计，得到比一般方法更严格的上界。在这里，我们观察 matched 变量。它具有这样的性质： 0 &lt;= matched &lt;= m； 只在第 10 行增加，每次增加 1； 只在第 6 行有可能减少。 考虑到循环的终止条件，第 10 行最多被执行 stop 次；也就是 matched 最多自增 stop 次。考虑到 matched 必须保证非负，并且每次执行到第 6 行 matched 都会至少减小 1，所以第 6 行也最多被执行 stop 次。这也就是说，整个部分最多有 $2 \cdot \text{stop}$ 次操作。因此，它的时间复杂度不超过 $O(n)$。 同样的，我们可以用摊还分析的方法，分析部分匹配表的算法。 123456for curr in xrange(1, lp): ptr = curr while ptr &gt; 0 and pattern[curr] != pattern[res[ptr]]: ptr = res[ptr] else: res.append(res[ptr] + 1) 在这里，我们观察 res 这个部分匹配表；它具有这样的性质： 0&lt;= res[ptr] &lt;= lp； res[res[ptr]] &lt; res[ptr]，只在第 4 行出现 res[ptr] 当前值减小的情况； res[ptr] &lt;= res[ptr - 1] + 1，只在第 6 行有可能成立等号。 很眼熟，对吗？这个分析过程和 KMP 算法的主体几乎一模一样。事实上，求得部分匹配表的过程，就是拿模式串自己匹配自己的过程；无怪乎它和算法主体很相似了。同样，考虑到循环的终止条件，求得部分匹配表的过程，复杂度不超过 $O(m)$。 因此，考虑到总是有 $m &lt; n$，整个 KMP 算法的时间复杂度不超过 $O(n)$。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Pattern Match</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[调度场算法]]></title>
    <url>%2F2016%2F12%2F14%2FShunting-Yard-Algorithm%2F</url>
    <content type="text"><![CDATA[在软件工程课中，有一个经典的作业题：实现一个小学四则运算器。当然，它有不少变种，比如要求学生预先生成合规的四则运算题目。但不论如何变形，此类问题都绕不开 Dijkstra 提出的调度场算法。 回顾问题对于中国人来说，可能从小学学会四则运算开始，这件事情就变成了深入骨髓的本能。类似的问题，可能还有：人脸识别、性别判断等等。对于计算机而言，似乎有这样一个悖论：有一些对人而言非常自然和简单的事情，想要用有效的算法表示出来，就不那么容易。 比如，对于一个四则运算式子 11 + 2 * (3 + (4 + 5 - 6) * 2) 对于人来说，可能一眼扫过去，就知道应该怎样运算。可是，当被问及下面这个问题的时候，人们就很难回答了：怎样让计算机理解你使用的算法，并有足够的通用性去解决普遍的四则运算问题（带括号）。但不论如何，我们还是要回到这个问题本身，尝试理清一下，我们究竟是怎样在大脑里处理四则运算的。 首先，我们定义了「先乘除、后加减」的优先级规则，所有的运算都应该遵循这个规则。 其次，对于有括号的式子，我们会找到括号层次最深的部分（在这里就是 4 + 5 - 6），按照上述规则进行计算，逐层脱去括号。等到没有括号的时候，再依据基本的规则计算最终结果。 有人可能会说：你看，其实还是很简单的嘛，几句话就说清楚了。其实不然，原因有几个： 对于人来说，可以一观全貌，因此可以轻易地找到括号嵌套最深的部分。但是对于计算机而言，必须逐个 token (numbers and operators) 地读入，经过一系列的判断才能确定嵌套最深的部分。 对于人来说，可以一观全貌，因此可以轻松地判断是否还有括号。但对于计算机而言，每次脱去一层括号的时候，都需要完整地将式子扫描一遍（或者将记录扫描一遍），才能确定这个问题。 稍有算法分析和设计经验的人，可能会很敏感地发现：这事儿复杂度很高。其实不光是算法复杂度很高，用程序设计语言描述算法这件事情本身就很复杂——你试过就知道，你需要写一大堆的 if-else 才能完成这一任务。甚至，还有我们未曾考虑的问题：如何判断确定式子的合法性（比如括号是否成对）。 人类的习惯与计算机的习惯通过上面的说明，不难发现，这一件人类看起来相当简单的问题，对计算机来说不那么好处理。这话有些耳熟不是吗？哦，原来，在制作计算机之处，人们就发现用电路表示十进制运算，很困难。当然，这个问题早就解决了，因为人们发现，电路的通断很自然地就对应了二进制的 0 和 1。因此，在计算机内部，运算都是以二进制的形式展现的，只有到了呈现给人看的时候，才转换成十进制。这就引出了一个问题：十进制运算对人来说很自然，这是人类的习惯（因为人有十个手指，可能？），但是计算机看不懂；同时，二进制对于计算机来说很自然，这是计算机的习惯，但是人类读起二进制的 01 串，就费劲得很。 这件事情应该于我们有启发：处理带括号的四则运算这件事情，在计算机看来很复杂，究竟是因为问题本身困难？还是因为问题的形式不好？答案似乎是显而易见的——如果问题本身困难，那么人类也就无法快速学会四则运算了。所以，我们需要寻找问题的另一种展现形式。 中缀表达式与后缀表达式之前我们举过例子，给了一个简单的四则运算式子。这个式子，还有我们过去见过的大部分数学式子，都是用中缀表达式呈现的。有这些例子打底，顾名思义，不难理解何谓中缀表达式：将操作符（加减乘除符号）置于操作数中间的算式表示法，就是中缀表示法；对应的算式就是中缀表达式。 刚才说到，中缀表达式在人类看起来很简单和直观，但是对于计算机而言就不那么方便处理了。为此，我们需要引入另一种算式的表示方法：后缀表达式（逆波兰表达式）。它的特点有： 操作符置于被操作数的后面； 不需要括号，也不需要定义优先级，只需从左到右依次计算即可。 显而易见，操作符置于什么地方本身并不能解决痛点，但是省略了括号和优先级，就能正确计算结果，才是对计算机来说最重要的特性。就刚才的式子来说，转换成后缀表达式应该是： 11 2 3 4 5 + 6 - 2 * + * + 对计算机来说，它只需要从左向右扫描后缀表达式，每当遇到操作符的时候，就停下来，取出刚才读入的合适数量的操作数进行计算。而后它需要将计算结果放回序列，再重复整个步骤，直到完成计算就可以了。 现在的问题是，我们要如何快速有效地将中缀表达式转换成后缀表达式，以便计算机能够顺利处理。 调度场算法理想的算法是怎样的？事情总是从易到难，慢慢解决的。我们先看一个简单的例子，它不包含括号这种恼人的东西。 11 + 2 * 3 / 4 - 5 我们希望，一个完美的算法，能够从左往右扫描中缀表达式，然后就能得到等价的后缀表达式。虽然我们暂时不知道这个算法长什么样，不过我们可以先扫描试试看。 读入操作数 1，将它放在结果序列中 读入操作符 +，将它暂时保存在某个地方 尽管这个式子里，没有括号，但是仍然有操作符的优先级问题。现在，我们读入了操作符 +，问题就来了：我们不知道在 + 的后面，是否有优先级更高的操作符，会和它「争抢」操作数（也就是优先进行运算）。因此，我们不能将它直接放在结果序列中。因为，在后缀表达式中，操作符执行的顺序只取决于操作符在表达式中的顺序为止；如果我们将 + 直接放在结果序列中，那么即使后续有优先级更高的操作符出现，按照规则也只能先执行 +。因此，我们需要将 + 暂时保存在某个地方。 读入操作数 2，将它放在结果序列中 读入操作符 *，将它与那个地方最后的操作符 + 比较后，发现当前操作符的优先级更高 现在遇到了操作符 *，和「某个地方」最后的操作符 + 相比，* 的优先级更高。因此，在运算时，我们必须先执行 * 再执行 +。这毫无疑问。不过，尽管 * 的优先级更高，我们也依然无法保证后面是否会有更高优先级的运算符出现。因此我们仍然将 * 暂存。 读入操作数 3，将它放在结果序列中 读入操作符 /，将它与那个地方最后的操作符 * 比较后，发现二者优先级一致 现在我们遇到了 /，它的优先级与「那个地方」最后的操作符一致。我们知道 * 和 / 都是左结合的，也就是说，应该按顺序从左向右计算。所以，应该先计算 * 再计算 /。因此我们 将那个地方最后的运算符 * 取出，放入结果序列 紧接着，将 / 放入那个地方 读入操作数 4，将它放在结果序列中 读入操作符 -，与那个地方最后的操作符 / 比较，发现当前操作符的优先级更低 显而易见，当前操作符优先级低，就应该先进行 / 的计算。因此 将那个地方最后的运算符 / 取出，放入结果序列 将当前操作符 - 与那个地方最后的操作符 + 比较，发现二者优先级一致（遇到了熟悉的情况） 将那个地方最后的运算符 + 取出，放入结果序列 紧接着，将 - 放入那个地方 读入操作数 5，放入结果序列 读入完毕，将那个地方剩余的操作符 - 取出，于是得到 11 2 3 * 4 / + 5 - 完美！总结一下，我们不难发现整个流程有以下一些特点： 每次遇到操作数，都直接放入结果序列； 每次遇到操作符，都要与那个地方做比较，当 a. 当前操作符优先级较高，则将当前操作符放进那个地方；否则， b. 将那个地方最后的操作符取出并放入结果序列，并将当前操作符放进那个地方 结果序列是顺序填充的，一旦填充就确定位置不会更改； 那个地方挺神秘的，不过 a. 任意时刻，那个地方先进去的操作符总是在优先级上低于后进去的操作符；因此 b. 在从那个地方取出操作符的时候，总是先取出后进去的操作符 不难发现，「那个地方」所具有的性质，就是一个栈所具有的性质。因此，我们说，在这套流程里，我们需要一个栈作为辅助的数据结构，而作为结果序列，则只需要一个顺序表即可。我们将整个过程整理如下。 输入动作输出操作符栈说明1将操作数加入输出队列1+操作符压栈1+2将操作数加入输出队列1 2+*操作符压栈1 2+ *当前操作符优先级高于栈顶3将操作数加入输出队列1 2 3+ */操作符弹栈入列1 2 3 *+当前操作符优先级与栈顶相等操作符压栈1 2 3 *+ /当前操作符优先级高4将操作数加入输出队列1 2 3 * 4+ /-操作符弹栈入列1 2 3 * 4 /+当前操作符优先级低于栈顶操作符弹栈入列1 2 3 * 4 / +当前操作符优先级与栈顶相等操作符压栈1 2 3 * 4 / +-5将操作数加入输出队列1 2 3 * 4 / + 5-EOL弹栈入列至空1 2 3 * 4 / + 5 - 又有来自 Wikipedia 的图解（类似但不完全相同的问题）由 Salix alba - 自己的作品，CC BY-SA 3.0，链接 从图解中不难看出，操作符栈的行为，与供火车检修用和调度用的调度场非常相似，所以这个算法得名「调度场算法（Shunting Yard Algorithm）」. 算法描述经过了上面的分析，你应该已经对调度场算法有了大致的了解。剩余的内容，就是如何将括号，以及右结合的操作符纳入考量范围的过程了。不过，有了上面详细的分析，这些都不难。因此，这里就直接给出算法描述。 读入一个记号，直到无记号可读 如果记号是操作数，则加入输出队列 如果记号是操作符，记作 $O_c$ 若 $O_c$ 是左结合的且优先级不高于栈顶，或者 $O_c$ 是右结合的且优先级低于栈顶，则弹栈入列，直到条件被打破； $O_c$ 压栈 如果记号是左括号，则压栈 如果记号是右括号，则 弹栈入列，直到遇见左括号 弹栈，丢弃左括号 若遇见左括号之前，栈为空，则括号不匹配（右括号多） 无记号可读时 弹栈入列，直至栈空 若栈空之前遇见左括号，则括号不匹配（左括号多）]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Shunting Yard Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重读「病梅馆记」]]></title>
    <url>%2F2016%2F12%2F12%2Freview-of-bingmeiguanji%2F</url>
    <content type="text"><![CDATA[今天有人在群里讲，大意是「我就喜欢 CJK，不喜欢 CTeX 宏集，不够通用」。我对此的评价是「啥也不懂，瞎搞胡搞」，然后摘了龚自珍的「病梅馆记」中的一段话作为评论。 梅以曲为美，直则无姿；以欹为美，正则无景；以疏为美，密则无态。 后有人惊奇，曰：「这么偏的中学古文，你居然还记得」。答曰：「大约因为吾与龚自珍同类也」。 原文 江宁之龙蟠，苏州之邓尉，杭州之西溪，皆产梅。或曰：“梅以曲为美，直则无姿；以欹为美，正则无景；以疏为美，密则无态。”固也。此文人画士，心知其意，未可明诏大号以绳天下之梅也；又不可以使天下之民斫直，删密，锄正，以夭梅病梅为业以求钱也。梅之欹之疏之曲，又非蠢蠢求钱之民能以其智力为也。有以文人画士孤癖之隐明告鬻梅者，斫其正，养其旁条，删其密，夭其稚枝，锄其直，遏其生气，以求重价，而江浙之梅皆病。文人画士之祸之烈至此哉！ 予购三百盆，皆病者，无一完者。既泣之三日，乃誓疗之：纵之顺之，毁其盆，悉埋于地，解其棕缚；以五年为期，必复之全之。予本非文人画士，甘受诟厉，辟病梅之馆以贮之。 呜呼！安得使予多暇日，又多闲田，以广贮江宁、杭州、苏州之病梅，穷予生之光阴以疗梅也哉！ 重新读它不管是读古文，还是读英文，我都是反对通篇翻译的。你是来读文章的，不是来翻译它自虐的。所以我不翻译它，只是说说它讲了啥，以及我们该如何做。 文章第一段，用时下的粗话讲，就是：「你们这些脑残，胡搞瞎搞，好好的东西非得整坏了使」。怎么说呢？且看。 文章说，A/B/C 三个地方，都出产梅。然而好好的梅花，一帮子穷酸书呆子认为非得歪七扭八，才「别致」才「有韵味」。这帮心理变态瞎搞胡闹，惹得买梅花的人辛苦栽好了梅花，为了卖个好价钱，非得把树枝折了才好。这多脑残啊！ 文章第二段，用时下的话讲，就是：「梅花多可怜，我要拯救它。你们不喜欢，我就开一个『病梅馆』，故意跟你们对着干。怼死你！」 文章第三段，又急转直下，说：「脑残太多啊，药不够了啊！」 我们应该学到什么用适合的工具做合适的事Vim 很好，Emacs 很好。可是，它们不是万能的。作为通用编辑器，它们在编写的过程中，能提供很多快捷键、宏，来加快编辑速度。但是，在其他很多功能上，它们终究比不上以 Visual Studio 为代表的 IDE。 LaTeX 很好。可是，它也不是万能的。对于中文竖排、对于各种幻灯片特效的制作，它都不擅长。 可能有人会说：「Vim 加上 XX 插件也能完成 YY 任务」，或者「LaTeX 也可以做幻灯片的，有这样或那样的技巧」。 是，你们说的都没错。但是，我有更好的选择，能够又好又快地达成我的目标，我干嘛要浪费时间和生命在折腾这些工具上？要知道，我的目的是用工具来创造价值，而不是去研究工具本身。非得用工具做它不擅长的事情，就和那些穷酸书生非得对着梅花胡搞瞎搞，一个样。 要深入了解，不要轻易妄言什么是好？这个问题太大，一般人没法回答。但是，对于生物来说，所谓的「好」，就是健康地生活下去，最终传递自己的基因给下一代。穷酸书生，为了自己扭曲的审美，把梅花这里折断，那里掰弯，把梅花弄得奄奄一息——哦，要不是梅花这么坚韧的植物，还经不起这番折腾呢。这不是好，这就是名副其实地胡搞瞎搞。 究其本质，是这些穷酸书生没有深入去了解梅花的习性，自以为是又轻易妄言。 对于 CJK 来说，它取代了天元、CCT 等 LaTeX 中文支持方案。在那个时代是好的。这主要是因为，CJK 方案省去了将中文 .tex 文件预处理的步骤，可以直接编译。然而，使用 CJK 需要先将中文字体切成许多分子字体，然后制作成 TeX 能够识别的字体。这个过程本身繁琐，在任何平台上使用，都要做这么个操作，因此根本一点都不通用。 随着 XeTeX/LuaTeX 的开发完善，并随着 LuaTeX-ja/xeCJK/CTeX 宏包（宏集）的完善，CJK 已经完成了它的历史使命，应该说仅作为兼容性保留了。如果对 CJK 有过一些深入的了解，就知道它麻烦且排版效果不好了。说它通用性好，更是无稽之谈。 总之，要深入了解，不要妄下判断，甚至抱残守缺。]]></content>
      <categories>
        <category>Literature and Social Sciences</category>
      </categories>
      <tags>
        <tag>Review</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTeX 字体机制简介]]></title>
    <url>%2F2016%2F12%2F11%2FLaTeX-traditional-font-scheme%2F</url>
    <content type="text"><![CDATA[一直有很多人闹不清 .def, .fd, .pfb 之类文件的作用，这里正好看到 egreg 的回答，感觉很好，就翻译过来。 原文地址：http://tex.stackexchange.com/a/119501/38350 .def 文件t1enc.def 之类的 &lt;encoding&gt;enc.def 文件定义了字符形状（glyph）与编码的对应关系，LaTeX 读入这些文件之后，才能在相应的编码下正确调用字符形状来排版。在任意时刻，都有一个当前的字体编码。诸如 \&quot;{o} 的命令，在不同编码下的效果是不一样的。例如，在 OT1 编码下（或是其它不包含字符形状 ö 的编码），\&quot;{o} 会被翻译成 \accent&quot;7F o；在 T1 编码下，则是 \char&quot;F6。 当加载 fontenc 宏包的时候，LaTeX 就会读入 &lt;encoding&gt;enc.def 文件。具体读入的文件，由 fontenc 宏包的参数确定。每次读入 &lt;encoding&gt;enc.def 文件就改变一次当前字体编码。和大多数宏包不同，fontenc 宏包可以加载多次，以便根据不同的字体指定不同的编码。有一些字体相关的宏包，会在内部隐式地调用 fontenc 宏包（比如 textcomp 宏包）。在 \begin{document} 处的字体编码，则是最后一次传给 fontenc 宏包的参数。 除了 &lt;encoding&gt;enc.def 类型的文件，还有其他一些 .def 文件。不过这些文件就和字体没关系了。 .fd 文件当 LaTeX 遇到 \fontfamily{&lt;family&gt;}\selectfont 的时候（可能隐式地调用，比如在 \ttfamily 之类的字体声明处，以及在 \textsf 之类的字体命令处），LaTeX 会在内部表中查询是否有已知的，由 \DeclareFontFamily{&lt;encoding&gt;}{&lt;family&gt;}{&lt;tokens&gt;} 定义的组合 1&lt;encoding&gt;+&lt;family&gt; 这里，&lt;encoding&gt; 就是当前的字体编码。 假设当前的字体编码是 T1，然后希望使用 Palatino 字族（ppl），但 T1+ppl 的组合没有定义（也就是 \T1+ppl 命令未定义，对的，命令中间有个加号），那么 LaTeX 就会去寻找 t1ppl.fd 或者大写版本的 T1ppl.fd 文件。 如果二者都找不到，那么 LaTeX 就会输出警告，告诉用户「当前的字体我找不到，不过我会用另外的字体来替代」。不过，这种替代，不会改变当前的字体编码。 .fd 文件总是以 \DeclareFontFamily 声明开头，然后跟着若干个 \DeclareFontShape 命令。这些命令组合在一起，对应了 &lt;encoding&gt;+&lt;family&gt; 的组合。fntguide.pdf 里有更详细的介绍。 当然，你也可以在导言区里写 \DeclareFontFamily 或者 \DeclareFontShape 这样的命令。\DeclareFontShape 必须与紧跟的 \DeclareFontFamily 对应。这些声明会对应字体四个维度的属性声明，并对应一个字体尺寸文件（font metric file）。在我们的例子中 1\usefont&#123;T1&#125;&#123;ppl&#125;&#123;b&#125;&#123;up&#125; 会指向 pplb8t 这个字体尺寸。具体来说，字体尺寸文件又两种：.vf 文件或者 .tfm 文件。如果存在 pplb8t.vf 文件，那么 TeX 会优先加载它，否则就会加载 pplb8t.tfm 文件。二者必需有一个，否则就会报错。 在 \DeclareFontShape 命令中，你可以设定字体替换等规则；如果 LaTeX 没有找到合适的字体替换规则，那么就会使用默认字体去替换。如果 .fd 文件里，或者导言区中的，\DeclareFontShape 写错了，也会导致错误（Corrupt NFSS tables）。 接下来，假设 TeX 找到了 pplb8t.vf 或者 pplb8t.tfm 文件。 .vf 文件字体尺寸文件可以是虚拟的，pplb8t 正是这种情况。.vf 尺寸文件中有字符边界框、意大利体修正、铅空、连字等信息，还有一些关于从其它文件中（虚拟的或者实际存在的）选择实际字符形状的信息。在本例中，pplb8t.vf 选择了一个实际存在的字符形状 pplb8r 123456(MAPFONT D 0 (FONTNAME pplb8r) (FONTCHECKSUM O 25012244013) (FONTAT R 1.0) (FONTDSIZE R 10.0) ) 并按照 T1 字体编码重新对字符形状做了排序。例如，在 pplb8t.vf 的 &quot;F7 位上 （八进制 `367），有如下声明 12345678(CHARACTER O 367 (CHARWD R 0.832996) (CHARHT R 0.485498) (CHARDP R 0.011493) (MAP (SETCHAR O 234) ) ) 这是说，字符形状 œ（你在 LaTeX 里可以用 \oe 输出它）实际会在 pplb8r 的以八进制计算的第 `234 个位置（十六进制：&quot;9C）中取得，不过实际的用户是不会像关心它的。这里也包含了关于字符形状的尺寸信息：宽度 8.32996pt、高度 4.85498pt、深度 0.11493pt，并且意大利体修正为 0（这是在字体大小为 10pt 时候的值，否则需要按比例做额外的换算）。 .tfm 文件.tfm 文件（在本例中 pplb8r.tfm 文件必须存在）中的内容格式和 .vf 文件的格式完全相同，不过，它可以指向其他字体尺寸文件。 打住实际上，TeX 引擎关心的东西到这里就结束了：根据字符尺寸将字符排版并按页输出。打印或预览的驱动才会实际去关注字符形状。不过，对 pdfTeX 来说，它也需要储存所有的字符形状（译注：因为要直接输出 PDF 文件，必须知道字符形状）。 .map 文件粗体的字形 œ 最终从 pplb8r 里取得。因此 pdfTeX 会读取已经加载的 .map 文件（默认是 pdftex.map），在其中查找以 pplb8r 开头的条目 1pplb8r URWPalladioL-Bold " TeXBase1Encoding ReEncodeFont " &lt;8r.enc &lt;uplb8a.pfb 于是，pdfTeX 会读取 Type1 字体文件 uplb8a.pfb（如果已经读取过了就不会再次读取了），然后，pdfTeX 会对字体文件重新编码。这是因为 .pfb 文件是以 Adobe Standard Encoding 编码保存的，并且有一些字符形状在这种情况下是隐藏起来的。 于是，驱动（译注：在 pdfTeX 的情况下，驱动就是它自己）会根据 8r 编码（与 T1 类似，但不推荐在实际文稿中使用）重新排布字符形状的顺序。此时，字符形状 œ 会被保存在 &quot;F7 位置（而不是 Adobe Standard Encoding 中的 &quot;FA）。此外，字符形状 ö 不在 Adobe Standard Encoding 当中，不过它在 .pfb 文件中以未编码的形式存在着；在 8r 编码中，它被保存在 &quot;F6 位置。 我们需要的是 pplb8a，为什么最后读取的是 uplb8a 呢？这是因为，字体最终是由 URW 提供的免费版本。当然，实际用户是不会关注这个的。 .pfb 文件.pfb 文件包含了字符的形状，它们决定了字符在打印（或者预览）中是怎样呈现的。这些文件不会被用户直接调取，而是被引擎或者驱动程序调用。当然，也有 .pfa 文件，它和 .pfb 文件储存的信息完全相同，只不过它是用可见的 ASCII 码字符来储存信息的，因此它会比相应的 .pfb 文件要大出不少。 译注：在现代的 TeX 发行版中，有名为 tex-font-cheatsheet.pdf 的文件。你可以在系统命令行中执行 texdoc tex-font-cheatsheet 打开它。有惊喜！ 对于本篇的捐助，将用于支持 TeX 在中文界的发展。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Font</tag>
        <tag>Scheme</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈 C++ 中的右值引用]]></title>
    <url>%2F2016%2F12%2F11%2Frvalue-reference-in-Cpp%2F</url>
    <content type="text"><![CDATA[最近在改 XGBoost 的代码。XGBoost 在代码中使用了很多来自 C++11 标准中的特性，让我比较好奇和困惑的，就有其中关于右值引用的部分。涉及到代码里，有比较明显的两类用法： std::move1std::move(foo) std::unique_ptr1std::vector&lt;std::unique_ptr&lt;T&gt;&gt; 前者是使用 std::move 返回 foo 的右值引用；后者则在容器 std::vector 中放入了不可复制只能移动的类的对象（智能指针 std::unique_ptr），当你尝试用常规方法将整个 std::vector 中的元素依次加入另一个 std::vector 的时候，编译器就会报错，提示 std::unique_ptr 的拷贝构造函数是被删除的。 因为好奇和困惑，所以想要把它们搞清楚，于是有了这篇文章。 左值和右值左值和右值，最早是从 C 语言继承而来的。在 C 语言，或者继承版本，的解释中， 左值是可以位于赋值运算符 = 左侧的表达式（当然，左值也可以位于 = 的右侧），而 右值是不可以位于赋值运算符 = 左侧的表达式。 对于这个经典的解释，我们有如下示例 lvalue-and-rvalue123456789101112int foo(42);int bar(43);// foo, bar 都是左值foo = bar;bar = foo;foo = foo * bar;// foo * bar 是右值int baz;baz = foo * bar; // OK: 右值在赋值运算符右侧foo * bar = 42; // Err: 右值在赋值运算符左侧 这个解释很经典，也容易懂。不过在 C++ 里面，左值和右值不能这样定义。根据《C++ Primer》的说法，左值和右值可以这样区分： 一个表达式是左值还是右值，取决于我们使用的是它的值还是它在内存中的位置（作为对象的身份）。也就是说一个表达式具体是左值还是右值，要根据实际在语句中的含义来确定。例如1234567int foo(42);int bar;// 将 foo 的值赋给 bar，保存在 bar 对应的内存中// foo 在这里作为表达式是右值；bar 在这里作为表达式是左值// 但是 foo 作为对象，既可以充当左值又可以充当右值bar = foo; 因为 C++ 中的对象本身可以是一个表达式，所以这里有一个重要的原则，即 在大多数情况下，需要右值的地方可以用左值来替代，但 需要左值的地方，一定不能用右值来替代。 又有一个重要的特点，即 左值存放在对象中，有持久的状态；而 右值要么是字面常量，要么是在表达式求值过程中创建的临时对象，没有持久的状态。 左值引用和右值引用在 C++ 中，有两种对对象的引用：左值引用和右值引用。 左值引用是常见的引用，所以一般在提到「对象的引用」的时候，指得就是左值引用。如果我们将一个对象的内存空间绑定到另一个变量上，那么这个变量就是左值引用。在建立引用的时候，我们是「将内存空间绑定」，因此我们使用的是一个对象在内存中的位置，这是一个左值。因此，我们不能将一个右值绑定到左值引用上。另一方面，由于常量左值引用保证了我们不能通过引用改变对应内存空间的值，因此我们可以将右值绑定在常量引用上。 lvalue-reference1234int foo(42);int&amp; bar = foo; // OK: foo 在此是左值，将它的内存空间与 bar 绑定在一起int&amp; baz = 42; // Err: 42 是右值，不能将它绑定在左值引用上const int&amp; qux = 42; // OK: 42 是右值，但是编译器可以为它开辟一块内存空间，绑定在 qux 上 右值引用也是引用，但是它只能且必须绑定在右值上。 rvalue-reference1234567int foo(42);int&amp; bar = foo; // OK: 将 foo 绑定在左值引用上int&amp;&amp; baz = foo; // Err: foo 可以是左值，所以不能将它绑定在右值引用上int&amp;&amp; qux = 42; // OK: 将右值 42 绑定在右值引用上int&amp;&amp; quux = foo * 1; // OK: foo * 1 的结果是一个右值，将它绑定在右值引用上int&amp; garply = foo++; // Err: 后置自增运算符返回的是右值，不能将它绑定在左值引用上int&amp;&amp; waldo = foo--; // OK: 后置自减运算符返回的是右值，将它绑定在右值引用上 由于右值引用只能绑定在右值上，而右值要么是字面常量，要么是临时对象，所以： 右值引用的对象，是临时的，即将被销毁；并且 右值引用的对象，不会在其它地方使用。 敲黑板：这是重点！ 这两个特性意味着：接受和使用右值引用的代码，可以自由地接管所引用的对象的资源，而无需担心对其他代码逻辑造成数据破坏。 引用的值类型与引用叠加值类型我们思考一个问题：右值引用本身是左值还是右值？或者可以先思考一下它的对偶问题：左值引用本身是左值还是右值？ 先看下面的代码： lvalue-reference-value-type1234int foo(42);int&amp; bar = foo; // bar 是对 foo 的左值引用int&amp; baz = bar; // baz 是对 bar 的左值引用，因而 bar 是左值int qux = ++foo; // 前置自增运算符返回左值引用，在这里赋值给 qux，此时左值引用作为右值 观察上面代码，不难发现，左值引用本身既可以是左值，又可以是右值。它具体是左值还是右值，依然取决于它作为表达式时候的作用。更仔细地观察可以发现，如果左值引用作为一个变量被保存下来了，那么它就可以是左值（当然也可以起到右值的作用）；而如果左值引用是一个临时变量（例如函数的返回值），那么它就是右值。 同理可以用在右值引用上。 rvalue-reference-value-type123456789class Type;void foo(Type&amp;&amp; bar) &#123; // 将右值引用作为 Type 的构造函数的参数 // 此时匹配 Type::Type(const Type&amp; orig), 即拷贝构造函数 // bar 是左值 Type baz(bar);&#125;Type&amp;&amp; qux();quux = qux(); // qux 的返回值是 Type 类型的右值引用，此时右值引用是右值 和左值引用一样，右值引用本身也既可以作为左值也可以作为右值。并且，同样的是：如果右值引用作为变量被保存下来了，那么应该把它当做是一个左值看待；否则应当作为右值看待。 因此，不论是左值引用还是右值引用，都有 当引用作为变量被保存下来，那么它是左值；否则 它是右值。 叠加我们先来看一段代码。 reference_collapsing.cpp123456789typedef int&amp; intR;typedef intR&amp; intRR;int main() &#123; int foo = 42; intR bar = foo; intRR baz = bar; return 0;&#125; 在这里，intR 实际上是 int&amp;。因此 intRR 就变成了 int&amp; &amp;，注意两个 &amp; 之间有一个空格，表示这是对 int 类型引用的引用，也就是引用的叠加。在 C++11 之前，编译这份代码是会报错的： 1ref_test.cpp:2:15: 错误：无法声明对‘intR &#123;aka int&amp;&#125;’的引用 这是因为在 C++11 之前，C++ 标准没有写明引用叠加。在 C++11 中，引用叠加有如下规则： 1234Type&amp; &amp; -&gt; Type&amp;Type&amp; &amp;&amp; -&gt; Type&amp;Type&amp;&amp; &amp; -&gt; Type&amp;Type&amp;&amp; &amp;&amp; -&gt; Type&amp;&amp; 这有点类似布尔代数中的与运算：左值引用是 0，右值引用是 1。因此，在 C++11 中，上述代码中的 intRR 实际就是 int&amp; 类型。这样一来，代码就合法了。 同样的引用叠加规则，也可以应用到模板参数推导中。看这个例子 template-param12template &lt;typename T&gt; void func(T&amp;&amp; foo);auto fp = func&lt;int&amp;&amp;&gt;; 在这里，func 是一个模板函数，fp 是函数指针。要确定 fp 的实际类型，就要先确定模板函数参数的类型。 在模板中，T 被 int&amp;&amp; 替换，因此 T 是 int 的右值引用； 在函数参数列表声明中，foo 是 T&amp;&amp; 类型，因此是 int&amp;&amp; &amp;&amp; 类型，根据叠加规则，实际 foo 是 int&amp;&amp; 类型。 这样一来，fp 就是 void (*)(int&amp;&amp;) 类型的指针了。 右值引用怎么用说了这么多右值引用的概念，应该说点实际的用途了，这样右值引用这件事情看起来才会显得自然。 move 语义假设 class Container 有这样的定义 Container-demo12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;string&gt;class Container &#123; private: typedef std::string Resource; public: Container() &#123; resource_ = new Resource; std::cout &lt;&lt; "default constructor." &lt;&lt; std::endl; &#125; explicit Container(const Resource&amp; resource) &#123; resource_ = new Resource(resource); std::cout &lt;&lt; "explicit constructor." &lt;&lt; std::endl; &#125; ~Container() &#123; delete resource_; std::cout &lt;&lt; "destructor" &lt;&lt; std::endl; &#125; Container(const Container&amp; rhs) &#123; resource_ = new Resource(*(rhs.resource_)); std::cout &lt;&lt; "copy constructor." &lt;&lt; std::endl; &#125; Container&amp; operator=(const Container&amp; rhs) &#123; delete resource_; resource_ = new Resource(*(rhs.resource_)); std::cout &lt;&lt; "copy assignment." &lt;&lt; std::endl; return *this; &#125; private: Resource* resource_ = nullptr;&#125;; 于是当你执行类似这样的代码的时候，你会很郁闷地发现，效率很低： demo-return-Container1234567891011121314151617Container get() &#123; Container ret("tag"); return ret;&#125;int main() &#123; Container foo; // ... foo = get(); return 0;&#125;// $ ./a.out// default constructor.// explicit constructor.// copy assignment.// destructor// destructor 在执行 bar = foo() 的时候，会进行这样的操作： 从函数返回值中得到临时对象 rhs； 销毁 bar 中的资源（delete resource_;）； 将 rhs 中的资源拷贝一份，赋值给 bar 中的资源（resource_ = new Resource(*(rhs.resource_));）； 销毁 rhs 这一临时对象。 仔细想想你会发现，销毁 bar 中的资源，再从临时对象中复制相应的资源，这件事情完全没有必要。我们最好能直接抛弃 bar 中的资源而后直接接管 foo 返回的临时对象。这就是 move 语义。 这样一来，就意味着我们需要重载 Container 类的赋值操作符，它应该有这样的函数声明： 1Container&amp; Container::operator=(&lt;mystery type&gt; rhs) 为了与拷贝版本的赋值运算符区分，我们希望，当 Container::operator= 的右操作数是右值引用时，调用这个版本的赋值运算符，那么毫无疑问，&lt;mystery type&gt; 应该是 Container&amp;&amp;。于是我们定义它（称为移动赋值运算符，以及同时定义移动构造函数）： move-demo12345678910111213141516171819202122232425262728293031323334353637383940class Container &#123; private: typedef std::string Resource; public: Container() &#123; resource_ = new Resource; std::cout &lt;&lt; "default constructor." &lt;&lt; std::endl; &#125; explicit Container(const Resource&amp; resource) &#123; resource_ = new Resource(resource); std::cout &lt;&lt; "explicit constructor." &lt;&lt; std::endl; &#125; ~Container() &#123; delete resource_; std::cout &lt;&lt; "destructor" &lt;&lt; std::endl; &#125; Container(const Container&amp; rhs) &#123; resource_ = new Resource(*(rhs.resource_)); std::cout &lt;&lt; "copy constructor." &lt;&lt; std::endl; &#125; Container&amp; operator=(const Container&amp; rhs) &#123; delete resource_; resource_ = new Resource(*(rhs.resource_)); std::cout &lt;&lt; "copy assignment." &lt;&lt; std::endl; return *this; &#125; Container(Container&amp;&amp; rhs) : resource_(rhs.resource_) &#123; rhs.resource_ = nullptr; std::cout &lt;&lt; "move constructor." &lt;&lt; std::endl; &#125; Container&amp; operator=(Container&amp;&amp; rhs) &#123; Resource* tmp = resource_; resource_ = rhs.resource_; rhs.resource_ = tmp; std::cout &lt;&lt; "move assignment." &lt;&lt; std::endl; return *this; &#125; private: Resource* resource_ = nullptr;&#125;; 亦即，我们只需要对两个指针的值进行操作就可以了。这样一来，相同代码的执行过程会变成： move-demo-return-Container1234567891011121314151617Container get() &#123; Container ret("tag"); return ret;&#125;int main() &#123; Container foo; // ... foo = get(); return 0;&#125;// $ ./a.out// default constructor.// explicit constructor.// move assignment.// destructor// destructor 从函数返回值中得到临时对象 rhs； 交换 foo.resource_ 和 rhs.resource_ 两个指针的值； 销毁 rhs 这一临时对象。 这相当于我们将临时对象 rhs 中的资源「移动」到了 foo 当中，避免了销毁资源再拷贝赋值的开销。 完美转发（perfect forwarding）首先我们来看一个工厂函数 factory1234template&lt;typename T, typename ArgT&gt;std::shared_ptr&lt;T&gt; factory(const ArgT&amp; arg) &#123; return shapred_ptr&lt;T&gt;(new T(arg));&#125; factory 函数有两个模板参数 T 与 ArgT，并假定类型 T 有一个构造函数，可以接受 const ArgT&amp; 类型的参数，进行 T 类型对象的构造，然后返回一个 T 类型的智能指针，指向构造出来的对象。 毫无疑问，在这个例子里，factory 函数的 arg 变量既可以接受左值，也可以接受右值（允许将右值绑定在常量左值引用上）。但这里还有一个问题，按照之前的分析，不论 arg 接受的是什么类型，到了 factory 函数内部，arg 本身都将是一个左值。这样一来，假设类型 T 的构造函数支持对 ArgT 类型的右值引用，也将永远不会被调用。也就是说，factory 函数无法实现 move 语义，也就无法不能算是完美转发。 这里我们引入一个函数，它是标准库的一部分： forward12345template&lt;class S&gt;S&amp;&amp; forward(typename std::remove_reference&lt;S&gt;::type&amp; a) noexcept&#123; return static_cast&lt;S&amp;&amp;&gt;(a);&#125; 当 a 的类型是 S&amp; 的时候，函数将返回 S&amp;；当 a 的类型是 S&amp;&amp; 的时候，函数将返回 S&amp;&amp;。因此，在这种情况下，我们只需要稍微改动工厂函数的定义就可以了： factory-final1234template&lt;typename T, typename ArgT&gt;std::shared_ptr&lt;T&gt; factory(ArgT&amp;&amp; arg) &#123; return std::shapred_ptr&lt;T&gt;(new T(std::forward&lt;ArgT&gt;(arg)));&#125; 于是： 当 arg 是接受的参数是 Type&amp; 时，ArgT 是 Type&amp;，arg 的类型是 Type&amp;，T::T(Type&amp;) 被调用； 当 arg 是接受的参数是 Type&amp;&amp; 时，ArgT 是 Type&amp;&amp;，arg 的类型是 Type&amp;&amp;，T::T(Type&amp;&amp;) 被调用。 这样一来，就保留了 move 语义，实现了完美转发。 std::move标准库还定义了 std::move 函数，它的作用就是将传入的参数以右值引用的方式返回。 std::move1234567template&lt;class T&gt;typename std::remove_reference&lt;T&gt;::type&amp;&amp;std::move(T&amp;&amp; a) noexcept&#123; typedef typename std::remove_reference&lt;T&gt;::type&amp;&amp; RvalRef; return static_cast&lt;RvalRef&gt;(a);&#125; 首先，出现了两次 std::remove_reference&lt;T&gt;::type&amp;&amp;，它确保不论 T 传入的是什么，都将返回一个真实类型的右值引用。static_cast&lt;RvalRef&gt;(a) 则将 a 强制转换成右值引用并返回。有了 std::move，我们就可以调用 std::unique_ptr 的移动赋值运算符了（当然，单独这样调用可能没有什么意义）： 123std::unique_ptr&lt;Type&gt; new_ptr = std::move(old_ptr);// old_ptr 应当立即被销毁，或者赋予别的值// 不应对 old_ptr 当前的状态做任何假设 在这里，因为使用了 std::move 窃取了 old_ptr 中的资源，然后将他们移动到了 new_ptr 中去。这就隐含了一层意思：接下来我们不会在用 old_ptr 做任何事情，除非我们显式地对 old_ptr 赋予新值。事实上，我们不应对 old_ptr 当前的状态做任何假设，它就和已定义但未初始化的状态一样。因为，old_ptr 当前的状态，完全取决于 std::unique_ptr&lt;Type&gt;::operator=(unique_ptr&lt;Type&gt;&amp;&amp;) 的行为。 移动迭代器（move_iterator）现在假设有这样一个容器 std::vector&lt;std::unique_ptr&lt;RegTree&gt;&gt;，即在向量中保存了若干指向 RegTree 的 unique_ptr 智能指针；又有一个函数 BoostNewTrees(std::vector&lt;std::unique_ptr&lt;RegTree&gt;&gt;&amp; ret)，将会首先清洗 ret 中的数据，然后再将新的数据放入 ret 中。 现在，我需要循环多次执行 BoostNewTrees 函数，并将他们生成的数据依次放入一个容器里。那么，下面的代码会产生编译错误： 123456std::vector&lt;std::unique_ptr&lt;RegTree&gt;&gt; ret;for (size_t i(0); i != limit; ++i) &#123; std::vector&lt;std::unique_ptr&lt;RegTree&gt;&gt; tmp; BoostNewTrees(tmp); ret.insert(ret.end(), tmp.begin(), tmp.end()); // compile error!&#125; 这是因为，在调用 ret.insert() 函数时，传入的迭代器 tmp.begin() 在解引用时，会返回 std::unique_ptr&lt;RegTree&gt;&amp;，进而尝试调用拷贝构造函数 unique_ptr&lt;RegTree&gt;(const unique_ptr&lt;RegTree&gt;&amp;)，复制内容。然而，该函数被声明为「删除的」，不允许用户调用，于是报错。 为此，我们需要调用 std::make_move_iterator 函数（定义在 iterator 头文件里），将普通的迭代器转换为移动迭代器。相比普通迭代器，移动迭代器仅仅在解引用时的行为有不同：它将返回元素类型的右值引用（而不是普通迭代器返回的左值引用）。这相当于对普通迭代器每次解引用之后，都调用一次 std::move 获取右值引用。于是，在进行 insert 的时候，调用的就是移动构造函数 unique_ptr&lt;RegTree&gt;(unique_ptr&lt;RegTree&gt;&amp;&amp;) 了，而这是允许的。 123456789std::vector&lt;std::unique_ptr&lt;RegTree&gt;&gt; ret;for (size_t i(0); i != limit; ++i) &#123; std::vector&lt;std::unique_ptr&lt;RegTree&gt;&gt; tmp; BoostNewTrees(tmp); ret.insert(ret.end(), std::make_move_iterator(tmp.begin()), std::make_move_iterator(tmp.end()));&#125;// now we get `ret`. 参考 《C++ Primer, 5th Edition》 http://thbecker.net/articles/rvalue_references/section_01.html https://accu.org/index.php/journals/227 http://www.ibm.com/support/knowledgecenter/SSGH3R_13.1.2/com.ibm.xlcpp131.aix.doc/language_ref/reference_collapsing.html]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>Reference</tag>
        <tag>rvalue</tag>
        <tag>move</tag>
        <tag>move_iterator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Tmux 的 session 之间移动窗口]]></title>
    <url>%2F2016%2F12%2F11%2Fmove-windows-between-Tmux-sessions%2F</url>
    <content type="text"><![CDATA[继续记录一下 Tmux 的技巧。 实际使用中，我会在同一个宿主机上开多个 Tmux session。通常来说，每个 Session 内的不同 Windows 共同完成一件事情。这就意味着，同一个 Session 可能用 SSH 连着不同的机器。 某时刻，在 Session 1 中的 Window 1 已经完成任务；恰好，它连着机器 A，而 Session 2 正需要一个连着机器 A 的终端。此时就会考虑把 A 的终端从 Session 1 中移到 Session 2。 这可以用 Tmux 命令 move-window 来实现。 命令的使用命令的语法是 12move-window [-d] [-s src-window] [-t dst-window] (alias: movew) 首先你需要用 leader + : 来激活 Tmux 的命令模式（leader 的默认值是 Ctrl + B）。 然后，你可以用 -s session:window 和 -t session 来指定从哪里（-s）移动到哪里（-t）。比如 1movew -s dev-29:1 -t dev-33 这样，就能把 dev-29 这个 session 中的窗口 1 移植 dev-33 了。如果你已经在 dev-29:1 里面，那么直接用 1movew -t dev-33 就可以了。同样，如果你已经在 dev-33 里，那么就可以借助 -d 参数 1movew -d dev-29:1 来省略目标 session 的名字。 如果你没有给 session 起名字，就只能使用 session-id 代替名字了。你可以用 leader + s 查看所有 session 的 id。 参考 http://stackoverflow.com/a/3123600/3419508]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Tmux</tag>
        <tag>Session</tag>
        <tag>Window</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[互联网下半场对个人而言意味着什么？]]></title>
    <url>%2F2016%2F11%2F27%2Fbrief-think-of-the-last-half-of-Internet-time%2F</url>
    <content type="text"><![CDATA[互联网的人口红利已经结束了，上半场的粗犷增长已经结束，可以算是进入下半场了。所以我在想，这个下半场对于个人而言，意味着什么。 对于商家而言，最好挣的钱是信息不对称带来的；与之对应，对于个人而言，会最惨的结局，也会是因为信息不对称。举个栗子，过去，人们去中关村买东西，会被骗，中关村被称为骗子一条街；会被骗，就是因为信息不对称：这种不对称是因为不懂电脑，但更重要的是不知道别的顾客对东西的评价。后来有了电商，这种不对称就消失了；因为所有的评价都公开透明了：你买东西，所有曾经买过这个东西的人，都有评价。好的就点赞，差的就骂娘。这些所有的一切，你都能看到。 那么时代发展到这里，接下来的信息不对称，会以怎样的方式呈现出来呢？我觉得这件事情就变得很重要了。掌握了这件事情，就能成事，能挣钱；对于个人而言，就能避免悲惨的结局。今天我看到消息，讲Google 的 DeepMind 团队，和剑桥大学合作，搞了个「唇语识别 AI」。这个项目，轻轻松松，就秒杀了多年训练的人类唇语阅读专家，准确率是翻倍的提升。DeepMind 只是「稍稍尝试了一下」，就完成了这样的工作。于是我有感触，互联网下半场对于个人而言，信息不对称以另外的方式呈现：不善于学习和不敢于尝试新东西的人会在这波被落下，边缘化，然后彻底被抛弃。也就是说，因为互联网的信息传递能力，社会的平均信息水平提高；但与之相对应的，个人信息水平与对事物的接触早晚程度关系不大，主要决定于个人的学习能力。郑渊洁前段时间在演讲里说，「时代已经从『隔行如隔山』发展到了『隔行可登山』」，深以为然。 所以结论是：如果一个人，不善于学习、不敢于尝试，在接下来的时代，会死得很惨。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Internet</tag>
        <tag>Thinking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 惯用法 CRTP 简介]]></title>
    <url>%2F2016%2F11%2F26%2FIntroduction-to-CRTP-in-Cpp%2F</url>
    <content type="text"><![CDATA[虚函数与动态绑定C++ 通过类的继承与虚函数的动态绑定，实现了多态。这种特性，使得我们能够用基类的指针，访问子类的实例。例如我们可以实现一个名为 Animal 的基类，以及 Cat, Dog 等子类，并通过在子类中重载虚函数 jump，实现不同动物的跳跃动作。而后我们可以通过访问 Zoo 类的实例中存有 Animal 指针的数组，让动物园中所有的动物都跳一遍。 123456789101112class Zoo &#123; ... private: std::vector&lt;shared_ptr&lt;Animal&gt;&gt; animals; public: void () &#123; for (auto animal : animals) &#123; animal-&gt;jump(); &#125; &#125; ...&#125; 在每次执行 animal-&gt;jump() 的时候，系统会检查 animal 指向的实例实际的类型，然后调用对应类型的 jump 函数。这一步骤需要通过查询虚函数表（vtable）来实现；由于实际 animal 指向对象的类型在运行时才确定（而不是在编译时就确定），所以这种方式称为动态绑定（或者运行时绑定）。 因为每次都需要查询虚函数表，所以动态绑定会降低程序的执行效率。为了兼顾多态与效率，有人提出了 Curiously Recurring Template Pattern 的概念。 通过模板实现静态绑定为了在编译时绑定，我们就需要放弃 C++ 的虚函数机制，而只是在基类和子类中实现同名的函数；同时，为了在编译时确定类型，我们就需要将子类的名字在编译时提前传给基类。因此，我们需要用到 C++ 的模板。 demo.cpp12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;template&lt;typename T&gt;class Base &#123; public: void show () const &#123; static_cast&lt;const T*&gt;(this)-&gt;show(); &#125;&#125;;class Derived: public Base&lt;Derived&gt; &#123; public: void show () const &#123; cout &lt;&lt; "Shown in Derived class." &lt;&lt; endl; &#125;&#125;;int main () &#123; Derived d; Base&lt;Derived&gt; *b = &amp;d; b-&gt;show(); return 0;&#125; 这是一个简单的 CRTP 的例子，有以下一些特点： 基类是一个模板类，接收子类的类型名字； 因此子类的继承列表会类似于 Derived: public Base&lt;Derived&gt;； 基类的函数在函数体中，使用 static_cast&lt;&gt; 将基类的指针转为（模板）子类的指针，在编译期完成绑定。 因此，在实际执行时，我们用 b-&gt;show() 打印出「Shown in Derived class.」的字样，显示我们确实调用了子类的 show 函数。 再举一个稍微复杂一点的例子。 complicated_demo.cpp1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;template&lt;typename T&gt;class Base &#123; public: void show () const &#123; static_cast&lt;const T*&gt;(this)-&gt;show(); &#125; Base&lt;T&gt; operator++() &#123; static_cast&lt;T*&gt;(this)-&gt;operator++(); &#125;&#125;;class Derived: public Base&lt;Derived&gt; &#123; public: Derived () : val(0) &#123;&#125;; void show () const &#123; cout &lt;&lt; "Shown in Derived class." &lt;&lt; endl; cout &lt;&lt; "Val is " &lt;&lt; this-&gt;val &lt;&lt; "." &lt;&lt; endl; &#125; Derived operator++() &#123; ++(this-&gt;val); return *this; &#125; private: int val;&#125;;int main () &#123; Derived d; Base&lt;Derived&gt; *b = &amp;d; b-&gt;show(); ++(*b); b-&gt;show(); return 0;&#125; 这一次，我们在子类中，额外重载了前置的自增运算符（参数列表不带 int）。因此，在基类中，我们首先要将 this 指针转换为 T* 类型，然后调用子类的前置自增运算符（operator++()）。 用在哪里？现在我们考虑这样一个问题。 在使用虚函数的风格中，我们可以把 Cat*, Dog*… 等不同子类的指针，复制给基类的指针 Animal*，然后把基类的指针存入容器中（比如 vector&lt;Animal*&gt;）。但是，在 CRTP 中，我们就做不到这样了。这是因为同样是基类的指针 Animal&lt;Cat&gt;* 和 Animal&lt;Dog&gt;* 是两种完全不同的类型的指针。这样一来，我们就没法构造一个动物园了。 摔！ 那么，CRTP 到底应该怎么用呢？我们不妨回过头来想一想，最初我们引入 CRTP 是为了什么。文章开头的第一段，我们提到多态是个很好的特性，但是动态绑定比较慢，因为要查虚函数表。而事实上，动态绑定慢，通常是因为多级继承；如果继承很短，那么查虚函数表的开销实际上也没多大。 在之前举出的例子里，我们运用 CRTP，完全消除了动态绑定；但与此同时，我们也在某种意义上损失了多态性。现在我们希望二者兼顾：保留多态性，同时降低多级继承带来的虚函数表查询开销。答案也很简单：让 CRTP 的模板类继承一个非模板的基类——这相当于这个非模板的基类会有多个平级的不同的子类。一个示例如下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;vector&gt;using std::cout; using std::endl;using std::vector;class Animal &#123; public: virtual void say () const = 0; virtual ~Animal() &#123;&#125;&#125;;template &lt;typename T&gt;class Animal_CRTP: public Animal &#123; public: void say() const override &#123; static_cast&lt;const T*&gt;(this)-&gt;say(); &#125;&#125;;class Cat: public Animal_CRTP&lt;Cat&gt; &#123; public: void say() const &#123; cout &lt;&lt; "Meow~ I'm a cat." &lt;&lt; endl; &#125;&#125;;class Dog: public Animal_CRTP&lt;Dog&gt; &#123; public: void say() const &#123; cout &lt;&lt; "Wang~ I'm a dog." &lt;&lt; endl; &#125;&#125;;int main () &#123; vector&lt;Animal*&gt; zoo; zoo.push_back(new Cat()); zoo.push_back(new Dog()); for (vector&lt;Animal*&gt;::const_iterator iter&#123;zoo.begin()&#125;; iter != zoo.end(); ++iter) &#123; (*iter)-&gt;say(); &#125; for (vector&lt;Animal*&gt;::iterator iter&#123;zoo.begin()&#125;; iter != zoo.end(); ++iter) &#123; delete (*iter); &#125; return 0;&#125; 这样一来，我们就兼顾了多态性和效率。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Template</tag>
        <tag>Cpp</tag>
        <tag>Class</tag>
        <tag>Idiom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从硬编码的数组中初始化 vector 容器]]></title>
    <url>%2F2016%2F11%2F26%2Finit-vector-from-array%2F</url>
    <content type="text"><![CDATA[这是一篇简单的记录，因为我总是忘记如何从硬编码的 Array 中初始化得到一个 Vector。 123456789#include &lt;vector&gt;using std::vector;int main () &#123; const int arr[] = &#123;16,2,77,29&#125;; vector&lt;int&gt; vec (arr, arr + sizeof(arr) / sizeof(arr[0])); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>Vector</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探幽：C++ 的读入速度]]></title>
    <url>%2F2016%2F11%2F19%2Fthe-speed-of-reading-files-in-Cpp%2F</url>
    <content type="text"><![CDATA[这篇文章的缘起有二： 很多人主张「应当在几乎所有情况下使用 C 风格的 I/O」（比如这里），而我很怀疑； 另一方面，在刷 POJ 的时候，使用 std::cin 确实能 TLE 而改成 std::scanf 就 AC 了，因此想试试看 std::cin 能否加速。 中文网络里，已有码农场和 byvoid 菊苣的讨论。不过二者对于原理的解释，自我感觉都不够清晰；又本着自己动手做实验的坚持，决定写下这篇文章，探讨 C++ 的读入速度的问题，特别是读入文件速度的问题。 从稍微底层介绍起std::cin 为什么慢？要解释这个问题，就得从稍微底层的角度说起。 以 Linux 为例。Linux 内核负责管理计算机硬件，对接硬件规格，向上提供系统调用（System Call）。内核之上的运行时库（Runtime Library）负责对接系统调用，向上提供操作系统应用编程接口（Operation System Application Programming Interface, OS API）。 对于我们使用 C/C++ 编程来说，所作的几乎全部事情，都基于运行时库提供的 OS API（glibc 提供的 POSIX API）；少数操作，可以通过 OS API 中提供的类函数直接操作系统调用（如 fork() 函数）。 因此，不难理解，不论是 std::cin 还是 std::scanf 都是对 OS API 的封装，而 OS API 又是对系统调用的封装。至于再往下，系统调用就直接通过内核操作硬件了。因此，可以粗略地估计，直接使用系统调用做 I/O 会比用 OS API 要快；而用 OS API 又会比封装 OS API 的语言库函数要慢。 我们这里讨论 std::cin 和 std::scanf，因此主要关系 I/O 中的 Input 部分。在 Linux 系统调用中，和文件读取相关的系统调用有两个类函数。 void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);: 封装名为 mmap2 的系统调用（mmap 自 Linux 2.4 起弃用）；mmap 将磁盘上的文件一一映射到实存空间，当进程调用相关内存的时候，通过缺页错误真正将文件内容拷贝到实存。 ssize_t read(int fd, void *buf, size_t count);: 封装名为 read 的系统调用。这里 ssize_t 是 __kernel_ssize_t 的 typedef；而 __kernel_ssize_t 在 32 位系统上是 int 的 typedef，在 64 位系统上是 long ing 的 typedef。read 会从文件描述符（file description）fd 中读入 count 个字节，存入 buf 缓存中。 由于 mmap 做的事情比 read 少（事实上它几乎只分配了内存空间并做了一个映射），所以 mmap 函数本身会比 read 函数快一些。 在标准库中，和输入相关函数的有以下一些。 size_t fread ( void * ptr, size_t size, size_t count, FILE * stream );: 从文件流中读取一块内容，存入 ptr 指向的内存。 int scanf ( const char * format, ... );: 从标准输入中读入内容，并以格式化字符串将读入的内容存入相应的指针。 std::istream: C++ 风格的输入流（包括 std::cin 等）。 std::cin 做了哪些额外的工作通常为人诟病的是 std::cin 的速度。std::cin 是标准库里的东西。我们知道，标准库是要为千万人所用的东西，所以它对性能要求非常严格。按理说，标准库里的东西，只要正确使用，就不应该慢。那么现在，既然它慢，就有个原因。这个原因，又肯定是它做了额外的工作（相比 std::scanf）。那么 std::cin 做了哪些额外的工作呢？ 事实上，为了「安全」，std::cin 主要做了两件额外的事情： 与 std::cout 绑定，每次 std::cin 从缓冲区读入内容之前，确保已经执行过 std::cout.flush()； 与 stdio 同步（synchronize），确保混搭使用 C 风格的 I/O 操作不会引发问题。 如果我们能手工确保不会出问题，那么就可以省略 std::cin 做的这些额外的工作。 std::ios::tie首先我们解决「绑定」的问题。 绑定是通过 std::ios::tie 这个函数实现的。它作为 ios 类的成员函数，有两个重载。 ostream* tie() const: 返回当前绑定的输出流实例的指针。 ostream* tie (ostream* tiestr): 返回当前绑定的输出流实例的指针，再将 tiestr 绑定到当前实例。 cplusplus 网站上提供了这样的示例： demo_tie.cpp1234567891011121314151617181920// redefine tied object#include &lt;iostream&gt; // std::ostream, std::cout, std::cin#include &lt;fstream&gt; // std::ofstreamint main () &#123; std::ostream *prevstr; std::ofstream ofs; ofs.open ("test.txt"); std::cout &lt;&lt; "tie example:\n"; *std::cin.tie() &lt;&lt; "This is inserted into cout"; prevstr = std::cin.tie (&amp;ofs); *std::cin.tie() &lt;&lt; "This is inserted into the file"; std::cin.tie (prevstr); ofs.close(); return 0;&#125; 默认情况下，std::cin 与 std::cout 绑定。因此第一次调用 std::cin.tie() 返回的是 std::cout 的指针。因此第一次输出将会打印到标准输出上。 之后，我们用 std::cin.tie (&amp;ofs) 将一个文件输出流绑定在 std::cin 上，并将 std::cout 的指针存在 prevstr 中。这时候，第二次调用 std::cin.tie() 返回的是 ofs 的指针。因此第二次输出将会打印到 ofs 绑定的文件中（test.txt）。 因此，代码正确执行后，将会在控制台打印： tie example:This is inserted into cout 在文件 test.txt 中写入： This is inserted into the file 为了解除 std::cin 与 std::cout 的绑定，我们可以这样做 untie123std::ostream *prevstr = std::cin.tie();std::cin.tie(nullptr);// ... use cin without tying to cout std::ios_base::sync_with_stdio接下来我们解决同步的问题。 在所有输入输出流的基类（std::ios_base）中定义了 sync_with_stdio 函数。它的原型是： 1static bool sync_with_stdio( bool sync = true ) 默认情况下，这个同步机制是打开的。于是，在 C++ 的流上做的任何操作，会被立即同步到相应的 C 的流中。因此，在代码里我们可以混搭 C 风格和 C++ 风格的流操作。 我们可以通过这样做，以解除 C++ 风格的输入输出流与 C 风格的输入输出流的绑定： 1std::ios_base::sync_with_stdio(false); 实验随机数生成作为实验的预备，我们需要生成一组随机数，作为读入。这里计划生成的文件，样式为： 123456a_1 b_1a_2 b_2...a_k b_k...a_n b_n 其中，$a_1, \ldots, a_n$ 是随机整数，$b_1, \ldots, b_n$ 是随机浮点数。我们用 Python 来实现随机数的生成和输出。 gen_random.py123456789101112131415import randomimport sysdef getRandom(fname_base, lines_num): fname = '%s_%d.txt' % (fname_base, lines_num) with open(fname, 'w') as fout: temp = '%d %f\n' % (random.randint(-1000, 1000), random.gauss(0, 10)) fout.write(temp)if __name__ == '__main__': exp = [3, 4, 5, 6, 7, 8] NUMS = map(lambda x: 10 ** x, exp) base = 'random' for num in NUMS: getRandom(base, num) 实验环境 编译器：gcc-4.7.2 操作系统：CentOS 5.4 CPU 型号：Intel(R) Xeon(R) CPU E5645@2.4 GHz 主存大小：65979428 KiB 磁盘大小：388 GiB 实验代码scanf.cpp12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;chrono&gt;int main()&#123; int a(0); double b(0.0); auto start = std::chrono::high_resolution_clock::now(); while (~scanf("%d %f", &amp;a, &amp;b)) &#123;&#125; auto end = std::chrono::high_resolution_clock::now(); auto take_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start); std::cout &lt;&lt; take_time.count() &lt;&lt; " us\n"; return 0;&#125; cin.cpp12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;chrono&gt;int main()&#123; int a(0); double b(0.0); auto start = std::chrono::high_resolution_clock::now(); while (std::cin &gt;&gt; a &gt;&gt; b) &#123;&#125; auto end = std::chrono::high_resolution_clock::now(); auto take_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start); std::cout &lt;&lt; take_time.count() &lt;&lt; " us\n"; return 0;&#125; cin-speed_up.cpp123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;chrono&gt;int main()&#123; int a(0); double b(0.0); std::cin.tie(0); std::ios_base::sync_with_stdio(false); auto start = std::chrono::high_resolution_clock::now(); while (std::cin &gt;&gt; a &gt;&gt; b) &#123;&#125; auto end = std::chrono::high_resolution_clock::now(); auto take_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start); std::cout &lt;&lt; take_time.count() &lt;&lt; " us\n"; return 0;&#125; 实验结果这里用管道的方式，将输入数据传给编译好的可执行映像。 1cat foobar.txt | ./a.out 这里将每一份数据重复输入可执行映像 5 次，然后去除最低和最高的执行时间，取中间三个做平均值，得到结果如下（单位：微秒）。 数据大小cincin -O2cin 加速cin 加速 -O2scanfscanf -O2 10^31962217911311020754773 10^4200992044810496981771877205 10^513954114678175328703025249855002 10^614015581382098681064651954476777481314 10^713318033139568416687289646869247794534760468 从表中可以看出，std::scanf 在实验条件下速度始终最快，但与「加速之后的」std::cin 处于同一个数量级。而它们都比默认的 std::cin 要快出一个数量级。这个结论随着数据量的增长保持不变。 另外，使用编译器的 -O2 参数，打开编译器优化之后，std::cin 对优化不敏感，甚至在一些数据集上优化之后的速度反而变慢；加速之后的 std::cin 和 std::scanf 则对优化敏感，其中加速之后的 std::cin 对优化尤其敏感。 在这个实验中，std::scanf 的确在速度上有优势，似乎验证了「很多人」的主张。不过，tatanaideyo 做了类似的实验，结果表明： std::scanf 和加速之后的 std::cin 一定比 std::cin 快； std::scanf 在读入浮点数时比加速之后的 std::cin 快； std::scanf 在读入整形数值时比加速之后的 std::cin 慢。 总结加速之后的 std::cin 并不一定比 std::scanf 慢；在大多数日常使用的情形下，其效率在渐进意义上与 std::scanf 相当。tatanaideyo 则表明，如果数据中包含大量的整形数值，则使用加速之后的 std::cin 会更有优势；反之若数据中包含大量的浮点数，则使用 std::scanf 更佳。 更多探讨可以参考：http://codeforces.com/blog/entry/5217 参考 《程序员的自我修养：链接、装载和库》 http://www.tutorialspoint.com/unix_system_calls/read.htm http://man7.org/linux/man-pages/man2/read.2.html http://man7.org/linux/man-pages/man2/mmap.2.html http://www.cplusplus.com/reference/cstdio/fread/ http://www.cplusplus.com/reference/cstdio/scanf/ http://www.cplusplus.com/reference/ios/ios/tie/ http://en.cppreference.com/w/cpp/io/ios_base/sync_with_stdio https://www.byvoid.com/blog/fast-readfile/ http://www.hankcs.com/program/cpp/cin-tie-with-sync_with_stdio-acceleration-input-and-output.html https://heavywatal.github.io/cxx/speed.html http://tatanaideyo.hatenablog.com/entry/2014/10/24/214714 http://codeforces.com/blog/entry/5217 http://stackoverflow.com/questions/14052627/why-do-we-need-to-tie-cin-and-cout https://www.quora.com/What-is-use-of-the-statement-ios_base-sync_with_stdio-false-cin-tie-NULL-cout-tie-NULL-What-does-it-do http://www.cnblogs.com/huxiao-tee/p/4660352.html http://en.cppreference.com/w/cpp/chrono/duration]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>I/O</tag>
        <tag>cin</tag>
        <tag>scanf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Shell 脚本中解析选项]]></title>
    <url>%2F2016%2F11%2F11%2Fways-to-parse-arguments-in-shell-script%2F</url>
    <content type="text"><![CDATA[大多数命令行工具，都会提供一些选项。在不同的选项组合之下，这些工具会有不同的行为。GNU 标准的命令行选项解析工具是 getopts，它比其兄弟 getopt 更为强大。除了介绍 getopts 的用法之外，这里还会介绍两种手工解析参数的方法。 在正式介绍之前，有必要区分几个概念（在 Shell 脚本中）。 Argument, Option: 中文对应「选项」，形如 -a, --save 的都是选项；选项可以接收参数（Parameter），也可以不接受参数。 Flag: 中文对应「标签」，形如 -v(verbose)；标签是布尔值，不接受参数。 下面正式开始介绍。 手工解析手工解析部分比较简单，这里不做过多的展开。涉及到参数截取的内容，可以参考前作。 手工解析部分提供两种传参的方式： 形如 --save foo.txt； 形如 --save=foo.txt。 space_mode.sh1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/env bashwhile [[ $# -gt 1 ]]dokey="$1"case $key in -e|--extension) EXTENSION="$2" shift # past argument ;; -s|--searchpath) SEARCHPATH="$2" shift # past argument ;; -l|--lib) LIBPATH="$2" shift # past argument ;; --default) DEFAULT=YES ;; *) # unknown option ;;esacshift # past argument or valuedoneecho FILE EXTENSION = "$&#123;EXTENSION&#125;"echo SEARCH PATH = "$&#123;SEARCHPATH&#125;"echo LIBRARY PATH = "$&#123;LIBPATH&#125;"echo "Number files in SEARCH PATH with EXTENSION:" $(ls -1 "$&#123;SEARCHPATH&#125;"/*."$&#123;EXTENSION&#125;" | wc -l)if [[ -n $1 ]]; then echo "Last line of file specified as non-opt/last argument:" tail -1 $1fi equal_sign_mode.sh12345678910111213141516171819202122232425262728293031323334#!/usr/bin/env bashfor i in "$@"docase $i in -e=*|--extension=*) EXTENSION="$&#123;i#*=&#125;" shift # past argument=value ;; -s=*|--searchpath=*) SEARCHPATH="$&#123;i#*=&#125;" shift # past argument=value ;; -l=*|--lib=*) LIBPATH="$&#123;i#*=&#125;" shift # past argument=value ;; --default) DEFAULT=YES shift # past argument with no value ;; *) # unknown option ;;esacdoneecho "FILE EXTENSION = $&#123;EXTENSION&#125;"echo "SEARCH PATH = $&#123;SEARCHPATH&#125;"echo "LIBRARY PATH = $&#123;LIBPATH&#125;"echo "Number files in SEARCH PATH with EXTENSION:" $(ls -1 "$&#123;SEARCHPATH&#125;"/*."$&#123;EXTENSION&#125;" | wc -l)if [[ -n $1 ]]; then echo "Last line of file specified as non-opt/last argument:" tail -1 $1fi getopts 的用法getopts 是成熟的选项解析工具，因此功能相对手工解析来说自然是更加完备和强大。我们先来看看使用 getopts 解析选项的脚本的一个用法示例。 1mybackup -x -f /etc/mybackup.conf ./foo.txt ./bar.txt 这里，mybackup 是一个 Shell 脚本，它接收了几个选项： -x，这是一个标签，由 - 和标签名字 x 组成； -f，这是一个选项，它的参数是 /etc/mybackup.conf； ./foo.txt 和 ./bar.txt 则是余下的参数，他们作为操作数 (operands) 传递给脚本。 使用 getopts 的话，这个调用方法等价于 1mybackup -xf /etc/mybackup.conf ./foo.txt ./bar.txt getopts 的工作方式通常来说，我们会将 getopts 放在 while 循环的条件判断式中。getopts 在顺利解析到参数的时候，会返回 TRUE；否则返回 FALSE，用以结束循环。（类似 C++ 中 while (cin &gt;&gt; var) 的用法） getopts 在两种情况下会停止解析并返回 FALSE： getopts 读入不以 - 开始的字符串； getopts 读入连续的两个 - (i.e. --)。 注意：getopts 不支持两个连字符引导的选项，而是将两个连续的连字符作为「选项结束的标志」。 123while getopts ...; do ...done 变量和用法 OPTIND: getopts 在解析传入 Shell 脚本的参数时（也就是 #@），并不会执行 shift 操作，而是通过变量 OPTIND 来记住接下来要解析的参数的位置。 OPTARG: getopts 在解析到选项的参数时，就会将参数保存在 OPTARG 变量当中；如果 getopts 遇到不合法的选项，择把选项本身保存在 OPTARG 当中。 getopts 的用法如下 1getopts OPTSTRING VARNAME [ARGS...] 这里 OPTSTRING 记录合法的选项列表（以及参数情况）； VARNAME 则传入一个 Shell 变量的名字，用于保存 getopts 解析到的选项的名字（而不是参数值，参数值保存在 OPTARG 里）； ATGS... 是可选的，默认是 $@，即传入 Shell 脚本的全部参数。 OPTSTRING通过 OPTSTRING，我们可以告诉 getopts 哪些参数是合法的，哪些参数又是需要接受参数的。OPTSTRING 的格式很简单，就是一个简单的字符串。字符串里，每一个字母（大小写均可，但区分大小写）都是一个选项的名字。 值得一提的是冒号 (:)。在 OPTSTRING 中，冒号有两种含义： 首位的 : 表示「不打印错误信息」； 紧邻字母（选项名字）的 : 表示该选项接收一个参数。 举几个例子。 1getopts fAx VARNAME 表示 getopts 会寻找 -f, -A 和 -x 三个选项。它们都是标签，不接受参数。 1getopts :f:Ax VARNAME 表示 getopts 会寻找 -f, -A 和 -x 三个选项，并且不打印错误信息。其中 -A 和 -x 是标签，不接受参数；-f 是可以接受参数的选项。 举个栗子getopts_test.sh123456789101112#!/usr/bin/env bashwhile getopts ":a" opt; do case $opt in a) echo "-a was triggered!" &gt;&amp;2 ;; \?) echo "Invalid option: -$OPTARG" &gt;&amp;2 ;; esacdone 首先给一点解释。 我们首先看 getopts 的 OPTSTRING 部分：:a。按照上面的介绍，我们知道，getopts 将不会打印错误信息，并且会寻找 -a 这个选项。而后，VARNAME 是 opt。这就是说，getopts 会将找到的选项的名字（例如 a）存在 opt 这个 Shell 变量当中。在后续的处理过程中，我们可以引用它。 将上述内容保存为 getopts_test.sh，然后就可以验证了。 啥也不做 12$ ./getopts_test.sh$ getopts 解析的内容是 $@，在这个例子里是空。于是 getopts 返回 FALSE 结束循环。整个脚本什么也不做。 传入不是选项的参数 12$ ./getopts_test.sh foo.txt$ 这次 $@ 有东西了。但是 foo.txt 不以连字符 - 开始，所以 getopts 仍然返回 FALSE，结束循环。整个脚本什么也不做。 传入参数 123$ ./getopts_test.sh -a-a was triggered!$ 如约打印了「标签 a 激活了」的字样。 123456$ ./go_test.sh -a -x -b -c-a was triggered!Invalid option: -xInvalid option: -bInvalid option: -c$ 注意，这里传入的 -x, -b 和 -c 都是不合法的选项，于是 getopts 将 ? 存入 $opt，而将非法的选项名字 x, b 和 c 保存在 $OPTARG 当中；进而被 case 语句抓住，并打印相关内容。 又一个栗子another_test.sh1234567891011121314151617#!/usr/bin/env bashwhile getopts ":a:" opt; do case $opt in a) echo "-a was triggered, Parameter: $OPTARG" &gt;&amp;2 ;; \?) echo "Invalid option: -$OPTARG" &gt;&amp;2 exit 1 ;; :) echo "Option -$OPTARG requires an argument." &gt;&amp;2 exit 1 ;; esacdone 参照之前的例子和已有的解释，不难理解这个脚本会有怎样的行为。除去和上一个例子相同的测试之外，我们看看下面两个测试。 合法选项、缺少参数 123$ ./another_test.sh -aOption -a requires an argument.$ 在遇到 : 时，getopts 尝试解析一个参数却失败了。此时，getopts 将 : 保存在 $opt 当中，而后将参数名（这里是 a）保存在 $OPTARG 当中。 合法选项和参数 123$ ./another_test.sh -a /etc/passwd-a was triggered, Parameter: /etc/passwd$ 一点黑魔法：-- 的妙用*nix 中，ls 命令是用来列出当前目录下的文件和子目录的。它可以接受一些选项（如 -lrt）。现在的问题是，如果有一个文件，它的名字叫做 -foobar，要怎样才能列出它的相关信息呢？ 实际上 ls 内部使用了 getopts 解析参数。于是我们可以这样 1ls -lrt -- -foobar 利用两个连续的连字符 --，显式地告诉 getopts：到这为止！然后，ls 会读入 -foobar 作为文件名，显示它的相关信息。 参考文献 http://stackoverflow.com/a/14203146/3419508 http://wiki.bash-hackers.org/dict/terms/end_of_options]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Shell</tag>
        <tag>Argument</tag>
        <tag>Script</tag>
        <tag>Option</tag>
        <tag>Flag</tag>
        <tag>getopts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell 变量引用和字符串处理]]></title>
    <url>%2F2016%2F11%2F08%2FShell-variable-reference-and-string-cut-off%2F</url>
    <content type="text"><![CDATA[使用 Linux，免不了和 Shell 打交道。和 Shell 打交道，就免不了和 Shell 的变量及字符串打交道。这里总结一下 Shell 对变量的引用和字符串处理的一些经验。 变量和变量的引用方式Shell 的变量以 var=&lt;value&gt; 的方式定义，以 $var 或者 ${var} 的方式使用。Shell 的变量没有类型的分别，实际就是一个字符串。因此 Shell 变量的使用和字符串密不可分。这一节先介绍一下变量的一些特殊的引用方法。 $var/${var} - 最基本的用法，返回变量 var 的值——一个字符串。 ${var-&quot;something&quot;} - 当 var 没有被预先定义时，返回 &quot;something&quot;。 ${var：-&quot;something&quot;} - 当 var 没有被预先定义，或者被定义为空时，返回 &quot;something&quot;。 ${var=&quot;something&quot;} - 当 var 没有被预先定义时，返回 &quot;something&quot;，同时设置 var=&quot;something&quot;。 ${var:=&quot;something&quot;} - 当 var 没有被预先定义，或者被定义为空时，返回 &quot;something&quot;，同时设置 var=&quot;something&quot;。 ${var?&quot;something&quot;} - 当 var 没有被预先定义时，返回 &quot;something&quot;，而后终止脚本。 ${var:?&quot;something&quot;} - 当 var 没有被预先定义，或者被定义为空时，返回 &quot;something&quot;，而后终止脚本。 ${var+&quot;something&quot;} - 当 var 已经被定义时，返回 &quot;something&quot;。 ${var:+&quot;something&quot;} - 当 var 已经被定义并且不为空时，返回 &quot;something&quot;。 示例123456789101112131415161718192021222324252627$ echo $&#123;var&#125;$ echo $&#123;#var&#125; # return the length of $&#123;var&#125;0$ echo $&#123;var-"hello"&#125;hello$ echo $&#123;var&#125;$ var=""$ echo $&#123;var-"hello"&#125;$ echo $&#123;var:-"hello"&#125;hello$ echo $&#123;var&#125;$ echo $&#123;#var&#125;0$ unset var$ echo $&#123;var="hello"&#125;hello$ echo $&#123;var&#125;hello$ unset var; var=""$ echo $&#123;var:="hello"&#125;hello$ echo $&#123;#var&#125;5 圆括号的使用除了花括号之外，$ 符号还可以搭配圆括号使用。基本有两种用法： $(command) - 返回 command 执行完毕的输出结果，相当于 `command`。 $((expression)) - 执行算术运算 expression 并返回运算结果，例如 $((2 + 3 * 2)) 返回 8。 按长度截取字符串当 Shell 变量中保存着内容时，我们就可以按索引和长度截取字符串中的内容。Shell 变量的索引从 0 开始。主要有两种方式： ${var:pos} - 返回从 pos 开始一直到末尾的字符串。 ${var:pos:len} - 返回从 pos 开始长度为 len 的字符串。 示例12345678910111213$ var="hello"$ echo $&#123;var&#125;hello$ echo $&#123;#var&#125;5$ echo $&#123;var:3&#125;lo$ echo $&#123;var:6&#125;$ echo $&#123;var:0:3&#125;hel$ echo $&#123;var:0:6&#125;hello 按匹配截取字符串Shell 的变量支持从左或者从右删除包含通配符的子串： 使用 # 或者 ## 从左删除子串； 使用 % 或者 %% 从右删除子串。 单符号的版本（#/%）尽可能短地匹配子串；双符号的版本（##/%%）尽可能长地匹配子串。 示例1234567891011$ var="hellohello"$ echo $&#123;var&#125;hellohello$ echo $&#123;var#*ll&#125;ohello$ echo $&#123;var##*ll&#125;o$ echo $&#123;var%ll*&#125;hellohe$ echo $&#123;var%%ll*&#125;he 字符串替换Shell 的变量也支持字符串替换。 ${var/FROM/TO} - 将 $var 中的第一个 FROM 匹配的子串替换成 TO，然后返回。 ${var//FROM/TO} - 将 $var 中所有的 FROM 匹配的子串替换成 TO，然后返回。 ${var/#FROM/TO - 若 $var 从第一个字符开始能够匹配 FROM，则替换成 TO 然后返回；否则直接返回 ${var}。 ${var/%FROM/TO} - 若 $var 从最后一个字符开始能够匹配 FROM，则替换成 TO 然后返回；否则直接返回 ${var}。 示例1234567891011121314151617$ var="hellohello"$ echo $&#123;var&#125;hellohello$ echo $&#123;var/ll/xx&#125;hexxohello$ echo $&#123;var//ll/xx&#125;hexxohexxo$ echo $&#123;var/#*ll/xx&#125;xxo$ echo $&#123;var/#*lx/xx&#125;hellohello$ echo $&#123;var/%ll*/xx&#125;hexx$ echo $&#123;var/%lx*/xx&#125;hellohello$ echo $&#123;var&#125;hellohello]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Shell</tag>
        <tag>Variable</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一点黑魔法：Linux 中对纯文本文件的列操作]]></title>
    <url>%2F2016%2F11%2F07%2Fhow-to-remove-a-column-from-a-plain-text-file-on-Linux%2F</url>
    <content type="text"><![CDATA[如果你经常和数据打交道，那么你肯定会经常需要对列进行操作。在 Linux 中，对纯文本文件的列操作有两个十分有用的命令：cut 和 paste。其中 cut 主要用于从纯文本文件中取出某些列，paste 则可以用于按列合并。 cut 命令假设有这样一个测试文件 cut.txt： 1234561|2|3|4|5|6|7|8|九|01|2|3|4|5|6|7|8|九|01|2|3|4|5|6|7|8|九|01|2|3|4|5|6|7|8|九|01|2|3|4|5|6|7|8|九|01|2|3|4|5|6|7|8|九|0 我们将用这个测试文件来做一些实验。 cut 基础与字节模式前面说过，cut 命令的本职工作就是取出某些列。实际上，更准确地说法，是 cut 命令逐行地处理输入，并从中取出某些列。这里说的「列」有三种模式： 123-b # 以字节作为标准取出列-c # 以字符作为标准取出列-f # 以域 (field) 作为标准取出列 首先我们看看字节模式。比如我们可以取出每一行的第三个字节中的内容。我们知道，英文字符都是以 ASCII 编码用一个字符保存的。这样，我们预期会输出 6 个 2。我们来看下实际的输出。 1234567$ cut -b 3 cut.txt222222 完美，完全符合预期！ 我们来看一下 cut 命令的样式 1cut -[b,c,f] &lt;columns&gt; &lt;filename&gt; 在刚才的例子中，我们选择了字节模式（-b），并指定了第三列。值得一提的是，cut 命令的列指定风格非常的灵活。 123453 # 第三列3,5,8 # 第三列、第五列、第八列3-5,8 # 第三列至第五列、第八列-3,8 # 第一列至第三列、第八列1,3- # 第一列、第三列至最后一列 字节模式在某些情况会遇到问题。比如，遇到非 ASCII 编码的字符时（特别是多字节字符），就会遇到问题。我们试着看看用 -b 模式输出第 17 列会怎样。 1$ cut -b 17 cut.txt 实际上，-b 模式的第 17 列，会输出「九」的第一个字节。具体输出的内容取决于系统使用的编码。如果我们想输出字符「九」就需要使用字符模式了。 字符模式与域模式-c 是字符模式。为了输出一列汉字「九」，我们可以这样 1234567$ cut -c 17 cut.txt九九九九九九 除了解析列的方式不一样之外，-c 和 -b 完全一样。 类似的，还有域模式。与字节模式以及字符模式最大的不同是，域模式可以指定单个字符作为分隔符，逐行地将文件分成若干列。比如，这里我们可以用 | 作为分隔符，输出第三列至第五列以及第九列。注意，在列模式下，分隔符也会按需输出。 1234567$ cut -d '|' -f 3-5,9 cut.txt3|4|5|九3|4|5|九3|4|5|九3|4|5|九3|4|5|九3|4|5|九 补集cut 命令还支持 --complement 参数，意思是取补集。比如在我们刚才的例子中，取补集就意味着取出第一列、第二列、第六列至第八列以及第十列。 1234567$ cut -d '|' -f 3-5,9 --complement cut.txt1|2|6|7|8|01|2|6|7|8|01|2|6|7|8|01|2|6|7|8|01|2|6|7|8|01|2|6|7|8|0 使用 --complement 参数，我们可以很容易地从纯文本中删除某一列。比如我们想删除第四列 1234567$ cut -d '|' -f 4 --complement cut.txt1|2|3|5|6|7|8|九|01|2|3|5|6|7|8|九|01|2|3|5|6|7|8|九|01|2|3|5|6|7|8|九|01|2|3|5|6|7|8|九|01|2|3|5|6|7|8|九|0 轻而易举~ 一点黑魔法：处理连续空格分割的情况cut 在处理连续空格分割列的时候，结果就会变得一团糟。不过，好在我们有 tr 命令。使用 -s 参数，可以逐行地将连续的字符 unique 成单独的一个字符。 12345678$ whoLiam :0 2016-11-08 00:07Liam pts/0 2016-11-08 00:23 (:0.0)Liam pts/1 2016-11-08 00:15 (:0.0)$ who | tr -s ' 'Liam :0 2016-11-08 00:07Liam pts/0 2016-11-08 00:23 (:0.0)Liam pts/1 2016-11-08 00:15 (:0.0) 这样，我们就能轻易地获得各个用户的登录时间了 1234$ who | tr -s ' ' | cut -d ' ' -f 1,3,4Liam 2016-11-08 00:07Liam 2016-11-08 00:23Liam 2016-11-08 00:15 paste 命令基本用法相比 cut 命令，paste 命令的用法就简单粗暴许多了。 假设我们有三个文件 1234$ cat paste1.txt | $ cat paste2.txt | $ cat paste3.txt1 | a | A2 | b | B3 | c | C 现在我们用 paste 试试看 12345678910111213141516$ paste paste1.txt paste2.txt1 a2 b3 c$ paste paste2.txt paste1.txta 1b 2c 3$ paste paste2.txt paste1.txt paste3.txta 1 Ab 2 Bc 3 C$ paste paste2.txt paste1.txt paste3.txt | sed -n la\t1\tAb\t2\tBc\t3\tC 不难发现，paste 命令支持输入多个文件，并按顺序将他们用制表符粘在一起。如果你想用其他的分隔符将他们粘在一起，也可以像 cut 命令那样使用 -d 参数指定。 1234$ paste -d '|' paste2.txt paste1.txt paste3.txta|1|Ab|2|Bc|3|C 一点黑魔法：避免使用临时文件如果我们需要将几个程序的即时输出（标准输出）按列粘在一起的话，可能不得不将这些输出先写入临时文件当中，然后再调用 paste 命令。不过，也有不用这样麻烦的办法——使用 Bash Process Substituation 来解决这个问题。 简单来说，就是使用 &lt;(command) 来「伪装成一个文件」的样子，作为 paste 命令的输入。比如 1234$ paste -d '|' &lt;(cat paste2.txt) &lt;(cat paste1.txt) &lt;(cat paste3.txt)a|1|Ab|2|Bc|3|C]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Paste</tag>
        <tag>Cut</tag>
        <tag>Column</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 相关信息速查表]]></title>
    <url>%2F2016%2F11%2F06%2FLinux-Info-Cheatsheet%2F</url>
    <content type="text"><![CDATA[使用 Linux 的过程中，我们经常会想看看系统的信息、状态。这里做一个速查表。 系统相关12345678910lsb_release -a # 查看操作系统版本head -n 1 /etc/issue # 查看操作系统版本cat /proc/version # 查看操作系统内核信息uname -a # 查看操作系统内核信息、CPU 信息cat /proc/cpuinfo # 查看 CPU 信息hostname # 查看计算机名字env # 列出环境变量lsmod # 列出加载的内核模块uptime # 查看系统运行时间、负载、用户数量cat /proc/loadavg # 查看系统负载 内存与外存12345678910free -m # 查看物理内存和交换区的使用情况grep MemTotal /proc/meminfo # 查看内存总量grep MemFree /proc/meminfo # 查看空闲内存总量df -h # 查看各分区使用情况fdisk -l # 查看所有分区swapon -s # 查看所有交换分区hdparm -i /dev/hda # 查看 IDE 磁盘的参数dmesg | grep IDE # 查看系统启动时 IDE 磁盘的状态mount | column -t # 查看各分区的挂载状态du -sh &lt;目录名&gt; # 查看指定目录的大小 网络状态123456ifconfig # 查看所有网络接口的属性iptables -L # 查看 iptables 防火墙route -n # 查看本机路由表netstat -lntp # 查看所有监听端口netstat -antp # 查看所有已建立的连接netstat -s # 查看网络统计信息 用户状态相关12345w # 查看活动用户以及他们在做什么who # 查看活动用户id &lt;用户名&gt; # 查看用户的 ID、组信息cut -d: -f1 /etc/passwd # 查看系统中所有用户cut -d: -f1 /etc/group # 查看系统所有组 进程状态相关12ps -ef # 查看所有进程top # 动态显示进程状态]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Cheatsheet</tag>
        <tag>CPU</tag>
        <tag>Memory</tag>
        <tag>Disk</tag>
        <tag>Process</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何计算 sin 36°]]></title>
    <url>%2F2016%2F10%2F27%2Fhow-to-calc-sin-36%2F</url>
    <content type="text"><![CDATA[近日在知乎上看到一则和应聘/面试有关的小故事。题主提到，面试官请他计算 sin 36° 的值。 这里我们用几种办法来计算。 纯代数方法考虑 $\sin 36^\circ = 2\sin 18^\circ\cos 18^\circ$，如果我们有办法求得 $18^\circ$ 的正弦值或余弦值，我们就能根据二倍角公式，直接得到 $36^\circ$ 的正弦值。 考虑 $\sin 54^\circ = \cos 36^\circ$，而有 \begin{equation} \begin{aligned} \sin 54^\circ &amp;{}= 3\sin 18^\circ - 4\sin^3 18^\circ\\ \cos 36^\circ &amp;{}= 1 - 2\sin^2 18^\circ \end{aligned} \end{equation} 我们能得到关于 $\sin 18^\circ$ 的方程 \begin{equation} 4x^3 - 2x^2 - 3x + 1 = 0 \end{equation} 作因式分解，也就是 \begin{equation} (x - 1)(4x^2 + 2x - 1) = 0 \end{equation} 该方程有 3 个解，考虑 $\sin 18^\circ \in (0, 1)$，取有效解 $\sin 18^\circ = \frac{\sqrt{5} - 1}{4}$。如此容易求得 $\sin 36^\circ = \frac{\sqrt{10 - 2\sqrt{5}}}{4}$。 借助黄金三角形和正弦定理作等腰 $\triangle ABC$，其中 $\angle CAB = 36^\circ$, $\angle ABC = \angle BCA = 72^\circ$。记底边长度 $\overline{BC} = a$，记腰长 $\overline{AB} = \overline{CA} = b$。 过 $B$ 做 $\angle ABC$ 的角平分线，与边 $CA$ 交于点 $D$。如此，图中有 3 个等腰三角形：$\triangle ABC$, $\triangle BCD$, $\triangle DAB$。并且，显而易见地有 $\triangle ABC \sim \triangle BCD$。 考虑等腰，有 $\frac{\overline{BC}}{\overline{CD}} = \frac{\overline{AB}}{\overline{BC}}$。这也就是说 \begin{equation}\overline{CD} = \frac{a^2}{b},\end{equation} 因此 \begin{equation}\overline{DA} = b - \frac{a^2}{b}.\end{equation} 考虑等腰，有 $\overline{BC} = \overline{BD} = \overline{DA}$，所以 \begin{equation}a = b - \frac{a^2}{b},\end{equation} 也就是 \begin{equation}\biggl(\frac{b}{a}\biggr)^2 - \frac{b}{a} - 1 = 0.\end{equation} 取有效解，知 $\frac{b}{a} = \frac{\sqrt{5} + 1}{2}$。在 $\triangle ABC$ 中应用正弦定理，有 \begin{equation}\frac{\sin 72^\circ}{\sin 36^\circ} = \frac{2\sin 36^\circ\cos 36^\circ}{\sin 36^\circ} = \frac{b}{a} = 2\cos 36^\circ = \frac{\sqrt{5} + 1}{2},\end{equation} 知 $\cos 36^\circ = \frac{\sqrt{5} + 1}{4}$，易得 $\sin 36^\circ = \frac{\sqrt{10 - 2\sqrt{5}}}{4}$。]]></content>
      <categories>
        <category>Mathematics and Natural Sciences</category>
      </categories>
      <tags>
        <tag>Trigonometric function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[尾注的处理]]></title>
    <url>%2F2016%2F10%2F14%2FLaTeX-endnotes%2F</url>
    <content type="text"><![CDATA[LaTeX 中的 \footnote 命令可以产生脚注——在正文位置留下一个编号，在当前页的底部输出实际的注释内容。这个功能很好用，但是在一些情况下，可能产生意想不到的情况。 数量少而大段的尾注导致尾注先于标记出现； 数量多而小段的尾注导致尾注晚于标记出现。 这些不太寻常的注释会导致 LaTeX 标注文档类没有办法很好地处理脚注。这里，后者可以通过 footmisc 宏包的 para 选项来挽救，但是前者就没有什么好办法了。于是，我们想到了尾注。 简介尾注，即将注释与标记分离，写在文档的末尾。LaTeX 标准文档类没有提供尾注的功能，而由 endnotes 宏包提供。 尾注的用法和脚注基本相同，只需要 将原本需要使用 \footnote 命令的地方替换成 \endnote； 在需要输出尾注的地方，执行 \theendnotes 命令。 给尾注加上类似 \footnote 的横线默认的尾注标题，只有一个光秃秃的 Notes 字样，和默认的脚注样式不太一样。我们可以通过修改 \enoteheading 命令来修改这个样式。这里我们以 book 类为例（article 类应该将 \section* 改为 \subsection*）。 12345678910111213\documentclass&#123;book&#125;\usepackage&#123;endnotes&#125;\makeatletter\def\enoteheading&#123;\section*&#123;\notesname \@mkboth&#123;\MakeUppercase&#123;\notesname&#125;&#125;&#123;\MakeUppercase&#123;\notesname&#125;&#125;&#125;% \mbox&#123;&#125;\par\vskip-2.3\baselineskip\noindent\rule&#123;.5\textwidth&#125;&#123;0.4pt&#125;\par\vskip\baselineskip&#125;\makeatother\begin&#123;document&#125;\chapter&#123;First&#125;Testing.\endnote&#123;First test.&#125; Hello \LaTeX&#123;&#125;.\endnote&#123;LaTeX&#125;\theendnotes\end&#123;document&#125; 在每个章节后输出尾注不难发现，其实尾注输出的位置取决于 \theendnotes 命令的位置。因此我们只需要在每个 \chapter 命令之前（book 类，article 类是 \section 命令）加上 \theendnotes 命令就好了。 不过，由于 \endnote 是在全文范围内编号的，如果希望尾注的编号在输出章节尾注后重新开始，那么我们需要在调用 \theendnotes 之后将计数器置零——当然你也可以使用 \counterwithin 之类的命令来实现。这里我们用 etoolbox 提供的 \csappto 命令来实现这个效果。 1234567891011121314151617181920\documentclass&#123;book&#125;\usepackage&#123;endnotes&#125;\usepackage&#123;etoolbox&#125;\makeatletter\def\enoteheading&#123;\section*&#123;\notesname \@mkboth&#123;\MakeUppercase&#123;\notesname&#125;&#125;&#123;\MakeUppercase&#123;\notesname&#125;&#125;&#125;% \mbox&#123;&#125;\par\vskip-2.3\baselineskip\noindent\rule&#123;.5\textwidth&#125;&#123;0.4pt&#125;\par\vskip\baselineskip&#125;\makeatother\csappto&#123;theendnotes&#125;&#123;\setcounter&#123;endnote&#125;&#123;0&#125;&#125;\begin&#123;document&#125;\chapter&#123;First&#125;Testing.\endnote&#123;First test.&#125; Hello \LaTeX&#123;&#125;.\endnote&#123;LaTeX&#125;\theendnotes\chapter&#123;Next&#125;Again.\endnote&#123;Second test.&#125;\theendnotes\end&#123;document&#125;]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Endnotes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[地球潮汐对地月系统的影响是怎样的]]></title>
    <url>%2F2016%2F09%2F28%2Ftide-influence-on-the-moon%2F</url>
    <content type="text"><![CDATA[在知乎上看到这样一个问题月球引起潮汐会使月亮能量减少吗？ 月亮会发生什么事？，张工的回答引述部分有些问题，所以手痒就做了个回答。这里也保存在博客。 潮汐是怎样来的在天体领域中，月球的质量以及其相对地球的位置的特点是：距离相对很近，质量相对较大。因为月球的引力能够对地球产生较大的影响，所以地月系统与其说是行星-卫星系统，不如说是一个双行星系统。也就是说，地球和月球围绕地月系统的质心相互旋转，这一描述会更加贴合实际情况。不过，因为地球的质量是月球的大约 81 倍，所以地月系统中地球相对系统质心的旋转不太明显，因此更多的时候，人们将月球当做地球的卫星，围绕地球公转。这篇文章里，只在有必要的时候使用「双行星系统」的描述，更多的时候为求简便，仍使用「卫星系统」的描述。 除了对地球本身的引力作用，月球还能吸引地球表面的物体。最显著的现象，就是吸引海水，形成潮汐。因为月球的引力作用，地球表面的海水，会在地心-月心连线方向上（近似）形成两个凸起。靠近月球方向的凸起，主要是由月球的引力造成的；远离月球方向的凸起，则是地球绕系统质心旋转产生的离心现象（可以想作是离心力将背对月球地方的海水甩出去了）。考虑到地球自转的角速度与月球公转的角速度不同，而「凸起」（基本上）是锁定月球的方向，于是「凸起」会相对地表不断移动。这个相对运动，在地球上生活的人看来，就是涨潮和落潮。 地月相互作用因为地球自转的角速度大于月球公转的角速度，因此地球自转会「推着凸起」向前运动。这就导致了「凸起」并不完全锁定月球的方向，而是在地球自转的方向上相对月球位置提前。（见示意图，来自 Wikipedia） 向着月球方向的凸起，这部分海水的质量「拽着」月球往前走；相反，背对着月球方向的凸起，这部分海水的质量「拖住」月球走慢点。考虑到引力的大小和距离的平方呈反比，这两个作用力大小并不相等。因此，地月之间存在着相互的净力矩。 从能量的角度考虑 这个力矩作用在凸起的海水上，使得海水的周期运动比地球自转慢。二者摩擦之间，就使得地球自转逐渐变慢。 这个力矩作用在公转的月球上，使得对月球做功，使得月球的能量增加。考虑到这个能量的增加过程十分缓慢，于是任意时刻我们仍然可以认为月球绕着地球作稳定的（椭）圆轨道的周期运动。因此，在保持公转轨道形状稳定的前提下，月球的公转线速度会下降，但公转轨道会抬升。也就是说，月球的公转动能会下降，但地月引力势能会增加——并且大于月球公转动能下降的数量。 从角动量的角度考虑若假设地月系统不受外力作用，则地月系统的角动量守恒。 这个力矩作用在凸起的海水上，使得海水的周期运动比地球自转慢。二者摩擦之间，就使得地球自转逐渐变慢，地球自转角动量下降。 考虑到角动量守恒，则必然月球公转的角动量上升。同样，为了保持月球公转轨道的稳定，这种上升，是通过降低角速度的同时相对更多地提升转动惯量来实现的。也就是说，月球公转轨道会抬升。 因为潮汐作用导致卫星公转能量升高/公转角动量升高的现象，被称为潮汐加速。 实际的数据因为地球自转角速度大于月球公转角速度，「凸起」到地心的连线与地月连线之间的角度大约是 3°。 从能量上来说，地球自转动能的损失，大约有 29/30 消耗在摩擦生热中；而只有大约 1/30 的能量被转移给月球。 因为潮汐作用，地球每天延长越 23 微秒，月球轨道（平均）每年抬高 38 毫米。 最终结果能量 月球公转线速度降低，因此月球公转动能减少； 月球轨道抬升，因此地月系统引力势能升高； 相对地球，月球的动能减少，但势能升高，总体表现月球的机械能升高； 地球的自转速度降低，因此地球的自转动能减少； 地球自转动能减少的量与月球机械能升高的量的差值，大部分以热能的形式释放（损耗）了； 包括释放的热能，地月系统机械能守恒。 角动量和角速度 月球公转角速度降低； 月球轨道抬升，因此月球的转动惯量升高； 月球的公转角动量升高； 地球的自转角动量降低； 地月系统角动量守恒。 地月系统会怎样 月球相对地球越来越远，平均每年远离地球 38 毫米； 地球的自转越来越慢，直到地球自转角速度与双星系统公转角速度相同，地月互相潮汐锁定——当然，这件事情到太阳变成红巨星的阶段都还没完成。]]></content>
      <categories>
        <category>Mathematics and Natural Sciences</category>
      </categories>
      <tags>
        <tag>Tide</tag>
        <tag>Earth-Moon System</tag>
        <tag>Einetic Energy</tag>
        <tag>Gravitation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python envoy 模块源码剖析]]></title>
    <url>%2F2016%2F09%2F25%2Freview-of-envoy%2F</url>
    <content type="text"><![CDATA[Kenneth Reitz 是公认的这个世界上 Python 代码写得最好的人之一。抱着学习的心态，我阅读了 Reitz 写的 envoy 模块的源码，将笔记记录如下。 介绍和 requests 模块一样，envoy 也是 Reitz 的作品，连官方描述都类似——Python Subprocesses for Humans。 实际上，envoy 的核心代码非常少，总共只有不到 300 行代码，只是简单的对标准库 subprocess 的封装。但是，所谓短小精干，envoy 实现的接口简单易用，比裸用 subprocess 方便不少。 背景知识在讲 envoy 的代码之前，我们先回顾一些背景知识。 程序和进程在计算机科学及相关领域，经常能看到程序和进程的概念。有些人不清楚它们的差别，混为一谈。这是不好的。 程序：一般是一组CPU指令的集合构成的文件，静态存储在诸如硬盘之类的存储设备上。 进程：当一个程序要被计算机运行时，就是在内存中产生该程序的一个运行时实例，我们就把这个实例叫做进程。 简单来说，程序就是编译出来的二进制可执行文件，比如 Windows 里的 .exe 文件，*nix 里的 ELF 文件。操作系统将它们装载到内存空间并执行时的实例，就是进程。程序和进程之间隔着一个「装载」的步骤。 Linux 里的进程 以下实验均在 CentOS 5.4 环境下操作。 首先，我们在终端里执行 1ps -eo pid,ppid,comm,cmd | less 这里 ps 命令用来查询正在运行的进程，-e 表示我们想要查看所有的进程，-o 则选择我们想查看的列名称。这里我们查看 pid, ppid, comm, cmd。 在这个输出结果中，每一行代表一个进程（表头除外），共分为 4 列。 PID: Process IDentity，进程在当前系统中的唯一识别码，相当于我们的身份证号。 PPID: Parent PID，父进程的 PID。 COMMAND: 进程的简称。 CMD: 进程对应的程序及其运行时所带的参数。 从计算机启动到进程的创建计算机启动时，首先会从主板上的 BIOS (Basic Input/Output System) 中执行程序，从某个设备（比如软盘、硬盘、光盘、网络等）上启动计算机。而后，计算机会定位到所选的设备上，读取开头的 512 字节里的 MBR (Master Boot Record)。MBR 里记录着从存储设备启动 Boot Loader 的具体分区和位置。Boot Loder 里记录着操作系统名称、内核所在位置等信息，启动 Boot Loader 之后，它会帮我们加载 Kernel。内核负责两件事：对下负责管理硬件，对上负责提供系统调用。于是，内核首先会预留自己运行所需的内存空间，然后调用驱动程序 (drivers)检测计算机硬件，最后启动 init 进程，并将控制权交给这个进程。在 Linux 里，init 的 PID 是 1。init 进程负责设置计算机名称、时区，检测文件系统，挂载硬盘，清空临时文件，设置网络等操作。通常意义上说，当 init 完成这些工作，计算机就算启动完成了。 我们小结一下，计算机启动的流程是： BIOS -&gt; MBR -&gt; Boot Loader -&gt; Kernel -&gt; 预留内存空间 -&gt; drivers -&gt; init -&gt; settings 我们知道，运行于操作系统上的进程（包括 init）与操作系统交互，都是通过系统调用来完成的。然而 Linux 并没有提供创建新进程的系统调用。实际上，Linux 里创建新的进程这一动作，是通过 fork 和 exec 两个函数来实现的。 我们先来看看 fork 函数的用法。 123456pid_t pid;if (pid = fork()) &#123; // ...&#125; else &#123; // ...&#125; 调用 fork 函数后，新的进程（任务）和当前进程一起从代码的同一位置开始执行：从 fork 函数获得返回值。在这里，新的进程称为子进程 (Child Process)，当前进程相对应称之为父进程 (Parent Process)。不过，在子进程中，fork 函数返回 0；在父进程中，fork 函数则返回子进程的 PID。因此，在子进程中，表达式 pid = fork() 为 false，跳转到后续的 else 语句块继续执行；在父进程中，表达式 pid = fork() 为 true，继续执行语句块。 fork 函数的产生子进程的速度非常快。这是因为，通过 fork 产生的子进程，只是简单地分配了内存空间，并与父进程共享写时复制 (Copy on Write, COW)内存空间。这意味着，通过 fork 产生子进程的过程中，并没有内存中内容的复制，因此速度非常快。 fork 产生的子进程，只是父进程的镜像。通过 fork 的返回值，我们可以在代码里判断是否是子进程。如果是子进程，就可以调用 exec 函数，使用新的程序（可执行映像文件）覆盖当前的映像，从而执行新的任务。 不难发现，Linux 中所有的进程，不断追溯其父进程，都会最终追溯到 init 进程。 进程的终止当一个进程执行 exit 函数之后，内核会释放它所打开的文件、占用的内存等资源，然后在操作系统内核中保留一些退出信息 PID Exit Code CPU time taken by the process 简而言之，进程退出后，会释放资源，然后在内核里留下一些诊断信息，成为僵尸进程 (Zombie Process)。进程退出后，将 PID 留在了操作系统内核中尚未释放。因此，该 PID 是不可以被后续的新进程使用的。因此，在 Linux 的设计中，父进程需要调用 wait 或者 waitpid 函数从内核中获取并处理子进程的诊断信息，并释放 PID（清扫僵尸进程）。 如果子进程退出时，父进程尚在，但父进程始终不处理子进程退出后留下的僵尸进程，而不断因为业务逻辑产生新的子进程，那么僵尸进程就会不断积累，最终占满所有可用的 PID（没有进程槽了）。这样一来，在操作系统中就无法产生新的子进程了。（参见 fork 炸弹）因此，通过 fork 函数创建子进程之后，一定要注意 wait 子进程。 如果父进程退出时，子进程尚在。这时候，没爹没娘的孤儿进程（Orphand Process）就会被 init 进程收养，直到它退出后被 init 处理。 envoy 源码剖析Reitz 的 envoy 项目地址是 https://github.com/kennethreitz/envoy。为了保证本文的长期有效性，我将它 fork 到了这里 https://github.com/reviewlib/envoy。 envoy 的核心代码保存在 ./envoy/core.py 当中。我们先就这份代码的语法点做分析，然后讨论它的结构。 库1234567import osimport sysimport shleximport signalimport subprocessimport threadingimport traceback 最头上的两个 os 和 sys 是常用的标准库，不必多说。 shlex 的名字可以分为两部分：sh 代表 shell；lex 是一个著名的词法分析器的生成器（lexical analyzer）。运用这个标准库，我们可以很容易地解析出用户需要在子进程中执行的命令。 signal 是 Python 里处理 Linux 内核信号的标准库。我们这里主要用它内部定义的信号的值，不涉及它的具体用法。 subprocess 是 Python 中实现子进程的标准库，是 envoy 封装的实际内容。 threading 是 Python 中实现多线程的一个标准库。在 envoy 里，我们实际用它来执行 subprocess.Popen() 创建子进程并执行任务。 traceback 是 Python 中用来追溯异常的标准库。 Command 类我们来看 Command 类。这是一个模块内部使用的类，Command 类的每个实例都能执行 run() 方法，在一个子进程里执行 Shell 命令。 初始化函数 __init__() 直截了当，只是简单地对各个数据成员赋值。 整个类的主要部分是 run() 函数，我们仔细深入进去观察一下。 第一个值得注意的地方，是对环境变量的处理。 12environ = dict(os.environ)environ.update(env or &#123;&#125;) 首先，作者将 os.environ 转换成一个 Python 内建字典，保存在 environ 中。而后，用字典的 update() 方法，将用户传入的环境变量补充到 environ 中。这里，update() 方法有两个特点 输入必须是一个非空的字典，因此作者利用短路求值 env or {} 的方式确保「非空」； 输入的 env 如果有与 os.environ 同名的环境变量，则会以 env 中的值为准，否则直接在 environ 中添加键值对。 利用这两个特点，作者巧妙地实现了程序逻辑。 第二个值得注意的地方，是在 run() 函数的内部，嵌套定义了 target() 函数。 12345678910111213141516171819202122def target(): try: self.process = subprocess.Popen(self.cmd, universal_newlines=True, shell=False, env=environ, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=0, cwd=cwd, ) if sys.version_info[0] &gt;= 3: self.out, self.err = self.process.communicate( input = bytes(self.data, "UTF-8") if self.data else None ) else: self.out, self.err = self.process.communicate(self.data) except Exception as exc: self.exc = exc 在 Python 中，函数定义是允许嵌套的，不过 各个函数有自己的作用域； 内层函数优先访问内层作用域的变量，如果内层没有所需变量，则逐层向外寻找所需变量； 外层函数不能访问内层函数的变量（对外层函数来说，这是局部变量）；除非内层函数声明变量时加上了 global 关键字修饰，并且在访问它时已经调用过内层函数。 这里的 target() 函数定义了我们接到一个执行 Shell 命令的需求时，我们要做哪些事情。依其定义，我们要首先使用 subprocess.Popen() 创建一个子进程，并在相应的条件下执行 self.cmd。然后调用 self.process.communicate() 方法，将 self.data 通过管道传给正在 Shell 中执行的程序，并获取程序的标准输出和标准错误。在整个过程中，但凡出现任何问题，都保存在 self.exc 当中。这里作者使用了所有异常的基类 Exception，这是因为对于作者来说 self.cmd 是不可控的，在执行 self.cmd 的过程中可能出现任何形式的异常。为了能够处理所有异常，作者必须使用 Exception 来处理。 第三个值得注意的地方，是作者在工作线程中去实际执行 target() 完成的任务。 123thread = threading.Thread(target=target)thread.start()thread.join(timeout) 首先，作者创建了一个线程，将 target() 函数作为参数传入构造。也就是说，thread.start() 实际会执行 target() 函数的代码。而后，作者用 thread.join(timeout) 的方式，来处理上层传下来的超时限制。这样，主进程将会阻塞住，直到 线程中的任务完成（也就是 target() 中创建的子进程的任务完成）；或者 达到超时时间限制。 第四个值得注意的地方，是作者回收和处理在线程中运行的子进程任务的执行状态信息。 12345678910if self.exc: raise self.excif _is_alive(thread) : _terminate_process(self.process) thread.join(kill_timeout) if _is_alive(thread): _kill_process(self.process) thread.join()self.returncode = self.process.returncodereturn self.out, self.err 首先，子进程可能抛出异常，因此需要捕获和继续向上抛出异常。 其次，线程 thread 可能因为超时而执行到当前代码，因此通过预定义的 _is_alive() 函数来判断线程是正常退出还是扔在超时运行。如果确实超时，那么首先应该终止子进程，然后尝试等待线程超时终止。如果线程仍然还活着，说明线程内的子进程没有被正确终止，那么首先杀死子进程，然后阻塞线程直到它完成。这样的设计，是确保子进程和线程都完全停止，防止僵尸进程的出现。 最后，函数返回标准输出和标准错误的内容。 Response 类我们来看 Response 类。这是一个模块内部使用的类，Response 类的每个实例都是 Command 类的实例调用 run() 方法后的执行结果信息。 12345678910111213141516171819class Response(object): """A command's response""" def __init__(self, process=None): super(Response, self).__init__() self._process = process self.command = None self.std_err = None self.std_out = None self.status_code = None self.history = [] def __repr__(self): if len(self.command): return '&lt;Response [&#123;0&#125;]&gt;'.format(self.command[0]) else: return '&lt;Response&gt;' 从只有一个 __repr__() 方法可以看出，Response 类几乎只是一个简单的数据结构，提供了可供打印的功能，仅此而已。那么作者为什么要设计这样一个类呢？这里我们留给读者思考。 expand_args 函数expand_args(command) 函数接收一个字符串作为参数，并将之解析为一个个的命令。 1234567891011121314151617181920def expand_args(command): """Parses command strings and returns a Popen-ready list.""" # Prepare arguments. if isinstance(command, (str, unicode)): splitter = shlex.shlex(command.encode('utf-8')) splitter.whitespace = '|' splitter.whitespace_split = True command = [] while True: token = splitter.get_token() if token: command.append(token) else: break command = list(map(shlex.split, command)) return command 我们以 &#39;cat inFile | sort | uniq&#39; 为引数，传入 expand_args 函数，分析一下会发生什么。 首先，作者用 shlex.shlex() 构造了一个词法分析器，并设置以管道符号 | 为标志，分割传入的字符串（或者 unicode 类型的实例，后不再重复）。加上之后的 while 循环，这基本相当于执行了 command = command.split(&#39;|&#39;) 的效果。 而后，执行 command = list(map(shlex.split, command))，调用 shlex.split 函数，作用在 command 的每一个元素上，并返回一个列表，保存在 command 当中。最后以 return 将 command 返回给调用函数。 这里的 map() 函数接收两个参数 一个函数 一个可迭代的列表 然后将函数作用在列表的每一个元素上，并返回一个列表。类似的函数还有 reduce() 函数（参考 Google 的 MapReduce 架构）。这里给出两个示例，供体会它们的作用 map.py1234#!/usr/bin/env pythoninIter = ['adam', 'LISA', 'barT']regNames = lambda iter: map ((lambda inStr: inStr.capitalize()), iter)print regNames (inIter) reduce.py1234#!/usr/bin/env pythoninIter = [1, 2, 3, 4, 5]prod = lambda iter: reduce ((lambda x, y: x * y), iter)print prod (inIter) 最后，输入 &#39;cat inFile | sort | uniq&#39; 有输出 [[&#39;cat&#39;, &#39;inFile&#39;], [&#39;sort&#39;], [&#39;uniq&#39;]]。 run 函数run(command, data=None, timeout=None, kill_timeout=None, env=None, cwd=None) 函数是 envoy 模块的主要接口，用来在子进程里执行 Shell 命令。 首先解释一下 run() 函数的各个参数的含义 command 需要执行的 Shell 命令（可以包含管道，但是不允许包含 &amp;&amp; 或者 ; 之类的符号）； data 通过管道传入 Shell 命令的内容； timeout 子进程执行超时时间； kill_timeout 终止子进程失败的超时时间，超过这个时间将直接杀死子进程； env 环境变量； cwd Current Working Directory，工作目录。 run 函数的实现相对来说是平铺直叙的，这里用注释简单说明一下各个部分都做了什么即可。 12345678910111213141516171819202122232425262728293031323334353637383940def run(command, data=None, timeout=None, kill_timeout=None, env=None, cwd=None): """Executes a given commmand and returns Response. Blocks until process is complete, or timeout is reached. """ '''对 `command` 做词法分析，拆分命令''' command = expand_args(command) history = [] for c in command: '''模拟管道的作用，传入上一程序的标准输出''' if len(history): # due to broken pipe problems pass only first 10 KiB data = history[-1].std_out[0:10*1024] '''实际在子进程里执行命令''' cmd = Command(c) try: out, err = cmd.run(data, timeout, kill_timeout, env, cwd) status_code = cmd.returncode except OSError as e: out, err = '', u"\n".join([e.strerror, traceback.format_exc()]) status_code = 127 '''将执行结果保存在 `history` 当中''' r = Response(process=cmd) r.command = c r.std_out = out r.std_err = err r.status_code = status_code history.append(r) '''函数返回最后一个管道（如果有）之后命令的输出和详细情况''' r = history.pop() r.history = history return r 模块设计分析Kenneth Reitz 不愧是公认的这个世界上 Python 代码写得最好的人之一——虽然 envoy 是对 subprocess 的简单封装，功能有限，但是代码结构非常优雅，内部实现的逐层封装十分完善。 对于模块的用户（程序员）来说，envoy 几乎只有 run 这一个入口。而它的作用也很明确：开一个子进程，执行一条 Shell 命令，然后在规定时间内取得执行结果——中间的脏活累活（处理异常、超时、主进程阻塞等待、保存历史等等），envoy 都帮你做好了。 对于 run() 函数来说，它只需要知道执行 out, err = cmd.run() 就能在子进程里执行用户需要的命令，然后将结果存在 Response 里就可以了。 对于 Command.run() 函数来说，它只需要处理好环境变量，执行 target() 最后处理超时、异常、收集结果信息就可以了。 对于 target() 来说，这是一个嵌套定义的函数，它才是真正 fork 子进程并执行 Shell 命令的函数。 不难发现，每个层次完成的任务，几乎都可以用简单一句话解释清楚 envoy.run() - 将 Shell 命令交给它，就会在子进程里执行这些命令并处理好返回结果； Command.run() - 将一个具体的 Shell 命令（不包含管道）交给它，就会在子进程里执行这些命令并处理好返回结果； target() - fork 一个子进程，然后在子进程里开心地执行命令。 这种符合 *nix 哲学的设计，造就了优雅好用的 envoy 库。对于程序员来说，将命令交给它，然后坐等结果就可以了。无愧于 Python Subprocesses for Humans 的豪言壮语。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Library</tag>
        <tag>Subprocess</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 TikZ 实现带箭头的注释效果]]></title>
    <url>%2F2016%2F09%2F24%2FTikZ-comment-to-text%2F</url>
    <content type="text"><![CDATA[有时候，我们需要对文中的内容做进一步的解释；有时候，我们会想在文章边注的区域内，给特定的内容加上一个俏皮话（如下图）。 这篇文章，我们将用 TikZ 实现这个效果。 TikZ 的知识我们知道，在 tikzpicture 环境中，类似上面的效果，很容易就能实现。 tikzpicture_sample.tex1234567891011\documentclass&#123;article&#125;\usepackage&#123;tikz&#125;\usetikzlibrary&#123;positioning&#125;\tikzset&#123;&gt;=stealth&#125;\begin&#123;document&#125;\begin&#123;tikzpicture&#125;[node distance = 1.5cm] \node (test) &#123;I'm a soldier!&#125;; \node (testDesc) [above right = of test] &#123;Yes, you are!&#125;; \draw [-&gt;,thick] (testDesc) to [in = 60, out = -120] (test);\end&#123;tikzpicture&#125;\end&#123;document&#125; 在这里，我们引入了 tikz 宏包，以及它的 positioning 库，用来绘制和定位 nodes。在 tikzpicture 中，我们建立了两个 node: test 和 testDesc，后者的位于前者的右上方。最后，我们用绘制了从 testDesc 到 test 的曲线箭头，其样式由之前的 \tikzset{&gt;=stealth} 指定。 这是 TikZ 的基本应用，不必多言。然而我们的需求，是将位于正文中的文字（它应该是一个 node）和正文外 tikzpicture 中的 node 连起来。如果能解决这一点，那么我们就能将未知问题转换为已知问题。 我们从 TeX 的执行过程和 TikZ 出发，思考一下，为了解决这个问题，需要如何操作。首先，我们需要记录 test 和 testDesc 的位置。由于我们不可能将这个位置信息直接写入输出的 PDF 文件中，所以我们需要将它写入辅助文件中。这意味着，为了正确实现我们需要的效果，我们至少应该编译两次源文件。其次，对于连接 test 和 testDesc 的箭头来说，它的边界（bounding box）需要特别处理——如果按照正常的方式处理，那么箭头和正文部分就不能重叠。 所幸，TikZ 已经为我们做好了这些工作。我们需要它提供的 remember picture 和 overlay 连个选项。它们的作用是： remember picture: 将位置信息写入辅助文件，供后续使用； overlay: 不计算边界，允许与其它内容重叠。 实际实现看看首先，我们来实现 test 的部分。这部分比较通用，本质上就是用 TikZ 给几个单词打上 node 标记的过程。于是我们可以定义一个命令 123\newcommand&#123;\tikzmark&#125;[3][] &#123;\tikz[remember picture, baseline] \node [anchor=base,#1](#2) &#123;#3&#125;;&#125; 注意，这里我们用了 remember picture 选项，确保 \tikzmark 的位置会被保存下来。之后，在写注释的时候，就可以引用 \tikzmark 的位置了。这里有一个简单的实现 tikz_comment_sample.tex1234567891011121314151617181920\documentclass&#123;article&#125;\usepackage&#123;tikz&#125;\usetikzlibrary&#123;positioning&#125;\tikzset&#123;&gt;=stealth&#125;\newcommand&#123;\tikzmark&#125;[3][] &#123;\tikz[remember picture, baseline] \node [anchor=base,#1](#2) &#123;#3&#125;;&#125;\usepackage&#123;mwe&#125;\begin&#123;document&#125;\blindtext\tikzmark&#123;test&#125;&#123;I'm a soldier!&#125;\blindtext\begin&#123;tikzpicture&#125;[overlay, remember picture, node distance = 1.5cm] \node (testDesc) [above left = of test, xshift = -1cm] &#123;Yes, you are!&#125;; \draw [-&gt;,thick] (testDesc) to [in = 120, out = -60] (test);\end&#123;tikzpicture&#125;\end&#123;document&#125; 在写注释的时候，我们给 tikzpicture 环境加上了 overlay 选项。这是因为从 testDesc 到 test 的箭头应该可以与其它正文重叠。这段代码的效果，就是文章开头的那个样子。 还能用在数学公式里？是的，\tikzmark 也可以写在数学公式里。 comment_to_equation.tex1234567891011121314151617181920212223242526\documentclass&#123;article&#125;\usepackage&#123;amsmath&#125;\usepackage&#123;tikz&#125;\usetikzlibrary&#123;positioning&#125;\tikzset&#123;&gt;=stealth&#125;\newcommand&#123;\tikzmark&#125;[3][] &#123;\tikz[remember picture, baseline] \node [anchor=base,#1](#2) &#123;#3&#125;;&#125;\begin&#123;document&#125;\[ \mathcal&#123;A&#125; = (\tikzmark&#123;identity&#125;&#123;\texttt&#123;I&#125;&#125; -\tikzmark[red]&#123;G&#125;&#123;\texttt&#123;G&#125;&#125; \tikzmark[blue]&#123;L&#125;&#123;\texttt&#123;L&#125;&#125; - \tikzmark[purple]&#123;C&#125;&#123;\texttt&#123;C &#125;&#125;)\]\begin&#123;tikzpicture&#125;[overlay, remember picture,node distance =1.5cm] \node (identitydescr) [below left=of identity ]&#123;words&#125;; \draw[,-&gt;,thick] (identitydescr) to [in=-90,out=90] (identity); \node[red] (Gdescr) [below =of G]&#123;other words&#125;; \draw[red,-&gt;,thick] (Gdescr) to [in=-90,out=90] (G); \node[blue,xshift=1cm] (Ldescr) [above right =of L]&#123;some words&#125;; \draw[blue,-&gt;,thick] (Ldescr) to [in=45,out=-90] (L.north); \node[purple] (Cdescr) [below right =of C]&#123;more words&#125;; \draw[purple,-&gt;,thick] (Cdescr) to [in=-90,out=90] (C.south);\end&#123;tikzpicture&#125;\end&#123;document&#125; 你可以试着编译上面的代码，将得到以下效果 期待你能做出更多有趣的效果。:)]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>TikZ</tag>
        <tag>Comment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用双向队列实现跑马灯和频率限制器]]></title>
    <url>%2F2016%2F09%2F23%2Fusing-deque-to-implement-marquee-and-rate-limiter%2F</url>
    <content type="text"><![CDATA[工作中涉及到的数据，其数量越来越大。这就是说，我用 Python 写的工具，需要更高的性能。今天琢磨着把小工具的性能一下子提升了一个数量级，每秒能发出、接收和处理 800 次请求。所谓「事无好坏，过则成灾」，800 QPS 虽然不至于将线上服务压垮，但是多少会对线上服务造成一定的影响（比如响应时间显著延长）。这是不好的。 为了防止架构组的同学过来撕，有必要给我的小工具加上 EVA 的拘束器)，限制一下 QPS。 思路Y 是 QA 组的同学，开发了一系列的平台，对此比较有经验。和 Y 的讨论中，他提出，应该实时监控远程服务的响应时间，动态调整发出请求的速度和工作的进程数量，将 QPS 固定住。 从研究的角度来说，这是一个比较精确的思路。但是要给上述工具加上这样一层壳，工作量还是有一些的。这样，不符合补丁「短平快」的要求。 为了找到更合适的方案，我重新理了一下需求：我只需要给 QPS 设置一个上限，防止压力过大影响线上服务就可以了，并不需要将 QPS 固定在定值上。这样一来，动态监控远程服务的响应时间，就变得不重要了。 那么怎样解决这个问题呢？ 让我们先回顾一下 QPS 的含义。所谓 QPS，就是单位时间（$\tau$）的请求次数（$k$）。限制 QPS，就是要限制单位时间 $\tau$ 内的请求次数 $k$。换而言之，我们需要保证，在接踵而来的请求中，任意连续的 $k+1$ 个请求，其首尾的时间间隔都严格大于 $\tau$。 因此，我们需要用一个数据结构，顺序保存最近的 $k$ 个请求发生的时间戳。当第 $k + 1$ 个请求来临时，我们需要对比它和保存的时间戳中的最早者之间的时间间隔 $t$。 如果 $t &gt; \tau$，那么对该请求放行，将当前时间戳保存到数据结构并淘汰掉最早的那个时间戳； 如果 $t \leqslant \tau$，那么抛弃或阻塞该请求，等待下一次调用。 算法浅显易懂，而实现起来，我们只需要一个固定长度的双向队列即可。 collections 库中的 deque在 Python 的 list 基础上加上一些限制条件，当然可以满足我们的需要。不过 list 是用线性表实现的；而在我们的环境里，需要频繁快速地进行元素的插入和删除操作。所以，我们对选用 list 作为基础数据结构需要慎重考虑。 Python 的标准库 collections 是一组高性能的容器，其中提供了 deque 的双向队列。deque 使用链表实现的，因此能够在 O(1) 时间复杂度内进行队列首尾的插入和删除操作。从性能上说，deque 在我们的问题里，完胜 list。 插入和删除首尾的元素deque 提供了简便的方法，在队列首尾增减元素。 12345678910111213141516171819202122In [1]: from collections import dequeIn [2]: q = deque(['a', 'b', 'c'])In [3]: q.append('x') # 在队尾增加元素 'x'In [4]: q.appendleft('y') # 在队首增加元素 'y'In [5]: qOut[5]: deque(['y', 'a', 'b', 'c', 'x'])In [6]: q.pop() # 删除队尾元素并返回它的值Out[6]: 'x'In [7]: qOut[7]: deque(['y', 'a', 'b', 'c'])In [8]: q.popleft() # 删除队首元素并返回它的值Out[8]: 'y'In [9]: qOut[9]: deque(['a', 'b', 'c']) 限制长度在初始化一个 deque 的时候，可以指定它的最大长度（maxlen）。这个长度一旦指定，就是该 deque 实例的只读属性。当实例的长度达到设定的最大长度后 执行 append(element) 会先执行 popleft() 删除队首元素，再将 element 加在队尾； 执行 appendleft(element) 会先执行 pop() 删除队尾元素，再将 element 加在队首。 这真是大快人心的大好事啊，完美符合我们的需求。 轮转deque 还提供了一个有趣的成员函数，名字是 rotate(step)。其作用是： 当 step 是正整数时，从队首到队尾，循环挪动 step 步； 当 step 是负整数时，从队尾到队首，循环挪动 step 步。 通过 rotate 函数，我们可以实现一个有趣是跑马灯程序。 marquee.py1234567891011import sysimport timefrom collections import dequemarquee = deque('&gt;&gt;-----' * 10)while True: print '\r%s' % ''.join(marquee), marquee.rotate(1) sys.stdout.flush() time.sleep(0.04) 实现频率限制器有了上面的分析，又有了 deque 这一好用的工具，实现一个这样的限制器，是很容易的。我们将它封装成一个类，方便调用。 rate_limiter.py12345678910111213141516171819202122232425262728from collections import dequeimport timeclass RateLimiter: def __init__(self, maxCount = 5, timeUnit = 1): self.timeUnit = timeUnit self.deque = deque (maxlen = maxCount) def __call__(self): if self.deque.maxlen == len(self.deque): cTime = time.time() if cTime - self.deque[0] &gt; self.timeUnit: self.deque.append (cTime) return False else: return True self.deque.append (time.time()) return Falseif __name__ == '__main__': import random checkLim = RateLimiter(maxCount = 8) for i in xrange(50): rTime = random.uniform(0, 0.2) time.sleep(rTime) print i, "block[%f]" % (rTime) if checkLim() else "pass[%f]" % (rTime) 代码很简单，唯一可能有趣的是 __call__ 这个函数。它和一般的函数在功能上没有什么不同，但是有特别的作用：让 RateLimiter 这个类的实例成为可以调用的函数。这就是为什么我们可以用 if checkLim() 的原因。 代码的输出如下（由于加入了随机数，在你的计算机上执行可能不会完全相同），pass 表示被放行，block 表示频率过快，受到限制。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849500 pass[0.109310]1 pass[0.090743]2 pass[0.038481]3 pass[0.086077]4 pass[0.101313]5 pass[0.173419]6 pass[0.159947]7 pass[0.135079]8 block[0.011212]9 block[0.070294]10 block[0.029171]11 block[0.018660]12 pass[0.080185]13 pass[0.143896]14 pass[0.191853]15 pass[0.188746]16 pass[0.198628]17 pass[0.123896]18 pass[0.144908]19 pass[0.107941]20 pass[0.080700]21 pass[0.006529]22 pass[0.171683]23 block[0.040397]24 pass[0.187498]25 block[0.047226]26 pass[0.124452]27 pass[0.103683]28 pass[0.153917]29 block[0.021065]30 pass[0.196360]31 pass[0.042572]32 pass[0.093290]33 pass[0.113496]34 pass[0.178457]35 pass[0.079711]36 pass[0.129189]37 block[0.025027]38 pass[0.130345]39 block[0.037810]40 block[0.020917]41 pass[0.171373]42 pass[0.031104]43 pass[0.089182]44 pass[0.175822]45 pass[0.137213]46 block[0.018022]47 block[0.003023]48 pass[0.167048]49 pass[0.120170]]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Collections</tag>
        <tag>Marquee</tag>
        <tag>QPS</tag>
        <tag>Rate Limiter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 中的 random 库速查表]]></title>
    <url>%2F2016%2F09%2F23%2FPython-random%2F</url>
    <content type="text"><![CDATA[工作中，时不时需要产生一些随机数或者用到和随机数相关的操作。Python 标准库 random 自带了一些很实用的功能。这里对常用的几个函数（方法）做一个小结，加强记忆，也作为速查表使用。 名字和引入Python 中的随机库，名字就叫做 random，取的是英文中「随机的」之单词。和大多数 Python 库一样，可以用 import 关键字引入。 1import random 产生一个简单的随机数random 库中有几个函数可以产生随机数。 123random.random() # 在 [0.0, 1.0) 的左闭右开区间中产生一个随机的实数random.uniform(a, b) # 相当于 a + (b-a) * random.random()random.randint(a, b) # 在 [a, b] 的闭区间中产生一个随机的整数 产生特定分布的随机数random 库还可以按照特定的分布产生随机数。 1234# 取决于实现方式，guass(mu, sigma) 比 normalvariate(mu, sigma) 快一些random.gauss(mu, sigma) # 高斯分布：以 mu 为均值，sigma 为标准差random.normalvariate(mu, sigma) # 正态分布：以 mu 为均值，sigma 为标准差random.lognormvariate(mu, sigma)# 对数正态分布 对列表类型的操作random 库支持对非空的列表类型（包括列表、字符串和元组）的一些随机操作。 123random.choice(seq) # 从列表类型中随机选取一个元素返回random.shuffle(seq[, random-func]) # 对 seq 进行洗牌，默认用 random.random()random.sample(seq, k) # 从 seq 中随机选取一个子集并返回 示例random_test.py1234567891011import randomprint random.random()print random.uniform(1, 10)print random.randint(1, 10)print random.choice('abcdefghij')items = [1, 2, 3, 4, 5, 6, 7]random.shuffle(items)print itemsprint random.sample([1, 2, 3, 4, 5], 3)print items 输出 12345670.9728137217898.4212894682410e[1, 4, 6, 3, 5, 2, 7][3, 1, 5][1, 4, 6, 3, 5, 2, 7]]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>random</tag>
        <tag>Cheatsheet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[保存和恢复 Tmux 会话]]></title>
    <url>%2F2016%2F09%2F10%2Ftmux-plugin-resurrect%2F</url>
    <content type="text"><![CDATA[Tmux 是一个强大的终端复用软件，我们可以轻易地为它列举出一堆好处。 支持多标签； 支持窗口内部进行面板的划分； 支持多个终端同时 attach 同一个 Tmux 会话。 如果要为 Tmux 说一个缺点，那可能就是 Tmux 会话无法在系统重启之后比较容易地恢复。这个问题在常年开机的服务器上，可能问题不明显，但是在我们自己的计算机上，或者服务器因为某些原因需要重启，那之前的 Tmux 会话就都丢失了。 为了解决这个问题，我们需要用到 Tmux 的插件系统，并安装名为 tmux-resurrect 的插件。 Tmux Plugin Manager和大多数支持插件的软件（系统）一样，Tmux 也有一个插件管理系统，名字就叫做 Tmux Plugin Manager。首先，我们需要安装并学习如何使用这个管理器。 下载和安装Tmux Plugin Manager 的程式码托管在 GitHub 上，它的专案地址是：https://github.com/tmux-plugins/tpm。首先，我们需要将 Tmux Plugin Manager 的程式码克隆到本地。 1git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm 而后，我们需要在 Tmux 的配置文件底部加上这么几行： 1234567891011# List of pluginsset -g @plugin &apos;tmux-plugins/tpm&apos;set -g @plugin &apos;tmux-plugins/tmux-sensible&apos;# Other examples:# set -g @plugin &apos;github_username/plugin_name&apos;# set -g @plugin &apos;git@github.com/user/plugin&apos;# set -g @plugin &apos;git@bitbucket.com/user/plugin&apos;# Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)run &apos;~/.tmux/plugins/tpm/tpm&apos; 注意，最后的 run &#39;~/.tmux/plugins/tpm/tpm&#39; 一定要放在整个 ~/.tmux.conf 的最后一行。 如果你尚未启动 Tmux，那么现在就可以执行 tmux new -s foobar 打开一个新的窗口了。如果你已经启动了 Tmux，那么需要在 Tmux 环境里重新加载配置文件： 1tmux source ~/.tmux.conf 初始化注意到，在默认的配置中，我们已经添加了两个插件：tpm 和 tmux-sensible。这里 tpm 是 Tmux Plugin Manager 本身，自不必说；tmux-sensible 则是插件管理器官方推荐的必装插件——当然你可以选择不装，不过我们这里就不标新立异了。 然而，tpm 本身是已经通过 git clone 命令下载到本地了，tmux-sensible 却没有。所以，我们这里需要通过 prefix shift-i 来安装它。prefix shift-i 中，i 是 install 的缩写。执行它会根据配置文件中的插件列表，安装所有插件。 如果你的环境里命令执行正常，那么 Tmux 会提示： 1234567Already installed &quot;tpm&quot;Installing &quot;tmux-sensible&quot; &quot;tmux-sensible&quot; download successTMUX environment reloaded.Done, press ESCAPE to continue. 这样，插件管理器就算是初始化成功了。 安装、升级和反安装插件在 Tmux Plugin Manager 中安装、升级和反安装插件都很简单，他们的 Tmux 快捷键分别是： 123prefix shift-i # installprefix shift-u # updateprefix alt-u # uninstall plugins not on the plugin list tmux-resurrect和 Tmux Plugin Manager 一样，tmux-resurrect 的程式码也托管在 GitHub 上，专案地址是：https://github.com/tmux-plugins/tmux-resurrect。 安装有了插件管理器，安装插件就变得很简单了。 首先，我们需要修改 ~/.tmux.conf 文件，在插件列表中加上： 1set -g @plugin &apos;tmux-plugins/tmux-resurrect&apos; 这样，在执行 prefix shift-i 的时候，Tmux Plugin Manager 就会到 GitHub 上的相应位置寻找相应专案并下载安装。 配置同样是打开配置文件，插件配置中加上： 123456# tmux-resurrectset -g @resurrect-save-bash-history 'on'set -g @resurrect-capture-pane-contents 'on'set -g @resurrect-strategy-vim 'session'# set -g @resurrect-save 'S'# set -g @resurrect-restore 'R' 这样，tmux-resurrect 就会保存键入的命令历史、Tmux 的面板布局还有 Vim 的状态了。 保存和加载至此，tmux-resurrect 已经配置好，可以保存和加载 Tmux 会话的状态了，快捷键是： 12prefix Ctrl-s # save tmux session to local fileprefix Ctrl-r # reload tmux session from local file 这样，只要养成定期 prefix Ctrl-s 的好习惯，我们就不怕 Tmux 会话状态丢失了！]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Tmux</tag>
        <tag>Resurrect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个用 TikZ 实现的简易文本框]]></title>
    <url>%2F2016%2F09%2F03%2Fa-simple-text-block-by-TikZ%2F</url>
    <content type="text"><![CDATA[在知乎上看到一个问题，求一个简易的文本框。恰好之前在群里用 TikZ 给朋友实现过一个类似的，所以就做了一个回答。一些值得说的东西，记录在这里。 首先是代码。 simple-block.tex12345678910111213141516171819202122232425262728293031323334\documentclass[UTF8]&#123;ctexart&#125;\usepackage&#123;tikz&#125;\usepackage&#123;calc&#125;\usetikzlibrary&#123;calc&#125;\newlength&#123;\framelinewidth&#125;\newlength&#123;\horizonextendwidth&#125;\newlength&#123;\verticalextendwidth&#125;\setlength&#123;\framelinewidth&#125;&#123;2pt&#125;\setlength&#123;\horizonextendwidth&#125;&#123;3pt&#125;\setlength&#123;\verticalextendwidth&#125;&#123;3pt&#125;\newenvironment&#123;tblock&#125;&#123;\par\medskip\noindent\begin&#123;tikzpicture&#125; \node[inner sep = 0pt] (box) \bgroup% \begin&#123;minipage&#125;[t]&#123;\textwidth-\framelinewidth-2\horizonextendwidth&#125;%&#125;&#123;% \end&#123;minipage&#125;% \egroup; \draw[black, line width=\framelinewidth] ( $ (box.north east) + (\horizonextendwidth,-\verticalextendwidth) $ ) -- ( $ (box.north east) + (\horizonextendwidth,\verticalextendwidth) $ ) -- ( $ (box.north west) + (-\horizonextendwidth,\verticalextendwidth) $ ) -- + (0,-2\verticalextendwidth); \draw[black, line width=\framelinewidth] ( $ (box.south east) + (\horizonextendwidth,\verticalextendwidth) $ ) -- ( $ (box.south east) + (\horizonextendwidth,-\verticalextendwidth) $ ) -- ( $ (box.south west) + (-\horizonextendwidth,-\verticalextendwidth) $ ) -- + (0,2\verticalextendwidth);\end&#123;tikzpicture&#125;\par\medskip&#125;\usepackage&#123;mwe&#125;\begin&#123;document&#125;\begin&#123;tblock&#125;\blindtext\end&#123;tblock&#125;\end&#123;document&#125; 有几个地方值得一说。 主体当然是用 \newenvironment{tblock} 定义的 tblock 环境。这个环境里的文本部分是 tikzpicture 里用 \node 实现的，内里的换行用了 minipage。minipage 的宽度是 \textwidth-\framelinewidth-2\horizonextendwidth，这里利用了 calc 宏包提供的特性——直接做长度运算。为了让整个文本框宽度恰好是 \textwidth，内里的文本部分宽度必须减去框线两边延伸的宽度（2\horizonextendwidth）以及两边框线本身的粗细（2 * 0.5\framelinewidth）。 再就是 \node[inner sep = 0pt] (box) {} 的形式被修改为 \node[inner sep = 0pt] (box) \bgroup \egroup 的形式。这是为了避免在定义新环境时花括号不匹配的问题。详细可以看 TeX.sx 上的讨论。 最后就是引入了 \usetikzlibrary{calc}，这个库允许我们在 TikZ 里对点的坐标做运算。因此我们可以写出类似 ( $ (box.south east) + (\horizonextendwidth,\verticalextendwidth) $ ) 的代码，来表示 box 右下角偏移 (\horizonextendwidth,\verticalextendwidth) 的那个点。 大体就是如此了。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>TikZ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[listings 配置：MATLAB 语法高亮]]></title>
    <url>%2F2016%2F09%2F01%2Flistings-settings-for-MATLAB%2F</url>
    <content type="text"><![CDATA[最近会用到 MATLAB，总结的时候就想要在 LaTeX 里面插入 MATLAB 的代码。minted 宏包当然是一个选项，不过它基于 Python 的 pygments 库，使用起来有一定门槛；所以最终还是决定要动手配一下 MATLAB 的高亮。 具体来说，配置如下： 1234567891011121314151617181920212223242526272829\usepackage&#123;listings&#125;\usepackage[usenames,dvipsnames]&#123;color&#125;\definecolor&#123;DarkGreen&#125;&#123;rgb&#125;&#123;0.0,0.4,0.0&#125;\lstloadlanguages&#123;Matlab&#125;\lstset&#123;language=Matlab, frame=single, % single framed basicstyle=\small\ttfamily, keywordstyle=[1]\color&#123;Blue&#125;\bfseries, % primitive funs in bold blue keywordstyle=[2]\color&#123;Purple&#125;, % args of funs in purple keywordstyle=[3]\color&#123;Blue&#125;\underbar, % user funs in blue with underbar stringstyle=\color&#123;Purple&#125;, % strings in purple showstringspaces=false, identifierstyle=, commentstyle=\usefont&#123;T1&#125;&#123;pcr&#125;&#123;m&#125;&#123;sl&#125;\color&#123;DarkGreen&#125;\small, tabsize=4, % more standard MATLAB funcs morekeywords=&#123;sawtooth, square&#125;, % args of funcs morekeywords=[2]&#123;on, off, interp&#125;, % user funcs morekeywords=[3]&#123;FindESS, homework_example&#125;, morecomment=[l][\color&#123;Blue&#125;]&#123;...&#125;, % line continuation (...) like blue comment numbers=left, numberstyle=\tiny\color&#123;Blue&#125;, firstnumber=1, stepnumber=1 &#125; 每个设置的作用，在注释里都有了。具体使用起来，效果如下。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Listings</tag>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTeX 模板：lpaper]]></title>
    <url>%2F2016%2F08%2F30%2FLaTeX-template-lpaper%2F</url>
    <content type="text"><![CDATA[这是一篇很水的博文。 最近因为一些事情，仿照 CEJ 的模板，基于 revtex4-1 做了个「基佬紫」配色的模板。想了想，还是放出来，大家想要的话自取；模板还很不完善，如果有兴趣给我发 PR 帮我一起改进就更欢迎了。 地址：https://github.com/Liam0205/lpaper/releases]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Template</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员的自我修养（一）：计算机硬件架构的发展]]></title>
    <url>%2F2016%2F08%2F30%2Freview-of-hardware-development%2F</url>
    <content type="text"><![CDATA[前作介绍了内存寻址方面的一些知识。近期正在读《编译、链接与库》，于是借着读书的机会，梳理回顾一下计算机软硬件的基本结构以及相关的一些知识。 计算机硬件架构的发展计算机硬件涉及到各种设备、芯片以及接口。这些内容繁复、繁琐，作为软件开发者，通常不会去关心。作为软件开发者，最关心的往往是三个部件：中央处理器（CPU）、内存（Memory）以及 I/O 控制芯片（I/O Controller）。接下来，我们以这三个部件为中心，探索一下计算机硬件架构及其发展历程。 计算机硬件的发展，很大程度上可以归结于 CPU 技术的发展。具体的表现，就是 CPU 核心频率的不断提升。 在早期，CPU 的核心频率和内存的频率一致，因此 CPU 可以和内存连在同一根总线上。至于显示器、键盘、软盘驱动器、硬盘驱动器，它们的工作速度比 CPU 和内存慢得多。于是，通常来说，这些 I/O 设备需要通过各自的控制器与总线相连。 后来，CPU 的频率提升很多，而内存的频率跟不上 CPU 的频率。于是 CPU 开始采用倍频的方式与总线通信——也就是说，CPU 跑过多个时钟周期，再一股脑跟总线通信；就好像总司令连着颁布几道命令，通讯员一口气把这些命令下达到前线一样。与此同时，图形化操作系统（Windows）和 3D 游戏迅速发展起来，这就要求显卡能与 CPU 和内存之间进行大量的数据交换。于是，人们专门设计了一个北桥芯片（Northbridge, PCI Bridge），用来协调 CPU、内存和显卡之间的高速内存交换。 连接在北桥芯片上的设备，运行速度都非常高。相对应的，硬盘、键盘、鼠标等设备速度就显得很低了。如果北桥要同时协调一群高速设备和一群低速设备，那么北桥的设计就会变得非常复杂。为此，人们设计了南桥，用来统筹这些相对低速的设备。 后来，随着处理器制造技术的提升，北桥被 CPU 直接集成在内，形成了类似下图的结构。 可以看到，随着硬件制造技术的提升，特别是 CPU 制造技术的提升，计算机的硬件结构随之不断发生改变。不过，本质上还是没有逃开 CPU - 内存 - I/O 设备的结构。这也是为什么，我们在做程序设计和开发的时候，可以总是将计算机抽象成这样一个简单的模型。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Architecture</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 中类的拷贝控制]]></title>
    <url>%2F2016%2F08%2F14%2Fcopy-control-in-Cpp%2F</url>
    <content type="text"><![CDATA[数据成员有指针，构造函数 new 一坨，析构函数 delete 掉，然后不实现深拷贝构造函数。你咋不上天？ 为了避免「上天」，我们有必要讨论一下 C++ 中类的拷贝控制。 问题重现为了说明问题的严重性，我们先来重现一下这个问题。 double_free.cpp1234567891011#include &lt;iostream&gt;using namespace std;int main () &#123; int* p = new int[100]; auto q = p; delete[] p; p = nullptr; delete[] q; q = nullptr; // core dumped! return 0;&#125; 这段代码很简单，展现的问题也很清楚。 首先，我们在 main 函数里，在栈里动态分配了一个 int 型数组，返回的内存地址保存在 p 中。而后，通过赋值运算符，将 p 的值赋值给 q。这样，我们就有了 p 和 q，两个指针指向栈中同一块内存空间。 接下来，我们调用 delete[]，将 p 对应的内存空间释放，并将 p 置空。注意，这里是不够的！因为，p 和 q 原本指向同一块内存空间，而我们通过 p 将内存释放了，q 就变成野指针了。于是，在下面的操作中，delete[] q 就变成了对同一内存空间的第二次释放，这是未定义的行为。更有甚者，如果后续程序中，依然使用 q 对相应的内存空间进行存取访问，那么——我就呵呵一笑…… 拷贝与赋值的问题上述错误，根本原因是我们通过赋值运算符，将指针 p 的值赋给 q 之后，p 和 q 指向了同一块内存空间。于是，任何对 p/q 其一的操作，都等同于对另一的操作。莫说是多次释放可能造成问题，在正常使用过程中，p 与 q 相互干扰，也可能产生不符合预期的结果——而且很难追查。 这就是说，对于指针的复制，特别是指向动态内存的指针的复制，我们要特别小心。实际上，我们可能期待的是这样的效果： 1234567int* p = new int[100];// set value of elements in p// do a **deep copy**int* q = new int[100];for (size_t i = 0; i != 100; ++i) &#123; q[i] = p[i];&#125; 也就是说，我们需要一个「深度拷贝」，将 q 与 p 指向不同的内存空间；只不过，它们所包含的元素内容完全相同。如此一来，p 与 q 除了内里一致，其实完全是两块不相干的内存空间。之后，按照既定的规矩来操作，都会是安全可控的。 拷贝构造函数与赋值运算符重载对于 C++ 的内置类型，其拷贝（赋值）过程我们都非常熟悉，也不会出错。 12int i_tmp = 100;int i_copy = i_tmp; 涉及到类实例（instance of a Class, aka object of a Class）的拷贝和赋值，看似熟悉的问题，就不那么清晰了。每个类的实例当中，都存在若干成员变量。在我们的直觉中，类实例的拷贝和赋值，无非就是将一个实例中的全部成员变量，挨个拷贝、赋值给新的实例。大体上，也没错。但关键是，这些操作，谁来执行呢？ 我们知道，在 C++ 中，大多数的操作都是通过某个函数实现的。类实例的拷贝和赋值，也不例外。类实例的拷贝，是通过拷贝构造函数来实现的；而类实例的赋值，则是通过重载过的赋值运算符来实现的——运算符也是一种函数。不熟悉这个话题的读者，可能没有听说过「拷贝构造函数」或者「重载赋值运算符」。这是因为，一般情况下，编译器会为你合成这两个函数。 1234567891011121314151617181920212223SalesData &#123; public: SalesData (const SalesData&amp;); SalesData&amp; operator= (const SalesData&amp;); // other functions private: std::string ID; size_t sold_count;&#125;;// fake: synthesized copy constructorSalesData::SalesData (const SalesData&amp; orig) : ID (orig.ID), // call the copy constructor of std::string sold_count (orig.sold_count) // copy size_t &#123;&#125; // empty function body// fake: synthesized overloaded operatorSalesData&amp;SalesData::operator= (const SalesData&amp; rhs) &#123; this-&gt;ID = rhs.ID; // call std::string::operator= this-&gt;sold_count = rhs.sold_count; // operator= for size_t return *this;&#125; 这里我们手动实现了 SalesData 类的拷贝构造函数和重载了 SalesData 类的赋值运算符。这两个函数都接收 SalesData 类的常量引用；不同的是，拷贝构造函数没有返回值（因为它是构造函数），而赋值运算符返回了 SalesData 类的左值引用——这与默认的赋值运算符的行为是一致的。 我们注意到，在编译器合成的拷贝构造函数中，在初始化列表里，我们依次调用数据成员的拷贝构造函数，将成员的值拷贝到新的实例中。如果数据成员本身是类实例（而不是基本类型），那么在这个过程中，又会调用这些类的拷贝构造函数。编译器重载的赋值运算符的行为和编译器合成的拷贝构造函数行为类似。只不过，操作由调用拷贝构造函数，变为了调用相应成员变量的赋值运算符。 浅拷贝与深拷贝至今为止，我们看过的拷贝构造函数（与重载的赋值运算符）都还能如预期一样正常工作。但是，在一些情况下，类似编译器合成的拷贝构造函数和赋值运算符，就没法如预期一样工作了： 类成员中有静态变量，并且构造函数要操作这些静态变量（比如类实例计数）； 类成员中有指针，并且在类示例的生存期内会将它指向动态开辟的内存空间。 在这两种情况下，编译器合成的拷贝构造函数和赋值运算符，就都没办法正常工作了。在静态变量的情形中，默认的拷贝构造函数和复制运算符，不会操作静态变量——因为编译器合成的两个函数只操作实例中的数据成员，但类的静态变量属于类本身，而不属于任何单独的类实例。此时，如果依赖编译器自动合成的两个函数，就无法正确地维护静态变量。在动态开辟内存的情形中，则可能形成本文第一节中多次释放同一块内存空间的问题，引发核心转储。 我们将简单地对数据成员按位赋值的拷贝方式称为浅拷贝。毫无疑问，编译器自动合成的拷贝构造函数和赋值运算符，都属于浅拷贝。根据上述分析，我们知道，浅拷贝在某些情况下是不合适的。于是，在这些情况下，我们需要深拷贝。 所谓深拷贝，就是在拷贝的过程中，我们需要小心地处理类的静态变量或者动态内存空间。在第一节中，解决复制指针导致两次释放同一块内存空间的实践中，我们就用到了深拷贝。以下是一个深拷贝的例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#define MAX_BUFFER 10240SalesData &#123; public: SalesData () = default; SalesData (const SalesData&amp;); SalesData&amp; operator= (const SalesData&amp;); ~SalesData (); // other functions private: std::string ID; size_t sold_count; size_t* p_buffer;&#125;;SalesData::SalesData () : ID (""), sold_count (0) &#123; p_buffer = new size_t [MAX_BUFFER];&#125;SalesData::SalesData (const SalesData&amp; orig) : ID (orig.ID), // call the copy constructor of std::string sold_count (orig.sold_count) // copy size_t &#123; this-&gt;p_buffer = new size_t [MAX_BUFFER]; for (size_t i = 0; i != MAX_BUFFER; ++i) &#123; this-&gt;p_buffer[i] = orig.p_buffer[i]; &#125;&#125;SalesData&amp;SalesData::operator= (const SalesData&amp; rhs) &#123; this-&gt;ID = rhs.ID; // call std::string::operator= this-&gt;sold_count = rhs.sold_count; // operator= for size_t this-&gt;p_buffer = new size_t [MAX_BUFFER]; for (size_t i = 0; i != MAX_BUFFER; ++i) &#123; this-&gt;p_buffer[i] = rhs.p_buffer[i]; &#125; return *this;&#125;SalesData::~SalesData () &#123; delete[] p_buffer; p_buffer = nullptr;&#125; 什么时候需要手工实现深拷贝在 C++ 中，如果需要你手工实现一个析构函数，通常意味着你的类实例中有动态开辟的内存空间——因为只有这种情况，需要程序员手工在析构实例的时候释分配的内存空间。而我们注意到，一旦类实例中涉及到动态内存空间，在拷贝实例的时候，就需要用深拷贝小心地处理这些内存空间。于是，我们得到了第一条结论如果需要实现手工的析构函数，那么就需要实现手工的拷贝构造函数和重载赋值运算符。 此外，如果类定义中包含静态成员变量，并且这些成员变量在构建、析构实例的时候需要修改，那么通常我们也需要手工实现拷贝构造函数和重载复制运算符。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Class</tag>
        <tag>Copy Control</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语语法之四：时态选择]]></title>
    <url>%2F2016%2F07%2F31%2Ftense-selection%2F</url>
    <content type="text"><![CDATA[照例开头得有个抱怨：距离这个系列的上一篇文章的发表已经有一年多了，我真是懒啊懒啊懒……然而博客上至今也有一百二十多篇文章了，说明我还是笔根不辍的嘛，只是能写且想写的东西比较多，所以这个系列就这么落下了。 Simon 老师在知乎上发表了一篇文章，题为「换一种方式理解英语时态」。核心内容，是将时间与状态分开（原文中作：时与体），分别考量。文章内容确实是明白无误的，但是我却以为文章缺少了很关键的一部分：拿到一句话，到底应该选择何种时态呢——所谓「论理者多，致用者少」？ 本篇将在前作的基础上，与 Simon 老师的文章互通有无，希冀能够解决「时态选择困难症」。为了力求简便，本文的用词会相当精炼。 时间、状态和语态英文中，谓语动词的具体形式，需要在时间、状态和语态上做区分。 语态我们从最简单的语态说起，它分为两种 主动语态； 被动语态。 这很好理解。「我打了人」这个就是主动语态，「我被人打了」这就是被动语态。谓语动词的形式在语态上的变化如下（以动词 do 为例）。 主动语态 被动语态 动词原形: do be 动词 + 动词过去分词: be done 状态英语中动作的状态分为两类四种： 简单式 一般式 进行式 完成式 完成式 完成进行式 简单式 完成式 一般形态 动词 + 宾语/补语/表语: do sth have + 动词过去分词 + 宾语/补语/表语: have done sth 发生的时间 发生在一段时间内 发生在一段时间内，并有截止时间 时间轴 时间轴上的一个区间 时间轴上的一个箭头（指向截止时间） 注释 这一时间段，可以长至无穷大，也可以短至一个时间点 这一截止时间，可以是句中明确给出，也可以借由上下文推论出 上述表格中，一般形态里只列举了两种一般式。为了解决进行式的问题，我们先来看一下传统语法中四种动作状态的一般形式。 简单式 完成式 一般式 do sth have done sth 进行式 be doing (sth) have been doing (sth) 不难发现，不论是简单式还是完成式，其中的进行式都可以看做是相对于一般式的一种变化： 将 _be_ 看做是一种特殊的动词； 将 doing (sth) 看做是接在 _be_ 后面的名词结构。 因此，考虑到进行式只不过（可以看做）是一般式的一种变化，所以在考虑下面考虑时间对动词形式的影响时，可以在一定程度上把他们归为一类：即只考虑应当选用简单式还是完成式，暂不考虑使用一般式还是进行式的问题。 时间上面我们将动作的状态分成了两类：简单式、完成式。所以在探讨时间的过程中，我们也就需要分别对两类状态做讨论。 简单式 完成式 现在 时间轴上的区间包含「现在」这个时间点 时间轴上箭头指向的时间点是「现在」 过去 时间轴上的区间完全在「现在」的左边（过去） 时间轴上的箭头指向的时间点在「现在」的左边（过去） 将来 时间轴上的区间完全在「现在」的右边（将来） 时间轴上箭头指向的时间点在「现在」的右边（将来） 至于过去将来，这是站在过去的某个时间点探讨某件事情，最常用于虚拟语气中——虚拟语气就是站在过去的时间点上，否定掉已经发生的某些事情，探讨将来的可能性。 流程图 作者： ALL CLEAR!!! 读者：你说啥？啥 ALL CLEAR？还是搞不明白嘛！ 作者：现在就到了见证奇迹的时刻了！ 关于时态选择的东西，都在下面这张流程图里了。你只需要按照流程图走一遍，把黄色框框里的内容记录下来，就能知道自己需要使用什么时态了。 实际使用看看 奥巴马是美国总统。 首先，这句话没有明示或者暗示截止时间，所以流程图里第一个问题填「否」。 接下来，奥巴马从上任到离职，包括了「现在（2016-07-31）」这个时间点，所以第二个问题填「包含现在」。 再然后，这里不涉及「持续」或者「正在发生」的含义，所以第三个问题填「否」。 最后，这是个主动语态。 所以，最终的结果是，我们要用「一般现在时的主动语态」：Obama is the U.S. President. 妈妈爱孩子。 首先，这句话没有明示或者暗示截止时间，所以流程图里第一个问题填「否」。 接下来，从古至今还有以后所有的妈妈都爱孩子，包括了「现在」这个时间点，所以第二个问题填「包含现在」。 再然后，这里不涉及「持续」或者「正在发生」的含义，所以第三个问题填「否」。 最后，这是个主动语态。 所以，最终的结果是，我们要用「一般现在时的主动语态」：All mothers love their children. 注意，此处「从古至今还有以后所有的妈妈都爱孩子」预示着这是一条「真理」。真理要用一般现在时，就是这样来的。 证人心脏病发作时正在法庭上接受询问。 首先，这句话没有明示或者暗示截止时间，所以流程图里第一个问题填「否」。 接下来，心脏病发作时在「现在」之前，所以第二个问题填「在过去」。 再然后，这里涉及「正在发生」的含义，所以第三个问题填「是」。 最后，这是个被动语态。 所以，最终结果是，我们要用「过去进行时的被动语态」：The witness was being questioned in court when he had a heart attack. 明天下午五点过来就好。你的车子那时会修好。 首先，这句话明示了截止时间，所以流程图里第一个问题填「是」。 接下来，截止时间是明天下午五点，在未来，所以第二个问题填「截至将来」。 再然后，这里不涉及「持续」或者「正在发生」的含义，所以第三个问题填「否」。 最后，这是个被动语态。 所以，最终结果是，我们要用「将来完成时的被动语态」：Come back at 17:00. Your car will have been fixed by then. 两分钟后，她就煲电话粥整整仨小时了。 首先，这句话明示了截止时间，所以流程图里第一个问题填「是」。 接下来，截止时间是两分钟后，在未来，所以第二个问题填「截至将来」。 再然后，这里涉及「持续」的含义，所以第三个问题填「是」。 最后，这是个主动语态。 所以，最终结果是，我们要用「将来完成进行时的主动语态」：In another two more minutes, she will have been talking on the phone for three hours. 我确定我在哪见过这张脸。 首先，这句话暗示了截止时间（截至现在见过），所以流程图里第一个问题填「是」。 接下来，截止时间是现在，所以第二个问题填「截至现在」。 再然后，这里不涉及「持续」或者「正在发生」的含义，所以第三个问题填「否」。 最后，这是个主动语态。 所以，最终结果是，我们要用「现在完成时的主动语态」：I’m sure that I have seen this face somewhere. 昨天我就已经连续加班 18 天了！ 首先，这句话暗示了截止时间，所以流程图里第一个问题填「是」。 接下来，截止时间是昨天，在现在之前，所以第二个问题填「截至过去」。 再然后，这里涉及「持续」的含义，所以第三个问题填「是」。 最后，这是个主动语态。 所以，最终结果是，我们要用「过去完成进行时的主动语态」：Till yesterday, I had been working overtime for 18 days!]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>Grammar</tag>
        <tag>Tense</tag>
        <tag>Verb</tag>
        <tag>Flow Chart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Homebrew 上发布自己的 App]]></title>
    <url>%2F2016%2F07%2F30%2Frelease-your-own-app-in-Homebrew%2F</url>
    <content type="text"><![CDATA[Homebrew 是最初由 Max Howell 用 Ruby 写的 OS X 软件管理系统，其代码开源在 GitHub 上。 Homebrew 给自己贴了个一句话简介：The missing package manager for OS X。翻译过来成中文就是：寻它千百度的软件包管理器。名副其实地是，Homebrew 真的很好用。安装、升级、卸载等操作，在 Homebrew 的生态下，都只需要一条命令就可以了。并且 Homebrew 会自动为你解决软件包的依赖问题。 近日，Belleve 邀请我协助他维护 otfcc 在 OS X 上的预编译版本，并请我为之发布 Homebrew 的软件包。以下是对发布 Homebrew 软件包的总结。 显而易见的对比otfcc 现在已经有了预编译好的 Mac 版本。对于用户来说，只需要执行 123wget https://github.com/caryll/otfcc/releases/download/v0.2.3/otfcc-mac64-0.2.3.tar.xztar Jvxf otfcc-mac64-0.2.3.tar.xzsudo mv otfcc* /usr/local/bin 好吧，那个「只」字，我应该加上引号表示夸张的。现在看看有了 Homebrew 包我们可以怎样做 1brew tap caryll/tap &amp;&amp; brew install otfcc-mac64 对比确实是显而易见的，不是吗？使用 brew 安装，只需要执行命令。剩下的东西，只需要交给 Homebrew 去处理就好了。 基本概念在 Homebrew 的架构下，至少有 4 层概念 Keg（酒桶）：安装好的脚本、软件等； Cellar（酒窖）：所有用 Homebrew 安装在本地的脚本、软件组成的集合； Formula（配方）：定义如何下载、编译和安装脚本或软件的 Ruby 脚本； Tap：一个包含若干 Formula 的 GitHub 专案。 我们平时使用 brew install foobar 安装软件时，实际上是从 Homebrew/homebrew-core 这个 Tap 中获取相应的 Formula，然后将 Keg 安装在 Cellar 中。现在的问题是，Homebrew/homebrew-core 不允许普通用户提交自己写的小众脚本、软件。所以，我们需要建立一个新的 Tap（GitHub 专案），包含对应我们软件的 Formula，然后将 Keg 放入本地的 Cellar 中。 于是我们知道，我们要做的事情是： 理顺安装程序的步骤； 创建一个 Formula，将上述步骤用 Ruby 表述出来； 创建一个 GitHub 专案，将上述 Formula 纳于该专案的版本控制之下。 创建 Homebrew Package 并安装Homebrew 提供了一个官方指南。不过，这个指南写得比较晦涩难懂。所以，我另起炉灶，按照更容易理解的方式介绍一下创建 Homebrew 理顺步骤第一节中，我们已经看到手工安装 otfcc 的操作步骤。其中第一步是下载，这一步在执行 brew install 时，Homebrew 会根据 Formula 的指示完成。第二步是解包，这一步 Homebrew 也会为我们自动完成。因此，实际我们要做的，就是将二进制文件放到 /usr/local/bin 目录下。 创建 Formula假设我们的软件已经有了一个发布版本，并且可供下载，比如 https://github.com/caryll/otfcc/releases/download/v0.2.3/otfcc-mac64-0.2.3.tar.xz。接下来，我们在终端里执行 1brew create https://github.com/caryll/otfcc/releases/download/v0.2.3/otfcc-mac64-0.2.3.tar.xz 这条命令会在 /usr/local/Library/Formula/ 下创建一个 .rb 文件，其文件名取决于传给 brew create 的 URL。比如，我们这里会创建 /usr/local/Library/Formula/otfcc-mac64.rb。 otfcc-mac64.rb123456789101112131415161718192021222324252627282930313233343536373839# Documentation: https://github.com/Homebrew/brew/blob/master/share/doc/homebrew/Formula-Cookbook.md# http://www.rubydoc.info/github/Homebrew/brew/master/Formula# PLEASE REMOVE ALL GENERATED COMMENTS BEFORE SUBMITTING YOUR PULL REQUEST!class OtfccMac64 &lt; Formula desc "" homepage "" url "https://github.com/caryll/otfcc/releases/download/v0.2.3/otfcc-mac64-0.2.3.tar.xz" version "0.2.3" sha256 "f393b14f9c42c890b8a60949b13a8f9b5c3f814daa8b18901656ccc3b866f646" # depends_on "cmake" =&gt; :build depends_on :x11 # if your formula requires any X11/XQuartz components def install # ENV.deparallelize # if your formula fails when building in parallel # Remove unrecognized options if warned by configure system "./configure", "--disable-debug", "--disable-dependency-tracking", "--disable-silent-rules", "--prefix=#&#123;prefix&#125;" # system "cmake", ".", *std_cmake_args system "make", "install" # if this fails, try separate make/make install steps end test do # `test do` will create, run in and delete a temporary directory. # # This test will fail and we won't accept that! It's enough to just replace # "false" with the main program this formula installs, but it'd be nice if you # were more thorough. Run the test with `brew test otfcc-win32`. Options passed # to `brew install` such as `--HEAD` also need to be provided to `brew test`. # # The installed folder is not in the path, so use the entire path to any # executables being tested: `system "#&#123;bin&#125;/program", "do", "something"`. system "false" endend 我们先来看类的头部 12345desc ""homepage ""url "https://github.com/caryll/otfcc/releases/download/v0.2.3/otfcc-mac64-0.2.3.tar.xz"version "0.2.3"sha256 "f393b14f9c42c890b8a60949b13a8f9b5c3f814daa8b18901656ccc3b866f646" desc 是 description 的缩写，我们应该在这里填上 otfcc 的简介。homepage 相应地填上项目主页。后面的 url/version/sha256 都由 Homebrew 默认给我们填好了，我们只需要检查一下是否正确即可。 接下来是依赖项部分 12# depends_on "cmake" =&gt; :builddepends_on :x11 # if your formula requires any X11/XQuartz components 由于 otfcc 没有任何其他的依赖项，所以不需要在此填入任何内容。 接下来是安装部分 1234567891011def install # ENV.deparallelize # if your formula fails when building in parallel # Remove unrecognized options if warned by configure system "./configure", "--disable-debug", "--disable-dependency-tracking", "--disable-silent-rules", "--prefix=#&#123;prefix&#125;" # system "cmake", ".", *std_cmake_args system "make", "install" # if this fails, try separate make/make install stepsend 默认情况下，Homebrew 会并行地编译源代码。不过，有些程序并不适用并行编译。此时可以将 # ENV.deparallelize 的注释解开。后续的内容也比较简单，先后调用 ./configure 和 make install——这是标准的 *nix 编译安装流程。 由于我们现在讨论的是安装 otfcc 的预编译版本，所以不需要考虑编译的过程。只需要调用 Homebrew 提供的 bin.install 就可以了。 最后的测试部分，我们暂时不探讨。 于是我们就得到了最后的 otfcc-mac64.rb otfcc-mac64.rb12345678910111213141516171819# Documentation: https://github.com/Homebrew/brew/blob/master/share/doc/homebrew/Formula-Cookbook.md# http://www.rubydoc.info/github/Homebrew/brew/master/Formula# PLEASE REMOVE ALL GENERATED COMMENTS BEFORE SUBMITTING YOUR PULL REQUEST!class OtfccMac64 &lt; Formula desc "Parses &amp; writes SFNT structures." homepage "https://github.com/caryll/otfcc/releases/" url "https://github.com/caryll/otfcc/releases/download/v0.2.3/otfcc-mac64-0.2.3.tar.xz" version "0.2.3" sha256 "f393b14f9c42c890b8a60949b13a8f9b5c3f814daa8b18901656ccc3b866f646" def install # ENV.deparallelize # if your formula fails when building in parallel # system "tar -Jvxf otfcc-mac64-0.2.3.tar.zx" bin.install "otfccbuild" bin.install "otfccdump" endend 保存后，你就可以执行 brew install otfcc-mac64 了。 12345678$ brew install otfcc-mac64==&gt; Downloading https://github.com/caryll/otfcc/releases/download/v0.2.3/otfcc-mac64-0.2.3.tar.xzAlready downloaded: /Library/Caches/Homebrew/otfcc-mac64-0.2.3.tar.xz🍺 /usr/local/Cellar/otfcc-mac64/0.2.3: 3 files, 882.2K, built in 0 seconds$ which otfccdump/usr/local/bin/otfccdump$ which otfccbuild/usr/local/bin/otfccbuild 由于之前在 brew create 的过程中，已经下载了 otfcc-mac64-0.2.3.tar.zx 这一文件，所以 Homebrew 不会再次下载。执行完毕后，我们发现，otfccdump 和 otfccbuild 两个二进制程序已经被安装在了 /usr/local/bin/ 目录下——这是 Homebrew 安装二进制的默认目录。 我们的 Formula 比较简单，不涉及 Homebrew 提供的更深的功能。如果有必要，你需要参考官方指南。 创建 Tap至此我们已经创建了 Formula。根据这个 Formula，我们本地的 Homebrew 已经可以将 otfcc 安装到 /usr/local/bin 目录下了。然而，其他人暂时还不能获取、安装我们的软件。为此，我们需要创建自己的 Tap。 前面已经说过，Tap 实际上是 GitHub 网站上的一个专案。这个专案有些特殊，它的名字必须是 homebrew-foobar 的形式。也就是说，它必须有 homebrew- 这一前缀。otfcc 放在 GitHub 上的 caryll 组织中开发。于是我们可以在 caryll 中创建一个名为 homebrew-tap 的专案，然后将上述 otfcc-mac64.rb 纳入 homebrew-tap 这一专案的版本控制之下。 创建专案及纳入版本控制的过程是基本的 Git 操作，这里就不做展开了。创建好的专案在此：https://github.com/caryll/homebrew-tap，可供一观。 实际安装看看现在，我们创建了自己的 Formula 和 Tap，并在 GitHub 上为 Tap 创建了一个公开的专案。那么，世界上所有的 Homebrew 用户就可以使用下列指令很方便地安装 otfcc 了。 1brew tap caryll/tap &amp;&amp; brew install otfcc-mac64 注意，这里我们首先调用了 brew tap 命令，将我们自建的 Tap 加入到本地 Homebrew 的搜索列表中。加入搜索列表的内容是 caryll/tap——相比 GitHub 上的专案名称，Homebrew 会自动在传入 brew tap 的地址里加上 homebrew- 这一前缀。而后，我们照常调用 brew install 命令，就能顺利地安装 otfcc 在 OS X 上了。]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>OS X</tag>
        <tag>Homebrew</tag>
        <tag>App</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 Python 将中文数字转换成阿拉伯数字]]></title>
    <url>%2F2016%2F07%2F26%2Ftranslate-Chinese-digits-to-Arabic-number%2F</url>
    <content type="text"><![CDATA[在工作中，时不时会遇到需要将中文数字或者全角数字转换为半角阿拉伯数字的情形，于是写了一个简单的脚本来处理这样的情况。 脚本很简单，唯一需要思考一下的是，为什么「万」和「亿」不能与「千」、「百」、「十」放在一起处理。这个问题想通了，代码也就好理解了。 不多说，上代码。 convertChineseDigitsToArabic.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647chs_arabic_map = &#123;u'零':0, u'一':1, u'二':2, u'三':3, u'四':4, u'五':5, u'六':6, u'七':7, u'八':8, u'九':9, u'十':10, u'百':100, u'千':10 ** 3, u'万':10 ** 4, u'〇':0, u'壹':1, u'贰':2, u'叁':3, u'肆':4, u'伍':5, u'陆':6, u'柒':7, u'捌':8, u'玖':9, u'拾':10, u'佰':100, u'仟':10 ** 3, u'萬':10 ** 4, u'亿':10 ** 8, u'億':10 ** 8, u'幺': 1, u'０':0, u'１':1, u'２':2, u'３':3, u'４':4, u'５':5, u'６':6, u'７':7, u'８':8, u'９':9&#125;def convertChineseDigitsToArabic (chinese_digits, encoding="utf-8"): if isinstance (chinese_digits, str): chinese_digits = chinese_digits.decode (encoding) result = 0 tmp = 0 hnd_mln = 0 for count in range(len(chinese_digits)): curr_char = chinese_digits[count] curr_digit = chs_arabic_map.get(curr_char, None) # meet 「亿」 or 「億」 if curr_digit == 10 ** 8: result = result + tmp result = result * curr_digit # get result before 「亿」 and store it into hnd_mln # reset `result` hnd_mln = hnd_mln * 10 ** 8 + result result = 0 tmp = 0 # meet 「万」 or 「萬」 elif curr_digit == 10 ** 4: result = result + tmp result = result * curr_digit tmp = 0 # meet 「十」, 「百」, 「千」 or their traditional version elif curr_digit &gt;= 10: tmp = 1 if tmp == 0 else tmp result = result + curr_digit * tmp tmp = 0 # meet single digit elif curr_digit is not None: tmp = tmp * 10 + curr_digit else: return result result = result + tmp result = result + hnd_mln return result 完整版见：GitHub Repo 测试用例来自：fayaa]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Number</tag>
        <tag>Chinese</tag>
        <tag>Python</tag>
        <tag>Arabic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加快 iPhone 从 iCloud 恢复备份的速度]]></title>
    <url>%2F2016%2F07%2F23%2Fspeed-up-the-recovering-from-iCloud-for-iPhone-users-in-mainland-China%2F</url>
    <content type="text"><![CDATA[因为一些原因，我抹掉了 iPhone 上的所有设置和数据，而后拟从 iCloud 备份恢复手机状态。不过，在中国，去往 iCloud 的连接十分不稳定；于是恢复变得漫长无期，网友们也对此怨声载道 (1, 2, 3, 4)。 这里简单记录一下我观察到的现象以及解决方法。 现象抹掉 iPhone 上的数据并重启后，随着设置助手到备份恢复的步骤。一般来说，此时会有如下一些选项： 从 iTunes 备份恢复 从 iCloud 备份恢复 设置为新的 iPhone 从 Android 手机迁移 当选择「从 iCloud 备份恢复」之后，需要登录 iCloud 对应的 Apple ID。随后开始进入恢复状态。然而，当我的 iPhone 进入此状态后，进度条一个小时内没有任何动静；进度条底下的状态提示持续停留在「预估时间」。之后无论连接什么样的 Wi-Fi 热点，这个现象都会重复发生。 于是，经验上可以认为，iPhone 并没有成功和 iCloud 服务器正确连接，或者连接后因为网络问题（本地网络问题或者网络中某个结点）导致数据无法正确传输。 解决从上述怨声载道来看，虽然 Apple 在中国大陆地区架设了 CDN，然而并没有什么〇用。所以，我们必须想想别的办法。 现在的情况是，iPhone 借由 Wi-Fi 网络和 Apple 在中国大陆地区的服务器连接存在某种问题。我们的目的是要和 iCloud 服务器正确连接，然后恢复备份。 于是，解决问题的办法有两个： 排查问题，恢复网络通畅； 想办法绕过网络连接异常状态。 第一个办法，从上述怨声载道来看，并不可取。因为这可能是一个大范围的频繁发生的问题，甚至 Apple 也在官网发布了一个并没有什么〇用的帮助文本：插上电源，往死里等。所以，我们只能想办法绕过异常的网络连接。 通常，绕过异常连接的办法有以下几个： 挂 VXN，希望出口能绕过异常连接； 挂 PXXXY，希望出口能绕过异常连接； 对有 CDN 的服务，设置临近地区的 DNS，以解析得到网络连接无异常的 CDN 服务器并进行连接。 我暂时没有可用的 VXN，也不想让私密数据流量都依赖公开的匿名 PXXXY，所以修改 DNS 对我来说是最合适的解法。于是，问题就变成了：如何在 iPhone 初始化界面设置 DNS。 经过一番试（乱）验（按），我发现，成功连接上 Wi-Fi 之后，按下 Home 键会弹出一个菜单——这个菜单提供了更丰富地 Wi-Fi 设置的入口。进入之后，只需要点击已连接网络旁边的 (i)，即可对 DNS 进行设置。 在这里，我检索到了港台地区使用的一些 DNS。传说中很有效的中华电信 DNS 在我这里并没有什么用，最终选择的香港主副 DNS 倒是有奇效：整个恢复过程在设置香港主副 DNS 之后，只用了 7 分钟就完成了。 主 DNS：202.45.84.58 地理位置：香港特别行政区副 DNS：203.80.96.10 地理位置：香港特别行政区]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>iPhone</tag>
        <tag>iCloud</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTeX 黑魔法（一）：tcolorbox 宏包简明教程]]></title>
    <url>%2F2016%2F07%2F22%2Fusing-the-tcolorbox-package-to-create-a-new-theorem-environment%2F</url>
    <content type="text"><![CDATA[嗯，我消失好几天了。那么，我都在做什么呢？没错，就是写这篇文章了。这篇文章写起来着实有些费神了。于是，如果你觉得这篇文章对你有帮助，不妨扫描文末的二维码，适量赞助一下哦~！ tcolorbox 宏包是 Thomas F. Sturm 开发的一个用于绘制彩色文本框的宏包。tcolorbox 底层基于 pgf，功能也是十分强大。 一个月前，有群友在群里问到如何制作下面这样的蓝色边框，于是这里借着实现这一边框的时机，简单讲讲 tcolorbox 的用法。 概述：安装与调用和大多数宏包一样，tcolorbox 被 MiKTeX 和 TeX Live 都收录其中。因此，通常情况，你只需要用相应的宏包管理器安装就好。 使用起来，也很简单。和其他宏包一样，你需要在导言区，使用 \usepackage 命令调用这个宏包。 1\usepackage&#123;tcolorbox&#125; 你可以在调用宏包时，用可选参数指明需要加载哪些程序库；也可以在调用 tcolorbox 之后，显式地使用 \tcbuselibrary 来调用 tcolorbox 提供的丰富程序库。比如，下面的代码调用了 skins, breakable, theorems 三个程序库。 12\usepackage&#123;tcolorbox&#125;\tcbuselibrary&#123;skins, breakable, theorems&#125; 每个程序库，都对应着一个 tcbXXX.code.tex 文件。实际上，使用 \tcbuselibrary 命令，就是调用了一个个这样的文件。以下是常见可用的 tcolorbox 程序库： skins: 调用 tikz 宏包，提供丰富的文本框样式； vignette: 提供一些装饰性的样式； raster: 用以调整若干 tcolorbox 的排布样式 listings/listingsutf8/minted: 用以和对应的宏包联用，实现好看的代码清单 theorems: 用以生成定理类环境 breakable: 实现自动分页的文本框 magazine: 实现类似杂志的分段文本 fitting: 实现字体大小和文本框大小的自适应 tcolorbox 基础基础环境和基础命令tcolorbox 宏包提供了与宏包同名的环境，是整个宏包的基础环境，用于生成段落间的文本框。与之对应，宏包还提供了 \tcbox 命令，用于生成行内的文本框。 12345\begin&#123;tcolorbox&#125;[⟨options⟩]⟨environment content⟩\end&#123;tcolorbox&#125;\tcbox[⟨options⟩]&#123;⟨box content⟩&#125; tcolorbox 环境和 \tcbox 命令都可以接收一组选项，用来控制文本框的样式。我们来看看下面的代码，及其相应的效果。 tcb-basic.tex123456789101112131415161718192021222324252627282930313233343536373839404142434445\documentclass&#123;article&#125;\usepackage&#123;tcolorbox&#125;\usepackage&#123;colortbl&#125;\usepackage&#123;geometry&#125;\geometry&#123;margin = 1in&#125;\begin&#123;document&#125;\begin&#123;tcolorbox&#125;This is my first \textbf&#123;tcolorbox&#125;.\end&#123;tcolorbox&#125;\begin&#123;tcolorbox&#125;This is another \textbf&#123;tcolorbox&#125;.\tcblowerHere, you see the lower part of the box.\end&#123;tcolorbox&#125;\begin&#123;tcolorbox&#125;[title = &#123;I Love Sophia&#125;]This is a \textbf&#123;tcolorbox&#125; with title.\tcblowerHere, you see the lower part of the box.\end&#123;tcolorbox&#125;\tcbset&#123;colframe = blue!50!black, colback = white, colupper = red!50!black, fonttitle = \bfseries, nobeforeafter, center title&#125;Text \tcbox[tcbox raise base]&#123;Hello World&#125;\hfill%\tcbox[left = 0mm, right = 0mm, top = 0mm, bottom = 0mm, boxsep = 0mm, toptitle = 0.5mm, bottomtitle = 0.5mm, title = &#123;My table&#125;] &#123;\arrayrulecolor&#123;blue!50!black&#125; \renewcommand&#123;\arraystretch&#125;&#123;1.2&#125;% \begin&#123;tabular&#125;&#123;r|c|l&#125; One &amp; Two &amp; Three \\ \hline\hline Men &amp; Mice &amp; Lions \\\hline Upper &amp; Middle &amp; Lower \end&#123;tabular&#125;&#125;\hfill%\tcbox[colback=blue!85!black, left = 0mm, right = 0mm, top = 0mm, bottom = 0mm, boxsep = 1mm, arc = 0mm, boxrule = 0.5pt, title = &#123;My picture&#125;] &#123;\includegraphics[width = 5cm]&#123;example-image&#125;&#125;\end&#123;document&#125; 7 – 9 行是一个最朴素的 tcolorbox 环境。我们看到，在默认情况下，tcolorbox 输出了一个深灰色圆角边框、浅灰底色的文本框。 11 – 15 行则在上述最朴素的 tcolorbox 环境的基础上，增加了一条虚线。这条虚线由 \tcblower 控制，它将 tcolorbox 中的内容分成了上下两部分。 17 – 21 行则第一次指定了 tcolorbox 环境的选项。tcolorbox 环境和 \tcbox 都可以接受一串 key-value 的参数列表。这里，我们给 tcolorbox 环境传入了一个名为 title 的参数，它的值是 I Love Sophia。顾名思义，这给 tcolorbox 输出的文本框起了一个名字。默认情况下，这个名字会显示在文本框的头部。 23 – 25 行引入了一个新的命令——\tcbset。显而易见，tcb 是宏包名字的缩写，而 set 自然是「设置」的意思。\tcbset 也可以接受一串 key-value 参数列表，这些参数将对（同一个分组内） \tcbset 之后的所有 tcbcolorbox 环境和 \tcbox 命令生效。这里引入了一些参数，我们在此不深究它们的含义，且先看效果再说。 在 27 行，我们遇到了第一个 \tcbox 命令。在先前 \tcbset 设置的选项之外，这个 \tcbox 还显式地引入了 tcbox raise base 这一参数。结合效果，不难猜出这个选项调整了 \tcbox 生成盒子的基线（baseline）。 29 行和 40 行开头的两个 \tcbox 命令，一方面说明 tcolorbox 宏包提供了相当多的控制选项，因此文本框的样式是高度可定制的；另一方面说明了 \tcbox 内里可以装各种类型的文本——包括表格和图档。 定义和重定义新的 boxtcolorbox 宏包提供了 4 个命令，分别用来定义和重定义 tcolorbox 环境和 \tcbox 命令制作的文本框样式。 1234\newtcolorbox[⟨init options⟩]&#123;⟨name⟩&#125;[⟨number⟩][⟨default⟩]&#123;⟨options⟩&#125;\renewtcolorbox[⟨init options⟩]&#123;⟨name⟩&#125;[⟨number⟩][⟨default⟩]&#123;⟨options⟩&#125;\newtcbox[⟨init options⟩]&#123;\⟨name⟩&#125;[⟨number⟩][⟨default⟩]&#123;⟨options⟩&#125;\renewtcbox[⟨init options⟩]&#123;\⟨name⟩&#125;[⟨number⟩][⟨default⟩]&#123;⟨options⟩&#125; \newtcolorbox 类似 LaTeX 的 \newenvironment 命令，能够基于 tcolorbox 环境创建一个新的 box 环境；\renewcolorbox 则类似 LaTeX 的 \renewenvironment。\newtcbox 类似 LaTeX 的 \newcommand 命令，能够基于 \tcbox 命令创建一个新的 box 命令；\renewtcbox 则类似 LaTeX 的 \renewcommand 命令。 在这里 ⟨init options⟩ 通常是用来控制计数器的，具体可以参见 tcolorbox 宏包说明手册的第 5 章 ⟨name⟩ 是环境或命令的名字 ⟨number⟩ 是环境或命令参数的个数 ⟨default⟩ 是环境或命令可选参数的默认值 ⟨options⟩ 接受类似 \tcbset 的 key-value 参数列表 tcb-env.tex1234567891011121314151617\documentclass&#123;article&#125;\usepackage&#123;tcolorbox&#125;\begin&#123;document&#125;\newtcolorbox&#123;mybox&#125;&#123;colframe = red!75!black&#125;\begin&#123;mybox&#125;This is my own box.\end&#123;mybox&#125;\renewtcolorbox&#123;mybox&#125;&#123;colback = red!25!white, colframe = red!75!black&#125;\begin&#123;mybox&#125;This is my own box.\end&#123;mybox&#125;\begin&#123;tcolorbox&#125;[colback = red!25!white, colframe = red!75!black]This is my own box.\end&#123;tcolorbox&#125;\end&#123;document&#125; 这里，在 5 – 7 行，我们用 \newtcolorbox 定义了名为 mybox 的环境；在 9 – 12 行，我们用 \renewtcolorbox 重新定义了名为 mybox 的环境；14 – 16 行则用原始的 tcolorbox 重复实现了 mybox 环境的效果。 tcb-env-complex.tex1234567891011121314\documentclass&#123;article&#125;\usepackage&#123;tcolorbox&#125;\tcbuselibrary&#123;most&#125;\begin&#123;document&#125;\newtcolorbox&#123;mybox&#125;[2][] &#123;colback = red!5!white, colframe = red!75!black, fonttitle = \bfseries, colbacktitle = red!85!black, enhanced, attach boxed title to top center=&#123;yshift=-2mm&#125;, title=#2,#1&#125;\begin&#123;mybox&#125;[colback=yellow]&#123;Hello there&#125;This is my own box with a mandatory titleand options.\end&#123;mybox&#125;\end&#123;document&#125; 在这里，我们用 \newtcolorbox 命令定义了一个稍微复杂的 mybox 环境。它接收两个参数，其中第一个参数是可选的，默认值为空；第二个参数则是必填的参数。第一个参数用作 tcolorbox 环境参数补充，第二个参数则是 box 的标题。另外值得注意的是，代码中引入了 most 这个程序库。most 会自动调取除 minted 和 documentation 之外所有的 tcolorbox 程序库。 tcb-command.tex123456789101112\documentclass&#123;article&#125;\usepackage&#123;tcolorbox&#125;\begin&#123;document&#125;\newtcbox&#123;\mybox&#125;[1][red] &#123;on line, arc = 0pt, outer arc = 0pt, colback = #1!10!white, colframe = #1!50!black, boxsep = 0pt, left = 1pt, right = 1pt, top = 2pt, bottom = 2pt, boxrule = 0pt, bottomrule = 1pt, toprule = 1pt&#125;The \mybox[green]&#123;quick&#125; brown \mybox&#123;fox&#125;\mybox[blue]&#123;jumps&#125; over the \mybox[green]&#123;lazy&#125; \mybox&#123;dog&#125;.\end&#123;document&#125; 这里我们用 \newtcbox 命令定义了一个新的 \mybox 命令，它可以用来高亮选中的单词。 warp 既有环境有的时候，我们希望将既有的 LaTeX 环境改造成带文本框样式的环境。这时候，可以使用 \tcolorboxenvironment 环境。它的用法是 1\tcolorboxenvironment&#123;⟨name⟩&#125;&#123;⟨options⟩&#125; tex-env-redefine.tex12345678910111213141516\documentclass&#123;article&#125;\usepackage&#123;tcolorbox&#125;\tcbuselibrary&#123;most&#125;\newenvironment&#123;myitemize&#125;&#123;\begin&#123;itemize&#125;&#125;&#123;\end&#123;itemize&#125;&#125;\tcolorboxenvironment&#123;myitemize&#125; &#123;blanker, before skip = 6pt, after skip = 6pt, borderline west = &#123;3mm&#125;&#123;0pt&#125;&#123;red&#125;&#125;\begin&#123;document&#125;Some text. \begin&#123;myitemize&#125; \item Alpha \item Beta \item Gamma \end&#123;myitemize&#125; More text.\end&#123;document&#125; 在这里，我们用 \tcolorboxenvironment 命令，在 myitemize 环境外重新 wrap 了一层。新的 myitemize 环境在左侧有一道宽为 3mm 的红色提示线。不难发现，\tcolorboxenvironment 命令可以在（几乎）不改变原有环境效果的情况下，定义一个新的文本框环境。这种功能十分实用。 常用选项这里列一些常用的选项，用来控制 tcolorbox 环境和 \tcbox 命令的效果。其它未尽选项和效果，可以查看 tcolorbox 的说明手册。 标题的内容控制 title: 设置标题内容，默认为空。 adjusted title: 设置标题内容，默认为空。使用 title 生成的标题，标题栏会根据标题内容的高低自动调整；而使用 adjusted title 生成的标题，标题栏的高度由当前行文本框中，标题占据高度最高的文本框决定。 squeezed title: 设置标题内容，默认为空。使用 squeezed title 生成的标题，如果超过允许的长度，不会换行，而是会在横向进行压缩。 squeezed title*: 设置标题内容，默认为空。合并了 adjusted title 和 squeezed title 的效果。 tcb-titles.tex123456789101112131415161718192021222324252627282930313233343536\documentclass&#123;article&#125;\usepackage&#123;tcolorbox&#125;\tcbuselibrary&#123;most&#125;\begin&#123;document&#125;\tcbset&#123;colback=white,arc=0mm,width=(\linewidth-4pt)/4,equal height group=AT,before=,after=\hfill,fonttitle=\bfseries&#125;\noindent\foreach \n in &#123;xxx,ggg,AAA,\"Agypten&#125;&#123;\begin&#123;tcolorbox&#125;[title=\n,colframe=red!75!black] Some content.\end&#123;tcolorbox&#125;&#125;\noindent\foreach \n in &#123;xxx,ggg,AAA,\"Agypten&#125;&#123;\begin&#123;tcolorbox&#125;[adjusted title=\n,colframe=blue!75!black]Some content.\end&#123;tcolorbox&#125;&#125;\begin&#123;tcbitemize&#125;[raster columns=3,raster equal height, colframe=red!75!black,colback=red!5!white,fonttitle=\bfseries]\tcbitem[squeezed title=&#123;Short title&#125;]First box\tcbitem[squeezed title=&#123;This is a very very long title&#125;]Second box\tcbitem[squeezed title=&#123;This title is clearly to long for this application&#125;] Third box\end&#123;tcbitemize&#125;\begin&#123;tcbitemize&#125;[raster columns=3,raster equal height, colframe=blue!75!black,colback=red!5!white,fonttitle=\bfseries]\tcbitem[squeezed title*=&#123;Short title&#125;]First box\tcbitem[squeezed title*=&#123;This is a very very long title&#125;]Second box\tcbitem[squeezed title*=&#123;This title is clearly to long for this application&#125;] Third box\end&#123;tcbitemize&#125;\end&#123;document&#125; 我们看到，两组红色的文本框，它们的标题分别由 title 和 squeezed title 指定。因此，标题占据的高度会随着标题本身的高度变化。两组蓝色的文本框，它们的标题则分别由 adjusted title 和 squeezed title* 指定。于是，标题占据的高度，会根据所处同一行的文本框中，标题所需高度最高的那个文本框来确定，看起来，就整齐多了。 后面两组文本框，他们的标题分别由 squeezed title 和 squeezed title* 指定。我们发现，当标题长度过长时，标题在水平方向上会被压缩。 标题位置默认情况下，文本框的标题会附在文本框的上方。这一状态称为 attach。我们也可以将标题从默认位置上移开，这个动作称为 detach。detach 之后，我们就可以用 tcolorbox 提供的宏，将标题放在任意自己想要放的位置。其中，\tcbtitletext 储存了标题的文本内容，\tcbtitle 则储存了标题的文本及样式。 attach title: 默认样式，标题将显示在文本框上方的单独单元格里。 detach title: 取消文本框上方单独的单元格，标题需要用户手工指定位置。 attach title to upper = ⟨text⟩: 取消文本框上方单独的单元格，标题放在文本框 upper 部分的头部。 tcb-title-pos.tex12345678910111213141516171819202122\documentclass&#123;article&#125;\usepackage&#123;tcolorbox&#125;\tcbuselibrary&#123;most&#125;\begin&#123;document&#125;\newtcolorbox&#123;mybox&#125;[2][]&#123;colbacktitle=red!10!white, colback=blue!10!white,coltitle=red!70!black, title=&#123;#2&#125;,fonttitle=\bfseries,#1&#125;\begin&#123;mybox&#125;&#123;My title&#125;This is a \textbf&#123;tcolorbox&#125;.\end&#123;mybox&#125;\begin&#123;mybox&#125;[detach title,before upper=&#123;\tcbtitle\quad&#125;]&#123;My title&#125;This is a \textbf&#123;tcolorbox&#125;.\end&#123;mybox&#125;\begin&#123;mybox&#125;[detach title,after upper=&#123;\par\hfill\tcbtitle&#125;]&#123;My title&#125;This is a \textbf&#123;tcolorbox&#125;.\end&#123;mybox&#125;\begin&#123;mybox&#125;[attach title to upper=&#123;\ ---\ &#125;]&#123;My title&#125;This is a \textbf&#123;tcolorbox&#125;.\end&#123;mybox&#125;\begin&#123;mybox&#125;[attach title to upper,after title=&#123;:\ &#125;]&#123;My title&#125;This is a \textbf&#123;tcolorbox&#125;.\end&#123;mybox&#125;\end&#123;document&#125; 在这里，6 – 8 行是正常的情形；9 – 11 行是 detach 的情形，然后用 before upper 将 \tcbtitle 放在 upper 部分之前；12 – 14 行也是 detach 的情形，然后用 after upper 将 \tcbtitle 换行后放在 upper 部分的末尾；16 – 18 行和 19 – 21 行，都是 attach title to upper 的情形，前者直接给 attach title to upper 传入了标题后的分隔符，后者则使用 after title 传入分隔符——这两种方式的效果是一致的。 upper 和 lower 的状态tcolorbox 宏包输出的文本框，在逻辑上可以分为 upper 和 lower 两个部分，在代码中用 \tcblower 命令分割 upper 和 lower 两部分——如果没有 \tcblower，则当前文本框只有 upper 部分，而没有 lower 部分。 upper 和 lower 部分都有可见 (visible) 和不可见 (invisible) 两种状态，lower 部分还有被忽略 (ignored) 这一额外的状态。 upperbox = ⟨visible|invisible⟩: 控制 upper 部分是否可见 lowerbox = ⟨visible|invisible|ignored⟩: 控制 lower 部分是否可见 visible: 同时控制 upper 和 lower 部分可见 invisible: 同时控制 upper 和 lower 部分不可见 下面的代码很容易理解，就不做详细解释了。 tcb-visible.tex1234567891011121314151617181920212223\documentclass&#123;article&#125;\usepackage&#123;tcolorbox&#125;\tcbuselibrary&#123;most&#125;\begin&#123;document&#125;\begin&#123;tcolorbox&#125;[upperbox=invisible,colback=white]This is a \textbf&#123;tcolorbox&#125; (but invisible).\end&#123;tcolorbox&#125;\begin&#123;tcolorbox&#125;[upperbox=invisible,colback=white]This is a \textbf&#123;tcolorbox&#125; (but invisible).\tcblowerThis is the lower part.\end&#123;tcolorbox&#125;\begin&#123;tcolorbox&#125;[lowerbox=invisible,colback=white]This is a \textbf&#123;tcolorbox&#125;.\tcblowerThis is the lower part (but invisible).\end&#123;tcolorbox&#125;\begin&#123;tcolorbox&#125;[lowerbox=ignored,colback=white]This is a \textbf&#123;tcolorbox&#125;.\tcblowerThis is the lower part (but ignored).\end&#123;tcolorbox&#125;\end&#123;document&#125; upper 和 lower 部分的分隔默认情况下，upper 和 lower 部分之间会有一个分隔，不过，我们也可以通过 lower separated 来控制是否显示这一分隔符。 lower separated = ⟨true|false⟩: 控制是否显示 upper 和 lower 两部分中间的分隔。 tcb-lower-separated.tex1234567891011121314151617181920212223242526272829303132333435363738394041\documentclass&#123;article&#125;\usepackage&#123;tcolorbox&#125;\tcbuselibrary&#123;most&#125;\begin&#123;document&#125;\begin&#123;tcbraster&#125;[colback=red!5!white,colframe=red!75!black,fonttitle=\bfseries,fontlower=\itshape] %\begin&#123;tcolorbox&#125;[title=Lower separated] This is the upper part.\tcblowerThis is the lower part.\end&#123;tcolorbox&#125;%\begin&#123;tcolorbox&#125;[title=Lower not separated,lower separated=false]This is the upper part.\tcblowerThis is the lower part.\end&#123;tcolorbox&#125;%\begin&#123;tcolorbox&#125;[sidebyside,title=Lower separated]This is the upper part.\tcblowerThis is the lower part.\end&#123;tcolorbox&#125;%\begin&#123;tcolorbox&#125;[sidebyside,title=Lower not separated,lower separated=false] This is the upper part.\tcblowerThis is the lower part.\end&#123;tcolorbox&#125;%\begin&#123;tcolorbox&#125;[beamer,title=Lower separated]This is the upper part.\tcblowerThis is the lower part.\end&#123;tcolorbox&#125;%\begin&#123;tcolorbox&#125;[beamer,title=Lower not separated,lower separated=false] This is the upper part.\tcblowerThis is the lower part.\end&#123;tcolorbox&#125;%\end&#123;tcbraster&#125;\end&#123;document&#125; 这里用 tcbraster 环境做了一个明显的左右对比。我们可以看到，当开启 lower separated=false 时，各个 skin 下的分隔都不见了。值得注意的是，中间一行中，我们使用了 sidebyside 选项，它能将 upper 和 lower 两个部分从上下的布局样式，改变成左右的布局样式。 颜色和字体控制tcolorbox 提供了很多颜色控制选项，用来控制文本框各个部分的颜色效果。 colframe: 文本框框沿的颜色，默认是 black!75!white。 colback: 文本框内的底色，默认是 black!5!white。 colbacktitle: 文本框中标题框的底色，默认是 black!50!white。 colupper: upper 部分文字的颜色。 collower: lower 部分文字的颜色。 coltext: 同时设置 upper 和 lower 部分文字的颜色。 coltitle: title 部分文字的颜色。 tcb-color.tex1234567891011121314\documentclass&#123;article&#125;\usepackage&#123;tcolorbox&#125;\tcbuselibrary&#123;most&#125;\begin&#123;document&#125;\begin&#123;tcolorbox&#125;[title = &#123;My Box&#125;, colframe = red!50!white, colback = green!50!white, colbacktitle = green!30!white, colupper = yellow!25!red, collower = yellow!75!red, coltitle = black!90!white] This is a \textbf&#123;tcolorbox&#125;. \tcblower This is the lower part.\end&#123;tcolorbox&#125;\end&#123;document&#125; fontupper: 控制 upper 部分的字体 fontlower: 控制 lower 部分的字体 fonttitle: 控制 title 部分的字体 tcb-font.tex1234567891011\documentclass&#123;article&#125;\usepackage&#123;tcolorbox&#125;\tcbuselibrary&#123;most&#125;\begin&#123;document&#125;\begin&#123;tcolorbox&#125;[title = &#123;My Box&#125;, fonttitle = \bfseries, fontupper = \sffamily, fontlower = \itshape] This is a \textbf&#123;tcolorbox&#125;. \tcblower This is the lower part.\end&#123;tcolorbox&#125;\end&#123;document&#125; 宽度控制tcolorbox 宏包提供了三个选项对宽度进行最基本的控制，它们分别是： width: 文本框的总宽度，默认是 \linewidth。 textwidth: 文本框内文本的宽度。 add to width: 在现有设置的基础上，调整文本框的总宽度。 tcb-width.tex123456789101112131415\documentclass&#123;article&#125;\usepackage&#123;tcolorbox&#125;\tcbuselibrary&#123;most&#125;\begin&#123;document&#125;\tcbset&#123;width=5cm, colback=red!5!white, colframe=red!75!black&#125;\begin&#123;tcolorbox&#125;This is a \textbf&#123;tcolorbox&#125;.\end&#123;tcolorbox&#125;\begin&#123;tcolorbox&#125;[text width = 5cm]\rule&#123;5cm&#125;&#123;2ex&#125;\end&#123;tcolorbox&#125;\begin&#123;tcolorbox&#125;[add to width = -1cm]This is a \textbf&#123;tcolorbox&#125;.\end&#123;tcolorbox&#125;\end&#123;document&#125; 这里，我们首先将 width 设置为 5cm，然后将 text width 设置为 5cm，最后将 width 在 5cm 的基础上，用 add to width 减去 1cm。 线条tcolorbox 输出的文本框，其框线都可以设置宽度。 toprule/bottomrule/leftrule/rightrule: 分别设置文本框上、下、左、右的框线宽度。 titlerule: 设置标题框和内容框之间的框线宽度。 boxrule: 一口气设置上述 5 条框线的宽度。 tcb-rule.tex12345678910111213141516171819202122232425\documentclass&#123;article&#125;\usepackage&#123;tcolorbox&#125;\tcbuselibrary&#123;most&#125;\begin&#123;document&#125;\tcbset&#123;boxrule = 0.5mm, colback=red!5!white, colframe=red!75!black, title = &#123;My title&#125;&#125;\begin&#123;tcolorbox&#125; This is a \textbf&#123;tcolorbox&#125;.\end&#123;tcolorbox&#125;\begin&#123;tcolorbox&#125;[toprule = 3mm] This is a \textbf&#123;tcolorbox&#125;.\end&#123;tcolorbox&#125;\begin&#123;tcolorbox&#125;[bottomrule = 3mm] This is a \textbf&#123;tcolorbox&#125;.\end&#123;tcolorbox&#125;\begin&#123;tcolorbox&#125;[leftrule = 3mm] This is a \textbf&#123;tcolorbox&#125;.\end&#123;tcolorbox&#125;\begin&#123;tcolorbox&#125;[rightrule = 3mm] This is a \textbf&#123;tcolorbox&#125;.\end&#123;tcolorbox&#125;\begin&#123;tcolorbox&#125;[titlerule = 3mm] This is a \textbf&#123;tcolorbox&#125;.\end&#123;tcolorbox&#125;\end&#123;document&#125; 这里我们首先用 boxrule = 0.5mm 将文本框所有的框线设置为 0.5mm，而后按照上下左右标题的顺序，依次设置相应的框线为 3mm。 弧度文本框的弧度也是可以定制的。并且，文本框的弧度，在 tcolorbox 中被细分为内弧和外弧，可以分别设置。默认情况下，外弧的弧度与内弧保持一致（auto outer arc）。 arc=⟨length⟩: 设置内弧的半径。 outer arc=⟨length⟩: 设置外弧的半径，可以与内弧不同。 auto outer arc: 让外弧的半径自动随着内弧的半径增减，默认启用。 tcb-arc.tex123456789101112131415161718\documentclass&#123;article&#125;\usepackage&#123;tcolorbox&#125;\tcbuselibrary&#123;most&#125;\begin&#123;document&#125;\tcbset&#123;colback = red!5!white, colframe = red!75!black&#125;\begin&#123;tcolorbox&#125;[arc = 0mm]This is a \textbf&#123;tcolorbox&#125;.\end&#123;tcolorbox&#125;\begin&#123;tcolorbox&#125;[arc = 3mm]This is a \textbf&#123;tcolorbox&#125;.\end&#123;tcolorbox&#125;\begin&#123;tcolorbox&#125;[arc = 4mm, outer arc = 1mm]This is a \textbf&#123;tcolorbox&#125;.\end&#123;tcolorbox&#125;\begin&#123;tcolorbox&#125;[arc = 1mm, outer arc = 4mm]This is a \textbf&#123;tcolorbox&#125;.\end&#123;tcolorbox&#125;\end&#123;document&#125; 这里，第一个文本框，我们设置内弧的半径为 0mm，得到了一个直角；第二个文本框，我们设置内弧半径为 3mm，得到了一个比较圆润的边框；第三个文本框，我们设置内弧半径为 1mm，外弧半径为 4mm——与此同时，第四个文本框将内外弧半径调换，得到了两个有些另类的效果。 除了手工设置内外弧的半径之外，tcolorbox 还预定义了一些样式：circular arc、bean arc、octogon arc。 theorems 程序包tcolorbox 宏包提供了 theorems 程序包来实现定理类的环境。theorems 程序包会自动加载 amsmath 宏包。加载调用的方法如前所述： 1\tcbuselibrary&#123;theorems&#125; 基本用法theorems 程序包提供了两个命令，来生成文本框样式的定理类环境。 \newtcbtheorem[⟨init options⟩]{⟨name⟩}{⟨display name⟩}{⟨options⟩}{⟨prefix⟩} \renewtcbtheorem[⟨init options⟩]{⟨name⟩}{⟨display name⟩}{⟨options⟩}{⟨prefix⟩} 两个命令分别都有 4 个必需参数和 1 个可选参数。 name: 创建的 LaTeX 环境名称 display name: 创建的环境的标题名称 options: 传入 tcolorbox 的参数 prefix: 用于生成环境的 label init options: 用于控制编号 我们来看几个例子。 tcb-theorem-basic.tex123456789101112131415161718192021222324252627\documentclass[UTF8]&#123;ctexart&#125;\usepackage&#123;tcolorbox&#125;\tcbuselibrary&#123;most&#125;\begin&#123;document&#125;\section&#123;标题&#125;\newtcbtheorem[number within=section]&#123;mytheo&#125;&#123;我的定理环境&#125;% &#123;colback=green!5,colframe=green!35!black,fonttitle=\bfseries&#125;&#123;th&#125;\begin&#123;mytheo&#125;&#123;定理标题&#125;&#123;theoexample&#125;这里是定理内容。计数器按照设定，随着~\verb|\section|~的更新而更新。定理编号为：\ref&#123;th:theoexample&#125;，位于第~\pageref&#123;th:theoexample&#125;~页。\end&#123;mytheo&#125;\begin&#123;mytheo&#125;[label=myownlabel]&#123;定理标题&#125;&#123;&#125;通过可选参数，可以继续向~\verb|tcolorbox|~环境传入参数。\verb'label'~参数可以留空；当它不为空时，则可以作为定理环境的引用：\ref&#123;myownlabel&#125;。\end&#123;mytheo&#125;\begin&#123;mytheo&#125;&#123;&#125;&#123;&#125;如果定理标题留空，那么编号之后的分隔符（默认是冒号）会自动消失。\end&#123;mytheo&#125;\begin&#123;mytheo*&#125;&#123;不编号的定理之标题&#125;\verb'\newtcbtheorem'~也会同时定义带星花的版本，用于产生不编号的定理。不编号的定理，当然也就没有交叉引用一说了。\end&#123;mytheo*&#125;\begin&#123;mytheo*&#125;&#123;&#125;无标题的不编号的定理，当然也是可以有的。\end&#123;mytheo*&#125;\end&#123;document&#125; 选项theorems 程序包也提供了诸多选项，用来控制生成的定理环境样式。 separator sign = ⟨sign⟩: 设置定理环境编号和标题之间的分隔符，默认是 :。 separator sign colon: 相当于 separator sign = {:} separator sign dash: 相当于 separator sign = {-} separator sign none: 相当于 separator sign = {} description delimiters={⟨left⟩}{⟨right⟩}: 设置定理标题左右的定界符，默认是空。 description delimiters parenthesis: 相当于 description delimiters = {(}{)} description delimiters none: 相当于 description delimiters = {}{} description color = ⟨color⟩: 设置定理标题的字体颜色。 description font = ⟨text⟩: 设置定理标题的字体。 terminator sign = ⟨sign⟩: 设置定理标题结束后的终止符。 terminator sign colon: 相当于 terminator sign = {:} terminator sign dash: 相当于 terminator sign = {-} terminator sign none: 相当于 terminator sign = {} tcb-theorems-title.tex12345678910111213141516171819202122232425\documentclass[UTF8]&#123;ctexart&#125;\usepackage&#123;tcolorbox&#125;\tcbuselibrary&#123;most&#125;\usepackage&#123;amsmath, amssymb&#125;\begin&#123;document&#125;\section&#123;标题&#125;\newtcbtheorem[number within=section]&#123;mytheo&#125;&#123;定理&#125;% &#123;colback=green!5,colframe=green!35!black,fonttitle=\bfseries&#125;&#123;th&#125;\begin&#123;mytheo&#125;&#123;我的定理&#125;&#123;&#125;这是默认样式。\end&#123;mytheo&#125;\begin&#123;mytheo&#125;[separator sign = &#123;\ $\blacktriangleright$&#125;]&#123;我的定理&#125;&#123;&#125;分隔符修改为 $\blacktriangleright$。\end&#123;mytheo&#125;\begin&#123;mytheo&#125;[description delimiters parenthesis]&#123;我的定理&#125;&#123;&#125;定界符修改为圆括号。\end&#123;mytheo&#125;\begin&#123;mytheo&#125;[description color=red!25!yellow, description font= &#123;\mdseries\itshape&#125;]&#123;我的定理&#125;&#123;&#125;标题的字体及颜色修改。\end&#123;mytheo&#125;\begin&#123;mytheo&#125;[terminator sign=&#123;.&#125;]&#123;我的定理&#125;&#123;&#125;标题后的终止符。\end&#123;mytheo&#125;\end&#123;document&#125; 实际动手制作一个定理环境看看tcb-theorem-final.tex123456789101112131415161718192021222324\documentclass[UTF8]&#123;ctexart&#125;\usepackage&#123;enumitem&#125;\usepackage&#123;tcolorbox&#125;\tcbuselibrary&#123;skins, breakable, theorems&#125;\newtcbtheorem&#123;question&#125;&#123;题~(理&#125;% &#123;enhanced, breakable, colback = white, colframe = cyan, colbacktitle = cyan, attach boxed title to top left = &#123;yshift = -2mm, xshift = 5mm&#125;, boxed title style = &#123;sharp corners&#125;, fonttitle = \sffamily\bfseries, separator sign = &#123;).~&#125;&#125;&#123;qst&#125;\begin&#123;document&#125;\section&#123;测试&#125;\begin&#123;question&#125;&#123;函数&#125;&#123;example&#125;已知函数 $ f(x) = (x - 2)\mathrm&#123;e&#125;^&#123;2&#125; + a (x - 1)^&#123;2&#125; $ 有两个零点.\begin&#123;enumerate&#125;[label=(\arabic*)] \item 求 $ a $ 的取值范围; \item 设 $ x_&#123;1&#125; $, $ x_&#123;2&#125; $ 是 $ f(x) $ 的两个零点，证明 $ x_&#123;1&#125; + x_&#123;2&#125; &lt; 2 $.\end&#123;enumerate&#125;\end&#123;question&#125;\end&#123;document&#125; 这里我们调用了 skins/breakable/theorems 三个程序包，其中 theorems 我们已经见过了。skins 程序包提供了各种「皮肤」，可以在基础 tcolorbox 的基础上扩展更多样式：attach boxed title to top left 这一效果就来自 skins 程序包中的 enhanced 主题。breakable 的效果则使得文本框能够跨页。 其他的参数很好理解，就不用展开讲了。 希望你看过这篇文章之后，能够用 tcolorbox 宏包，制作出自己喜欢的文本框。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Theorem</tag>
        <tag>tcolorbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LambdaMART 不太简短之介绍]]></title>
    <url>%2F2016%2F07%2F10%2Fa-not-so-simple-introduction-to-lambdamart%2F</url>
    <content type="text"><![CDATA[传统的搜索引擎排序（Ranking）问题，通常会涉及到很多的排序策略。这些策略根据不同的特征，在不同的适用范围中起作用。因此，一个传统的排序算法，至少涉及到两方面的内容：策略的制定，以及不同策略的组合。策略的组合需要考虑策略分析适用的特征，以及相应策略的适用情况。根据这些内容，通过人工或者半机器半人工的方式组合起来，才能组成一个可堪使用的排序算法。 和自然语言处理中遇到的情况一样，随着数据量的增加，使用人工的方式做策略的组合，会变得越来越困难。因此，将机器学习引入搜索引擎排序问题，也就是相当自然的事情了。在排序问题中使用的机器学习算法，被称为 Learning to Rank (LTR) 算法，或者 Machine-Learning Rank (MLR) 算法。 LTR 算法通常有三种手段，分别是：Pointwise、Pairwise 和 Listwise。Pointwise 和 Pairwise 类型的 LTR 算法，将排序问题转化为回归、分类或者有序分类问题。Listwise 类型的 LTR 算法则另辟蹊径，将用户查询（Query）所得的结果作为整体，作为训练用的实例（Instance）。 LambdaMART 是一种 Listwise 类型的 LTR 算法，它基于 LambdaRank 算法和 MART (Multiple Additive Regression Tree) 算法，将搜索引擎结果排序问题转化为回归决策树问题。MART 实际就是梯度提升决策树（GBDT, Gradient Boosting Decision Tree）算法。GBDT 的核心思想是在不断的迭代中，新一轮迭代产生的回归决策树模型拟合损失函数的梯度，最终将所有的回归决策树叠加得到最终的模型。LambdaMART 使用一个特殊的 Lambda 值来代替上述梯度，也就是将 LambdaRank 算法与 MART 算法加和起来。考虑到 LambdaRank 是基于 RankNet 算法的，所以在搞清楚 LambdaMART 算法之前，我们首先需要了解 MART、RankNet 和 LambdaRank 是怎么回事。 MART 算法MART，即多重增量回归树（Multiple Additive Regression Tree）有许多名字： MART - 多重增量回归树（Multiple Additive Regression Tree） GBDT - 梯度渐进决策树（Gradient Boosting Decision Tree） GBRT - 梯度渐进回归树（Gradient Boosting Regression Tree） TreeNet - 决策树网络（Tree Net） 这些名字的含义都一样，都是一个意思。 从这些名字，我们可以看出 MART 的一些特征： 使用决策树来预测结果； 用到的决策树有很多个； 每个树都比之前的树改进一点点，逐渐回归、拟合到真实结果。 实际上，这三点就是 Boosting 思想的精髓了。Boosting 思想源自 Kearns 和 Valiant 的提问，并最终从 Robert Schapire 在 1990 年的论文 The Strength of Weak Learnablity 中对上述问题明确的回答发展起来。 Boosting（渐进）思想Boosting 思想，尝试通过不断迭代弱模型（Weak Learner），通过叠加弱模型的方式，渐进地逼近真实情况，起到足以预测真实值的强模型的作用。显而易见，Boosting 思想至少需要解决两个问题： 如何保证每一次迭代都对解决问题有所帮助，或者说如何确定迭代步骤中拟合的方向？ 如何将每一次迭代产生的弱模型有效地叠加起来？ 下面，我们通过 AdaBoost（Adaptive Boosting，自适应渐进法）来回答这两个问题。 AdaBoostAdaBoost 是 Yoav Freund 和 Robert Schapire 提出的机器学习算法。两人因为该算法获得了 2003 年的哥德尔奖。 AdaBoost 是一种用于分类的算法，它的运行过程大致可以理解如下： 制作一个弱分类器（实际是一个决策树），去拟合实际情况，我们将它记录为 WL1。 运行 WL1，记录分类错误的那些样本。接下来，赋予这些被错误分类的样本比较高的权重，进行第二次拟合，得到新的弱分类器 WL2。 依次运行 WL1 - WL2，记录分类错误的那些样本。接下来，赋予这些被错误分类的样本比较高的权重，进行第三次拟合，得到新的弱分类器 WL3。 依次运行 WL1 - WL2 - WL3，如此迭代…… 上图来自 Pattern Recognition and Machine Learning 一书的 660 页，讲述的是运用 Boosting 思想进行分类的过程。 蓝色和红色的圆圈，代表两类样本，圆圈的大小代表当前该点的权重；绿色的线条代表训练既得分类器模型；虚线表示当前训练新增的分类器模型。 可以看到，在不断的迭代过程中，每一次迭代，分类器都会关注之前区分错误的那些样本点，进行有针对性的处理。因此，在进行到 150 次迭代之后（$m = 150$），最终叠加起来的模型已经非常细致，足够将红蓝两种类别细致地区分开来了。 整个过程，用数学符号表达如下（PRML Page 658）： 在这里： $w^{(k)}_n$ 表示一个 $n$ 元向量，向量中的每一个元素都对应训练集中的一个样本点；向量中元素的值，就是所对应样本点在第 $k$ 次迭代中的权重。 $y_{k}(\mathbf{x})$ 是根据上述权重计算出来的第 $k$ 次迭代的模型。 $\alpha_{k}$ 是第 $k$ 次迭代的模型的权重。 $Y_M(\mathbf{x})$ 是根据上述 $M$ 个弱分类器加权求和得到的最终分类器。 最开始的时候，每个样本点的权重都一致。随着算法不断迭代，被错误分类的样本，权重不断加强，与此同时被正确分类的样本，权重不断减弱。可以想象，越往后，算法越关注那些容易被分错的样本点，从而最终解决整个问题。 现在，我们至少可以从 AdaBoost 的角度回答上一小节的两个问题了： AdaBoost 通过调整样本的权值，来确定下一轮迭代中弱模型的拟合方向：提升分类错误的样本的权值，降低分类正确的样本的权值。 AdaBoost 用一个「加法模型」，将每一轮迭代得到的弱模型组合叠加起来，得到一个有效的强模型。 MART 的数学原理MART 是一种 Boosting 思想下的算法框架，它的目标是寻找强模型 $f(x)$ 满足： $$\hat f(x) = \text{arg min}_{f(x)} E\Bigl[L\bigl(y, f(x)\bigr) \big| x\Bigr]$$ 和 AdaBoost 一样，训练之后的 MART 模型也是一个加法模型，形式如下：$$ \label{eq:MART-result} \hat f(x) = \hat f_M(x) = \sum_{m = 1}^M f_m(x) $$这里： $\hat f = \hat f_M: \mathbb{R}^d \mapsto \mathbb{R}$ 是模型的目标函数； $x \in \mathbb{R}^d$ 是样本点，它包含 $d$ 个特征的值； $\hat f(x) \in \mathbb{R}$ 是预测值； $M$ 是训练过程中迭代的次数，也就是模型中回归决策树的数量； $f_m: \mathbb{R}^d \mapsto \mathbb{R}$ 是模型训练过程中得到的弱模型（也就是回归决策树）。 那么，关于 MART 的 Boosting，我们还剩下一个回答，即：如何保证每一次迭代都对解决问题有所帮助，或者说如何确定迭代步骤中拟合的方向。接下来的分析，我们就来解决这个问题。 假设我们已经迭代了 $m$ 次，得到了 $m$ 颗决策树。我们将这 $m$ 颗决策树的和记作 $\hat f_m(x) = \sum_{i = 1}^m f_i(x)$，于是，第 $m + 1$ 轮拟合的目标 \begin{equation} \delta \hat f_{m + 1} = \hat f_{m + 1} - \hat f_m = f_{m + 1} \end{equation} 现在我们要求这个 $\delta \hat f_{m + 1}$。我们引入损失函数 $$ L = L\bigl((x, y), f\bigr) = L \bigl(y, f(x) \big| x\bigr) $$ 来描述预测函数 $f$ 的预测结果 $y^{*} = f(x)$ 与真实值 $y$ 的差距。那么，我们的目的是要在进行第 $m + 1$ 轮拟合之后，预测值与真实情况的差距会减小，即 $$ \delta L_{m + 1} = L\bigl((x, y), \hat f_{m + 1}\bigr) - L\bigl((x, y), \hat f_{m}\bigr) \lt 0 $$ 考虑到 $$ \delta L_{m + 1} \approx \frac{\partial L\bigl((x, y), \hat f_m\bigr)}{\partial \hat f_m}\cdot \delta \hat f_{m + 1}, $$ 若取 \begin{equation} \label{eq:gradient} \delta \hat f_{m + 1} = -g_{im} = -\frac{\partial L\bigl((x, y), \hat f_m\bigr)}{\partial \hat f_m}, \end{equation} 则必有 $\delta L_{m + 1} \lt 0$。因此，这个 $\delta \hat f_{m + 1}$ 就是 $f_{m + 1}$ 拟合的目标；也就是说，$f_{m + 1}$ 要拟合这样一个训练集： $$ \Biggl\{i = 1, 2, \ldots, N \Bigg\vert \biggl(x_i, -\frac{\partial L\bigl((x_i, y_i), \hat f_m(x_i)\bigr)}{\partial \hat f_m(x_i)}\biggr)\Biggr\} $$ 式 \ref{eq:gradient} 描述的正是损失函数（泛函） $L$ 的梯度。亦即，循环迭代中，模型每次拟合的目标都是损失函数的梯度。这就是算法被称为「梯度渐进」的原因。 决策树实际上将样本空间划分成了若干区域，并对每个划分区域赋上预测值。假设 $f_m$ 划分而成的区域是 $R_m$，预测值则是 $\gamma_m$。那么，我们有$$ f_m(x) = h_m(x; R_m, \gamma_m), $$也就是$$ \hat{f}(x) = \sum_{m=1}^{M}f_m(x) = \sum_{m=1}^{M}h_m(x; R_m, \gamma_m). $$ 那么，MART 的每一步也就是要解优化问题：\begin{equation} \label{eq:argmin} h_m(x; R_m, \gamma_m) = \text{arg min}_{R, \gamma}\sum_{i = 1}^{N} \bigl(-g_{im} - F(x_i;R,\gamma)\bigr)^2,\tag{$ \star $} \end{equation}其中 $F$ 是一棵回归决策树。 现在我们引入一个非常小的正数 $ \eta $，称为「学习度」或者「收缩系数」。如果，我们在每轮迭代中的预测结果前，乘上这么一个学习度；亦即我们将第 $m + 1$ 轮拟合的目标，从 $-g_{im}$ 调整为 $-\eta\cdot g_{im}$。这样一来，我们每次拟合的目标，就变成了损失函数梯度的一部分。由于 $\delta L \lt 0$ 仍然成立，经过多次迭代之后，模型依然可以得到一个很好的结果。但是，与引入学习度之前的情况相比较，每次拟合像是「朝着正确的方向只迈出了一小步」。这种 Shrinkage（缩减），主要是为了防止「过拟合」现象。 小结MART 是一种 Boosting 思想下的算法框架。它通过加法模型，将每次迭代得到的子模型叠加起来；而每次迭代拟合的对象都是学习率与损失函数梯度的乘积。这两点保证了 MART 是一个正确而有效的算法。 MART 中最重要的思想，就是每次拟合的对象是损失函数的梯度。值得注意的是，在这里，MART 并不对损失函数的形式做具体规定。实际上，损失函数几乎只需要满足可导这一条件就可以了。这一点非常重要，意味着我们可以把任何合理的可导函数安插在 MART 模型中。LambdaMART 就是用一个 $\lambda$ 值代替了损失函数的梯度，将 $\lambda$ 和 MART 结合起来罢了。 LambdaLambda 的设计，最早是由 LambdaRank 从 RankNet 继承而来。因此，我们先要从 RankNet 讲起。 RankNet 的创新Ranking 常见的评价指标都无法求梯度，因此没法直接对评价指标做梯度下降。 RankNet 的创新之处在于，它将不适宜用梯度下降求解的 Ranking 问题，转化为对概率的交叉熵损失函数的优化问题，从而适用梯度下降方法。 RankNet 的终极目标是得到一个带参的算分函数： $$s = f(x; w).$$ 于是，根据这个算分函数，我们可以计算文档 $x_i$ 和 $x_j$ 的得分 $s_i$ 和 $s_j$ $$s_i = f(x_i; w)\quad s_j = f(x_j; w),$$ 然后根据得分计算二者的偏序概率 $$P_{ij} = P(x_i \rhd x_j) = \frac{\exp\bigl(\sigma\cdot(s_i - s_j)\bigr)}{1 + \exp\bigl(\sigma\cdot(s_i - s_j)\bigr)} = \frac{1}{1 + \exp\bigl(-\sigma\cdot(s_i - s_j)\bigr)},$$ 再定义交叉熵为损失函数 $$L_{ij} = -\bar{P}_{ij}\log P_{ij} - (1 - \bar{P}_{ij})\log (1 - P_{ij}) = \frac12 (1 - S_{ij})\sigma\cdot(s_i - s_j) + \log\Bigl\{1 + \exp\bigl(-\sigma\cdot(s_i - s_j)\bigr)\Bigr\},$$ 进行梯度下降$$w_k \to w_k - \eta\frac{\partial L}{\partial w_k}.$$ 再探梯度 这里每条横线代表一条文档，其中蓝色的表示相关的文档，灰色的则表示不相关的文档。在某次迭代中，RankNet 将文档的顺序从左边调整到了右边。于是我们可以看到： RankNet 的梯度下降表现在结果的整体变化中是逆序对的下降：13 → 11 RankNet 的梯度下降表现在单条结果的变化中，是结果在列表中的移动趋势（图中黑色箭头） 我们通常更关注前几条文档的排序情况，因此我们会期待真正的移动趋势如图中红色箭头所示 那么问题就来了：我们能不能直接定义梯度呢？ LambdaRank现在的情况是这样： RankNet 告诉我们如何绕开 NDCG 等无法求导的评价指标得到一个可用的梯度； 上一节我们明确了我们需要怎样的梯度； 梯度（红色箭头）反应的是某条结果排序变化的趋势和强度； 结果排序最终由模型得分 $s$ 确定。 于是，我要扼住 $\frac{\partial L_{ij}}{\partial s_i}$ 的咽喉! 先看看 RankNet 的梯度$$ \frac{\partial L}{\partial w_k} = \sum_{(i, j) \in P}\frac{\partial L_{ij}}{\partial w_k} = \sum_{(i, j) \in P} \frac{\partial L_{ij}}{\partial s_i}\frac{\partial s_i}{\partial w_k} + \frac{\partial L_{ij}}{\partial s_j}\frac{\partial s_j}{\partial w_k}, $$注意有下面对称性$$ \begin{aligned} \frac{\partial L_{ij}}{\partial s_i} &amp; {} = \frac{\partial \biggl\{\frac12 (1 - S_{ij})\sigma\cdot(s_i - s_j) + \log\Bigl\{1 + \exp\bigl(-\sigma\cdot(s_i - s_j)\bigr)\Bigr\}\biggr\}}{\partial s_i}\\ &amp; {}= \frac12 (1 - S_{ij})\sigma - \frac{\sigma}{1 + \exp\bigl(\sigma\cdot(s_i - s_j)\bigr)} \\ &amp; {}= \sigma\Biggl[\frac12(1 - S_{ij}) - \frac{1}{1 + \exp\bigl(\sigma\cdot(s_i - s_j)\bigr)}\Biggr] \\ &amp; {}= -\frac{\partial L_{ij}}{\partial s_j}. \end{aligned} $$ 于是我们定义$$ \lambda_{ij}\mathrel{\stackrel{\mbox{def}}{=}} \frac{\partial L_{ij}}{\partial s_i} = -\frac{\partial L_{ij}}{\partial s_j}, $$考虑有序对 $(i, j)$，有 $S_{ij} = 1$，于是有简化$$ \lambda_{ij}\mathrel{\stackrel{\mbox{def}}{=}} - \frac{\sigma}{1 + \exp\bigl(\sigma\cdot(s_i - s_j)\bigr)}, $$在此基础上，考虑评价指标 $Z$（比如 NDCG）的变化$$ \lambda_{ij}\mathrel{\stackrel{\mbox{def}}{=}} - \frac{\sigma}{1 + \exp\bigl(\sigma\cdot(s_i - s_j)\bigr)}\cdot\lvert\Delta Z_{ij}\rvert. $$ 对于具体的文档 $x_i$，有$$ \lambda_{i} = \sum_{(i, j) \in P}\lambda_{ij} - \sum_{(j, i) \in P}\lambda_{ij}. $$ 也就是说：每条文档移动的方向和趋势取决于其他所有与之 label 不同的文档。 现在回过头来，看看我们做了什么？ 分析了梯度的物理意义； 绕开损失函数，直接定义梯度。 当然，我们可以反推一下 LambdaRank 的损失函数： $$L_{ij} = \log\Bigl\{1 + \exp\bigl(-\sigma\cdot(s_i - s_j)\bigr)\Bigr\}\cdot\lvert\Delta Z_{ij}\rvert.$$ LambdaMART现在的情况变成了这样： MART 是一个框架，缺一个「梯度」； LambdaRank 定义了一个「梯度」。 让他们在一起吧！于是，就有了 LambdaMART。 LambdaMART 的优点LambdaMART 有很多优点，取一些列举如下： 直接求解排序问题，而不是用分类或者回归的方法； 可以将 NDCG 之类的不可求导的 IR 指标转换为可导的损失函数，具有明确的物理意义； 可以在已有模型的基础上进行 Continue Training； 每次迭代选取 gain 最大的特征进行梯度下降，因此可以学到不同特征的组合情况，并体现出特征的重要程度（特征选择）； 对正例和负例的数量比例不敏感。 幻灯片下载]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>LambdaMART</tag>
        <tag>NDCG</tag>
        <tag>Search Engine</tag>
        <tag>Machine Learning</tag>
        <tag>Learning to Rank</tag>
        <tag>MART</tag>
        <tag>GBDT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复杂度速查表]]></title>
    <url>%2F2016%2F06%2F20%2Fbig-O-cheat-sheet%2F</url>
    <content type="text"><![CDATA[本篇基本上是原作的翻译。转载请保留本段文字。 复杂度通常会使用大-O 记号来表示，比如快速排序的平均时间复杂度是 $O(n \log(n))$。虽然我是「理解派」，但是虽然每个算法/数据结构都理解了，不时仍有可能忘记具体某个算法/数据结构的复杂度（特别是在最好、最坏和平均情形下的复杂度）。因此制作一个速查表是蛮有必要的。 动手前先看看是否已经有轮子是一个好习惯，果不其然，我找到了原作。 图例最佳好一般不好糟糕 抽象数据结构的操作复杂度数据结构时间复杂度空间复杂度&nbsp;平均最差最差&nbsp;访问搜索插入删除访问搜索插入删除&nbsp;顺序表$O(1)$$O(n)$$O(n)$$O(n)$$O(1)$$O(n)$$O(n)$$O(n)$$O(n)$栈$O(n)$$O(n)$$O(1)$$O(1)$$O(n)$$O(n)$$O(1)$$O(1)$$O(n)$单链表$O(n)$$O(n)$$O(1)$$O(1)$$O(n)$$O(n)$$O(1)$$O(1)$$O(n)$双链表$O(n)$$O(n)$$O(1)$$O(1)$$O(n)$$O(n)$$O(1)$$O(1)$$O(n)$跳表$O(\log(n))$$O(\log(n))$$O(\log(n))$$O(\log(n))$$O(n)$$O(n)$$O(n)$$O(n)$$O(n \log(n))$散列表-$O(1)$$O(1)$$O(1)$-$O(n)$$O(n)$$O(n)$$O(n)$二叉搜索树$O(\log(n))$$O(\log(n))$$O(\log(n))$$O(\log(n))$$O(n)$$O(n)$$O(n)$$O(n)$$O(n)$笛卡尔树-$O(\log(n))$$O(\log(n))$$O(\log(n))$-$O(n)$$O(n)$$O(n)$$O(n)$B-树$O(\log(n))$$O(\log(n))$$O(\log(n))$$O(\log(n))$$O(\log(n))$$O(\log(n))$$O(\log(n))$$O(\log(n))$$O(n)$红黑树$O(\log(n))$$O(\log(n))$$O(\log(n))$$O(\log(n))$$O(\log(n))$$O(\log(n))$$O(\log(n))$$O(\log(n))$$O(n)$伸展树-$O(\log(n))$$O(\log(n))$$O(\log(n))$-$O(\log(n))$$O(\log(n))$$O(\log(n))$$O(n)$AVL 树$O(\log(n))$$O(\log(n))$$O(\log(n))$$O(\log(n))$$O(\log(n))$$O(\log(n))$$O(\log(n))$$O(\log(n))$$O(n)$ 数组排序算法时间复杂度空间复杂度&nbsp;最佳平均最差最差快速排序$O(n \log(n))$$O(n \log(n))$$O(n^2)$$O(\log(n))$归并排序$O(n \log(n))$$O(n \log(n))$$O(n \log(n))$$O(n)$Timsort$O(n)$$O(n \log(n))$$O(n \log(n))$$O(n)$堆排序$O(n \log(n))$$O(n \log(n))$$O(n \log(n))$$O(1)$冒泡排序$O(n)$$O(n^2)$$O(n^2)$$O(1)$插入排序$O(n)$$O(n^2)$$O(n^2)$$O(1)$选择排序$O(n^2)$$O(n^2)$$O(n^2)$$O(1)$希尔排序$O(n)$$O((n\log(n))^2)$$O((n\log(n))^2)$$O(1)$桶排序$O(n+k)$$O(n+k)$$O(n^2)$$O(n)$基数排序$O(nk)$$O(nk)$$O(nk)$$O(n+k)$ 图操作节点 / 边界管理存储增加顶点增加边界移除顶点移除边界查询邻接表$O(|V|+|E|)$$O(1)$$O(1)$$O(|V| + |E|)$$O(|E|)$$O(|V|)$邻接矩阵$O(|V|^2)$$O(|V|^2)$$O(1)$$O(|V|^2)$$O(1)$$O(1)$ 堆操作类型时间复杂度&nbsp;建堆查找最大值分离最大值提升键插入删除合并（排好序的）链表-$O(1)$$O(1)$$O(n)$$O(n)$$O(1)$$O(m+n)$（未排序的）链表-$O(n)$$O(n)$$O(1)$$O(1)$$O(1)$$O(1)$二叉堆$O(n)$$O(1)$$O(\log(n))$$O(\log(n))$$O(\log(n))$$O(\log(n))$$O(m+n)$二项堆-$O(1)$$O(\log(n))$$O(\log(n))$$O(1)$$O(\log(n))$$O(\log(n))$斐波那契堆-$O(1)$$O(\log(n))$$O(1)$$O(1)$$O(\log(n))$$O(1)$ 大-O 复杂度曲线]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Cheatsheet</tag>
        <tag>Complexities</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最佳搭档：利用 find 和 crontab 命令清理过期文件]]></title>
    <url>%2F2016%2F06%2F19%2Fbest-match-using-find-and-crontab-to-removed-outdated-files%2F</url>
    <content type="text"><![CDATA[不论是生活中还是工作中，总有一些文件会不断产生。这些文件可能是日志文件，也可以是系统核心转储文件。如若不加清理，查询特定文件就会非常困难，抑或是过多的核心转储文件占满了磁盘空间，影响正常程序执行。 为此，我们需要有一个简单高效的方式，定期清理过期文件。 crontab: 在时间的八音盒上翩翩起舞crontab 命令是 Linux 中用来设定重复执行命令或脚本的工具。它能够在指定的时间段内，按照需求以某一时间间隔执行命令或脚本。 crontab 的基本用法12crontab [-u &lt;user&gt;] [-e|-l|-r]crontab &lt;filename&gt; crontab &lt;filename&gt; 可以读入一个以 crontab 语法书写的文件，并依照文件内的指示执行定时任务。与此同时，crontab -l 能够在标准输出上列出当前用户所有的定时任务情况。因此，我们可以用 crontab -l &gt; &lt;filename&gt; 来保存当前 crontab 的状况，在有需要的时候（比如误删除）用 crontab &lt;filename&gt; 读入恢复。 crontab -e 则会启动系统默认的编辑器。这个编辑器由系统环境变量 EDITOR 指定；例如 export EDITOR=vi，则 crontab -e 会启动 vi 来编辑当前用户的 crontab 定时任务文件。crontab -r 则会删除用户的所有 crontab 定时任务。 用来指定用户的 -u &lt;user&gt; 选项则会改变 -e/-l/-r 等选项的行为。如果不通过 -u 指定用户，则默认的操作都是针对当前用户的；反之，则针对指定的用户。例如 crontab -u Liam -r 则会删除用户 Liam 的 crontab 定时任务——当然，你需要有足够的权限这么做。 crontab 文件的格式不管是用 crontab &lt;filename&gt; 从文件读入定时任务，还是用 crontab -e 编辑定时任务，我们都会接触到 crontab 格式的命令。crontab 的命令格式如下： 从上图我们可以看出： 一条 crontab 命令分成六列，写在一行内； 前 5 列用于定时，指明什么时候开始执行； 第 6 列用于指定需要定时执行的命令或脚本； 此外，和 Shell 脚本一样，在 crontab 文件中，我们也可以用 # 来表示注释。 花式定时在 crontab 命令中用于定时的前 5 列中，支持以下符号，用于「花式定时」： 星花（*）：代表所有可能的值； 逗号（,）：用逗号隔开同一字段的不同范围； 连字符（-）：用连字符连接两个整数，表示整数范围； 斜线（/)：实际上是除法斜线，用来指定时间间隔频率。 一些例子有了这些知识，我们就可以看一些实例了。 12345678910# 每分钟执行一次* * * * * command# 每 5 分钟执行一次*/5 * * * * command# 每个小时的 15 分和 45 分执行一次15,45 * * * * command# 晚上 20:00 -- 20:15 每分钟执行一次0-15 20 * * * command# 每周一上午 10 点执行一次0 10 * * 1 command find —— 找些乐子man find 给出的 find 命令的一般形式是： 1find [-H] [-L] [-P] [-D debugopts] [-Olevel] path ... [expression] 其中 [-H] [-L] [-P] [-D debugopts] [-Olevel] 很少会用到。因此，find 命令的一般形式可以简化为 find path ... [expression]；亦即，在一些路径（默认递归地包含子路径）中找到合适的文件，然后根据 expression 执行相应动作。 path ...: find 命令查找的路径 expression: 具体形式是 -parameters [-exec -ok] -parameters 有很多，待下一节具体介绍常用的参数 -exec command {} \; 执行一条 Shell 命令 -ok command {} \; 同 -exec 的作用，不过在执行每条命令前，都会提示用户确认 常用的参数 -name: 按照文件名查找文件，接受通配符 find . -name &quot;*.cpp&quot;: 在当前目录 (.) 及子目录下递归地查找所有后缀为 .cpp 的文件，并打印在标准输出中 -perm: 按照文件权限查找文件 find . -perm 755: 在当前目录 (.) 及子目录下递归地查找所有权限为 755 的文件（目录），并打印在标准输出中 find . -perm 644 -name &quot;*.cpp&quot;: 在当前目录及子目录下 (.) 递归地查找所有权限为 644 的 .cpp 文件，并打印在标准输出中 -group: 按照文件的所属组查找 -user: 按照文件的所有者查找 find . -user search: 在当前目录 (.) 及子目录下递归地查找所有 search 账号所属的文件，并打印在标准输出中 -atime, -mtime, -amin, -mmin: a 开头的表示「按照上次访问时间查找」，m 开头的表示「按照上次修改时间查找」；-n 表示 n 时间内，+n 表示 n 时间以前 find . -atime +7: 在当前目录 (.) 及子目录下递归地查找所有上次访问在 7 天以前的文件，并打印在标准输出中 find . -mmin -10: 在当前目录 (.) 及子目录下递归地查找所有上次修改在 10 分钟以内的文件，并打印在标准输出中 -newer file1 ! file2: 查找比 file1 新但是比 file2 旧的文件 -type [b|d|c|p|l|f]: 按照文件类型查找 b: 块设备文件 d: 目录 c: 字符设备文件 p: 管道文件 l: 符号链接文件 f: 普通文件 -follow: 如果 find 命令遇到符号链接文件，就跟踪至链接所指向的文件 -delete: 删除查找到的文件或目录 定期清理至此，定期清理无用的文件就变得很简单了。我们只需要在 crontab 里结合 find 命令的 -delete 选项即可。 10 8 * * * find /home/s/coredump -user search -type f -mtime +7 -delete 这里，我们在每天早上 8 点整执行 find 命令；该命令会在 /home/s/coredump 目录下寻找 search 用户创建的普通 7 天前的文件，然后删除掉。]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Find</tag>
        <tag>Crontab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么说尺规作图三等分任意角是不可解的？]]></title>
    <url>%2F2016%2F06%2F11%2Fimpossibility-of-trisection-of-arbitrary%2F</url>
    <content type="text"><![CDATA[此篇缘起匡世珉的知乎回答。感谢匡世珉和他的铅笔们，也感谢我自己小时候为尺规作图付出的时间。 尺规作图（ruler-and-compass construction）是古希腊数学提出的一种平面几何作图方法。除了提出作图方法，古希腊人还留下了三个尺规作图困难问题。他们是： 三等分任意给定的角； 对任意给定的立方体，作一个新的立方体，使得新立方体的体积是前者的 2 倍； 对任意给定的圆，作一个正方形，使得圆和正方形的面积相等。 如今，这三个困扰数学家上千年的问题，均已经被证明不可解——当然，一些青 (min) 年 (ke) 还在被困扰着。 此篇将介绍上述三等分角的问题。 尺规作图如前所述，尺规作图是一种平面几何作图方法，它要求用一把没有刻度的直尺和一把圆规，在有限次的操作中完成作图任务。允许的操作如下： 通过两个已知点可作一直线； 已知圆心和半径可作一个圆； 若两已知直线相交，可求其交点； 若已知直线和一已知圆相交，可求其交点； 若两已知圆相交，可求其交点。 尺规作图中的代数问题咦？尺规作图是平面几何问题，为什么要讨论代数呢？稍安勿躁，稍后我们就会发现代数理论在几何领域是如何闪闪发光的了。 整数集在一条直线上，我们预先确定间隔一个单位长度的两个点。那么对于任意整数，我们可以用圆规在有限次重复中，得到长度是该整数的线段。也就是说，我们可以在数轴上标注出所有整数点。 注意，「预先确定间隔一个单位长度的两个点」这一确定「单位长度」的做法并不违反尺规作图的规则。这是因为，任意长度都可以充当这个单位长度；且它只是为了表述方便，而不影响任何尺规作图的规律。 具体操作如下图所示： 从原点开始，用圆规取好单位长度的半径，然后依次作圆弧和直线的交点，即可得到任意整数点。 从整数集到有理数域 $\mathbb{Q}$所谓数域，是指一类特殊的集合——该集合内任意两个操作数做加减乘除四则运算的结果都仍然落在集合内。显然，整数集合不是一个数域，因为 1 与 2 作除法得到的 $\frac{1}{2}$ 不是整数。全部有理数组成的集合 $\mathbb{Q}$ 则是一个数域（有理数域），因为在有理数中任意做加减乘除，结果仍然是有理数。 上一节中，我们已经知道，通过尺规作图，可以得到任意整数。那么，如果我们可以利用尺规作图进行加减乘除四则运算的话，就能通过尺规作图得到整个有理数域。 加减自不必说，我们来看看尺规作图如何做乘法——除法是乘法的逆运算，可以类似得到。 具体操作如下图所示： 操作流程如下： 过 $1$，作数轴的垂线； 以原点为圆心，$a$ 为半径画弧，与上述垂线相交 过原点与上述交点作直线 过 $b + 1$，作数轴的垂线，与上述直线相交 以原点为圆心，以上述交点到圆心的距离为半径作弧，与数轴相交 根据三角形相似的性质，可知上述交点到原点的距离是 $ a + a \times b$ 至此再做一个减法即可。 因此，我们知道，通过尺规作图，我们可以构建出整个有理数域。 开平方除了四则运算，尺规作图还可以开平方。 具体操作如下图所示： 操作流程如下： 找到 $a + 1$——因为可作加法，所以这是可行的； 找到原点和 $a + 1$ 的中点——因为可作除法，所以这是可行的； 以上述中点为圆心，原点到中点的距离为半径，做半圆； 过 $1$ 作数轴的垂线，与半圆相交； 上述垂线段的长度即为 $ \sqrt{a} $。 有理数域的扩张尺规作图可以得到整个有理数域，又能开方。因此我们可以在尺规作图的基础上讨论数域的扩张。 我们以数字 $ 2 $ 为例，显然对它做开方会离开有理数域 $\mathbb{Q}$，这是因为 $\sqrt{2}$ 不是有理数（$\sqrt{2} \not\in \mathbb{Q}$）。 如果我们找到了一个数域 $\mathbb{L}$，它满足 $\mathbb{Q} \subset \mathbb{L}$ 并且 $\sqrt{2} \in \mathbb{L}$，那么 $\mathbb{L}$ 是包含 $\sqrt{2}$ 的 $\mathbb{Q}$ 的一个扩域。显然，实数域 $\mathbb{R}$ 是满足条件的一个 $\mathbb{L}$。 在所有的 $\mathbb{L}$ 组成的集合 $S = \{\mathbb{L} \mid \mathbb{L}\text{ 是包含 $\sqrt{2}$ 的 $\mathbb{Q}$ 的一个扩域}\}$ 中，存在一个最小的域 $\mathbb{Q}(\sqrt{2}) \in S$，使得 $\mathbb{Q} \subset \mathbb{Q}(\sqrt{2}) \subset \mathbb{L}$ 对任意的 $\mathbb{L} \in S$ 都成立。 我们将 $\mathbb{Q}(\sqrt{2})$ 称作在 $\mathbb{Q}$ 中添加本原元 $\sqrt{2}$ 生成的扩域；从 $\mathbb{Q}$ 到 $\mathbb{Q}(\sqrt{2})$ 的扩张被称为单扩张。 那么 $\mathbb{Q}(\sqrt{2})$ 是什么样子的呢？在这里，我们不做严格推导，认定 $\mathbb{Q}(\sqrt{2}) = \{ x \mid x = a + b\sqrt{2},\, a, b \in \mathbb{Q} \}$。因为在上述扩张中，我们使用了长度为 2 的基 $\{1, \sqrt{2}\}$（分别作为 $a$ 和 $b$ 的系数）。因此，我们称上述扩张是维度为 2 的扩张，记作 $[\mathbb{Q}(\sqrt{2}):\mathbb{Q}] = 2$。 同理，如果本原元是 $\sqrt{3}$，我们也可以通过另一个维度为 2 的扩张得到 $\mathbb{Q}(\sqrt{3}) = \{ x \mid x = a + b\sqrt{3},\, a, b \in \mathbb{Q} \}$。 类似地，我们不难验证： $\mathbb{Q}(\sqrt{2})(\sqrt{3}) = \{ x \mid x = a + b\sqrt{3},\, a, b \in \mathbb{Q}(\sqrt{2}) \}$，即 $[\mathbb{Q}(\sqrt{2})(\sqrt{3}):\mathbb{Q}(\sqrt{2})] = 2$。 $\mathbb{Q}(\sqrt{2})(\sqrt{3}) = \mathbb{Q}(\{\sqrt{2},\sqrt{3}\}) = \mathbb{Q}(\sqrt{3})(\sqrt{2})$。 现在的问题是，$[\mathbb{Q}(\{\sqrt{2},\sqrt{3}\}):\mathbb{Q}]$ 是多少呢？ 由于我们可以从 $\mathbb{Q}(\{\sqrt{2},\sqrt{3}\})$ 中抽出一组基底 $\{ 1, \sqrt{2}, \sqrt{3}, \sqrt{6}\}$，使得$$\mathbb{Q}(\{\sqrt{2},\sqrt{3}\}) = \{a + b\sqrt{2} + c\sqrt{3} + d\sqrt{6} \mid a, b, c, d \in \mathbb{Q}\}.$$因此，$[\mathbb{Q}(\{\sqrt{2},\sqrt{3}\}):\mathbb{Q}] = 4$。 据此，我们可以观察得到一个未经严格证明（但确实是正确）的结论：\begin{equation}\label{eq:thm}[C:A] = [C:B] \times [B:A].\end{equation} 本原元的次数与扩张的维数对于本原元有所谓「次数」的概念，本原元的次数概念需要用多项式来定义。 如果本原元 $k$ 是基域 $\mathbb{Q}$ 上的代数数，那么必然存在 $\mathbb{Q}$ 上的首一多项式方程 $p(k) = 0$。在所有的 $p(k)$ 中，必然存在一个次数最低的多项式 $p_0(k)$，称作极小多项式。绩效多项式的次数 $n$ 就是本原元 $k$ 在基域 $\mathbb{Q}$ 上的次数。 值得一提的是以下两个结论： 若有首一的不可约多项式方程 $p(k) = 0$，那么 $p(k)$ 必然是 $k$ 的极小多项式； 若域扩张的本原元是域中的代数数，则对应的扩张的维数就是本原元的次数。 再探尺规作图与域扩张由于有理数域对四则运算是封闭的，而尺规作图能够轻易构建出有理数域，因此在尺规作图中进行加减乘除不涉及域的扩张。 除了四则运算，尺规作图还（只）能做开平方运算。如果一个有理数的平方根是有理数，那么这样的开平方运算也不涉及到域的扩张；而如果一个有理数的平方根是无理数，当然它总是代数数，那么这样的开方运算就会涉及到域的扩张。考虑到，在这种情况下，总是存在不可约的二次首一多项式方程$$x^2 - a = 0,$$因此，我们知道这种扩张的维度总是二维的。 根据 \ref{eq:thm}，我们可以得到结论：如果一个数对应长度的线段能够经过尺规作图得到，那么这个数必然是落在数域 $\mathbb{Q}’$ 中的代数数，并且 $[\mathbb{Q}’:\mathbb{Q}] = 2^k$。 三等分任意角问题不可解的证明我们用反证法来证明，首先给出反证假设：假设我们可以对 60° 角进行三等分，而后尝试从反正假设中推导出矛盾。 注意以下各步： 因为我们可以三等分 60° 角； 所以我们可以得到一个 20° 角； 因为过定点向点外直线引垂线是容易的，所以我们可以得到长度为 $\cos 20°$ 的线段。 由于 $\cos 60° = 0.5 \in \mathbb{Q}$，且 $\cos 60° = 4 \cos^3 20° - 3\cos 20°$，所以 $\cos 20°$ 是方程 $x^3 - 0.75x - 0.125 = 0$ 的根。由于 $f(x) = x^3 - 0.75x - 0.125$ 是不可约的，所以它是 $\cos 20°$ 在 $\mathbb{Q}$ 上的极小多项式，故而 $\cos 20°$ 在 $\mathbb{Q}$ 上的次数是 3。 因此，如果我们能够三等分任意角，这就意味着我们能够利用尺规作图对有限域进行维度是 3 的扩张，这与前面的结论是矛盾的。这个矛盾就说明了，三等分任意角是不可用尺规作图解决的。 倍立方问题及化圆为方问题和三等分角问题一样，倍立方问题和化圆为方问题也可以用代数理论轻巧地证明是不可解的。其中，倍立方问题在尺规作图中可以等价为作长度为 $\sqrt[3]{2}$ 的线段，而它的次数不巧也是 3；至于化圆为方问题则可以等价为作长度为 $\sqrt{\pi}$ 的线段，这根本就是一个超越数，连代数数都不是。 后记——人类心智的荣耀上述不严谨的证明，只需要简单的几何学知识（尺规作图知识）就可以完成，如此轻巧的证明，得益于以法国数学家伽罗瓦（Galois）为代表的代数学家的努力。 在伽罗瓦还只有十几岁的时候，他就发现了 $n$ 次多项式可以用根式解的充要条件，解决了长期困扰数学界的问题。他的工作为伽罗瓦理论（一个抽象代数的主要分支）以及伽罗瓦连接领域的研究奠定了基石。他是第一个使用群这一个数学术语来表示一组置换的人。与尼尔斯·阿贝尔并称为现代群论的创始人。1832 年 3 月伽罗瓦在狱中（因政治原因入狱）结识一个医生的女儿并陷入狂恋，因为这段感情，他陷入一场决斗，自知必死的伽罗瓦在决斗前夜将他的所有数学成果狂笔疾书纪录下来，幷时不时在一旁写下「我没有时间」，第二天他果然在决斗中身亡，时间是 1832 年 5 月 31 日。他的朋友Chevalier遵照伽罗瓦的遗愿，将他的数学论文寄给卡尔·弗里德里希·高斯与雅各比，但是都石沉大海，要一直到 1843 年，才由刘维尔肯定伽罗瓦结果之正确、独创与深邃，并在 1846 年将它发表。https://zh.wikipedia.org/wiki/%E5%9F%83%E7%93%A6%E9%87%8C%E6%96%AF%E7%89%B9%C2%B7%E4%BC%BD%E7%BD%97%E7%93%A6 谨以此纪念仍然闪烁人类心志荣耀之光的伽罗瓦理论和英年早逝的数学家埃瓦里斯特·伽罗瓦。]]></content>
      <categories>
        <category>Mathematics and Natural Sciences</category>
      </categories>
      <tags>
        <tag>Algebra</tag>
        <tag>Geometry</tag>
        <tag>Galois</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排版伪代码时打印垂直的缩进提示线]]></title>
    <url>%2F2016%2F06%2F10%2Fpseudocode-with-vertical-line%2F</url>
    <content type="text"><![CDATA[和实际使用中的 Python 一样，伪代码的排版很讲究缩进。书写 Python 代码，通常会使用等宽字族（打字机字族），因此缩进一板一眼十分清晰；然而，在排版算法时，经常会遇到非等宽的字族和等宽字族混用的情况——此时，缩进有时候就不那么明确了。此时，给伪代码排版加上垂直的缩进提示线能够起到很好的提示作用。 排版欧几里得算法试试看123456789101112131415161718192021\documentclass&#123;article&#125;\usepackage&#123;algorithm&#125;%\PassOptionsToPackage&#123;noend&#125;&#123;algpseudocode&#125; % 不显示循环、条件的结尾\usepackage&#123;algpseudocode&#125;\begin&#123;document&#125;\begin&#123;algorithm&#125; \caption&#123;Euclid’s algorithm&#125;\label&#123;euclid&#125; \begin&#123;algorithmic&#125;[1] \Procedure&#123;Euclid&#125;&#123;$a,b$&#125;\Comment&#123;The g.c.d.\ of a and b&#125; \State&#123;$r\gets a\bmod b$&#125; \While&#123;$r\not=0$&#125;\Comment&#123;We have the answer if r is 0&#125; \State&#123;$a\gets\displaystyle\sum_&#123;i=1&#125;^n x_i$&#125;\Comment&#123;Nonsense to show that tall lines might work&#125; \State&#123;$a\gets b$&#125; \State&#123;$b\gets r$&#125; \State&#123;$r\gets a\bmod b$&#125; \EndWhile\label&#123;euclidendwhile&#125; \State&#123;\Return $b$\Comment&#123;The gcd is b&#125;&#125; \EndProcedure \end&#123;algorithmic&#125;\end&#123;algorithm&#125;\end&#123;document&#125; 干脆利落的代码，很好懂对吧。: ) 这里，我们调用了 algorithm 宏包，它提供了 algorithm 环境。这是一个三线表样式的浮动体，浮动的策略和 LaTeX 标准的 figure、table 环境一致。algpseudocode 宏包则是 algorithmicx 宏包的一部分，它提供了实际用来排版伪代码的环境。 从一小段竖线开始改造123\newcommand*&#123;\algrule&#125;[1][\algorithmicindent]&#123;\makebox[#1][l]&#123;\hspace*&#123;.1em&#125;\vrule height \algrl@height depth \algrl@depth&#125;&#125;%\newcommand*&#123;\algrl@height&#125;&#123;.75\baselineskip&#125;\newcommand*&#123;\algrl@depth&#125;&#123;.25\baselineskip&#125; 这一小段代码相对还是很好理解的。 主要命令 \algrule 依赖两个长度：\algrl@height 和 \algrl@depth。如果你对 plainTeX 比较熟悉的话，那么显而易见，这两个长度分别是标尺 \vrule 的高度和深度。 此外，\algrule 还有一个默认参数 \algorithmicindent。这是 algorithmicx 宏包中定义的长度变量，用来保存每一个缩进块的缩进长度。这里我们将它作为默认参数传给内部的 \makebox，\makebox 制作了一个宽度为 \algorithmicindent 的水平盒子，在靠左边的地方，画了一条高度为 \algrl@height、深度为 \algrl@depth 的标尺（一小节竖线）。 值得注意的是，\algrl@height 和 \algrl@depth 加起来正好是 \baselineskip，也就是行距。这里我们将它们定义成宏，是为了方便后续调整每一节细线的具体高度。若不然，遇到超过 \baselineskip 的情形（例如插入了一个庞大的数学公式），上下两行之间的竖线就会断开。 逐层打印当前行的提示线有了上面定义的竖线，我们就可以逐层打印某一行的提示线了。 在这里，我们不难总结：如果当前伪代码缩进了 $k$ 次，那么我们就需要画出 $k$ 个小竖线。为此，我们需要定义一个临时用的计数器，并构建一个以它为循环变量的 TeX 循环。 1234567891011121314151617\newcount\ALG@printvrule@tempcnta\def\ALG@printvrule&#123;% \ifnum \theALG@nested&gt;0% \ifx\ALG@text\ALG@x@notext% % do nothing \else \unskip \addvspace&#123;-1pt&#125;% \ALG@printvrule@tempcnta=1% \loop \algrule[\csname ALG@ind@\the\ALG@printvrule@tempcnta\endcsname]% \advance \ALG@printvrule@tempcnta 1 \ifnum \ALG@printvrule@tempcnta&lt;\numexpr\theALG@nested+1\relax \repeat \fi \fi&#125;% 在这里，\ALG@printvrule@tempcnta 是我们的循环变量，用来表征「即将打印的是第几级缩进」。 此外，由于 \ALG@printvrule 会实际输出内容，因此要特别注意行末的换行符带来的额外空格。在有必要的地方，我们需要加上注释符号 % 抹掉这些空格。 \theALG@nested 是 algorithmicx 宏包的内部变量，用来保存当前行嵌套了多少层缩进。当它大于零时，我们就知道该干活了。我们主要关注循环部分。 首先，我们将 \ALG@printvrule@tempcnta 初始化为 1，因为我们总是从第一级缩进开始排版； 而后，我们进入循环，调用刚才定义的 \algrule 命令； 此处，\csname ALG@ind@\the\ALG@printvrule@tempcnta\endcsname 将展开为形如 \ALG@ind@1、\ALG@ind@2这样的变量，他们在algorithmicx` 宏包里用来保存各级缩进的缩进深度； 调用 \algrule 命令后，我们已经完成阶段性的工作，开始维护循环变量：通过 \advance 将它自加 1； 最后的判断极好理解：我们必须确保循环变量不超过嵌套的层数。 给 \ALG@doentity 打补丁\ALG@doentity 命令是 algorithmicx 宏包内部用来输出每条算法实体（entity）的工具。在进行一系列判断、控制后，它将根据 \theALG@nested 缩进恰当的距离，而后输出算法的具体内容。修改它需要用到 etoolbox 宏包的 \patchcmd 命令，它能够在宏的展开中查找替换指定的内容。 123\patchcmd&#123;\ALG@doentity&#125;% &#123;\noindent\hskip\ALG@tlm&#125;&#123;\ALG@printvrule&#125; &#123;&#125;&#123;\errmessage&#123;failed to patch&#125;&#125; \patchcmd 接收 5 个参数，分别表示： 你想对哪个命令打补丁 你想替换啥 你想将它替换成啥 如果替换成功了咋办 如果替换失败了咋办 因此，这个补丁将会对 \ALG@doentity 进行修改：将原本单纯的缩进输出，替换为我们自己定义的带提示线的缩进输出。 给 \State 命令打补丁上面提到，在某些情况下，\algrl@height 和 \algrl@depth 定义的默认高度是不够的；而至今为止，我们还没有让它俩能够自动适应变化的行高。\State 命令是 algorithmicx 宏包中用来输出算法语句的命令，我们在它的基础上定义一个新的 \vState 命令。 123456789101112131415\newbox\statebox\newcommand&#123;\vState&#125;[1]&#123;% \setbox\statebox=\vbox&#123;#1&#125;% \edef\algrl@height&#123;\dimexpr \the\ht\statebox + 1pt\relax&#125;% \edef\algrl@depth&#123;\dimexpr \the\dp\statebox + 1pt\relax&#125;% \ifdim\algrl@height &lt; .75\baselineskip \def\algrl@height&#123;\dimexpr .75\baselineskip + 1pt\relax&#125;% \fi \ifdim\algrl@depth &lt; .25\baselineskip \def\algrl@depth&#123;\dimexpr .25\baselineskip + 1pt\relax&#125;% \fi \State #1% \def\algrl@height&#123;\dimexpr .75\baselineskip + 1pt\relax&#125;% \def\algrl@depth&#123;\dimexpr .25\baselineskip + 1pt\relax&#125;%&#125; 这里，我们将 \vState 的参数读入一个竖直盒子中，然后将 \algrl@height 和 \algrl@depth 分别设置为盒子的高度和深度。同时，为了保险，还用 \ifdim 对它俩的值做了判断，确保二者相加不会小于 \baselineskip。在调用原始的 \State 命令输出后，我们又将二者的定义还原回去。此处用到了大量的 \dimexpr ... \relax 表达式，这是 eTeX 中用来做长度计算的语句。 实际运行看看将上述补丁组合在一起，就能得到我们期待的效果了。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Macro</tag>
        <tag>Pseudocode</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识 Docker]]></title>
    <url>%2F2016%2F05%2F29%2Fsay-hi-to-docker%2F</url>
    <content type="text"><![CDATA[本文部分译自 Benjamin Cane 的博文。 Docker 是目前风靡全球的虚拟化技术。然而在两年前，Docker 还仅仅是设计者脑海中的概念而已。 本篇将介绍 Docker 的一些基本情况，以及基本操作。顺带着，我们将能见识到 Docker 一些有趣的特性。 容器技术与虚拟机同样作为操作系统虚拟化的方法，容器并不如虚拟机那样出名。它们有相似之处，但也有一些差别。 由于 Hypervisor 向虚拟机提供了虚拟化的硬件，虚拟机可以包含一整个操作系统、系统软件包，以及一些应用程序。因此，在一个宿主机上，可以运行许多独立的客户机。运行在同一宿主机上的虚拟机，提供完整的操作系统环境，共享宿主机上的同一套物理资源。 与之对应，容器技术使得单一的宿主机能够运行多种操作系统环境。在这一点上，容器技术和虚拟机很相似。只不过，容器技术提供的虚拟环境，并不是完整的操作系统。一般来说，容器技术只包含了必要的系统软件包以及应用程序，而不包含整个操作系统或是虚拟化的硬件。因此，容器技术比传统的虚拟机技术占用资源少。容器技术将同一宿主机上的进程相互隔离，互不影响。事实上，与其拿来与虚拟机相较，不如说容器技术与 BSD Jails 以及 chroot 更相似。 Docker 究竟做了什么？Docker 其实是个很难定位的技术，我们很难说清 Docker 究竟算不算是容器技术，但它的一些特性又让人无法否认这一点。这似乎有点不可知论的意思了。 Docker 支持 Solaris Zones 和 BSD Jails 这两种容器技术，提供了管理、打包以及部署容器的手段。虚拟机多多少少有类似的功能；但在过往的容器技术里，则几乎看不到——即使有，也很不好用。 容器技术本身不是 Docker 的重点。相反，管理、打包和部署容器的能力，才是 Docker 的杀手锏。 安装 DockerDocker 通常没有默认安装在系统中，所以我们首先要装好它。 在 Ubuntu 里，我们可以用 apt-get install docker.io 来简单地安装它。在 yum 系的 Linux 中，也是类似。在 OS X 里，则可以用 Homebrew 来安装。这里我们以 Ubuntu 为例： 12345678910111213141516# apt-get install docker.ioReading package lists... DoneBuilding dependency treeReading state information... DoneThe following extra packages will be installed: aufs-tools cgroup-lite git git-man liberror-perlSuggested packages: btrfs-tools debootstrap lxc rinse git-daemon-run git-daemon-sysvinit git-doc git-el git-email git-gui gitk gitweb git-arch git-bzr git-cvs git-mediawiki git-svnThe following NEW packages will be installed: aufs-tools cgroup-lite docker.io git git-man liberror-perl0 upgraded, 6 newly installed, 0 to remove and 0 not upgraded.Need to get 7,553 kB of archives.After this operation, 46.6 MB of additional disk space will be used.Do you want to continue? [Y/n] y 在终端里执行 docker ps 可以查看当前运行着的容器。 12# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 顾名思义。docker ps 和 *nix 系统中的 ps 命令具有类似的功能。docker ps 会打印所有可用的 Docker 容器以及它们当前的状态。因为我们什么也没做，所以命令显示当前没有运行着的容器。 部署打包好的 nginx Docker 容器Docker 可以像 yum 以及 apt-get 那样部署软件包，这一特性十分讨喜。这次，我们用 docker run 命令，实际部署 nginx 服务器看看。 123456789101112131415# docker run -d nginxUnable to find image 'nginx' locallyPulling repository nginx5c82215b03d1: Download completee2a4fb18da48: Download complete58016a5acc80: Download complete657abfa43d82: Download completedcb2fe003d16: Download completec79a417d7c6f: Download completeabb90243122c: Download completed6137c9e2964: Download complete85e566ddc7ef: Download complete69f100eb42b5: Download completecd720b803060: Download complete7cc81e9a118a: Download complete 接受 docker run 命令后，Docker 会寻找置顶的 Docker 镜像并运行。默认情况下，Docker 容器会在前台执行。也就是说，你的 shell 会与 Docker 控制台及容器中正在运行的进程绑定。加上 -d (detach) 选项，Docker 容器就会在后台执行了。 再次执行 docker ps命令，我们就能看到 nginx 容器正在了。 123# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESf6d31ab01fc9 nginx:latest nginx -g 'daemon off 4 seconds ago Up 3 seconds 443/tcp, 80/tcp desperate_lalande 不难看出，容器 desperate_lalande 正在运行，它由 nginx:latest 镜像构建而来。 Docker 镜像镜像是 Docker 的核心特征之一。与虚拟机镜像类似，Docker 的镜像是一个打包存档的容器。与此同时，Docker 并未就此止步——Docker 还能通过 Docker 仓库发布这些镜像。Docker 仓库扮演的角色，类似于软件包仓库，因此，Docker 可以像 yum 那样工作。让我们回顾一下 docker run 的输出。 12# docker run -d nginxUnable to find image 'nginx' locally 首先，Docker 表示在本地没有找到 nginx 镜像。这是因为，执行 docker run 时，我们希望 Docker 启动名为 nginx 的容器；而启动容器，需要找到对应的镜像。Docker 首先会在本地寻找相应名称的镜像；若是找不到，则会联网在远程 Docker 仓库寻找。 由于 Docker 是刚安装的，自然不存在名为 nginx 的镜像。于是，Docker 将会连接远程仓库下载它。 12345678910111213Pulling repository nginx5c82215b03d1: Download completee2a4fb18da48: Download complete58016a5acc80: Download complete657abfa43d82: Download completedcb2fe003d16: Download completec79a417d7c6f: Download completeabb90243122c: Download completed6137c9e2964: Download complete85e566ddc7ef: Download complete69f100eb42b5: Download completecd720b803060: Download complete7cc81e9a118a: Download complete 接下来，Docker 打印了这些信息。默认情况下，Docker 会连接 Docker 公司维护的 Docker Hub仓库。 与 GitHub 相同，在 Docker Hub 上创建公开仓库是免费的，创建私有仓库则是收费的。你也可以部署你自己的 Docker 仓库——只需要运行 docker run registry 就好了。不过，本文不会讨论这一块内容。 停止并移除容器在我们创建自己的 Docker 容器之前，让我们先清理一下 Docker 环境。首先，我们要停止运行着的容器，然后移除它。 与 docker run 对应，docker kill &lt;container-name&gt; 会停止正在运行的容器。 12# docker kill desperate_lalandedesperate_lalande 再次执行 docker ps 可以发现，容器已经不再运行了。 12# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES docker kill 关闭了容器；虽然它不再运行，但仍然存在于 Docker 系统中。docker ps 默认只显示正在运行的容器，docker ps -a 则会显示所有容器（包括未运行的）。 123# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESf6d31ab01fc9 5c82215b03d1 nginx -g 'daemon off 4 weeks ago Exited (-1) About a minute ago desperate_lalande 我们可以用 docker rm 来完全地移除容器。 12# docker rm desperate_lalandedesperate_lalande 不过，虽然容器被移走了，但是 Docker 系统中仍有缓存的 nginx 镜像。因此，若然此时执行 docker run -d nginx，Docker 会直接调用本地的镜像启动容器，而无需联网下载。 docker image 会列出所有本地可用的镜像。 123# docker imagesREPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZEnginx latest 9fab4090484a 5 days ago 132.8 MB]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Operating System</tag>
        <tag>Virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划与状态机：最大子序列和问题的扩展]]></title>
    <url>%2F2016%2F05%2F13%2Fdynamic-programming-and-state-machine%2F</url>
    <content type="text"><![CDATA[前作以最大子序列和问题为起点，引出了动态规划思想的核心框架。今日恰逢构建之法群里，讨论起一个股票买卖问题，我用动态规划解决了。和邹欣老师的交流中，我进一步发现，引入状态机后，实际上股票买卖问题是最大子序列和问题的扩展。并且，这样的扩展可以更进一步地接近动态规划的核心，因此续作此篇，讨论一下动态规划与状态机。 动态规划与状态机状态机是一种抽象的数学模型。它描述的是一些特定的状态，以及在这些状态之间转移的行为。如果状态的数量和转移方式都是有限的，那么这就是一个有限状态机。下图是一个有限状态机的示例： 图中，每一个圆圈代表一个状态；每一道箭头代表一次转移；箭头上的内容则是转移的条件。 在前作中，我们讨论了动态规划思想的核心框架，其中提到了阶段、状态和最优子结构等概念。仔细琢磨这些概念，我们就能发现，他们和状态机中的概念是能够对应起来的： 状态机 动态规划 阶段 状态的集合 状态 状态 转移 从一个阶段到下一个阶段 转移条件 最优子结构 唯一的区别在于，动态规划只关注每个阶段的局部最优解；而状态机理论中，则没有这种倾向。 可见，动态规划思想，实际上是一种特殊的状态机罢了。 再探 Kadane 算法那么，在最大子序列和的 Kadane 算法中，蕴含了怎样的状态机呢？呃，好吧。这个状态机非常简单，所以可能很多人都意识不到。 没错，就只有一个状态点而已。 start：读入序列中第一个整数 $\text{S}_a$：以当前整数为结尾的子序列之和 最优解：上述和中最大的那个 转移：读入下一个整数 最优解的转移条件（最优子结构）：local_max = max (local_max + nums[i], nums[i]) 不难发现，代码中的循环，实际上就是实现了这个状态机而已。 股票买卖问题接下来我们看一个最大子序列和的升级版问题：股票买卖问题。 这个问题是说：给定一个包含若干整数（正负不限）的序列，该序列中的数值对应过去某天的股票价格。假设只有一张股票可以买卖，你可以自由地选择在某天买入或卖出，但必须保证：先买入后卖出、卖出后至少一天不允许交易（cooldown day）、每天最多只能交易一次（要么买入、要么卖出、要么不交易）。现在请问，在买入卖出的过程中，你最多能挣取多大收益？ 假设我们对如下序列做讨论： 1prices = [1, 2, 3, 1, 1, 2, 5, 3, 4, 2] 对于这个问题，我们可以定义如图所示的状态机： 这个状态机是对问题的忠实还原： 两个 start 表示最开始你可以选择休息，也可以选择购买股票。 买入股票后，进入状态 $\text{S}_1$，此时可以选择休息，或者卖出股票进入状态 $\text{S}_2$。 卖出股票后，进入状态 $\text{S}_2$，此时只能选择休息（cooldown day）进入状态 $\text{S}_0$。 进入状态 $\text{S}_0$ 后，可以选择继续休息，也可以选择买入股票。 我们要做的事情有两件：1. 定义初始状态；2. 找到在状态转移过程中，状态最优解之间的关系。 这很好做，因为我们有状态机作为参考。 对于 $\text{S}_0$ 状态来说，如果第一天不做操作，那么收益为 0，即 s0[0] = 0。接下来考虑，如果第 i 天进入了 $\text{S}_0$ 状态，那么第 i - 1 天要么在 $\text{S}_0$ 状态，要么在 $\text{S}_2$ 状态。因此 s0[i] = max (s0[i - 1], s2[i - 1])。 对于 $\text{S}_1$ 状态来说，如果第一天买入股票，那么收益为 -prices[0]，即 s1[0] = -prices[0]。接下来考虑，如果第 i 天进入了 $\text{S}_1$ 状态，那么第 i - 1 天要么在 $\text{S}_0$ 状态，要么在 $\text{S}_1$ 状态。因此 s1[i] = max (s0[i - 1] - prices[i], s1[i - 1])。 对于 $\text{S}_2$ 状态来说，不存在第一天就卖出的现象，因此我们需要一个足够小的值，来表示这种不可能出现的状态，即 s2[0] = -sys.maxint - 1。接下来考虑，如果第 i 天进入了 $\text{S}_2$ 状态，那么第 i - 1 天必然在 $\text{S}_1$ 状态。因此 s2[i] = s1[i - 1] + prices[i]。 于是，我们很容易能写出代码： maxProfit.py12345678910111213141516171819202122import sysdef maxProfit (prices): length = len (prices) if length &lt; 2: return 0 s0, s1, s2 = [0] * length, [0] * length, [0] * length s0[0], s1[0], s2[0] = 0, -prices[0], -sys.maxint - 1 for i in xrange (1, length): s0[i] = max (s0[i - 1], s2[i - 1]) s1[i] = max (s0[i - 1] - prices[i], s1[i - 1]) s2[i] = s1[i - 1] + prices[i] return max (s0[-1], s2[-1])if __name__ == "__main__": test_cases = [[], [1], [1, 2, 3, 1, 1, 2, 5, 3, 4, 2], [6, 5, 4, 3, 2, 1, 0]] for prices in test_cases: print "The maxProfit of", prices, "is", maxProfit (prices) 结果输出： 1234The maxProfit of [] is 0The maxProfit of [1] is 0The maxProfit of [1, 2, 3, 1, 1, 2, 5, 3, 4, 2] is 6The maxProfit of [6, 5, 4, 3, 2, 1, 0] is 0 符合预期；并且，由于循环内的操作均可以在常数时间内完成，因此这是一个 O(n) 复杂度的算法。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Max Subsequence Sum</tag>
        <tag>Max Subarray Sum</tag>
        <tag>Dynamic Programming</tag>
        <tag>State Machine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xeCJK 宏包的隐藏技能：字符映射]]></title>
    <url>%2F2016%2F05%2F12%2Fthe-hidden-skill-of-the-xeCJK-package-Mapping%2F</url>
    <content type="text"><![CDATA[有段时间没写 LaTeX 相关的文章了，此篇讲一讲 xeCJK 宏包中的 Mapping 功能。 由于中文空心句号是一个小圈，容易与作为下标的数字 0 或字母 o 混淆。因此，在专业数学书籍、论文排版中，最好是使用实心句点 ． 来代替中文空心句号。但是，使用中文空心句号编写中文 LaTeX 手稿是大家的习惯；这样一来，使用查找替换固然是一个方案，但是繁琐且容易出错。这时候，我们就可以用到 xeCJK 宏包提供的 Mapping 选项。 Mapping 实际上是借助了 TECKit 来做字符映射。xeCJK 的作者还预先定义了能够实现简体中文和正体中文相互转换的映射表。因此，使用 xeCJK 还能实现中文的简正转换。 基本用法相信你对 xeCJK 宏包的基本用法已经了解，因此我就不对下面的代码作过多的解释。我们来看一下 Mapping 选项的基本用法。 mapping_fullwidth-stop.tex123456789%!TeX program = xelatex\documentclass&#123;article&#125;\usepackage&#123;xeCJK&#125;\setCJKmainfont[Mapping = fullwidth-stop]&#123;STSong&#125; % 华文宋体\begin&#123;document&#125;华文宋体。可以发现，中文空心句号自动映射成了实心句点。\end&#123;document&#125; 这里我们为文档主字体调用了 fullwidth-stop 这一映射文件。它的作用是将中文空心句号映射成实心句点，这个文件是 xeCJK 的作者预先定义的。 xeCJK 的作者也有定义作用与之完全相反的映射文件：full-stop。 简正转换除了中文空心句号和实心句点的映射，xeCJK 的作者还提供了 han-trad 和 han-simp 两个映射文件。前者可以将 TeX 手稿中的简体中文字符映射成正体中文字符；后者则相反。 mapping_han-trad.tex123456789%!TeX program = xelatex\documentclass&#123;article&#125;\usepackage&#123;xeCJK&#125;\setCJKmainfont[Mapping = han-trad]&#123;STSong&#125; % 华文宋体\begin&#123;document&#125;华文宋体。可以发现，简体中文字符，都被一一地映射为对应的正体中文字符。\end&#123;document&#125; 不过，需要注意的是：在简化汉字的过程中，存在多个正体中文汉字映射到同一个简体中文汉字上的情况；同时，也存在一个正体中文汉字在表达不同含义时映射到不同简体中文汉字的情况。由于技术所限，xeCJK 的映射机制只能做到一一对应，无法实现上述复杂的映射状况。因此，在使用 Mapping = han-trad 时，会出现类似如下的情况：简体的「发挥」和「头发」被转换成正体的「發揮」和「頭發」，但后者应作「頭髮」。 再深入一步xeCJK 只提供了四个预定义的映射文件，如果还想要用这种方式制作更多的效果，就需要自己定义映射文件了。这可以参考 TECKit 的文档：http://scripts.sil.org/teckit。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>xeCJK</tag>
        <tag>Mapping</tag>
        <tag>Simplified Chinese</tag>
        <tag>Traditional Chinese</tag>
        <tag>Stop Sign</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[循环列表中的最大子序列和问题]]></title>
    <url>%2F2016%2F05%2F12%2Fmax-subsequence-sum-in-circular-list%2F</url>
    <content type="text"><![CDATA[序列的最大子序列和问题，说的是：给定一个包含若干整数（正负不限）的序列，寻找其中的一个子序列，使得该子序列元素之和在所有子序列的和中最大。 这一经典的问题，可由动态规划（中的 Kadane 算法）在 $O(n)$ 的时间内解决。 如果我们将给定的序列首尾相连，成为一个环状列表。同样的问题，就变得复杂起来。不过，在巧妙的思路下，问题仍然可以在 $O(n)$ 时间内解决。 下面我们先复习一下 Kadane 算法；然后看看怎样在线性时间内，解决循环列表中的最大子序列和问题。 Kadane 算法该算法由 CMU 的 Jay Kadane 提出，运用了动态规划的思想。 动态规划是求解最优化问题的一种思想，它的核心，是要寻找一种看待问题的方式： 这种看待问题的方式，将问题可能的中间过程，划分为若干状态； 对于每个状态来说，能取得的值可以有多个，但我们只关注其中的最优解； 随着解题过程向前推进，在每个阶段之间，状态之间可能发生转移； 在转移的过程中，各个状态在下一个阶段的最优解，可以由上一个阶段某些状态的最优解，经过某种确定的方式得到； 这种方式，只与上一阶段的状态有关，而与上一阶段的状态是如何得到的无关。 这样一来，如果我们能够在某个阶段找到确定的最优解，就能够逐层递推，找到原问题的最优解。 在这里： 有限的阶段，即是子问题； 每个阶段各个状态的最优解，共同构成了当前阶段的局部最优解； 最优解在阶段之间的递推关系，叫做最优子结构； 最优子结构只与上一阶段的状态本身有关，这个性质叫做无后效性。 也就是说，动态规划的核心，是要寻找一种具有最优子结构的无后效的问题拆解方式。 在 Kadane 算法中， 我们将从前往后扫描序列，每次扫描到一个新的整数，就是一个阶段； 对于每个阶段来说，我们只关注一个状态，这个时候阶段和状态的概念是等价的：以当前整数结尾的子序列的和； 对于每个阶段来说，和最大的那个子序列，就是局部最优解； 在转移过程中，下一个阶段的局部最优解很容易构造：如果上一阶段的最优解小于零，则下一个阶段的局部最优解就是下一个整数本身；如果上一阶段的局部最优解不小于零，则下一个阶段的局部最优解，只需要在上一阶段的局部最优解的基础上，加上下一个整数即可。 这样，我们就找到了一个无后效性的最优子结构。 据此，我们不难写出如下代码（Python）： Kadane.py12345678910111213141516171819def maxSubArraySum (nums): if not nums: return None elif 1 == len (nums): return nums[0] local_max, global_max = nums[0], nums[0] for i in xrange (1, len (nums)): local_max = max (local_max + nums[i], nums[i]) global_max = max (local_max, global_max) return global_maxif __name__ == '__main__': test_cases = [[], [0], [1], [1, 2, 3], [-3, -1, -2], [9, 8, 5, 2, -5, 6, 2, -2]] for nums in test_cases: print "The maxSubArraySum of", nums, "is", maxSubArraySum (nums) 循环列表中的最大子序列和问题对于一个循环列表来说，求解最大子序列和的问题，时间复杂度不会超过 $O(n^2)$。这是因为，我们可以依次移动长度为 $n$ 的窗口，然后用 Kadane 算法求解当前窗口的最大子序列和；而后再将这些窗口分别的最大子序列和做比较，求得其中的最大者。由于窗口数量最大为 $n$，而 Kadane 算法是线性的，所以这种平凡的解法，时间复杂度是 $O(n^2)$。 不过，问题也可以在线性时间内解决。考虑一个循环序列： 1arr[0], arr[1], arr[2], ..., arr[n] 其最大子序列和对应的子序列，有两种情况： 子序列不跨过 arr[n], arr[0]，即不 wrap 的情况。此时问题退化为普通序列的最大子序列和问题，我们可以在线性时间内解决。 子序列跨过 arr[n], arr[0]，即 wrap 的情况。此时，我们有 最大子序列和 = 全序列和 - 序列中不 wrap 的子序列的和。显而易见，全序列和 是一个常数，要 wrap 的子序列和尽可能大，就需要中间不 wrap 的子序列和尽可能小。这时候，如果我们将整个序列正负号翻转，那么求得该翻转后的序列的最大子序列和，就对应了翻转前的最小子序列和。因此，这种情况也可以在线性时间内解决。 据此，我们不难得到： circular_kadane.py12345678910111213141516171819202122232425262728293031323334353637383940414243def kadane (nums): if not nums: return None elif 1 == len (nums): return nums[0] local_max = nums[0] global_max = nums[0] for i in xrange (1, len (nums)): local_max = max (local_max + nums[i], nums[i]) global_max = max (local_max, global_max) return global_maxdef maxCircularSum (nums): if not nums: return None elif 1 == len (nums): return nums[0] max_kadane = kadane (nums) if max_kadane &lt;= 0: return max_kadane max_wrap = sum (nums) nums = [-x for x in nums] cur_kadane = kadane (nums) max_wrap += cur_kadane if max_wrap &gt; max_kadane: return max_wrap else: return max_kadaneif __name__ == '__main__': test_cases = [[], [0], [1], [1, 2, 3], [-3, -1, -2], [11, 10, -20, 5, -3, -5, 8, -13, 10]] for nums in test_cases: print "The maxCircularSum of", nums, "is", maxCircularSum (nums) 运行结果： 123456The maxCircularSum of [] is NoneThe maxCircularSum of [0] is 0The maxCircularSum of [1] is 1The maxCircularSum of [1, 2, 3] is 6The maxCircularSum of [-3, -1, -2] is -1The maxCircularSum of [11, 10, -20, 5, -3, -5, 8, -13, 10] is 31]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Max Subsequence Sum</tag>
        <tag>Max Subarray Sum</tag>
        <tag>Circular List</tag>
        <tag>Kadane Algorithm</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[健身房常见的抖动式腰带腹部甩脂机有用吗？]]></title>
    <url>%2F2016%2F05%2F08%2Fslimming-equipments-are-useless%2F</url>
    <content type="text"><![CDATA[健身房常见的抖动式腰带腹部甩脂机有用吗？ 明确的答案是：没用。 简单解释：脂肪对于人来说，是作为「能量储备」存在的。如果能轻易「甩」掉，那么作为储备来说可靠性也太差了。因此「甩脂机」，特别是号称「甩哪瘦哪」的甩脂机，是不可能有减肥效果的。 详细一点的解释：我们说的减肥，通常指消耗体内（中性）脂肪的过程。脂肪由一份子甘油（丙三醇）与三分子的脂肪酸脱水缩合而成。脂肪的分解代谢第一步成为「脂肪动员」，将脂肪水解为甘油和脂肪酸；而后甘油和脂肪酸有分别的代谢途径。 除了血液中游离的脂肪，脂肪在人体内大都储存在脂肪细胞中。脂肪细胞接受肾上腺素、去甲肾上腺素、胰高血糖素等激素的刺激，合成蛋白激酶，间接刺激激素敏感脂肪酶活化，促进脂肪动员。于是得到结论：脂肪动员的进行受到脂肪酶的控制，脂肪酶的活性受到其他若干种激素的影响，这些激素的合成受控于肾上腺素、去甲肾上腺素、胰高血糖素等。而肾上腺素、去甲肾上腺素、胰高血糖素的上升是有条件的，这些条件包括：禁食与饥饿，交感神经兴奋（生理上可以因运动、焦虑、情绪激动引起）。所以，除掉饥饿、焦虑等负面状态，要促进脂肪动员，基本只能依靠运动，甩脂机之类的东西是没有用的。 由于脂肪组织缺少甘油代谢所需的酶，脂肪动员产生的甘油需要通过血液运输到肝脏等器官进行代谢。甘油在甘油激酶的作用下最终转换为磷酸二羟丙酮，进入糖代谢途径（彻底氧化、变成葡萄糖或者经由磷酸化转为甘油磷酸）。这部分代谢主要依靠肝脏，所以号称「甩哪瘦哪」是不可能的，再怎么甩，也要经过肝脏。 脂肪酸的种类很多，代谢途径也很多（不过代谢途径太多了，于是对我们的问题的分析没什么帮助）。主要的代谢途径可以是： 脂肪酸活化，然后进行 beta-氧化，生成乙酰 CoA 参与三羧酸循环； 进行脱碳 alpha-氧化； 末端甲基羰基化，生成二羧酸，再进行 beta-氧化； 不饱和脂肪酸在异构酶的作用下异构，再进行 beta-氧化。 另外，脂肪酸代谢中会产生一些丙酸。这些丙酸经由 丙酰CoA - 琥珀酰CoA - 琥珀酸 - 草酰乙酸 的转换过程，进入三羧酸循环。总的来说，脂肪要完全代谢必须经过肝脏，同时刺激脂肪代谢主要还是得靠运动。 又：运动时，人类的「主要能源」的消耗顺序是：肌肉中的肌糖原 - 血液中的葡萄糖 - 肝脏中的肝糖原 - 血液中的脂肪 - 部分蛋白质 - 作为储备的脂肪。可见减肥确实不是一个简单的事情，同时也不存在轻松减肥的捷径。科学地减肥还是要靠适量锻炼与合理膳食搭配才行。 : )]]></content>
      <categories>
        <category>Mathematics and Natural Sciences</category>
      </categories>
      <tags>
        <tag>Slimming</tag>
        <tag>Fat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最佳搭档：利用 sort 和 uniq 做集合运算]]></title>
    <url>%2F2016%2F05%2F05%2Fbest-match-using-sort-and-uniq-to-do-set-operations%2F</url>
    <content type="text"><![CDATA[工作中遇到一些需要做集合运算的场景。这种时候，写个 Python 脚本当然是个选择；然而，我却嫌弃太重量级。因此，在 Linux 工具中寻找到了能够胜任这一工作的 sort 和 uniq 两个命令。 sort: 生而为排序sort 命令的用法很简单。最基本的用法有两种： 12cat &lt;filename&gt; | sortsort &lt;file1&gt; [&lt;file2&gt; [&lt;file3&gt; [...]]] 二者意义相同：sort 会逐行读入文件内容；然后依 ASCII 编码的顺序，升序排列文件的行；最后输出到标准输出（通常是屏幕）。注意，sort 可以连续读入多个文件，而后合在一起排序。 如果希望将 sort 结果保存到文件，则需要用到 -o 选项（当然，大多数情况也可以用 &gt; 重定向）： 1sort &lt;input&gt; -o &lt;output&gt; 如果希望倒序排列，则需要用到 -r 选项： 1sort -r &lt;filename&gt; 对于数字来说，按照 ASCII 编码排列就不合适了，此时可以用到 -n 选项： 1sort -n &lt;filename&gt; 其他选项： 123456-u 去除重复行-t 指定分隔符（通常与 -k 联用）-k 指定用于排序的列号-f 忽略大小写-M 能够排序月份-b 忽略行首空白 uniq: 专治重复，一针见效uniq 的作用可以描述为：针对相邻的重复行，进行相应的动作。 这句话中，有两个地方需要注意。首先，针对的是相邻的重复行。因此，uniq 对于不相邻的重复行是不起作用的。其次，进行相应的动作。这意味着，uniq 可以做的事情很多，不止一样。 不带任何参数的时候 uniq 的动作是：对相邻的重复行进行去除。例如： 1cat &lt;filename&gt; | sort | uniq 我们已经见过了 sort 的作用，那么上面命令的作用就很显然了：将 &lt;filename&gt; 按照 ASCII 升序排序；然后去除重复出现的行；最后将这个没有重复行的内容输出到标准输出。 给 uniq 加上参数，就能解锁更多姿势。 12345cat &lt;filename&gt; | sort | uniq -d # 只显示重复的行，每行只显示一次cat &lt;filename&gt; | sort | uniq -D # 只显示重复的行cat &lt;filename&gt; | sort | uniq -i # 忽略大小写cat &lt;filename&gt; | sort | uniq -u # 只显示只出现一次的行cat &lt;filename&gt; | sort | uniq -c # 统计每行重复的次数 集合运算接下来，我们强行将 sort 和 uniq 凑到一起，看看会发生什么。 求交集交集就是两个集合都出现的那些元素。放到我们的场景里，就是两个文件重复出现过的行。毫无疑问，我们需要 uniq 的 -d 选项。 1sort &lt;file1&gt; &lt;file2&gt; | uniq -d # 交集 求并集并集就是两个集合的元素加起来，去掉重复的部分。uniq 就是为此而生的。 1sort &lt;file1&gt; &lt;file2&gt; | uniq # 并集 求差集$A \setminus B = {x\mid x \in A \wedge x \not\in B}$，也就是存在于 $A$ 但不存在于 $B$ 的那些。简而言之，这是一个在集合 $A$ 中找到最高贵冷艳的元素的过程。 只要重复了，那就不叫高贵冷艳。同时我们知道，重复一次叫重复；重复两次，那也还是重复。因此，我们只需要将 &lt;file1&gt; 和两份 &lt;file2&gt; 放在一起，寻找只出现过一次的行就可以了。 1sort &lt;file1&gt; &lt;file2&gt; &lt;file2&gt; | uniq -u # 差集 求对称差$A \bigtriangleup B = (A \cup B) - (A \cap B)$。上面已经求得了并集和交集，所以在此基础上求一个差集就好了对吧——你疯啦！？ 对称差，就是要找到两个集合放在一起，也只出现了一次的那些元素。因此只需要简单的 -u 选项就好了。 1sort &lt;file1&gt; &lt;file2&gt; | uniq -u # 对称差集 好了，这就是用 Linux 命令做集合运算的故事了。:)]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>sort</tag>
        <tag>uniq</tag>
        <tag>Set</tag>
        <tag>Operation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存寻址]]></title>
    <url>%2F2016%2F05%2F01%2FIntroduction-to-Memory-Addressing%2F</url>
    <content type="text"><![CDATA[公认的计算机之父是阿兰·图灵在 1936 年提出了「图灵机」的概念。图灵机是一个抽象的计算模型，它可以形象地表述为： 有一个向两端无限延伸的带子，可以在上面记录内容 有一个可以在带子上擦除/写入的读写头，可以在带子上任意移动 有一个控制器，控制读写头的移动和擦除/写入操作 图灵机的表述看似纸上谈兵，但实际与现在计算机的体系结构有良好的对应，甚至可以说是所有现代计算机背后的灵魂。 带子对应于内存（当然内存不能无限大，这限制了计算机的处理能力是有上限的） 读写头可以在带子上任意移动读写对应内存的随机存取（内存的英文名字就是 Random Access Memory） 控制器对应中央处理器 在内存这条带子上，找到正确的位置以便进行存取的过程，就是所谓的「内存寻址」过程。在图灵机这个思想模型中，我们可以假设读写头可以按照要求立即在带子上找到正确的位置。但是在现实生活中，有效地内存寻址是必须要解决的问题。因此，内存寻址可谓是计算机体系结构的核心问题之一。 这篇文章主要讨论 Intel x86 架构上的内存寻址问题。纯干货，吃到撑。 基本概念物理内存和物理地址物理内存指的就是那些看得见摸得着的内存条实际提供的内存空间。 在文章开头处，我们说「在内存这条带子上，找到正确的位置以便进行存取的过程，就是所谓的『内存寻址』过程」。既然有所谓的「正确的位置」，那么就必然有一个描述位置的方法。在内存空间中描述位置的方法，就是内存地址。 对于物理内存来说，我们将它的内存空间按照字节（Byte, 1 Byte = 8 bit）划分开来，并从 0 开始将它们标上号。这些无符号的整数编号，就是物理内存地址。物理地址和地址总线上传输的地址一一对应。 如果正在运行的程序，能够直接通过物理地址操作物理内存，那么写这种代码的方式被称为「硬编码」。在硬编码的情形下，内存寻址的任务最简单：只需要拿着硬编码得到的地址，输进地址总线去访问内存就可以了。 线性内存和线性地址上节提到，物理内存按照字节划分开来，并从 0 开始编号，逐渐增大。这个增大的过程是线性的。 线性内存和物理内存类似，它的地址编号也是从 0 开始，线性增加。线性地址和物理地址的不同在于： 物理地址总是一一对应于实际物理内存空间的位置；但是线性地址则不一定这样：可以有多个线性地址对应到一个物理地址上。 物理地址的增加，总是线性地对应着内存空间的位置；但是线性地址的增加，对应到物理地址上，可以分段跳跃。 逻辑内存（虚拟内存）和逻辑地址（虚拟地址）现代的内存寻址机制，都引入了名为「分段」的概念：不同级别的程序、程序的不同数据类型，存放在不同的「段」上面，然后再定义在「段」上的偏移量。也就是说，现代程序看到的地址都不是线性的，而是分段过的地址，形如：segment:offset。 这些段和偏移量组成的空间，就是逻辑内存空间；这些二元组，就是逻辑地址。 逻辑内存经过转换得到的地址，如果是线性地址，就说明当前机器开启了内存分段机制和分页机制；如果是物理地址，那就说明当前机器只开启了内存分段机制。 宽度计算机体系结构中讲到的宽度，也称位宽，讲的是某个东西在同一时刻能够处理的数据的量。它的单位是数学中数字的「位」；现代计算机是以二进制为基础的，所以它的单位准确来说是「二进制的位数」。 上面提到的「处理」这一动作，根据讨论的对象的不同可能会发生改变。 比如，对于 CPU 中负责进行二进制算数运算的算术逻辑单元（Arithmetic Logic Unit, ALU）来说，它的处理就是进行二进制数的算术运算（二进制的加减乘，不包括除）。于是，如果一个 ALU 能够同时处理 4 bit 数据，也就是能一次计算 4 bit 二进制数的加减乘法，那么它就是一个 4 位的 ALU。对于 CPU 来说，ALU 的位宽也叫字长。 又如，对于负责 CPU 和北桥芯片（Northbridge Chip）的数据传递的前端总线（Front Side Bus, FSB）来说，它的处理就是传递二进制数据。于是，如果一条 FSB 能够一次性传输 8 bit 的数据，那么它就是一条 8 位的 FSB。对于总线来说，位宽也叫带宽。 CPU 的寻址能力浅说这一小节提到的寻址能力，都以 Byte 为单位：亦即在不讨论内存分页的情况下，进行寻址能力的讨论。 对于 $x$ 位 CPU 来说，它一次性能够表示的无符号数的范围是 $ [0, 2^{x} - 1] $。因此，对这枚 CPU 来说，它以字节（Byte）为单位寻址时，最多能在 $2^{x} \text{ Bytes}$ 的内存空间中找到它需要的数据。如果在寻址时，不加入其它信息，那么这是它的寻址能力上限。 CPU 需要通过地址总线去内存寻址。若地址总线的带宽为 $y$ 位，那么在地址总线中传输的物理内存地址的范围是 $ [0, 2^{y} - 1] $。也就是说，地址总线的可寻址空间是 $2^{y} \text{ Bytes}$。地址总线中的地址，是与物理内存地址保持一致的。 因此，如果在寻址时，不加入其它信息，CPU 具体的寻址能力取决于 CPU 本身的位宽和它连接的地址总线的带宽：$2^{\min(x, y)} \text{ Bytes}$。 值得一提的是，二进制数据在计算机内部用电信号表示，每一位二进制，就需要一份电信号。这就是说，在不考虑复用的情况下，$x$ 位的 CPU 需要 $x$ 个引脚与前端总线相连；$y$ 位的地址总线又需要 $y$ 个引脚。因此这枚微处理器的引脚个数必然不小于 $ x + y $。 硬编码的寻址世界上第一款 CPU 是 Intel 公司于 1971 年 11 月 15 日发布的 4004 微处理器。这是一款 4 位的处理器，地址总线的带宽是 12 位的（4004 的引脚个数正是 16 针），能够使用 640 Bytes 的内存。 随后，Intel 公司在 1974 年 4 月发布了 8080 微处理器。这是一款 8 位处理器，它有 7 个累加器：ABCDEHL。其中 A 是主累加器，其余的是次累加器。而次累加器可以配对，比如配对成 BC 或者 HL。两个 8 位的次累加器配对，可以表示 16 位的二进制数。据此，8080 可以访问 $ 2^{16} = 64 \text{ KiB}$ 的内存空间。 这两款 CPU 没有任何分段或分页的概念，都使用的是硬编码的方式去寻址。因此，当 CPU 接收到进程的访存请求后，直接将请求地址传入地址总线，然后去存取内存。可谓是简单粗暴。 实模式与内存分段初步1976 年 3 月，Intel 公司发布了 8086 微处理器，并搭配了 20 位的地址总线。因此，从地址总线的角度来说，8086 应当可以访问 1 MiB 的内存空间。不过，尴尬的是，8086 的 ALU 是 16 位的，也就是它是一个 16 位的处理器。 为什么要用 20 位这么「奇怪」的数字呢？原因有两个：一是当时要凑 1 MiB 的内存，所以地址总线至少得有 20 位的带宽；二是限于当时技术，造不出多于 40 个引脚的 CPU，又因为没有复用技术，所以搭配 16 位 CPU 的话，地址总线带宽最多是 24 位。所以最终就确定了 20 位的地址总线。 好了，再看到之前我们对 CPU 寻址能力的分析，我们就知道：这种时候，必然要引入额外的信息。Intel 将它称之为「内存分段（Segment）」。 具体做法是引入 4 个 16 位的段寄存器：CS, DS, SS 和 ES，分别用来存储程序的代码段、数据段、堆栈段和其他段。具体访问内存的时候，将相应的段寄存器的值左移 4 位，与 CPU 产生的 16 位访存地址相加，这样就得到一个 20 bit 的地址。这种带有分段的寻址模式，叫做实模式（Real Mode）。 举个栗子。假设 ES = 0x1000, DI=0xffff。那么，ES:DI 对应的物理地址就是：AD = ES * 0x10 + DI = 0x1ffff。 对于程序员来说，在采用这种寻址方式的 CPU 上编程时，只需要知道 CPU 的访存地址，不需要去计算 20 位的物理地址——硬件在底层会自动操作。也就是说，程序在运行的时候，进程内部只需要处理一个线性的 offset 即可，至于段基址，依靠操作系统在程序执行时绑定就好。这样一来，程序员在编程时就不需要「硬编码」了，调试和内存相关的错误，也更容易定位了；另一方面，对于编译器来说，也是一种解脱。 问题就此解决了吗？并没有…… 我们知道，20 位的寻址空间，能够表达的地址范围是 0x00000 -- 0xfffff。然而，用实模式寻址，最高能够得到的地址是 0xffff + 0xffff = 0x10ffef。这超出了寻址总线 20 位带宽允许的寻址空间的上限，但在逻辑上却完全正常，这就产生了矛盾。为了解决这个问题，Intel 引入了被称为 Wrap-around 的技术。这一技术是说，当实模式寻址的时候，如果需要访问实际不存在的 0x100000 -- 0x10ffef 范围内的物理内存时，对求得的物理地址用 0xfffff 取模。也就是说，Intel 将上述范围的地址，映射到 0x00000 -- 0x0ffef 上去。 不过，实模式虽然分段，但是只要获取到段寄存器中的地址，任何程序都可以直接操作内存读写。这就产生了两个显而易见的风险： 应用程序可以直接修改内存中的数据，甚至是操作系统的数据。因此，一旦应用程序把内存写烂了，那么整个系统就会立即挂掉。 第二个风险是第一个风险的扩展。因为应用程序可以直接修改内存中的数据，所以应用程序互相之间可能产生干扰。因此，实模式下，程序的安全性无法得到保证，操作系统无法支持多任务。 此外，具体到一个物理地址上，可以有多种不同的表示方式。例如，0x0001:0x0000 和 0x0000:0x0010 都表示的是 0x00010 这个物理地址。这种歧义性，也会带来一些难以控制的风险。 保护模式和内存分段进阶Intel 在 1982 年 2 月发布了它的进化版：80286 (iAPX 286)。80286 和 8086 一样，也是 16 位 CPU，不过搭配的地址总线则上升到了 24 位。因此它可以支持最大 16 MiB 的内存空间。 80286 引入了保护模式。在这种模式下，CPU 够对内存及一些其他外围设备做硬件级的保护设置（实质上就是屏蔽一些地址的访问）。特别地，在访问内存时，程序不能从段寄存器直接获得段的起始地址（段基地址）了，而要进行额外的转换和检查。 具体来说，保护模式中： CPU 的访存地址与 8086 一样，仍旧是 16 位。这意味着，每个内存段的大小上限依旧是 64 KiB。 段寄存器的位宽与 8086 的段寄存器一样，也依然是 16 位。不过，80286 的段寄存器中存放的不在是段基地址，而是一个被称为选择器（Selector）的数据 struct。 CPU 根据选择器中记录的数据，在描述符表（Descriptor Table，亦称段表）中找到段的详细信息，确定段基址和段地址上界，比对访问权级，成功后访问转为相应内存地址访问。 16 位选择器的具体组成如下： 0–1 位：访问权级（0 最高，3 最低） 2 位：段表类型 3–15 位：段表位置索引 其中，最低 2 位的访问权级是保护模式的核心内容，低权级的访存请求不能访问高权级的内存空间。描述符表类型是为了区分全局段表（Global DT, GDT）和进程自己维护的局部段表（Local DT, LDT）。段表的位置索引，则是指引 CPU 去访问段表，查找相应段的具体信息的无符号整数。 段表中的项的结构则比较复杂，不过最重要的信息，是段的起始地址（24 位），以及段的长度（16 位）。 不难看出，80286 引入的保护模式，与 8086 的实模式格格不入。为了 Intel 良好的「兼容传统」，80286 被制作成启动时继承了以前版本芯片的特性，工作在实模式下。这种模式实际上是关闭了新引入的的保护特性，因此过去的软件，可以继续工作在新的芯片下。后续的 x86 处理器都是在计算机加电启动时都是工作在实模式下，只能访问 1 MiB 的内存空间，而后切换到保护模式下。实际上，操作系统启动时最重要的几件事情之一，就是将 CPU 切换为保护模式。 因为 CPU 位宽限制，CPU 每次访存所要访问的物理地址为段表相应条目给出的 24 位段起始物理地址再加上 16 位的偏移量。可见，80286 保护模式下的应用程序能访问的内存线性地址空间仅为 64 KiB，非常有限。所以程序员编写使用大内存的应用程序时还必须使用远指针、近指针，相当繁琐。这种天生残废，影响了 286 保护模式的推广使用。 80386 的分段机制相对于实模式，80286 引入的保护模式无疑是一大进步。然而，80286 的天生残疾，注定了它不会长久。 1985 年 10 月 17 日，Intel 发布 80386。386 是正儿八经的 32 位 CPU——它的 ALU 位宽是 32 位，同时地址总线带宽与此保持一致，也是 32 位的。做一个简单的计算，我们知道，386 的寻址能力已经能够达到 4 GiB。 386 的寄存器在 8086 时代，为了强行寻址 1 MiB 的空间，16 位的 CPU 搭配 20 位的地址总线，不得不发明出内存分段的概念。在 80286 时代，依旧是 16 位的 CPU，但地址总线已经有 24 位。更加显著的差距，加上新引入的保护模式，在兼容的指导思想下，80286 的寻址模式被设计得更加复杂。 按说，80386 的 CPU 和地址总线都是 32 位的，内存寻址的方式应该可以变得十分简洁。然而很遗憾，依旧是「兼容思想」惹的祸，80386 必须兼容实模式，维护那些段寄存器。作为第一个 32 位 CPU，我们来看一下它相对于 16 位的 80286 的变化。 原 16 位的通用寄存器、标志寄存器以及指令寄存器，被扩充为 32 位。 增加 4 个 32 位的控制寄存器。 增加 4 个系统地址寄存器，两个 48 位的，另外两个是 16 位的。 增加 8 个 32 位的调试寄存器。 增加 2 个 32 位的测试寄存器。 段寄存器仍是 16 位；不过在数量上，除了原有的 4 个 CS, DS, SS 和 ES 段寄存器，还增加了 2 个段寄存器：FS 和 GS。 除了 6 个段寄存器，其他寄存器大都扩充到了 32 位甚至更高。唯二的两个 16 位的系统地址寄存器，也是因为分段的缘故，停留在了 16 位。这样的设计，想想当年 Intel 的设计师，估计脸都是黑的。 386 的描述符与 286 一样，引入了保护模式的 386 不再于段寄存器中保存段基址（段的起始地址），而是保存 16 位的选择器；具体选择器的内容也和 286 完全一致。 与 286 不同的是，386 的描述符足有 8 字节（64 位），具体内容如下： 63 – 56 位：段基址的 31 – 24 位。 55 位：寻址粒度位（G）。当 G = 0 时，段长度以字节计算；当 G = 1 时，段长度以分页长度 4 KiB 计算。 54 位：默认操作数位（D）。当 D = 0 时，操作数为 16 位；当 D = 1 时，操作数为 32 位。 53 – 52 位：强行置 0，留作向后兼容。 51 – 48 位：段界限的 19 – 16 位。 47 位：存在位（P）。当 P = 0 时，该段不存在于物理内存中；当 P = 1 时，该段存在于物理内存中。 46 – 45 位：访问权级位（DPL）。与选择符的 0 – 1 位对应，是保护模式的核心。 44 位：系统位（S）。当 S = 0 时，该段为系统段；当 S = 1 时，该段为用户程序的代码段、数据段或堆栈段。 43 – 41 位：类型段。3 位类型段的含义，根据该段的种类（代码段或是数据段、堆栈段）有不同。 40 位：存取权限字节的访问位（A 位）。在分段而不分页的系统中，当该段被访问时，该位置 1；对于使用分页的系统，该段无意义。 39 – 32 位：段基址的 23 – 16 位。 31 – 24 位：段基址的 15 – 8 位。 23 – 16 位：段基址的 7 – 0 位。 15 – 8 位：段界限的 15 – 8 位。 7 – 0 位：段界限的 7 – 0 位。 我们发现，描述符的前 5 字节相对规整，包含 24 位段基址，以及 16 位段界限。实际上，这正是从 286 的描述符继承而来的。描述符的第 7 字节（从 0 开始编号，最后一字节）存放的是段基址的最后 8 位；描述符第 6 字节的前 4 位，存放的是段界限的最后 4 位。这样一来，386 的段基址有 32 位，段界限则是 20 位。因此（参见寻址粒度 G 位），当以字节为单位寻址时，386 的内存分段，最大长度可以达到 1 MiB；而当以（后面将会介绍的）分页为单位寻址时，386 的内存分段，最大长度可以达到 4 GiB。这样一来，286 中令人吐血的「近指针」、「远指针」问题就不存在了。 如果我们把描述符中的内容，简单划分为三部分：段基址（Base）、段界限（Limit）和属性（Attribute），那么段表大致可以用下图所示的表格表示。 图中「索引」指的是选择器中的索引。 386 的段表386 的段表定义了系统中所有段的情况。因为 386 的描述符占 8 个字节，所以 386 的段表的大小，按字节计算，总是 8 的整数倍。段表中，最少含有一个描述符，最多含有 8 Ki 个描述符（选择器的索引位是 13 位）。因此段表的大小应当居于 8 Bytes – 64 KiB 之间。 386 将段表分为了 3 类：全局段表、局部段表和中断段表。全局段表，记录了除中断段表之外，其他所有任务公用的段的描述符；局部段表，则是每个任务都有一个，用于实现任务之间段层次的隔离；中断段表，对于程序员来说，不必太关心。 内存分页机制这一节里，我们仍以 386 为例。 硬件中的内存分页在介绍 386 的段描述符时，我们讲到描述符的第 55 位记录着分段内存的计算方式。当 G = 0 时，分页机制被禁用，逻辑地址经过分段机制转换出来的线性地址以字节计算；当 G = 1 时，分页机制启用，线性地址以分页长度计算。 那么什么叫分页呢？简单来说，分页就是人为地在逻辑上将连续的内存空间，按照固定大小切分成一段一段。对于线性内存来说，这样切分出来的固定大小叫做「页（Page）」；对于物理内存来说，这样切分出来的固定大小叫做「页帧（Page Frame）」。 因此，总结起来，分页机制将线性内存分为若干页，将物理内存分为若干帧，并建立从页到帧的映射关系。这个映射关系，是一个「多对一」的映射。 对于 386 来说，分页长度是 4 KiB。也就是说，对于一个 32 位的线性地址来说，它用末尾的 12 位表示分页内的偏移量。这 12 位的偏移量在页被映射到实际物理内存上的帧时，直接作为物理地址的末尾 12 位。至于线性地址的首 20 位，则作为从页映射到帧的编号参与映射计算。 页帧映射和页表内存分页机制，主要解决的问题，就是当 CPU 取得一个线性地址时，如何将它映射到正确的物理地址上面。这个过程就是页帧映射。 显而易见，最简单的方式是建立一张足够大的表（称为页表）：表中的 key 由线性地址的首 20 位计算得到（或者干脆就是它自己）；表中的 value 则是对应页帧在物理内存中的起始地址（帧基址）。 这种情况下，我们假设极端的情况：每个进程都请求了 4 GiB 的线性空间。按照 4 KiB 每页计算，共需 1 M 个页帧信息。每份页帧信息至少包括 20 位的帧基址，再加上其他信息凑齐 4 Bytes。这样一来，每个进程的页表就需要 4 MiB 的空间。相对于需要高速数据交换的 CPU 来说，这个量太大了。在这种情况下，多级页表出现了。 二级页表多级页表的原理和二级页表一样，所以这里以二级页表为例。 二级页表的原理是这样的： 维护一个大小为 4 KiB 的目录，称为页目录表（一级页表）。一级页表总共 1 Ki 项，对应线性地址的最高 10 位，每一项占 4 Bytes。每个进程在一级页表中对应一个表项，表项指向了进程实际二级页表的位置。 二级页表也是一个大小为 4 KiB 的映射表。二级页表同样一共有 1 Ki 项，对应线性地址中间的 10 位，其中每一项占 4 Bytes。表项记录了帧基址和其他一些控制信息。 高速缓存这样一来，每次从线性地址转换为物理地址，就需要查表两次，每次交换 8 KiB 的数据。对于 CPU 高速频繁访存的操作来说，每次交换这么多数据无法满足性能要求。因此 386 增加了高速缓存机制。 高速缓存将最近的访存页面对应的内容保存其中。当 CPU 访存时，首先在缓存中查询是否有目标页内容：若有，则直接存取内容；否则，再进行二级页表的查询，到内存中存取内容。如果缓存存满了，则根据一定的算法（退场机制），将缓存中的过期数据退场。 根据 Intel 自己的统计，大约 98% 的访存请求可以通过高速缓存处理。亦即，只有 2% 的访存请求，需要进行两次页表查询。可见，高速缓存的存在，大大降低了数据交换的量和频次。因此，高速缓存大大提升了寻址/访存速度。 一级页表项一级页表项占 4 字节，共 32 位。其中： 第 31 – 12 位：20 位的页表地址。之所以可以用 20 位表示页表地址，是因为页表地址的低 12 位总是 0。 第 11 – 9 位：留待操作系统使用。 第 8 位：总是置 0。 第 7 位：扩展分页标志（PSE）。PSE = 0 时，页大小为 4 KiB；PSE = 1 时，页大小为 4 MiB。 第 6 位：总是置 0。 第 5 位：访问位（A）。A = 1 时，说明当前项正在被访问。 第 4 位：高速缓存标志位（PCD）。PCD = 0 时，不启用高速缓存；PCD = 1 时，启用高速缓存。 第 3 位：高速缓存直写标志位（PWT）。PWT = 0 时，访存时只修改内存中的数据；PWT = 1 时，访存时同时修改内存和缓存中的数据。 第 2 – 1 位：页保护位。 第 0 位：存在位（P）。当 P = 1 时，页对应的帧存在于物理内存中；当 P = 0 时，页对应的帧不存在与物理内存中。 值得一提的是，当 P = 0 时，访问该页将会引发一个「缺页错误」。操作系统内核会从交换空间（或者 Windows 的页面文件，都是访问速度更慢一级的硬盘）中交换数据到内存中去。这就是为什么，线性空间可以远远大于实际的物理内存空间的原因。 二级页表项二级页表项同样占据 4 字节，共 32 位。二级页表项的高 20 位，存放的是帧基址；低 12 位的定义和内容含义与一级页表项完全相同；唯独区别在于一级页表项的第 6 位。 第 6 位：存取位（D）。当访存操作会修改内存中保存的内容时，该位置 1；否则置 0。 寻址空间的计算讲清楚了选择符、描述符和段表，我们就以 386 的寻址方案，计算一下 CPU 最多能查找多大的内存空间。 首先，最底层的是描述符。描述符里，段界限占据了 20 位。当描述符粒度位 G = 1 时，段以分页大小 4 KiB 为单位寻址。因此一个描述符，最多能寻址 $2^{32}$ Bytes。 其次，16 位的选择器中，有 13 位用来记录描述符在段表中的索引位置。因此，一个段表可以有 $2^{13}$ 个描述符。 最后，在 16 位的选择器中，第 2 位记录的是段表类型（GDT 还是 LDT）。这样一来，寻址时可以有 2 个段表。 因此，386 的寻址方案，在不讨论扩展分页的情况下，最多能在 $2 \times 2^{13} \times 2^{32} = 2^{46}$ Bytes，也就是 64 TiB 的巨大空间中寻址。这个空间，因为它是从 0 开始编号，逐渐编号到 64 TiB 的，所以我们将它称为「线性空间」。这也就是说，在 386 的分段和分段机制的搭配下，它能够在 64 TiB 的线性空间中寻址。 实际寻址流程当打开分页机制的 80386 接收到程序发来的访存请求 segment:offset 时，CPU 会…… 读取段寄存器中的选择器； 验证访问权级（保护模式）——通过； 根据段表类型和段表位置索引，读取段表中的描述符； 检查访问权级位（保护模式）——通过； 检查 offset，看偏移量是否超过段界限； 检查 P 位，确保目标位置在物理内存中可用； 将段基址与 offset 拼接成线性地址； 检查是否命中高速缓存——未命中； 根据线性地址最高 10 位，读取一级页表； 一级页表检查访问权级——通过； 得到 20 位 + 12 位补 0 的二级页表位置； 根据二级页表位置访问二级页表； 根据线性地址中间 10 位，读取二级页表； 二级页表检查访问权级——通过； 得到 20 位帧基址； 与线性地址的低位 12 位拼接成 32 位的物理地址； 访存。 x86 与 IA32由于 80386 设计的这套架构太流弊，它的后继者门也纷纷沿用并保持兼容。所以后来 Intel 将这套架构称之为 IA32 (32 Bit Intel Architecture)。又因为 IA32 家族最开始的 CPU 名称是 8086, 80286, 80386, 80486，所以，这套架构又被称作是 x86。 后记本文写得太急，内容铺开太广，而作者水平有限。因此，文中难免有疏漏。此外，文章还应该补上许多释义说明的图，然而这几天我把 Mac 里的 TeX 系统折腾挂了，所以没有合适的绘图工具。 诸如此类，待后续修补。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Architecture</tag>
        <tag>CPU</tag>
        <tag>Memory</tag>
        <tag>Addressing</tag>
        <tag>x86</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列化与反序列化简介]]></title>
    <url>%2F2016%2F04%2F21%2FIntroduction-to-Serialization%2F</url>
    <content type="text"><![CDATA[先来个背景音乐。 简介想必读者对编程中的「变量」、「实例（对象）」不会陌生。 变量和实例对应的，是一些有意义的数据。这些数据，在不同编程语言中，可能有不一样的表现；在不同操作系统中，也可能有不一样的形式。现代计算机应用，不可避免地会涉及到多个模块/程序之间的数据交换、不同语言之间的相互协作、计算机之间的数据交互。如果依着操作系统和编程语言的特性，用不同的形式去实现同样的数据，那整个计算机世界就会乱了套了。 数据的序列化和反序列化，就是为了解决这个问题而诞生的。 序列化是说，将变量和实例这些数据，依照某种约定，转化（通常伴随着压缩）为一种通用的数据格式；转化后的数据，可以用来储存或者传输，以备下次读取使用。其中提到的格式可以是二进制的，也可以是字符串式的。反序列化，就是上述过程的补集：将序列化的数据读入，解析为编程语言可识别的数据结构的过程。 序列化协议的特点从上面的简介可以看出，数据序列化的目的是解决跨变成语言、跨操作系统平台的数据传输和储存的问题。这样一来，一个好的序列化协议，就必须： 跨平台，并有多语言支持：这是根本目的。 足够流行：流行程度高意味着使用者众多，协议的基础设施迭代更新快。 足够成熟：协议应该经过足够的测试，和足够长时间的检验。 语言/平台的中立性：协议应该对各个编程语言、操作系统平台一碗水端平，对各个语言、平台的特性支持保持一致。 可读性：如果数据序列化之后的数据人眼可读，那么开发过程中对序列化数据的调试就会变得非常简单。 性能：为了保持原有的数据结构，数据在序列化的过程中，必然会加进额外的描述字段。加入额外的字段，必然会使序列化后的大小大于纯数据的大小，同时也会涉及到序列化、反序列化对描述字段的解读效率的问题。因此一个好的序列化协议，应该在空间复杂度和时间复杂度上有好的表现。 序列化协议的结构那么，一个设计良好的序列化协议，应该由那几部分组成呢？ IDLIDL 是 Interface description language（接口描述语言）的首字母缩写。 上文提到，一个设计良好的序列化协议，应该能够跨平台并支持多种程序设计语言。这也就是说，如果 Alice 在 $A$ 系统上使用 $\alpha$ 语言进行编程，同时 Bob 在 $B$ 系统上使用 $\beta$ 语言进行编程，如果 Alice 和 Bob 使用相同的序列化协议，那么两人的程序序列化的结果在格式上要完全一致，以保证二者的程序可以相互通信。由于操作系统或编程语言的不同，让 Alice 和 Bob 用不同的语言写出完全一样的序列化结构是不现实的，因此我们需要在 Alice 和 Bob 之间搭一座桥梁：这座桥梁可以用于操作系统平台及编程语言无关的方式，描述清楚用于交换的数据格式。这样一来，Alice 和 Bob 只要共同维护用这种方式叙述的清单即可。 这座桥梁，就是所谓的 IDL；用 IDL 叙述的数据原型清单，就是所谓的 IDL 文件。 IDL 编译器接着上文的例子。 假设 Alice 和 Bob 已经共同用 IDL 维护了一份 IDL 文件，现在 Alice 和 Bob 如何分别在 $\alpha$, $\beta$ 语言中使用在 IDL 文件中定义的数据原型呢？以 C++ 为例，我们拿到一份 IDL 文件，就会希望根据这份 IDL 文件，构建一个类。类中包含 IDL 中定义的全部数据原型——他们都应该是 private 的，同时提供 get() 和 set() 接口等等。对于其他语言，也应该有类似的功能。 如果有一个用表意精确的 IDL 语法书写的 IDL 文件，那么根据这个文件手工翻译出各个编程语言的类，显然是不可取的。为了自动化地完成这一步工作，一个设计良好的序列化协议，应该针对各个编程语言设计相应的 IDL 编译器：将 IDL 文件编译（翻译）为相应编程语言的类或动态库。 序列化和反序列化这自然是序列化协议中不可缺少的一部分——毕竟序列化协议就是为此而生的嘛。（笑） 作为一套软件的客户端和服务端，显而易见，二者都应该同时具备对序列化和反序列化的能力： 客户端接受应用层的参数和数据，将其序列化后通过底层传输给服务端；同时，反序列化服务端发会的数据。 服务端接受客户端发来的序列化数据，反序列化后进行相应的处理；再将结果序列化后发回给客户端。 尽管二者职能相近，但是大家给工作在客户端的序列化/反序列化组件起名为 Stub，相对的工作在服务端的组件则被称为 Skeleton。 与数据库做对比数据库作为数据以一定方式储存在一起、能为多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合，其形式与功能和序列化协议有相当高的相似程度。只不过，数据库主要提供了数据存储的场所，而序列化协议则主要提供数据在模块之间通讯的数据标准。 下表将序列化协议和数据库中的组件做了一个简单的对应： 序列化协议 数据库组件 接口描述语言（IDL） 数据定义语言（DDL） 接口描述语言文件（IDL File） 数据库架构（DB Schema） Stub/Skeleton lib Object Relational Mapping]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Serialization</tag>
        <tag>Deserialization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定义一个支持多列对齐的花式 cases 环境]]></title>
    <url>%2F2016%2F04%2F08%2Fan-environment-template-for-multiple-alignment-cases-with-specified-braces%2F</url>
    <content type="text"><![CDATA[现有的 cases 环境，只支持： 左侧的花括号 一个对齐符号 &amp; 如果在 cases 环境里需要多个对齐符号 &amp;，或者希望在它左右有不同风格的括号，就要动一番脑筋了。 定义以下代码借用了 amsmath 和 mathtools 的内部代码，可谓「站在巨人肩膀上」。 不过，也因为借用了内部代码，随着这两个宏包的更新，下列代码可能失效。然而，这两个宏包几乎是 LaTeX 数学公式输出的「基石」，不会经常改动，因此下列代码也多少有些意义。 但无论如何，还是建议在看懂代码的情况下使用；如果看不懂，请慎用，因为我可能不会再维护这段代码（万一以后出问题了的话）。 template123456789101112131415161718192021\usepackage&#123;amsmath&#125;\usepackage&#123;mathtools&#125;\MHInternalSyntaxOn\def\MT_start_cases_ams:n #1&#123;% \RIfM@\else \nonmatherr@&#123;\begin&#123;\@currenvir&#125;&#125; \fi \MH_group_align_safe_begin: \left#1 \alignedat@a&#125;\def\MH_end_cases_ams:&#123;% \endaligned \MH_group_align_safe_end:&#125;\newcommand*\defcases[3]&#123;% \newenvironment&#123;#1&#125; &#123;\MT_start_cases_ams:n &#123;#2&#125;&#125; &#123;\MH_end_cases_ams:\right#3&#125;&#125;\MHInternalSyntaxOff 这里定义了一个命令 \defcases，它接受 3 个参数。 新定义的环境的名字 左边的定界符（可自动伸缩） 右边的定界符（同上） 定义出来的环境，接受 1 个参数，用于指定环境中对齐符号 &amp; 的最大数量。 使用代码： demo.tex1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950\documentclass&#123;article&#125;\usepackage&#123;amsmath&#125;\usepackage&#123;mathtools&#125;\MHInternalSyntaxOn\def\MT_start_cases_ams:n #1&#123;% \RIfM@\else \nonmatherr@&#123;\begin&#123;\@currenvir&#125;&#125; \fi \MH_group_align_safe_begin: \left#1 \alignedat@a&#125;\def\MH_end_cases_ams:&#123;% \endaligned \MH_group_align_safe_end:&#125;\newcommand*\defcases[3]&#123;% \newenvironment&#123;#1&#125; &#123;\MT_start_cases_ams:n &#123;#2&#125;&#125; &#123;\MH_end_cases_ams:\right#3&#125;&#125;\MHInternalSyntaxOff\defcases&#123;mylcases&#125;&#123;\lbrace&#125;&#123;.&#125;\defcases&#123;myrcases&#125;&#123;.&#125;&#123;\rbrace&#125;\defcases&#123;mybcases&#125;&#123;\lbrace&#125;&#123;\rbrace&#125;\defcases&#123;mylrcases&#125;&#123;[&#125;&#123;\rbrace&#125;\begin&#123;document&#125;\[ \begin&#123;mylcases&#125;&#123;2&#125; a &amp;&#123;&#125; = b &amp;&#123;&#125; = c \\ a &amp;&#123;&#125; = b &amp;&#123;&#125; = c \\ a &amp;&#123;&#125; = b &amp;&#123;&#125; = c \end&#123;mylcases&#125;\qquad \begin&#123;myrcases&#125;&#123;2&#125; a &amp;&#123;&#125; = b &amp;&#123;&#125; = c \\ a &amp;&#123;&#125; = b &amp;&#123;&#125; = c \\ a &amp;&#123;&#125; = b &amp;&#123;&#125; = c \end&#123;myrcases&#125;\qquad \begin&#123;mybcases&#125;&#123;2&#125; a &amp;&#123;&#125; = b &amp;&#123;&#125; = c \\ a &amp;&#123;&#125; = b &amp;&#123;&#125; = c \\ a &amp;&#123;&#125; = b &amp;&#123;&#125; = c \end&#123;mybcases&#125;\qquad \begin&#123;mylrcases&#125;&#123;2&#125; a &amp;&#123;&#125; = b &amp;&#123;&#125; = c \\ a &amp;&#123;&#125; = b &amp;&#123;&#125; = c \\ a &amp;&#123;&#125; = b &amp;&#123;&#125; = c \end&#123;mylrcases&#125;\]\end&#123;document&#125;]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>AMS</tag>
        <tag>mathtools</tag>
        <tag>Alignment</tag>
        <tag>Cases</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分图最大匹配问题与匈牙利算法的核心思想]]></title>
    <url>%2F2016%2F04%2F03%2FHungarian-algorithm-in-the-maximum-matching-problem-of-bigraph%2F</url>
    <content type="text"><![CDATA[最近在学习图论相关知识，读到二分图最大匹配问题的匈牙利算法，感觉很有意思，所以记录下来。 概念在假设读者已经了解图论最最基本的概念的基础上（例如：顶点、边、路径、圈），我们先来看一下二分图特有的概念定义。 二分图（Bigraph, Bipartite graph）是一种特殊的图，它的顶点可以被分成两个不相交的集合（$U$ 和 $V$），并且同属一个集合内的点两两不相连（$E_U = E_V = \emptyset$）。这也就是说，如果一个图是二分图，那么它要么没有圈，要么圈所包含的边的数量必定是偶数。 Fig. 1 是一个简单的二分图 为了方便观看我们通常将它画为 Fig. 2 的形式： 匹配（Matching）是边的集合（$M \subset E$），其中任意两条边不共点（$\forall e_1, e_2 \in M\text{ s.t. } e_1 \cap e_2 = \emptyset$）。Fig. 3 中标红的边组成的集合，就是一个匹配。这些标红的边，被称为匹配边；匹配边所连接的点则被称为匹配点。同理可以定义非匹配边和非匹配点的概念。 显而易见，对于一个二分图来说，可能有很多种匹配。如果二分图里的某一个匹配包含的边的数量，在该二分图的所有匹配中最大，那么这个匹配称为最大匹配（Maximum Matching）。Fig. 4 是最大匹配的示例。 在二分图的匹配中，如果一条路径的首尾是非匹配点，路径中除此之外（如果有）其他的点均是匹配点，那么这条路径就是一条增广路径（Agumenting path）。Fig. 5 中，粗红线标出的是匹配路径和匹配点。 显而易见，8-&gt;4-&gt;7-&gt;1-&gt;5-&gt;2 是一条增广路径。因为 8 和 2 作为路径的首尾是非匹配点，而路径中剩余的 4/7/1/5 均是匹配点。 匈牙利算法增广路径的首尾是非匹配点。因此，增广路径的第一条和最后一条边，必然是非匹配边；同时它的第二条边（如果有）和倒数第二条边（如果有），必然是匹配边；以及第三条边（如果有）和倒数第三条边（如果有），一定是非匹配边。 亦即，增广路径从非匹配边开始，匹配边和非匹配边依次交替，最后由非匹配边结束。这样一来，增广路径中非匹配边的数目会比匹配边大 1。 如果我们置换增广路径中的匹配边和非匹配边，由于增广路径的首尾是非匹配点，其余则是匹配点，这样的置换不会影响原匹配中其他的匹配边和匹配点，因而不会破坏匹配；亦即增广路径的置换，可以得到比原有匹配更大的匹配（具体来说，匹配的边数增加了 1）。 由于二分图的最大匹配必然存在（比如，上限是包含所有顶点的完全匹配），所以，再任意匹配的基础上，如果我们有办法不断地搜寻出增广路径，直到最终我们找不到新的增广路径为止，我们就有可能得到二分图的一个最大匹配。这就是匈牙利算法的核心思想。 唯一的问题在于，在这种贪心的思路下，我们如何保证不存在例外的情况，即：当前匹配不是二分图的最大匹配，但已找不到一条新的增广路径。 我们从反证法考虑，即假设存在这样的情况。因为当前匹配不是二分图的最大匹配，那么在两个集合中，分别至少存在一个非匹配点。那么情况分为两种： 这两个点之间存在一条边——那么我们找到了一条新的增广路径，产生矛盾； 这两个点之间不存在直接的边，即这两个点分别都只与匹配点相连——那么： 如果这两个点可以用已有的匹配点相连，那么我们找到了一条新的增广路径，产生矛盾； 如果这两个点无法用已有的匹配点相连，那么这两个点也就无法增加匹配中边的数量，也就是我们已经找到了二分图的最大匹配，产生矛盾。 在所有可能的情况，上述假设都会产生矛盾。因此假设不成立，亦即贪心算法必然能求得最大匹配的解。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Hungarian Algorithm</tag>
        <tag>Maximum Matching</tag>
        <tag>Bigraph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈牛津逗号]]></title>
    <url>%2F2016%2F04%2F02%2Fsomething-about-the-oxford-comma%2F</url>
    <content type="text"><![CDATA[今天接触到了一个挺有意思的概念：牛津逗号。 所谓牛津逗号（Oxford Comma），当然和牛津大学有点关系。牛津逗号，指的是用英文枚举一些示例的时候，紧跟在并列连词（通常是 and 和 or）之前的那个逗号。举个栗子： Mary likes apple, banana, and strawberry. 这个例子里面，and 之前的逗号，就是所谓的牛津逗号。叫它牛津逗号，是因为牛津大学出版社要求作者必须在枚举的并列连词之前加上一个逗号。不过，由于哈佛大学出版社也有这么一个要求，所以这种逗号也可以称为哈佛逗号（Harvard Comma）。当然，你也可以根据它所处的环境，把它叫做 Serial Comma。 牛津逗号可以消除歧义那么，牛津和哈佛，这两所世界最著名的学府，为什么要求作者在行文时注意添加这些逗号呢？一般认为，有以下一些理由： 约定俗成（呃…从中学学英语起，就非常痛恨这个「约定俗成」…说白了就是耍流氓嘛…）； 此处的逗号和通常朗读的抑扬顿挫一致，也就是逗号起到提示停顿的作用（这个听起来还有那么点道理）； 能消除一些歧义（这个似乎才是主要原因和目的）； 分号并列多个项目时，并列连词 and 前是要加上分号的；在这里，逗号应该与其保持一致。 我们举个栗子，来说明牛津逗号是如何消除歧义的： We invited the strippers, JFK and Stalin.We invited the strippers, JFK, and Stalin. 两个句子十分相似，唯一的区别就是 and 前是否有牛津逗号。我们看第一个句子中，顺序枚举了： A: the strippers B: JFK C: Stalin 因此，作者可能想表达的意思是「我们邀请了 A、B、C 过来」。但是，and 作为明确的并列关系词，它能够很强地结合起它前后的并列结构；在这里，就是 B 和 C。因此，按照这种写法，（BC）也可以理解为一个整体；此时 strippers 之后的逗号，就应该被理解为插入语的提示符号。也就是说，这样的句子，也可以理解为「我们邀请了 A：B、C 过来」；亦即，「我们邀请了 A 过来，具体来说，是 B 和 C 两个人」。 第二个句子中，JFK 和 Stalin 之间，除了 and 还有一个牛津逗号。牛津逗号在这里，削弱了 and 作为并列连词的结合作用。于是，在这种情况下，我们只能理解为：我们邀请了 A、B、C 过来，如此一来也就消除了歧义。 引自 http://jandan.net/2011/09/17/fun-with-oxford-comma.html 牛津逗号也可能产生更多的歧义这样看起来，牛津逗号是个好东西啊，大家抓紧用起来就对了。然而，事实总是比想象要残酷一些。我们来看两组句子。 To my parents, Liam and Sophia.To my parents, Liam, and Sophia. 第一句话存在两种理解： 献给我的父母：Liam 和 Sophia。（献给两个人） 献给我的父母、Liam 和 Sophia。（献给四个人） 第二句话，就只有第二种理解。 To my father, Liam and Sophia.To my father, Liam, and Sophia. 此时，第二句话有两种理解： 献给我的父亲、Liam 以及 Sophia。（Liam 不是我的父亲） 先给我的父亲（Liam）以及 Sophia。（Liam 作为插入语出现，他是我父亲） 而第一句话，就只有第一种理解行得通。因为，如果将 Liam and Sophia 当做一个整体，作为 father 之后的插入语，那么 father 就是 Liam 和 Sophia 两个人。而众所周知，一个人只能有一个生父。因此，这里我们只能理解 father/Liam/Sophia 是三个不同的人，在句子中相互并列。 在这两组例子中，我们看到：第一组例子和上一小节举出的例子异曲同工，牛津逗号的出现消除了歧义；而第二组例子则反过来，多出的牛津逗号，反而导致了本不该有的歧义。 分析困境、痛点在哪里？ 在中文语境中，我们没有听说过「清华逗号」或者「北大逗号」的说法。那么我们不禁要去思考，为什么中文不需要规定这样的逗号呢？我们先来看下中文逗号的用法规则： 句子内部主语与谓语之间如需停顿，用逗号； 句子内部动词与宾语之间如需停顿，用逗号； 句子内部状语后边如需停顿，用逗号； 复句内各分句之间的停顿，除了有时要用分号外，都要用逗号； 用来分开句内各语或表示语气的停顿。 很明显，和英文不同，中文的逗号功能很明确：表达停顿。反观英文逗号：英文逗号表示并列的功能，在中文里由顿号实现；表示插入语的功能，在中文中用破折号实现。我们试着用中文改写上面有歧义的例子： To my father, Liam and Sophia.献给我的父亲、Liam 和 Sophia。献给我的父亲——Liam——和 Sophia。 你看，用中文标点时，可以分别表示两种不同的意思，不会引起歧义。 因此，牛津逗号的困境，本质上源于英文中逗号的多种功能：它可以表示并列，但是并列的意味不如明确的 and 强烈；它可以提示插入语，但又可能造成同位的插入语和逗号前的概念不匹配。所以，是否需要加上牛津逗号，要仔细分析后面 and 连接的内容是否可以作为前面概念插入语： 如果可以作为插入语，那么需要在 and 加上牛津逗号以消除歧义（比如 strippers 的例子和 parents 的例子）； 如果不合适作为插入语，那么添加牛津逗号，反而可能造成歧义，因此这种情况最好不要加牛津逗号（比如 father 的例子）。]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>Punctuation</tag>
        <tag>Oxford Comma</tag>
        <tag>Harvard Comma</tag>
        <tag>Serial Comma</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈利用竖式手工开平方]]></title>
    <url>%2F2016%2F03%2F19%2Fmanually-solving-the-square-root%2F</url>
    <content type="text"><![CDATA[前段时间，在知乎上看到有人将「手工开平方」列为失传的技艺。本宝宝表示不服，今天来讲讲竖式开平方的原理和操作方法。 原理简便起见，我们假设有 $$\bigl(\alpha\beta_{(10)}\bigr)^2 = abcd_{(10)}.$$ 其中 $\alpha\beta_{(10)}$ 表示它是一个十进制数；而 $\alpha\beta$ 则表示 $\alpha\cdot\beta$。我们将 $\alpha\beta_{(10)}$ 按进制位拆开： $$\alpha\beta_{(10)} = \alpha * 10^1 + \beta * 10^0$$ 那么有： $$abcd_{(10)} = \alpha^2 * 10^{2 * 1} + 2\alpha\beta* 10^{1 + 0} + \beta^2* 10^{2 * 0}$$ 从这个分析中，我们可以看出来个简单的规律： 平方数 $abcd_{(10)}$ 的高位 $ab_{(10)} * 10 ^{2}$，可以完全地决定它平方根的高位 $\alpha * 10^{1}$。 平方根的低位 $\beta * 10^{0}$ 由平方数的高位和低位共同决定。 我们会用到「和平方公式」： \begin{equation} \label{sum-square} (\alpha + \beta) ^ {2} = \alpha ^ {2} + 2\alpha\beta + \beta ^ {2} \end{equation} 所以，手工开平方的原理，可以简单概括为：从低位开始往高位，两位两位地分割；再从高位往低位，利用和平方公式，逐位地确定平方根。 举个栗子，假设我们要求 $144$ 的平方根（虽然我们都知道是 $12$）。 首先，我们从低位往高位，两位两位地分割，得到 $1$, $44$。注意，这里的 $1$ 指的是 $1 * 10^2$。由于平方数的高位，完全决定平方根的高位。又有： $$ \begin{cases} 1^2 = 1,\\ 2^2 = 4 &gt; 1. \end{cases} $$ 所以，我们确定平方根的高位是 $1$。这也就是说，在公式 \ref{sum-square} 中，我们已经确定 $\alpha = 1 * 10^1 = 10$。现在要求解，满足下式的最大的整数 $\beta$。 $$2 * \alpha * \beta + \beta ^ {2} \leqslant 44 = 144 - 10^2,$$ 这也就是 \begin{equation} \label{getting-b} (2 * \alpha + \beta) * \beta \leqslant 44. \end{equation} 显然，$\beta = 2$ 时，式 \ref{getting-b} 的等号成立。这说明，$144 = (10 + 2)^2 = 12^2$。 操作方法通过上面的原理分析和举例说明，我们不难得到一个 step-by-step 的操作方法。详述如下： 对平方数，从小数点开始，两位两位地向两端划分（向整数部分的高位和小数部分的低位）； 对最高位的分割，假设为 $ab_{(10)}$，求最大的整数 $\alpha$，满足 $\alpha^2 \leqslant ab_{(10)}$； 求余数 $\overline{cd}_{(10)} = abcd_{(10)} - \alpha^2 * 10^2$； 求最大的整数 $\beta$，满足 $(2 * \alpha + \beta) * \beta \leqslant \overline{cd}_{(10)}$； 类似地方法，依次往低位运算，直到求得平方根，或达成目标精度为止。 下面我们通过一个例子，用竖式的方式，遵照上面的步骤，手工开平方根。 首先，考察高位 $6$。我们有 $2^2 \leqslant 6$ 但 $(2 + 1)^2 &gt; 6$。所以平方根首位是 $2$。 接下来，求余数，得 $235$，这就是上述步骤中的 $\overline{cd}_{(10)}$。$2$ 翻倍为 $4$，我们要找满足 $4\beta_{(10)} * \beta \leqslant 235$ 的最大的 $\beta$。求得结果是 $\beta = 5$。 重复地，求余数，得 $1078$。$25$ 翻倍为 $50$，我们要找满足 $50\beta_{(10)} * \beta \leqslant 1078$ 的最大的 $\beta$。求得结果是 $\beta = 2$。 重复地，求余数，得 $7400$。$252$ 翻倍为 $504$，我们要找满足 $504\beta_{(10)} * \beta \leqslant 7400$ 的最大的 $\beta$。求得结果是 $\beta = 1$。 重复地，求余数，得 $235900$。$2521$ 翻倍为 $5042$，我们要找满足 $5042\beta_{(10)} * \beta \leqslant 235900$ 的最大的 $\beta$。求得结果是 $\beta = 4$。 …… 如此重复，可以求得更高的精度。不过，作为演示，这个例子就到此为止了。我们得到结果 $\sqrt{63578} = 252.14\cdots$。]]></content>
      <categories>
        <category>Mathematics and Natural Sciences</category>
      </categories>
      <tags>
        <tag>Square root</tag>
        <tag>Manually</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 中生成包含空列表的特定长度的列表]]></title>
    <url>%2F2016%2F03%2F07%2Fgenerate-fixed-length-of-empty-list%2F</url>
    <content type="text"><![CDATA[最近用 Python 的时候，踩了一个坑。 主需求，是将横向排列为主的二维数组，读入序列化为纵向排列为主的二维数组。为此，需要先确定原数据的列数，然后建立一个特定长度的空列表: 1[[], [], [], ... [], []] 这是个坑Python 的乘法非常神奇。比如有： 123&gt;&gt;&gt; a = [[]] * 2&gt;&gt;&gt; a[[], []] 这个方式非常优雅，所以我首先想到的，就是用这样的乘法生成符合要求的二维空数组。 trap.py123456width = 3a = [list()] * 3b = range (width + 1)for i in xrange (width): a[i].append (b[i + 1])print a 预想中，最后的 print a 应该输出 [[1], [2], [3]]，然而实际上却输出了 1[[1, 2, 3], [1, 2, 3], [1, 2, 3]] 看到这个结果，我直接懵逼了。 出坑原来，Python 里的乘法创建的是实例的引用。也就是说，[list()] * 3 里的（作为元素的）列表，实际是一个实例：修改其中之一，会同步修改到剩余所有的引用。也就是有： 123456&gt;&gt;&gt; a = [[1]] * 2&gt;&gt;&gt; a[[1], [1]]&gt;&gt;&gt; a[0][0] = 2&gt;&gt;&gt; a[[2], [2]] 因此，为了达到我最开始的目的，不能用「魔术乘法」，只能老实地用列表推导式。如： answer.py123456width = 3a = [list() for i in xrange (width)]b = range (width + 1)for i in xrange (width): a[i].append (b[i + 1])print a 得到预期： 1[[1], [2], [3]]]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>List</tag>
        <tag>List Comprehensions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python HTTP 库：requests 快速入门]]></title>
    <url>%2F2016%2F02%2F27%2FThe-requests-library-in-Python%2F</url>
    <content type="text"><![CDATA[2013 年我接触 Python 的时候，就听闻 Python 的网络编程能力十分强大。因此，在熟悉 Python 的基本语法之后，我就和几个小伙伴一起合作，试着用 Python 的 urllib 和 urllib2 库构建了一个百度贴吧 Python 客户端。 然而，使用的过程中，我发现两个标准库的语法并不自然，甚至可以说十分反人类——用着很难受。又有，我平时使用 Python 甚少涉及到网络编程的内容。因此，Python 的网络编程就被我放下了，直到我认识了 requests 库。 初识 requestsrequests 库的宣言是 HTTP for Humans （给人用的 HTTP 库） 我们首先来验证一下。 在网络编程中，最最基本的任务包含： 发送请求 登录 获取数据 解析数据 反序列化打印内容 我们以 GitHub 为例，先看一下使用 urllib2 要怎么做。为了把事情弄简单点，我们假设实现已经知道，GET 请求 https://api.github.com/ 返回的内容是个 JSON 格式的数据（实际上通过 content-type 也能判断）。 123456789101112131415161718192021222324import urllib2import jsongh_url = 'https://api.github.com'cs_user = 'user'cs_psw = 'password'req = urllib2.Request(gh_url)password_manager = urllib2.HTTPPasswordMgrWithDefaultRealm()password_manager.add_password(None, gh_url, cs_user, cs_psw)auth_manager = urllib2.HTTPBasicAuthHandler(password_manager)opener = urllib2.build_opener(auth_manager)urllib2.install_opener(opener)handler = urllib2.urlopen(req)if handler.getcode() == requests.codes.ok: text = handler.read() d_text = json.loads(text) for k, v in d_text.items(): print k, v 如果运行正确，那么代码应该返回： 1234567issues_url https://api.github.com/issuescurrent_user_repositories_url https://api.github.com/user/repos&#123;?type,page,per_page,sort&#125;rate_limit_url https://api.github.com/rate_limitrepository_url https://api.github.com/repos/&#123;owner&#125;/&#123;repo&#125;...user_repositories_url https://api.github.com/users/&#123;user&#125;/repos&#123;?type,page,per_page,sort&#125;team_url https://api.github.com/teams 同样的效果，用 requests 库则有如下代码： 1234567891011import requestscs_url = 'https://api.github.com'cs_user = 'user'cs_psw = 'password'r = requests.get(cs_url, auth=(cs_user, cs_psw))if r.status_code == requests.codes.ok for k, v in r.json().items(): print k, v 溢美之词就不用说了，读到这里的你心里肯定只有一声「卧槽，这才是 Python 该有的样子」。那么，接下来我们看看 requests 都有哪些黑魔法。 安装最推荐的方式，是直接安装推荐过的 Anaconda。 如果你不想安装 Anaconda，那么建议你使用 pip 安装；只需在命令行下执行： 1pip install requests 基本用法requests 的基本用法，呃，真是不能再基本了。最基本的操作，就是以某种 HTTP 方法向远端服务器发送一个请求而已；而 requests 库就是这么做的。 12345678910import requestscs_url = 'http://httpbin.org'r = requests.get("%s/%s" % (cs_url, 'get'))r = requests.post("%s/%s" % (cs_url, 'post'))r = requests.put("%s/%s" % (cs_url, 'put'))r = requests.delete("%s/%s" % (cs_url, 'delete'))r = requests.patch("%s/%s" % (cs_url, 'patch'))r = requests.options("%s/%s" % (cs_url, 'get')) 从语法上看，requests 库设计的非常自然。所谓 requests.get，就是以 GET 方式发送一个 REQUEST，得到一个 Response 类的结果，保存为 r。 你可以在 r 中取得所有你想得到的和 HTTP 有关的信息。下面，我们以 GET 方法为例，依次介绍。 URL 传参 / 获取请求的 URL如果你经常上网（废话，看到这里的都上过网吧……），一定见过类似下面的链接： https://encrypted.google.com/search?q=hello 即： 1&lt;协议&gt;://&lt;域名&gt;/&lt;接口&gt;?&lt;键1&gt;=&lt;值1&gt;&amp;&lt;键2&gt;=&lt;值2&gt; requests 库提供的 HTTP 方法，都提供了名为 params 的参数。这个参数可以接受一个 Python 字典，并自动格式化为上述格式。 1234567import requestscs_url = 'http://www.so.com/s'param = &#123;'ie':'utf-8', 'q':'query'&#125;r = requests.get (cs_url, params = param)print r.url 运行将得到： 1http://www.so.com/s?q=query&amp;ie=utf-8 HTTP 状态码 / 重定向跳转requests 库定义的 Response 类可以方便地获取请求的 HTTP 状态码和重定向状态。 360 公司的搜索引擎，原名「好搜」，现在改为「360 搜索」；域名也从 www.haosou.com 改成了 www.so.com。如果你在地址栏输入 www.haosou.com，那么会经由 302 跳转到 www.so.com。我们借此来演示。 12345678910import requestscs_url = 'http://www.so.com/s'param = &#123;'ie':'utf-8', 'q':'query'&#125;r = requests.get (cs_url, params = param)print r.url, r.status_codecs_url = 'http://www.haosou.com/s'r = requests.get (cs_url, params = param)print r.url, r.status_code, r.history 结果是： 12http://www.so.com/s?q=query&amp;ie=utf-8 200http://www.so.com/s?q=query&amp;ie=utf-8 200 [&lt;Response [302]&gt;] 我们发现，requests 默认自动地处理了 302 跳转。在经过跳转的请求中，返回的 URL 和状态码都是跳转之后的信息；唯独在 history 中，用 Python 列表记录了跳转情况。 大多数情况下，自动处理是挺好的。不过，有时候我们也想单步追踪页面跳转情况。此时，可以给请求加上 allow_redirects = False 参数。 12345678910import requestscs_url = 'http://www.so.com/s'param = &#123;'ie':'utf-8', 'q':'query'&#125;r = requests.get (cs_url, params = param)print r.url, r.status_codecs_url = 'http://www.haosou.com/s'r = requests.get (cs_url, params = param, allow_redirects = False)print r.url, r.status_code, r.history 输出结果： 12http://www.so.com/s?q=query&amp;ie=utf-8 200http://www.haosou.com/s?q=query&amp;ie=utf-8 302 [] 不允许 requests 自动处理跳转后，返回的 URL 和状态码都符合预期了。 超时设置requests 的超时设置以秒为单位。例如，对请求加参数 timeout = 5 即可设置超时为 5 秒。 12345# a very short timeout is set intentionallyimport requestscs_url = 'http://www.zhihu.com'r = requests.get (cs_url, timeout = 0.000001) 返回报错： 1234567891011121314Traceback (most recent call last): File &quot;D:\test\py\test.py&quot;, line 6, in &lt;module&gt; r = requests.get (cs_url, timeout = 0.000001) File &quot;C:\Users\username\AppData\Local\Continuum\Anaconda\lib\site-packages\requests\api.py&quot;, line 69, in get return request(&apos;get&apos;, url, params=params, **kwargs) File &quot;C:\Users\username\AppData\Local\Continuum\Anaconda\lib\site-packages\requests\api.py&quot;, line 50, in request response = session.request(method=method, url=url, **kwargs) File &quot;C:\Users\username\AppData\Local\Continuum\Anaconda\lib\site-packages\requests\sessions.py&quot;, line 465, in request resp = self.send(prep, **send_kwargs) File &quot;C:\Users\username\AppData\Local\Continuum\Anaconda\lib\site-packages\requests\sessions.py&quot;, line 573, in send r = adapter.send(request, **kwargs) File &quot;C:\Users\username\AppData\Local\Continuum\Anaconda\lib\site-packages\requests\adapters.py&quot;, line 419, in send raise ConnectTimeout(e, request=request)requests.exceptions.ConnectTimeout: HTTPConnectionPool(host=&apos;www.zhihu.com&apos;, port=80): Max retries exceeded with url: / (Caused by ConnectTimeoutError(&lt;requests.packages.urllib3.connection.HTTPConnection object at 0x0000000002AFABE0&gt;, &apos;Connection to www.zhihu.com timed out. (connect timeout=1e-06)&apos;)) 请求头我们利用 httpbin 这个网站，先来看一下 requests 发出的 HTTP 报文默认的请求头是什么样子的。 12345import requestscs_url = 'http://httpbin.org/get'r = requests.get (cs_url)print r.content 返回结果： 1234567891011&#123; &quot;args&quot;: &#123;&#125;, &quot;headers&quot;: &#123; &quot;Accept&quot;: &quot;*/*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;python-requests/2.7.0 CPython/2.7.10 Windows/7&quot; &#125;, &quot;origin&quot;: &quot;xx.xx.xx.xx&quot;, &quot;url&quot;: &quot;http://httpbin.org/get&quot;&#125; 注意，这里使用 r.content 来查看请求头部是因为 httpbin 这个网站的特殊性——它什么也不干，就把请求的内容返回给请求者。在 requests 当中，应当使用 r.request.headers 来查看请求的头部。 通常我们比较关注其中的 User-Agent 和 Accept-Encoding。如果我们要修改 HTTP 头中的这两项内容，只需要将一个合适的字典参数传给 headers 即可。 123456import requestsmy_headers = &#123;'User-Agent' : 'From Liam Huang', 'Accept-Encoding' : 'gzip'&#125;cs_url = 'http://httpbin.org/get'r = requests.get (cs_url, headers = my_headers)print r.content 返回： 1234567891011&#123; &quot;args&quot;: &#123;&#125;, &quot;headers&quot;: &#123; &quot;Accept&quot;: &quot;*/*&quot;, &quot;Accept-Encoding&quot;: &quot;gzip&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;From Liam Huang&quot; &#125;, &quot;origin&quot;: &quot;xx.xx.xx.xx&quot;, &quot;url&quot;: &quot;http://httpbin.org/get&quot;&#125; 可以看到，UA 和 AE 都已经被修改了。 响应头作为 HTTP 请求的响应，返回的内容中也有 HTTP 头。它是一个反序列化为 Python 字典的数据结构，可以通过 Response.headers 来查看。 12345import requestscs_url = 'http://httpbin.org/get'r = requests.get (cs_url)print r.headers 返回： 123456789&#123; &quot;content-length&quot;: &quot;263&quot;, &quot;server&quot;: &quot;nginx&quot;, &quot;connection&quot;: &quot;keep-alive&quot;, &quot;access-control-allow-credentials&quot;: &quot;true&quot;, &quot;date&quot;: &quot;Fri, 26 Feb 2016 10:26:17 GMT&quot;, &quot;access-control-allow-origin&quot;: &quot;*&quot;, &quot;content-type&quot;: &quot;application/json&quot;&#125; 响应内容字节模式 / 自动解包长期以来，互联网都存在带宽有限的情况。因此，网络上传输的数据，很多情况下都是经过压缩的。经由 requests 发送的请求，当收到的响应内容经过 gzip 或 deflate 压缩时，requests 会自动为我们解包。我们可以用 Response.content 来获得以字节形式返回的相应内容。 1234567import requestscs_url = 'http://www.zhihu.com'r = requests.get (cs_url)if r.status_code == requests.codes.ok: print r.content 这相当于 urllib2.urlopen(url).read()。 如果相应内容不是文本，而是二进制数据（比如图片），那么上述打印结果可能会糊你一脸。这里以图片为例，示例一下该怎么办。 123456789import requestsfrom PIL import Imagefrom StringIO import StringIOcs_url = 'http://liam0205.me/uploads/avatar/avatar-2.jpg'r = requests.get (cs_url)if r.status_code == requests.codes.ok: Image.open(StringIO(r.content)).show() 运行无误的话，能看到我和我爱人的照片。 文本模式 / 编码如果响应返回是文本，那么你可以用 Response.text 获得 Unicode 编码的响应返回内容。 1234567import requestscs_url = 'http://www.zhihu.com'r = requests.get (cs_url)if r.status_code == requests.codes.ok: print r.text 要获得 Unicode 编码的结果，意味着 requests 会为我们做解码工作。那么 requests 是按照何种编码去对返回结果解码的呢？ requests 会读取 HTTP header 中关于字符集的内容。如果获取成功，则会依此进行解码；若不然，则会根据响应内容对编码进行猜测。具体来说，我们可以用 Response.encoding 来查看/修改使用的编码。 1234567import requestscs_url = 'http://www.zhihu.com'r = requests.get (cs_url)if r.status_code == requests.codes.ok: print r.encoding 反序列化 JSON 数据开篇给出的第一个 requests 示例中，特别吸引人的一点就是 requests 无需任何其他库，就能解析序列化为 JSON 格式的数据。 我们以 IP 查询 Google 公共 DNS 为例： 12345678import requestscs_url = 'http://ip.taobao.com/service/getIpInfo.php'my_param = &#123;'ip':'8.8.8.8'&#125;r = requests.get(cs_url, params = my_param)print r.json()['data']['country'].encode('utf-8') 结果将输出： 1美国 模拟登录 GitHub 看看Cookie 介绍HTTP 协议是无状态的。因此，若不借助其他手段，远程的服务器就无法知道以前和客户端做了哪些通信。Cookie 就是「其他手段」之一。 Cookie 一个典型的应用场景，就是用于记录用户在网站上的登录状态。 用户登录成功后，服务器下发一个（通常是加密了的）Cookie 文件。 客户端（通常是网页浏览器）将收到的 Cookie 文件保存起来。 下次客户端与服务器连接时，将 Cookie 文件发送给服务器，由服务器校验其含义，恢复登录状态（从而避免再次登录）。 Cookie 在 requests 中 Cookie? 你说的是小甜点吧！ 别忘了，requests 是给人类设计的 Python 库。想想使用浏览器浏览网页的时候，我们没有手工去保存、重新发送 Cookie 对吗？浏览器都为我们自动完成了。 在 requests 中，也是这样。 当浏览器作为客户端与远端服务器连接时，远端服务器会根据需要，产生一个 SessionID，并附在 Cookie 中发给浏览器。接下来的时间里，只要 Cookie 不过期，浏览器与远端服务器的连接，都会使用这个 SessionID；而浏览器会自动与服务器协作，维护相应的 Cookie。 在 requests 中，也是这样。我们可以创建一个 requests.Session，尔后在该 Session 中与远端服务器通信，其中产生的 Cookie，requests 会自动为我们维护好。 POST 表单POST 方法可以将一组用户数据，以表单的形式发送到远端服务器。远端服务器接受后，依照表单内容做相应的动作。 调用 requests 的 POST 方法时，可以用 data 参数接收一个 Python 字典结构。requests 会自动将 Python 字典序列化为实际的表单内容。例如： 12345678910import requestscs_url = 'http://httpbin.org/post'my_data = &#123; 'key1' : 'value1', 'key2' : 'value2'&#125;r = requests.post (cs_url, data = my_data)print r.content 返回： 12345678&#123; ... &quot;form&quot;: &#123; &quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot; &#125;, ...&#125; 实际模拟登录 GitHub 试试看模拟登录的第一步，首先是要搞清楚我们用浏览器登录时都发生了什么。 GitHub 登录页面是 https://github.com/login。我们首先清空浏览器 Cookie 记录，然后用 Chrome 打开登录页面。 填入 Username 和 Password 之后，我们打开 Tamper Chrome 和 Chrome 的元素审查工具（找到 Network 标签页），之后点登录按钮。 在 Tamper Chrome 中，我们发现：虽然登录页面是 https://github.com/login，但实际接收表单的是 https://github.com/session。若登录成功，则跳转到 https://github.com/ 首页，返回状态码 200。 而在 Chrome 的审查元素窗口中，我们可以看到提交给 session 接口的表单信息。内里包含 commit utf8 authenticity_token login password 其中，commit 和 utf8 两项是定值；login 和 password 分别是用户名和密码，这很好理解。唯独 authenticity_token 是一长串无规律的字符，我们不清楚它是什么。 POST 动作发生在与 session 接口交互之前，因此可能的信息来源只有 login 接口。我们打开 login 页面的源码，试着搜索 authenticity_token 就不难发现有如下内容： 1&lt;input name="authenticity_token" type="hidden" value="......" /&gt; 原来，所谓的 authenticity_token 是明白卸载 HTML 页面里的，只不过用 hidden 模式隐藏起来了。为此，我们只需要使用 Python 的正则库解析一下，就好了。 这样一来，事情就变得简单起来，编码吧！ 模拟登录 GitHub12345678910111213141516171819202122232425262728import requestsimport recs_url = 'https://github.com/login'cs_user = 'user'cs_psw = 'psw'my_headers = &#123; 'User-Agent' : 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36', 'Accept' : 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Accept-Encoding' : 'gzip', 'Accept-Language' : 'zh-CN,zh;q=0.8,en;q=0.6,zh-TW;q=0.4'&#125;sss = requests.Session()r = sss.get(cs_url, headers = my_headers)reg = r'&lt;input name="authenticity_token" type="hidden" value="(.*)" /&gt;'pattern = re.compile(reg)result = pattern.findall(r.content)token = result[0]my_data = &#123; 'commit' : 'Sign in', 'utf8' : '%E2%9C%93', 'authenticity_token' : token, 'login' : cs_user, 'password' : cs_psw&#125;cs_url = 'https://github.com/session'r = sss.post(cs_url, headers = my_headers, data = my_data)print r.url, r.status_code, r.history 输出： 1https://github.com/ 200 [&lt;Response [302]&gt;] 代码很好理解，其实只是完全地模拟了浏览器的行为。 首先，我们准备好了和 Chrome 一致的 HTTP 请求头部信息。具体来说，其中的 User-Agent 是比较重要的。而后，仿照浏览器与服务器的通信，我们创建了一个 requests.Session。接着，我们用 GET 方法打开登录页面，并用正则库解析到 authenticity_token。随后，将所需的数据，整备成一个 Python 字典备用。最后，我们用 POST 方法，将表单提交到 session 接口。 最终的结果也是符合预期的：经由 302 跳转，打开了（200）GitHub 首页。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>HTTP</tag>
        <tag>Library</tag>
        <tag>requests</tag>
        <tag>urllib</tag>
        <tag>urllib2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合算法（C++ 实现）]]></title>
    <url>%2F2016%2F01%2F31%2Fbinomial-in-cpp%2F</url>
    <content type="text"><![CDATA[排列组合是高中数学中比较难的部分。用我高中数学老师的话说，叫做「会者不难，难者不会」，说是排列组合基本靠悟。 高中数学中，排列组合相关的题目，重点是求在某个场景下，排列/组合的可能数是多少，并不要求学生列出这些可能的排列/组合分别是什么。在实际工程应用中，有些场景却会有这样的需求。 在 Python 中，标准库 itertools 提供了排列、组合、笛卡尔积的方法。然而在 C++ 中，标准库只提供了 next_permutation 和 prev_permutation，通常来说不太够用。 这里，我们给出两种思路的算法。 二进制辅助的方法我们先来讨论一下非递归的方法。 对于组合来说，对每个元素是否选取，只有「选」和「不选」两种状态。因此，我们可以用一串二进制，来表示「选与不选」。例如：10110 表示五选三时，第一位、第三位和第四位被选择，剩下两位则不选。 接下来，我们要非重复、不遗漏地找到所有可能的组合方式，就有必要找到某种顺序。这种顺序应该满足： 不重复 不遗漏 有某种可以观察的良好性质 在计算机上容易实现 不难想到，如果我们以二进制来表示一种组合状态，那么它就对应着一个十进制数。比如五选三时，就是要求解五位二进制数中，有三个数位是 1 的全部可能性。要不重复不遗漏地找出这些可能性，我们可以很简单地定义这样的顺序：找到满足五位二进制数中有三个数位是 1 的数字的升序排列。 我们首先来看看一个已经排序好的序列： 1234567891011100 -&gt; 7 (左边表示低位，即实际的二进制数应是 00111。下同)11010 -&gt; 1110110 -&gt; 1301110 -&gt; 1411001 -&gt; 1910101 -&gt; 2101101 -&gt; 2210011 -&gt; 2501011 -&gt; 2600111 -&gt; 28 不难发现，这实际上是一个「逐位移动」的问题。想要得到升序中相邻的数，显而易见，应该将低位的 1 与相邻的高位的 0 交换位置。也就是说，提高了这个 1 的权重。同时，应该将比发生换位的 1 低位的所有的 1 挪到最低位。 放进我们的示例当中，就有伪代码： 1234567891011Given: int: choose, fromOutout: vector&lt;string&gt;: result---working &lt;- &quot;1&quot; * choose + &quot;0&quot; * (from - choose)result.append(working)while (found(10)) swap (found(10)) sort (working, working + found(10), reverse = true) result.append(working) 这样，我们可以写出相应的 C++ 代码： binomial.cc12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;string&gt;&amp; combination (vector&lt;string&gt;&amp; res, const size_t&amp; choose, const size_t&amp; from);bool compare (const char&amp; lhs, const char&amp; rhs);int main () &#123; vector&lt;string&gt; res; const size_t choose = 3, from = 5; combination (res, choose, from); for (size_t i = 0; i != res.size(); ++i) &#123; cout &lt;&lt; res[i] &lt;&lt; '\t'; for (size_t j = 0; j != from; ++j) &#123; if (res[i][j] == '1') &#123; cout &lt;&lt; j + 1 &lt;&lt; ' '; &#125; &#125; cout &lt;&lt; endl; &#125; return 0;&#125;vector&lt;string&gt;&amp; combination (vector&lt;string&gt;&amp; res, const size_t&amp; choose, const size_t&amp; from) &#123; string wk = string (choose, '1') + string (from - choose, '0'); res.push_back (wk); size_t found = string::npos; while ((found = wk.find("10")) != string::npos) &#123; // 1. swap found wk[found] ^= wk[found + 1]; wk[found + 1] ^= wk[found]; wk[found] ^= wk[found + 1]; // 2. sort before sort (wk.begin(), wk.begin() + found, compare); res.push_back (wk); &#125; return res;&#125;bool compare (const char&amp; lhs, const char&amp; rhs) &#123; return lhs &gt; rhs;&#125; 这里我用 std::string 实现了算法。实际上，可以用更快的 cstring 来实现（因为它实际是数组）。 平凡的递归解法现在我们来看看求解组合的递归算法。 首先，我们回忆一下高中数学中提到的组合数递推关系： \begin{equation} \label{eq:binomial-re} \mathrm{C}_n^m = \mathrm{C}_{n - 1}^{m - 1} + \mathrm{C}_{n - 1}^{m}. \end{equation} 在高中讲到组合数时，老师一定根据组合数的定义，手工推导了这一递推关系。但是，当时老师并不一定讲了这个递推关系的内在含义。 实际上，这个递推关系有着明确的意义。我们考虑从 $n$ 个物件中取出 $m$ 个物件的情况（$m &lt; n$）。对第一个物件来说，我们要不然选它，然后在剩下的 $n - 1$ 个物件中取出 $m - 1$ 个物件；要不然不选它，然后干脆地在剩下的 $n - 1$ 个物件中取出 $m$ 个物件。 将这两种情况合起来，就得到公式 \ref{eq:binomial-re} 了。 上述分析给出了明确的递归思路，那么不难得到下面的代码： binomial.cc12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;vector&lt;string&gt;&amp; combination (vector&lt;string&gt;&amp; res, const size_t&amp; choose, string&amp; working, const size_t&amp; pos);int main () &#123; vector&lt;string&gt; res; const size_t choose = 3; string working (5, '0'); combination (res, choose, working, 0); for (size_t i = 0; i != res.size(); ++i) &#123; cout &lt;&lt; res[i] &lt;&lt; '\t'; for (size_t j = 0; j != working.size(); ++j) &#123; if (res[i][j] == '1') &#123; cout &lt;&lt; j + 1 &lt;&lt; ' '; &#125; &#125; cout &lt;&lt; endl; &#125; return 0;&#125;vector&lt;string&gt;&amp; combination (vector&lt;string&gt;&amp; res, const size_t&amp; choose, string&amp; working, const size_t&amp; pos) &#123; if (choose &gt; working.size() - pos) return res; for (size_t i = pos; i != working.size(); ++i) &#123; working[i] = '0'; &#125; if (choose == 0 || pos == working.size()) &#123; res.push_back (working); return res; &#125; working[pos] = '1'; combination (res, choose - 1, working, pos + 1); working[pos] = '0'; combination (res, choose, working, pos + 1); return res;&#125;]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Combination</tag>
        <tag>Binomial</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用美赛模板 mcmthesis]]></title>
    <url>%2F2016%2F01%2F27%2Fhow-to-use-mcmthesis%2F</url>
    <content type="text"><![CDATA[最早由王昭礼编写制作的 mcmthesis 模板，服务了许多届参加美国大学生数学建模竞赛（简称：美赛）的大学生。2014 年我接手了模板的开发和维护工作，将模板由宏包改为文档类，并上传至 CTAN。截至今日，TeX Live (2015 及之后的版本) 和 MiKTeX 均收录了这个模板。 这篇文章将介绍一下模板的基本情况和用法。 在所有的正文内容开始之前，我认为有必要做一些简短的说明。 美赛并没有强制要求必须使用 LaTeX 排版参赛论文，使用 Microsoft Office Word 进行论文的编排也是可以的。往年也有很多使用 Word 排版出的优秀论文的获奖情况。 LaTeX 是一个「精致的」文书准备系统，使用起来有一定的门槛。虽然 mcmthesis 已经在很大程度上减少了美赛参与者在这方面的工作了，但是我不推荐毫无 LaTeX 使用经验的参赛者使用。 如果你确实毫无使用经验，或是自我感觉对 LaTeX 的了解还有很多模糊的地方，建议你先看一下这篇文章。 LaTeX 圈子流行着一句话：使用模板就不要管格式。简单来说，目前的模板已经适配了美赛官方对论文格式的全部要求，不需要用户再做任何修改。在美赛有限的参赛时间内，纠结诸如「给目录中的 \section 添加引导符」之类的审美上的需求，纯粹是自作自受且自讨苦吃。 下面开始正文。 获取模板普通用户对于普通用户来说，建议认真阅读这段文字，不要采用高级用户手工编译安装的方式安装。所谓「普通用户」指得就是你。 对于普通用户来说，建议使用所谓「即开即用」的版本。 安装好一个 TeX 发行版，推荐 TeX Live/MiKTeX；不推荐 CTeX 套装。 前往发布页面，下载最新的稳定版本。 解开压缩包。 阅读 mcmthesis.pdf 及本文后，编辑 mcmthesis-demo.tex 文件，直接开始使用。 中级用户前文已经提到，模板已经被 TeX Live 和 MiKTeX 收录。因此，使用这两个发行版的用户，可以通过相应的宏包管理器安装。如果你已经预先安装了所有宏包，那么可以跳过「获取模板」这一节，直接使用。建议完全的新手安装所有宏包，避免以后缺少宏包带来的麻烦。 至于 CTeX 套装的用户，请卸载干净 CTeX，而后安装 TeX Live 和你喜欢的编辑器；或者使用上述「即开即用」的版本。 TeX Live在系统命令行下执行： 123tlmgr option repository http://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnettlmgr update --self --all --reinstall-forcibly-removedtlmgr install mcmthesis 这里第一行，我们使用清华大学的镜像；如果你有更好的选择，也可以设置为你喜欢的镜像。第二行，将现有的宏包都更新到最新。第三行，安装 mcmthesis 模板。 注意，在 Linux/Mac OS X 系统中运行，你可能需要使用 sudo 前缀，以 root 权限执行。 MiKTeXMiKTeX 的宏包管理器有比较好的图形化前端。从开始菜单找到 MiKTeX -&gt; Maintenance (Admin) -&gt; Package Manager (Admin)，打开包管理器。然后选中 mcmthesis 宏包，再点安装按钮就好了。不明白的话，这里有别人做的 Youbute 的视频：Installing a package with MikTeX。 高级用户 模板的官方主页是：http://www.ctan.org/pkg/mcmthesis 模板的开发主页是：http://github.com/Liam0205/mcmthesis 作者王昭礼的主页是：http://www.latexstudio.net 我的主页是：https://liam.page 你可以在模板的官方主页下载到模板源文件。解包之后，打开系统命令行，依次执行： 123456789cd /path/to/mcmthesisxetex mcmthesis.dtxxelatex mcmthesis.dtxxelatex mcmthesis.dtxxelatex mcmthesis-demo.texxelatex mcmthesis-demo.texmv LICENSE.tex LICENSEmv README.tex READMErm *.log *.out *.aux *.glo *.idx 接下来： 1234567mkdir TEXMF/tex/latex/mcmthesis/mv mcmthesis.cls TEXMF/tex/latex/mcmthesis/mkdir TEXMF/source/latex/mcmthesis/mv mcmthesis.dtx TEXMF/source/latex/mcmthesis/mkdir TEXMF/doc/latex/mcmthesis/mv ./* TEXMF/doc/latex/mcmthesis/texhash 如果你在执行上面任何一步遇到了问题，说明你可能不是「高级用户」，请参照普通用户的安装方法进行安装。 初识模板阅读模板说明我们要养成良好的习惯，在使用新的工具之前，阅读它的说明书。TeX 系统提供了 texdoc 命令，用于调取各个宏包/组件的说明书。使用方法也很简单，只需要在命令行执行 texdoc &lt;name&gt; 就可以了。例如： 1texdoc mcmthesis 会打开 mcmthesis 的说明书。而： 1texdoc mcmthesis-demo 则会打开使用 mcmthesis 模板编译的示例文档。 Hello World我们构建最简单的示例看看： demo.tex1234567891011121314151617181920212223%!TeX program = xelatex%!TeX builder = latexmk\documentclass&#123;mcmthesis&#125;\usepackage&#123;blindtext&#125; % 提供 \blindtext 命令，演示用\title&#123;The Title&#125;\author&#123;Liam Huang&#125;\date&#123;today&#125;\begin&#123;document&#125;\begin&#123;abstract&#125;\blindtext % 演示用无意义文字\begin&#123;keywords&#125;keyword1; keyword2\end&#123;keywords&#125;\end&#123;abstract&#125;\maketitle % 打印控制页等\blindtext % 演示用无意义文字\end&#123;document&#125; 使用 XeLaTeX 编译后，效果如图： 调整选项mcmthesis 提供了 \mcmsetup 命令来调整模板的行为。具体使用方法是载入 mcmthesis.cls 之后调用，例如： 12\documentclass&#123;mcmthesis&#125;\mcmsetup&#123;tcn = 12345, problem = B, titlepage = false&#125; 队伍控制号码 / tcn每个美赛参赛队伍，都会由赛事主办方提供一个唯一的控制号码（Team Control Number）。主办方要求该号码必须出现在摘要页上，以及之后正文的页眉中。mcmthesis 通过选项 tcn 来设定该号码，如果不进行设置，将使用默认的 0000。 1\mcmsetup&#123;tcn = 0000&#125; 选题 / problem每个参赛队伍能且只能选择一个题目进行作答。赛事主办方要求参赛队伍将选题的题号标注在摘要页上。mcmthesis 通过选项 problem 来设定选题，如果不进行设置，将使用默认的 A。 1\mcmsetup&#123;problem = A&#125; 摘要页 / sheetmcmthesis 用 LaTeX 代码实现了自己的摘要页。如果你觉得默认的摘要页效果不满意，希望使用学校提供的摘要页，或者你有自信用 LaTeX 自己实现摘要页，那么你可以将该选项设置为 false，关闭 mcmthesis 的摘要页输出。如果不进行设置，将使用默认的 true，即输出 mcmthesis 摘要页。 1\mcmsetup&#123;sheet = true&#125; 摘要页中的标题 / titleinsheet如果参赛者希望在摘要页中「Summary」的上方显示文章标题，那么可以将该选项设置为 true。如果不进行设置，将使用默认的 false，即不在摘要页中显示文章标题。 1\mcmsetup&#123;titleinsheet = false&#125; 注意，赛事主办方没有对摘要页中是否显示文章标题做具体规定。但是，对于主办方来说，在初审（即只看摘要页中的摘要内容）时对文章标题并无兴趣。因此默认设置为 false。 摘要页中的关键字 / keywordsinsheet如果参赛者希望在摘要页中「Summary」的下方显示关键字，那么可以将该选项设置为 true。如果不进行设置，将使用默认的 false，即不在摘要页中显示关键字。 1\mcmsetup&#123;keywordsinsheet = false&#125; 注意，赛事主办方没有对摘要页中是否显示关键字做具体规定。但是，对于主办方来说，每篇文章的关键字其实都差不多，加上关键字对初审并没有提高多少信息量，反而显得累赘。因此默认设置为 false。 标题页 / titlepage如果参赛者不希望在摘要页后显示 LaTeX 标准的标题页，那么可以将该选项设置为 false。如果不进行设置，将使用默认的 true，即 mcmthesis 会在摘要页后显示 LaTeX 标准的标题页。 1\mcmsetup&#123;titlepage = true&#125; 标题页中的摘要 / abstract如果参赛者认为，摘要页已经显示过一次摘要，在标题页显示摘要有些累赘，故而不希望在摘要页后的标题页中显示摘要（和关键字），那么可以将该选项设置为 false。如果不进行设置，将使用默认的 true，即 mcmthesis 会在标题页中显示摘要。 1\mcmsetup&#123;abstract = true&#125; CTeX 套装兼容选项 / CTeX v6.0 及之后版本有此选项 当你使用 CTeX 套装时，请将该选项设置为 true。如果不进行设置，将使用默认的 false，即关闭与 CTeX 套装的兼容。 1\mcmsetup&#123;CTeX = false&#125; 不建议使用 CTeX 套装 定制摘要页头部内容 v6.2 及之后版本有此选项 MCM/ICM 的主办方经常变动摘要页头部的年份及赛事名称说明的格式，可谓岁岁年年各不同。因此，模板很难保证这部分的格式与当年的要求完全一致，故而给出一个易于修改的接口。例如： 1\renewcommand&#123;\headset&#125;&#123;&#123;\Large\the\year&#125;\\MCM/ICM\\Summary Sheet&#125; 将输出： 结语对于大多数中国的大学生来说，参加美赛可能是第一次接触 LaTeX。这是一个好机会，但时间上却显得紧迫。因此，王昭礼和我先后维护了 mcmthesis 模板，希望参加美赛的 LaTeX 用户，在格式上花费最少的时间，办最好的事（即输出效果最好的文章）。 然而，除却模板规定的格式之外，文章质量的好坏，还与用户对 LaTeX 的了解以及用户的代码书写习惯有很大关系。因此，前文才提到「不建议新手使用」的说法。 不过，年年美赛，看着一茬又一茬的学生投入美赛并使用自己写的模板，还是很有成就感的。总的来说，祝各位美赛好运！]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>mcmthesis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 BibTeX 生成参考文献列表]]></title>
    <url>%2F2016%2F01%2F23%2Fusing-bibtex-to-generate-reference%2F</url>
    <content type="text"><![CDATA[LaTeX 是一些理工专业论文排版的事实标准。既然是论文排版，就不可避免会涉及到参考文献的处理。Oren Patashnik 和 Leslie Lamport 在 1985 年开发的 BibTeX 是在 LaTeX 社区相当流行的参考文献格式化工具。 其实网络上流传的 BibTeX 教程很多，本不用我再来插一句嘴。不过这么多年来，始终有很多朋友会对几个问题反复提问。这让我感到，现有的教程恐怕是不够的。这篇文章尝试将 BibTeX 的基本用法讲解清楚，同时适当地提及一些处理流程，争取在有限的篇幅里，讲清楚 BibTeX 的来龙去脉。 bst 和 bib 格式简介BibTeX 涉及到两种特有的辅助的文件格式：bst 和 bib。 bst 是 (B)ibliography (ST)yle 的缩写。顾名思义，和 sty 文件是 style 的缩写一样，bst 文件控制着参考文献列表的格式。在这里说的「格式」，主要指参考文献列表中的编号、排序规则、对人名的处理（是否缩写）、月份的处理（是否缩写）、期刊名称的缩写等。 bib 是 BibTeX 定义的「参考文献数据库」。通常，我们会按照 BibTeX 规定的格式，向 bib 文件写入多条文献信息。在实际使用时，我们就可以根据 bib 文件中定义的文献标记（label），从数据库中调取文献信息，继而排版成参考文献列表。 值得注意的是，bib 是一个数据库，其中的内容并不一定等于 LaTeX 排版参考文献列表时的内容。也就是说，如果 bib 数据库中有 10 条文献信息，并不一定说 LaTeX 排版出来的 PDF 文件中，参考文献列表里也一定有 10 条。实际排版出来的参考文献列表中有多少条文献，实际是哪几条，具体由文中使用的 \cite 命令（以及 \nocite 命令）指定。如果没有使用 \cite 命令调取文献信息，那么即使在 bib 文件中定义了文献信息，也不会展现在参考文献列表中。很多人对此误解甚深，于是经常有人问道「为什么我在 bib 文件里写的文献，不出现在参考文献中」之类的问题。 BibTeX 的工作流程介绍中提到，BibTeX 是一个参考文献格式化工具。这个定义，给 BibTeX 的用处做了良好的界定：BibTeX 不是用来排版参考文献的，更不是个排版工具，它只是根据需要，按照（bst 文件规定的）某种格式，将（bib 文件中包含的）参考文献信息，格式化 为 LaTeX 能够使用的列表信息。 清楚了 BibTeX 需要做的事情（用软件工程的话说，就是清楚了 BibTeX 的 API），我们就可以理清 BibTeX 的工作流程。 知道需要哪些参考文献信息既然 BibTeX 会根据需要 格式化数据，那么首先要解决的问题就是：BibTeX 如何了解此处的「需求」。 对 BibTeX 稍有了解的读者可能知道，运行 BibTeX 的命令行命令是： 1bibtex foo.aux # 其中后缀名 .aux 可以省略 实际上，BibTeX 正是通过读取 aux 文件中的 \citation{} 标记，来确定用户需要哪些参考文献的。 举个例子，假设用户用 LaTeX 编译了以下代码： foo.tex1234\documentclass&#123;article&#125;\begin&#123;document&#125;bar\cite&#123;baz&#125;\end&#123;document&#125; 如果该文件名为 foo.tex，那么就会生成 foo.aux。其内容大约是： foo.aux12\relax\citation&#123;baz&#125; 在这里，\relax 表示休息一会儿，什么也不做；\citation 则是由 tex 文件中的 \cite 命令写入 aux 文件的标记。它说明了：用户需要标记为 baz 的参考文献信息。 当 BibTeX 读入 aux 文件的时候，它就会记录下所有 \citation 命令中的内容（即文献标记——label），这样就知道了用户需要哪些参考文献信息。 了解文献列表格式以及读取文献数据库当 BibTeX 清楚了用户需要哪些文献信息，接下来自然应该搞清楚用户想要什么样的格式。而知道了格式之后，就可以从数据库中抽取所需的文献信息，按照格式准备数据。 为了讲清楚这个步骤，我们对上述 LaTeX 代码做些许的修改。 foo.tex123456\documentclass&#123;article&#125;\begin&#123;document&#125;\bibliographystyle&#123;unsrt&#125;bar\cite&#123;baz&#125;\bibliography&#123;foobar&#125;\end&#123;document&#125; 同样，我们将它保存为 foo.tex，经由 LaTeX 编译之后得到一个 foo.aux 文件，其内容如下： foo.aux1234\relax\bibstyle&#123;unsrt&#125;\citation&#123;baz&#125;\bibdata&#123;foobar&#125; 简单的对比，不难发现： foo.tex 中新增的 \bibliographystyle{unsrt} 与 aux 文件中的 \bibstyle{unsrt} 相对应。 foo.tex 中新增的 \bibliography{foobar} 与 aux 文件中的 \bibdata{foobar} 相对应。 根据命令的名字，我们很容易猜测各个命令的作用。tex 文件中的 \bibliographystyle 指定了用户期待的参考文献列表格式文件，并将其写入 aux 文件备用，通过 \bibstyle 标记。与此同时，\bibliography 命令则用 \bibdata 在 aux 文件中记录了参考文献数据库的名字（不含扩展名）。 在这里，unsrt 是 unsort 的缩写，它对应着 unsrt.bst 文件，是大多数 TeX 发行版自带的标准格式文件之一；foobar 则对应着 foobar.bib 文件，该文件是用户自己编写或生成的参考文献数据库。 实际操作看看我们假设上述 foobar.bib 文件有如下内容： foobar.bib1234567@BOOK&#123; baz, title = &#123;Dummy Book&#125;, publisher = &#123;Egypt&#125;, year = &#123;321&#125;, author = &#123;The King&#125;&#125; 我们在命令行执行以下操作： 12latex foo.tex # .tex 可以省略bibtex foo.aux # .aux 可以省略 我们会发现，BibTeX 生成了两个文件：foo.bbl 和 foo.blg。其中 foo.bbl 的内容如下： foo.bbl12345678\begin&#123;thebibliography&#125;&#123;1&#125;\bibitem&#123;baz&#125;The King.\newblock &#123;\em Dummy Book&#125;.\newblock Egypt, 321.\end&#123;thebibliography&#125; 显然，这就是一个标准的 LaTeX 环境。对 LaTeX 参考文献排版稍有了解的读者可能知道 thebibliography 环境正是 LaTeX 中手工编排参考文献时使用的环境。因此，foo.bbl 就是 BibTeX 格式化输出的结果，LaTeX 只需要将该文件的内容读入，就能在相应的位置输出格式化之后的参考文献列表了。 接下来，我们看看 foo.blg 的内容。blg 实际是 BibTeX Log 的缩写，亦即这是一个日志文件。 foo.blg1234567This is BibTeX, Version 0.99d (TeX Live 2015)Capacity: max_strings=35307, hash_size=35307, hash_prime=30011The top-level auxiliary file: foo.auxThe style file: unsrt.bstDatabase file #1: foobar.bibYou've used 1 entry,... 我们看到，BibTeX 打出的日志文件中，记录了读入 aux/bst/bib 文件的情况。特别地，记录了所需的参考文献条目（entry）的数量（此处为 1）。 日志中值得注意的地方是在提到 bib 文件时，使用了 #1 的标记。既然存在 #1，那么合理推测也可以存在 #2。也就是说，BibTeX 可能支持两个或更多的 bib 数据库共同工作。具体如何实现，请读者自己阅读相关资料（手册或 Google 检索）后实验。 紧接着，我们再执行一次 LaTeX： 1latex foo.tex 首先，来看看 aux 文件会发生什么变化：foo.aux12345\relax\bibstyle&#123;unsrt&#125;\citation&#123;baz&#125;\bibdata&#123;foobar&#125;\bibcite&#123;baz&#125;&#123;1&#125; 相比上一次的 foo.aux，在读入 BibTeX 之后，LaTeX 向 aux 文件写入了更多的信息。这里 \bibcite{baz}{1} 将 baz 这一参考文献标记（label）与参考文献编号（数字 1）绑定起来了。 接下来，我们看看 dvi 文件的内容： 不难发现，由于读入了 foo.bbl 文件，参考文献列表已经正确展现出来了。然而，正文中依然有一个问号。 实际上，LaTeX 需要 aux 文件中的 \bibcite 命令，将参考文献标记与参考文献编号关联起来，从而在 tex 文件中的 \cite 命令位置填上正确的参考文献编号。我们注意到，在我们第二次执行 LaTeX 命令编译之前，foo.aux 文件中是没有这些信息的，直到编译完成，这些信息才被正确写入。因此，第二次执行 LaTeX 命令时，LaTeX 还不能填入正确的文献编号，于是就写入了一个问号作为占位符。 解决这个问题的办法也很简单——此时 aux 文件中已经有了需要的信息，再编译一遍就好了。 1latex foo.tex 如果没有意外，此时的 foo.dvi 文件应该看起来一切正常了。 小结 BibTeX 是一个参考文献格式化工具，它会根据需要，按照（bst 文件规定的）某种格式，将（bib 文件中包含的）参考文献信息，格式化 为 LaTeX 能够使用的列表信息。 正确使用 BibTeX 处理参考文献，需要先用 (Xe/PDF)LaTeX 编译 tex 文件，生成 aux 辅助文件。 执行 BibTeX 将读入 aux 文件，搞清楚用户需要哪些文献。 紧接着，BibTeX 根据 aux 文件中的内容，找到正确的 bst 和 bib 文件，并将参考文献信息格式化为 LaTeX 的 thebibliography 环境，作为 bbl 文件输出。 第二次执行 (Xe/PDF)LaTeX 将会读入新生成的 bbl 文件，同时更新 aux 文件。 此时，参考文献列表将会正常展示，但是正文中的引用标记显示为问号。 第三次执行 (Xe/PDF)LaTeX 将会读入 bbl 文件和更新过后的 aux 文件。此时，参考文献相关内容都正常显示。 因此，总的来说，想要正确使用 BibTeX 协同 LaTeX 处理参考文献，需要编译四次： 1234(xe/pdf)latex foo.tex # 表示使用 latex, pdflatex 或 xelatex 编译，下同bibtex foo.aux(xe/pdf)latex foo.tex(xe/pdf)latex foo.tex 常见问题 我希望将一条文献展示在参考文献列表中，但不想在正文中用 \cite 命令引用，怎么办？ 首先，确保这条文献已经写入了 bib 文件。其次，可以在 \bibliography 命令之前，用 \nocite{label} 提示 BibTeX 调取这条文献。 我有很多条文献，都存在这样的情况。每条文献逐一 \nocite 太繁琐了，有没有懒人适用的办法？ 有的。\nocite{*}。 每次都要编译四次，我感觉懒癌又要发作了，有没有办法治疗？ 有的。可以尝试 LaTeXmk, TeXify 之类的自动化工具。 我对默认提供的 bst 文件的格式效果不满意，哪里能找到更多的 bst？ 现代 TeX 发行版都提供了多种 bst 可供选择，每个 bst 文件的格式、适用范围、使用条件都不一样，需要仔细甄别。具体可以去安装目录下搜索试试。 有没有遵循国家标准的 bst？ 有的，这里。 我找到的 bst，效果都不满意，怎么办？ 你可以在命令行执行 latex makebst，制作一个符合自己要求的 bst 文件。你需要回答大约 100 个关于参考文献列表效果的问题。 bib 文件怎么生成？ 你可以手写，或者用 JabRef 之类的文献工具生成。具体请自行 Google 检索，篇幅所限就不展开了。 我听说还有一个名为 biblatex 的工具，能介绍一下吗？ biblatex 与 BibTeX 是不同的工具，超出了本文的范围。如果感兴趣，可以阅读这篇文章。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>BibTeX</tag>
        <tag>Reference</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 caption 宏包修复浮动体超链接不准的问题]]></title>
    <url>%2F2015%2F11%2F21%2Fusing-the-caption-package-to-justify-the-link-anchor%2F</url>
    <content type="text"><![CDATA[前文 我介绍了使用 hypcap 宏包修复图标超链接不准的问题。具体来说，是修复了将 \caption 放在 \includegraphics 后面，然后在文中对图片进行引用的话，点击超链接后将跳转到图片标题位置而不是浮动体顶部的问题。 之后，shengwenbo 在文后评论说，caption 宏包也能实现这一功能。本文就来介绍，如何使用 caption 宏包来实现这一效果。 基本用法最基本的用法很简单，只需要在加载插图宏包（graphicx）和超链接宏包（hyperref）之余，加载 caption 宏包即可。具体来说，代码如下。 123456789101112131415161718\documentclass&#123;article&#125;\usepackage&#123;graphicx&#125;\usepackage&#123;hyperref&#125;\usepackage&#123;caption&#125;\usepackage&#123;mwe&#125; % for dummy text\begin&#123;document&#125;\begin&#123;figure&#125;[!htb]\centering\includegraphics[width = 0.6\linewidth]&#123;example-image.jpg&#125;\caption&#123;dummy figure&#125;\label&#123;fig:test&#125;\end&#123;figure&#125;\blindtext\clearpage\blindtextThis is the hyper-reference of Figure \ref&#123;fig:test&#125;.\end&#123;document&#125; 这样一来，当点击第二页 Figure 之后的「1」之后，就能跳转至图片的开始位置（而不是标题位置）。 细节caption 宏包用于控制浮动体超链接跳转位置的功能，实际上由宏包选项 hypcap 控制。默认情况下，hypcap = true，即打开这一功能。 除此之外，caption 宏包还提供了 hypcapspace 选项，用来控制浮动体跳转的具体位置。具体来说，hypcapspace 选项接收一个 TeX 长度，跳转的位置则被设置为浮动体开始位置前的该长度；它的默认值为 hypcapspace = 0.5\baselineskip。比如说： 123456789101112131415161718\documentclass&#123;article&#125;\usepackage&#123;graphicx&#125;\usepackage&#123;hyperref&#125;\usepackage[hypcap = true, hypcapspace = 2cm]&#123;caption&#125;\usepackage&#123;mwe&#125; % for dummy text\begin&#123;document&#125;\begin&#123;figure&#125;[!htb]\centering\includegraphics[width = 0.6\linewidth]&#123;example-image.jpg&#125;\caption&#123;dummy figure&#125;\label&#123;fig:test&#125;\end&#123;figure&#125;\blindtext\clearpage\blindtextThis is the hyper-reference of Figure \ref&#123;fig:test&#125;.\end&#123;document&#125; 优势相较之前介绍过的 hypcap 宏包，由 caption 宏包完成这项工作，显得更加自然。毕竟，对浮动体标题的操作是一个常见需求，因而加载 caption 宏包很多时候是理所当然的；而 hypcap 宏包则更像是一个补丁。具体到功能上，caption 相较 hypcap 宏包有以下一些优势： hypcap 宏包只支持 LaTeX 自带的 figure 和 table 两个浮动体环境，而 caption 则支持更多。 hypcap 宏包不能与 caption 宏包定义的 \captionsetup{type = &lt;type&gt;} + \caption 联用，而 caption 对自家定义的宏当然支持良好。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Hyperref</tag>
        <tag>Caption</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 发行版：Anaconda]]></title>
    <url>%2F2015%2F11%2F21%2FPython-distribution-Anaconda%2F</url>
    <content type="text"><![CDATA[Python 是一款优秀的编程语言，其语法优雅简单，但更重要的是各类第三方 Python 库丰富。甚至可以说，学 Python 主要不是学它的语法，而是学习各类第三方 Python 库的用法。安装第三方 Python 库也很简单：Python 拥有 pip 这个包管理器（Package Manager），执行 pip install &lt;package_name&gt; 即可安装所需。 然而，在实际使用中，可能经常会遇到以下一些情况，导致我们无法轻易用 pip 安装第三方库： 系统 Python 安装在系统目录，需要 Root 权限才可写入，因此执行 pip 需要使用 sudo 命令。若当前用户不在 sudoer 组内，则无法使用 pip 安装第三方库。 系统 Python 安装在系统目录，需要 Root 权限才可写入。若当前用户不在 sudoer 组内，且未安装 pip，则用户无法安装 pip，继而无法用 pip 安装第三方库。 系统 Python 安装在用户 Home 目录，但因系统没有 libffi/zlib/openssl 或编译安装 Python 时没有正确配置好这些库的依赖，则也无法安装 Python 的 Setuptools 和 pip。 总而言之，pip 虽然方便，但是因为系统权限、依赖库等问题，有时难以使用。问系统管理员要权限，当然是一个解决方案，但是每次安装新的 Python 库都要麻烦别人，未免麻烦。 最近，我就遇到了这样的问题。 使用的账号没有在 sudoer 组内，因而不能用 sudo 命令获得临时的 root 权限。于是，我只能尝试自行编译安装，但又被各种第三方依赖库搞得焦头烂额。一番搜索之后，在网络上也并没有找到合适的解决方法，只好在 Unix.sx 上提问。 其中，Back2Basics 提出，可以尝试 Anaconda 这个 Python 发行版。该发行版内置了许多常用的 Python 第三方库，安装之后直接就可使用。此外，Anaconda 还安装了 Setuptools 和 pip 两个 Python 包管理器。最关键的是，Anaconda 不需要自己编译，可以直接安装在用户目录。此外 Anaconda 支持 Windows/Linux/Mac OS X 全平台，更是让人心头爱得不行。 具体： 默认安装的第三方库列表：http://docs.continuum.io/anaconda/pkg-docs 下载地址：https://www.continuum.io/downloads Windows: 64 位 - Python 2.7 - Python 3.5 | 32 位 - Python 2.7 - Python 3.5 OS X: 10.7 以上 - Python 2.7 - Python 3.5 | 10.5 以上 - Python 2.7 - Python 3.5 Linux: 64 位 - Python 2.7 - Python 3.5 | 32 位 - Python 2.7 - Python 3.5 Anaconda 的安装过程十分简单，这里就不赘述了。: )]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 OS X 上使用 Sublime Text 编译 C++11]]></title>
    <url>%2F2015%2F10%2F24%2Fusing-c%2B%2B11-with-sublime-text-3-on-os-x%2F</url>
    <content type="text"><![CDATA[OS X 上使用的 g++ 包含了 C++11，但默认情况下并没有打开。因此，在 Sublime Text 中编译 C++ 代码时，如果代码中使用了 C++11 引入的新的语言特性，编译器就会报错。 查看 g++ 的帮助首先，我们要搞清楚，启用 g++ 的 C++11 模块，应该给 g++ 加入那些 flag。我们在终端中执行： 1234567891011Liam@Mac OS X [17:58:30]:~/Documents/git-dev/blog-source/.hexo$ g++ --helpOVERVIEW: clang LLVM compilerUSAGE: clang [options] &lt;inputs&gt;OPTIONS:...-std=&lt;value&gt; Language standard to compile for... 在 g++ 打出的帮助文件里，我们看到： 在 OS X 里使用的 g++ 实际上是 clang； 使用 -std=&lt;value&gt; 选项可以指定语言标准。 编写 sublime-build 文件在 Sublime Text 窗口中，找到菜单栏上的 Tools -&gt; Build System -&gt; New Build System...。点击之后，Sublime Text 会打开一个新文件，将如下内容复制进文件： 1234567891011121314&#123; "cmd": ["g++", "$&#123;file&#125;", "-std=c++11", "-stdlib=libc++", "-o", "$&#123;file_path&#125;/$&#123;file_base_name&#125;"], "file_regex": "^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$", "working_dir": "$&#123;file_path&#125;", "selector": "source.c, source.c++, source.cxx, source.cc", "variants": [ &#123; "name": "Run", "cmd": ["bash", "-c", "g++ '$&#123;file&#125;' -std=c++11 -stdlib=libc++ -o '$&#123;file_path&#125;/$&#123;file_base_name&#125;' &amp;&amp; '$&#123;file_path&#125;/$&#123;file_base_name&#125;'"] &#125; ]&#125; 将其保存为 /Users/&lt;USERNAME&gt;/Library/Application Support/Sublime Text 3/Packages/User/C++11.sublime-build。 测试选择 Tools -&gt; Build System -&gt; Automatic，而后编辑如下文件： 123456789#include &lt;iostream&gt;int main () &#123; for (auto i = 0; i != 10; ++i) std::cout &lt;&lt; "I love Sophia!" &lt;&lt; std::endl; return 0;&#125; 按下组合键 CMD + Shift + B，选择「C++11 - Run」即可。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>OS X</tag>
        <tag>Sublime Text</tag>
        <tag>C++</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[取得一个整型变量二进制表示的最后一个「1」]]></title>
    <url>%2F2015%2F10%2F02%2Fhow-to-get-the-last-1-bit-of-an-integer%2F</url>
    <content type="text"><![CDATA[在实际工作中，我需要取得一个整数二进制表示的最后一个「1」在哪里。 最朴素的办法，是用短除法，逐次取余数。高明一点的办法，可以是将目标整数向右逐次右移 1 位，然后与常数 1 按位取与，结合计数器判断「1」的位置。 这里，我们介绍一个更加「聪明」的办法。 原码、反码和补码原码、反码和补码，是讨论整数在计算机中存储方式时用到的术语。 原码最好理解，对人类来说最直观。原码用最高位（最左边的二进制位）表示正负号，余下的部分表示数值。比如： 12 20 = 0001 0100(原)-20 = 1001 0100(原) 对于正数来说，其反码和原码一致。对负数来说，反码就是对除去最高符号位之外的所有二进制位取反。比如： 12 20 = 0001 0100(原) = 0001 0100(反)-20 = 1001 0100(原) = 1110 1011(反) 对于正数来说，其补码与反码一致。对负数来说，补码就是对反码做通常意义上的加一操作（含进位）。比如： 12 20 = 0001 0100(原) = 0001 0100(反) = 0001 0100(补)-20 = 1001 0100(原) = 1110 1011(反) = 1110 1100(补) 整数在计算机中是以补码的形式储存的，这就是为什么我们要介绍原码、反码和补码。补码的好处，其一是明确了整数「0」的表示（否则可以有 0000 0000 和 1000 0000 两种方式表示），其二是对整数的加法只需要统一的一套电路来处理即可。 一点观察12 20 = 0001 0100(补)-20 = 1110 1100(补) 在上面的例子中，我们注意到两个事实： 20 的最后一个非零二进制位是倒数第三位（0100），-20 的最后一个非零二进制位也恰好是倒数第三位（1100）。 从倒数第四位开始往前，20 和 -20 的二进制补码，一一对应，两两互补。 这样一来，很容易看出： 10000 0100(补) = 4 = 20 &amp; -20 = 0001 0100(补) &amp; 1110 1100(补) 也就是说，20 与其相反数按位取与，就得到了它二进制表示的最后一个「1」；同理，-20 与其相反数按位取于，也能得到想要的结果。 这是一个普遍规律吗？让我们多看几个例子。 1230000 0010(补) = 2 = 54 &amp; -54 = 0011 0110(补) &amp; 1100 1010(补)0000 0001(补) = 1 = 11 &amp; -11 = 0000 1011(补) &amp; 1111 0101(补)0100 0000(补) = 64 = 64 &amp; -64 = 0100 0000(补) &amp; 1100 0000(补) 毫无例外，测试的三个整数，都符合我们发现的规律。看起来，这会是一个普遍的规律，因此我们考虑来证明它。 规律的证明现在我们要去证明：任何整数，其二进制补码表示的最后一个「1」，可由该整数与其相反数按位取与得到。 零的处理零的二进制补码： 120 = 0000 0000(原) = 0000 0000(反) = 0000 0000(补)-0 = 0 = 0000 0000(原) = 0000 0000(反) = 0000 0000(补) 显然，0 &amp; -0 = 0，说明 0 的二进制表示中没有 1。因此结论对 0 成立。 非零的处理命题是对偶的。显然，如果证明了命题对正整数成立，那么对负整数也成立。因此，我们只需要考虑正整数的情况。 现假设，一个正整数二进制表示的最低 k 位均为 0，也就是： 10(高位部分)1(k 个 0) 那么，其相反数的反码则是： 11(高位部分按位取反)0(k 个 1) 按照补码的定义，对相反数的反码做通常意义上的二进制加一操作，注意低位逐次进位，得到： 11(高位部分按位取反)1(k 个 0) 注意到 0 &amp; 0 = 0 &amp; 1 = 1 &amp; 0 = 0，所以除了二进制表示中最后一个「1」，在相反数按位取与之后，所有的二进制位都是零。 这样一来，我们就证明了结论。 Cpp 实现简单用 Cpp 实现了一个测试小工具，用来验证上面的结论： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;int main () &#123; int int_wk; cout &lt;&lt; "Enter an integer:" &lt;&lt; endl; cin &gt;&gt; int_wk; void printBits (int int_input); printBits(int_wk); printBits(-int_wk); printBits((int_wk &amp; -int_wk)); return 0;&#125;void printBits (int int_input) &#123; unsigned uns_length = 8 * sizeof(int_input); stack&lt;int&gt; stack_bits; const int c_int_one = 1; cout &lt;&lt; "Parsing the bits of: " &lt;&lt; int_input &lt;&lt; endl; for (unsigned i = 0; i != uns_length; ++i) &#123; const int tmp = int_input &amp; c_int_one; stack_bits.push(tmp); int_input = int_input &gt;&gt; 1; &#125; unsigned uns_counter = 0; while (!stack_bits.empty()) &#123; cout &lt;&lt; stack_bits.top(); stack_bits.pop(); if (++uns_counter % 4 == 0) cout &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>Binary System</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 endfloat 宏包将浮动的图表放在文章末尾]]></title>
    <url>%2F2015%2F09%2F28%2Fusing-the-endfloat-package-to-delay-floats-to-the-and-of-document%2F</url>
    <content type="text"><![CDATA[许多期刊在投稿的时候要求作者将图表等大块内容与正文分开、放在文章末尾。通常来说，我们只能将本来放在正文中的插图、插表代码挪到文章末尾；然后再用交叉引用，说明图表的作用。 这样固然可以实现需要的效果，但是改变了行文的习惯，也不符合 LaTeX「内容与格式分离」的哲学。 McCauley 等人的 endfloat 宏包改变了 LaTeX 处理浮动体的流程，能够比较简单地将图表这些浮动体延迟到文章末尾输出——只需要简单的配置，不需要改变行文习惯。 基本用法endfloat 宏包现在只支持 LaTeX2e 了，所以 LaTeX 2.09 的用户只能去找它的旧版本用。实际上，LaTeX 2.09 是一个早就被迭代掉的版本，最好还是不要用了。 和大多数 LaTeX 宏包的用法一样，调用 endfloat 宏包只需要在导言区使用 \usepackage 命令就可以了。 1\usepackage[options]&#123;endfloat&#125; 一个简单而完整的例子是： 123456789101112131415161718192021\documentclass&#123;article&#125;\usepackage&#123;graphicx&#125;\usepackage&#123;endfloat&#125;\usepackage&#123;mwe&#125;\begin&#123;document&#125;\lipsum[1-5]\begin&#123;figure&#125;[!htb]\centering\includegraphics[width = 0.8\linewidth]&#123;example-image-a&#125;\caption&#123;Dummy Figure A&#125;\label&#123;fig:example-image-a&#125;\end&#123;figure&#125;\lipsum[6-10]\begin&#123;figure&#125;[!htb]\centering\includegraphics[width = 0.8\linewidth]&#123;example-image-b&#125;\caption&#123;Dummy Figure B&#125;\label&#123;fig:example-image-b&#125;\end&#123;figure&#125;\lipsum[11-15]\end&#123;document&#125; 这里，mwe 宏包和 \lipsum 命令是用来产生无意义的测试文字的，实际使用时可以删掉；example-image 则是 mwe 宏包提供的示例图片。 编译以上代码的结果可见： 由左侧缩略图可见，两个浮动体都被放在了文章最末尾输出；正文部分可见，在原本图片的位置生成了「Figure 1 about here.」的说明文字；此外，在输出图片之前，还自动调用了 \listoffigures，生成图片清单。 配置选项图表清单默认情况下，endfloat 宏包会调用 \listoffigures 和（或） \listoftables 生成图表清单。这些行为由以下几个选项控制： figlist / nofiglist：互补选项，默认打开 figlist，即输出图片清单； tablist / notablist：互补选项，默认打开 tablist，即输出表格清单； lists / nolists：互补选项，同时控制图表的清单，默认效果相当于打开了 lists 选项。 因此，如果你不想要上述例子中的图片清单，或者想手工用 \listoffigures 将图片清单放在其他位置，可以打开 nofiglist 选项。也就是： 123456789101112131415161718192021\documentclass&#123;article&#125;\usepackage&#123;graphicx&#125;\usepackage[nofiglist]&#123;endfloat&#125;\usepackage&#123;mwe&#125;\begin&#123;document&#125;\lipsum[1-5]\begin&#123;figure&#125;[!htb]\centering\includegraphics[width = 0.8\linewidth]&#123;example-image-a&#125;\caption&#123;Dummy Figure A&#125;\label&#123;fig:example-image-a&#125;\end&#123;figure&#125;\lipsum[6-10]\begin&#123;figure&#125;[!htb]\centering\includegraphics[width = 0.8\linewidth]&#123;example-image-b&#125;\caption&#123;Dummy Figure B&#125;\label&#123;fig:example-image-b&#125;\end&#123;figure&#125;\lipsum[11-15]\end&#123;document&#125; 图表章节标题在输出图表的之前，有时我们也需要给一个章节标题，表示「从这儿开始都是图片」之意。同样，endfloat 宏包提供了一组选项控制： fighead / nofighead：互补选项，默认打开 nofighead，即不输出图片章节标题； tabhead / notabhead：互补选项，默认打开 notabhead，即不输出表格章节标题； heads / noheads：互补选项，同时控制图表的章节标题，默认效果相当于打开了 noheads 选项。 如果你想要 endfloat 宏包为你输出图片标题，可以这么做： 123456789101112131415161718192021\documentclass&#123;article&#125;\usepackage&#123;graphicx&#125;\usepackage[fighead]&#123;endfloat&#125;\usepackage&#123;mwe&#125;\begin&#123;document&#125;\lipsum[1-5]\begin&#123;figure&#125;[!htb]\centering\includegraphics[width = 0.8\linewidth]&#123;example-image-a&#125;\caption&#123;Dummy Figure A&#125;\label&#123;fig:example-image-a&#125;\end&#123;figure&#125;\lipsum[6-10]\begin&#123;figure&#125;[!htb]\centering\includegraphics[width = 0.8\linewidth]&#123;example-image-b&#125;\caption&#123;Dummy Figure B&#125;\label&#123;fig:example-image-b&#125;\end&#123;figure&#125;\lipsum[11-15]\end&#123;document&#125; 图表标记前文提到，使用 endfloat 宏包之后，原本应当防止图表的地方，会自动生成一个记号。这个行为由 markers / nomarkers 这一组互补的选项控制：默认打开 markers 选项，即生成这样的标记。如果你不想要，可以用 nomarkers 关掉。 不处理图片或不处理表格默认情况下，endfloat 宏包会将图表都延迟在文章末尾输出。如果你只想处理图片，或者只想处理表格的话，可以用下面一组选项来控制： tablesonly：只处理表格，图片保持原样； figuresonly：只处理图片，表格保持原样。 图表的顺序同时延迟输出图表的情况下，endfloat 宏包会先输出图片，然后再输出表格。如果你想改变这个顺序，可以用下面的选项： figuresfirst / tablesfirst：控制图表输出的顺序，默认打开 figuresfirst，即先输出图片，再输出表格。 注意，当启用了 tablesonly 或者 figuresfirst 的时候，这两个选项就没有意义了。 修改 endfloat 宏包的默认行为endfloat 宏包虽好，但是人类的需求多种多样，总有它满足不了的时候。对于 endfloat 宏包来说，比较集中的问题就是记号的样式、还有图表章节标题的内容；此外，默认情况下，endfloat 宏包会将图表一页放一个，有时我们也会希望将几个图表放在同一页上。 记号样式的修改记号的样式定义在 \xxxplace 这个宏里。比如，针对图片，我们就要修改 \figureplace 这个宏的定义。 比如下面的代码： 1234567891011121314151617181920212223242526\documentclass[UTF8]&#123;ctexart&#125;\usepackage&#123;graphicx&#125;\usepackage&#123;endfloat&#125;\usepackage&#123;mwe&#125;\renewcommand&#123;\figureplace&#125;&#123;\begin&#123;center&#125; [\figurename~\thepostfigure. 在这里]\end&#123;center&#125;&#125;\begin&#123;document&#125;\lipsum[1-3]\begin&#123;figure&#125;[!htb]\centering\includegraphics[width = 0.8\linewidth]&#123;example-image-a&#125;\caption&#123;Dummy Figure A&#125;\label&#123;fig:example-image-a&#125;\end&#123;figure&#125;\lipsum[4-6]\begin&#123;figure&#125;[!htb]\centering\includegraphics[width = 0.8\linewidth]&#123;example-image-b&#125;\caption&#123;Dummy Figure B&#125;\label&#123;fig:example-image-b&#125;\end&#123;figure&#125;\lipsum[7-9]\end&#123;document&#125; 在这里，\figurename 为人熟知，是图片标题的 label 内容；在 ctexart 文档类中，它是「图」。\thepostfigure 则记录了相应的编号。 修改图表章节标题的内容当启用 fighead 或 tabhead 时，在输出图表之前，就会打印相应的章节标题，提示接下来的内容。endfloat 的默认会打印「Figures」和「Tables」。 实际上，这两个标题的内容，分别存储在 \figuresection 和 \tablesection 两个宏当中。因此，如果想修改章节标题的内容，只需要修改这两个宏就好了。比如： 12\renewcommand&#123;\figuresection&#125;&#123;本文的插图&#125;\renewcommand&#123;\tablesection&#125;&#123;本文的表格&#125; 使多个图表能够放在同一页面上endfloat 宏包默认让每个图表独占一页，有时我们不希望这样，而希望保持原有的特性。 实际上，endfloat 宏包会在输出每个浮动体之后，调用 \efloatseparator 命令。默认情况下，这个命令被定义为 \clearpage。也就是说，输出浮动体之后，立即刷新到下一页；这就是 endfloat 宏包默认让每个图表独占一页的底层原因。 如果我们想要一页同时能够容纳多张图表（就像没有引入 endfloat 宏包时，浮动体排在中文中那样），只需要将 \efloatseparator 修改为 \relax 即可： 1\renewcommand&#123;\efloatseparator&#125;&#123;\relax&#125;]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Float</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SecureCRT 配色方案（仿 Solarized）]]></title>
    <url>%2F2015%2F09%2F24%2Fcolor-scheme-for-securecrt%2F</url>
    <content type="text"><![CDATA[工作中需要用到 SecureCRT，但是 SecureCRT 默认的配色方案实在是丑得不能用，写代码看久了还伤眼。「刚需」驱动下，自己仿照 Solarized 方案做了一个配色，顺眼多了。 设置 Emulation按照以下顺序进入 Emulation 的设置： 菜单栏 Options 选择 Global Options 左侧 Category General Default Session 右侧 Edit default settings Edit Default Settings 按钮 左侧 Category Terminal Emulation 按照图示，将 Terminal 模式选择 Linux，同时勾选 ANSI Color。 按 OK 键保存，之后选择 Change ALL Sessionts (no undo)，将更改应用到所有会话。 设置 ANSI Color在同一个窗口，设置 ANSI Color；即，按照以下顺序进入 ANSI Color 的设置： 菜单栏 Options 选择 Global Options 左侧 Category General Default Session 右侧 Edit default settings Edit Default Settings 按钮 左侧 Category Terminal Appearance ANSI Color 按照下列图示，分别设置： 背景颜色 RGB：0:50:50。 字体颜色 RGB：130:150:150。 Vim 注释颜色 RGB：255:128:128。 目录颜色 RGB：128:128:255。 压缩文件颜色 RGB：128:128:0。 按 OK 键保存，之后选择 Change ALL Sessionts (no undo)，将更改应用到所有会话。 设置光标在同一个窗口，设置 Appearance；即，按照以下顺序进入光标的设置： 菜单栏 Options 选择 Global Options 左侧 Category General Default Session 右侧 Edit default settings Edit Default Settings 按钮 左侧 Category Terminal Appearance 按照图示，设置光标颜色，并将 Cursor style 设置为 Wide Vertical Bar。 按 OK 键保存，之后选择 Change ALL Sessionts (no undo)，将更改应用到所有会话。 设置字体和字符集在同一个窗口，设置 Appearance；即，按照以下顺序进入字体和字符集的设置： 菜单栏 Options 选择 Global Options 左侧 Category General Default Session 右侧 Edit default settings Edit Default Settings 按钮 左侧 Category Terminal Appearance 按照图示，设置字体（Font），并将 Character Encoding 设置为 UTF-8。 这里 YaHei Consolas Hybrid 是一款合成字体，集合了微软雅黑与 Consolas，非常适合编程使用；建议你自行从网络上下载，安装在你的计算机上。 按 OK 键保存，之后选择 Change ALL Sessionts (no undo)，将更改应用到所有会话。 最终效果至此就设置完毕了，我们来看一下最终效果：]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Color Scheme</tag>
        <tag>Solarized</tag>
        <tag>SecureCRT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 LaTeX 中实现定理的重述]]></title>
    <url>%2F2015%2F09%2F12%2Fprimed-theorems%2F</url>
    <content type="text"><![CDATA[之前的文章中，我们介绍了如何复写定理。这里我们讨论如何实现定理的重述。 所谓定理的重述，是这样的情况：在文章的某处，我们陈述了一个定理；接下来，我们在文章的其他地方，陈述了一个与之等价但叙述方式不同的定理。此时，如果第一个定理的编号是 Theorem 7，那么第二个的编号就应该是 Theorem 7&#39;。 我们来观察一下这个需求，不难发现有以下特征： 原定理的位置不确定； 原定理的编号不确定； 重述定理的编号和原定理的编号相同，只不过多了一个撇（Prime）。 对 LaTeX 有一定了解的用户，可能会发现，这些特征和「交叉引用」非常相似。交叉引用的 \label 位置和编号也是不确定的（只有在第一遍编译之后才确定）；交叉引用的结果 \ref 显示的内容应当与 \label 标记的锚点编号一致。 因此，我们考虑用交叉引用来处理这个问题。 对于定理重述，另一个显而易见的事情是：除了编号，定理重述的格式应当与定理本身保持一致。因此，定理重述的环境应该在定理环境的基础上做修改，而不是全盘推翻重做。 考虑到这些需求，有经验的 LaTeX 用户不难写出以下代码： 123456\newtheorem&#123;thm&#125;&#123;Theorem&#125;\newenvironment&#123;thmbis&#125;[1] &#123;\renewcommand&#123;\thethm&#125;&#123;\ref&#123;#1&#125;$'$&#125;% \addtocounter&#123;thm&#125;&#123;-1&#125;% \begin&#123;thm&#125;&#125; &#123;\end&#123;thm&#125;&#125; 这里，我们用 \renewcommand 修改了计数器 thm 的显示方式 \thethm：首先对原定理做引用，然后加上一个撇。随后，在 thm 的当前值上减 1。这是因为，在之后的 \begin{thm} 中会给 thm 计数器自加 1，这里作为「补偿」，需要预先减去 1。 完整的例子可见： 1234567891011121314151617181920212223\documentclass[a4paper]&#123;article&#125;\newtheorem&#123;thm&#125;&#123;Theorem&#125;\newenvironment&#123;thmbis&#125;[1] &#123;\renewcommand&#123;\thethm&#125;&#123;\ref&#123;#1&#125;$'$&#125;% \addtocounter&#123;thm&#125;&#123;-1&#125;% \begin&#123;thm&#125;&#125; &#123;\end&#123;thm&#125;&#125;\begin&#123;document&#125;\begin&#123;thm&#125;$1+1=2$\end&#123;thm&#125;\begin&#123;thm&#125;\label&#123;comm&#125;$a+b=b+a$\end&#123;thm&#125;\begin&#123;thmbis&#125;&#123;comm&#125;$x+y=y+x$\end&#123;thmbis&#125;\begin&#123;thm&#125;$0\ne0$\end&#123;thm&#125;\end&#123;document&#125;]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Theorem</tag>
        <tag>Numbering</tag>
        <tag>Restate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决 MathJax 与 Markdown 的冲突]]></title>
    <url>%2F2015%2F09%2F09%2Ffix-conflict-between-mathjax-and-markdown%2F</url>
    <content type="text"><![CDATA[MathJax 是一个 JavaScript 引擎，能够将 LaTeX 语法书写的公式在网页上显示出来，而且效果杠杠的。Markdown 是一种轻量级的标记语言。用 Markdown 书写的文章，可以用 Markdown 解释器处理成标准的 HTML 文档。因此 Markdown 很适合用来写网络日志。 作为数学系毕业的学生，写博客时不可避免地会涉及到一些数学公式。可惜不巧，用 Markdown 写博客的我，在使用 MathJax 的时候遇到了一点麻烦。 在 Markdown 中，下划线 _ 被保留，用作标记符号。比如 _Slant_ 会生成倾斜的 Slant。在 LaTeX 中，下划线 _ 被用作下标记号。比如 x_i 会生成 $x_i$。 由于 Markdown 在 MathJax 之前起作用，有时下标记号会被 Markdown 吃掉，变成 HTML 标记 &lt;i&gt; 而失去 LaTeX 的下标效果，造成数学公式显示不正常。比如 This is an example: $f_i = f_{i + 1}$ 里的两个下划线会被 Markdown 理解成倾斜的标记，这就不对了。 分析与思路问题的本质在于，下划线 _ 首先被 Markdown 处理，变成 HTML 标记 &lt;i&gt;。之后，MathJax 会认为相关代码是不合法的公式代码，不予处理。比如上述例子，在 MathJax 看来会变成这样：This is an example: $f&lt;i&gt;i = f&lt;i&gt;{i + 1}$——这是什么鬼（MathJax 内心独白）。因此，我们要做的，就是在 Markdown 处理文本的时候，将公式中的下划线保留起来；然后，再让 MathJax 去处理保留下来的下划线。 在 Markdown 中，我们可以用 backtip (`) 来做原样抄写（Verbatim）。也就是说，包含在两个 ` 中间的内容，会被 Markdown 原样保留下来。这正符合我们「保护下划线」的需求。于是，上述例子应该写成 This is an example: `$f_i = f_{i + 1}$`。 问题看似解决了，不过却又引发了下一个问题。被反引号包括的部分，被 Markdown 当做代码来处理，会加上 HTML 标签 &lt;code&gt;。这样一来，MathJax 在处理文档时，就会跳过这一部分——虽然下划线被保留了，但是整个公式都被忽略了。 一个妥协的办法，是用 JavaScript 处理所有的 &lt;code&gt; 标签：如果发现 &lt;code&gt; 标签内包含数学公式（以美元符号 \$ 开头结尾），那么就剥离标签，并调用 MathJax 处理。 下面我们来实现这一思路。 JavaScript 代码123456789101112131415161718192021&lt;script type="text/javascript"&gt;$(document).ready(function()&#123; $("code").map(function()&#123; match = /^\$(.*)\$$/.exec($(this).html()); if (match) &#123; $(this).replaceWith("&lt;span class=hpl_mathjax_inline&gt;" + $(this).html() + "&lt;/span&gt;"); MathJax.Hub.Queue(["Typeset",MathJax.Hub,$(this).get(0)]); &#125; match = /^\$\$(.*)\$\$$/.exec($(this).html()); if (match) &#123; $(this).replaceWith("&lt;span class=hpl_mathjax_inline&gt;" + $(this).html() + "&lt;/span&gt;"); MathJax.Hub.Queue(["Typeset",MathJax.Hub,$(this).get(0)]); &#125; match = /^\\begin/.exec($(this).html()); if (match) &#123; $(this).replaceWith("&lt;span class=hpl_mathjax_inline&gt;" + $(this).html() + "&lt;/span&gt;"); MathJax.Hub.Queue(["Typeset",MathJax.Hub,$(this).get(0)]); &#125; &#125;);&#125;);&lt;/script&gt; 这里，我们用正则表达式匹配了 &lt;code&gt; 标签内的美元符号，然后将 &lt;code&gt; 标签替换成 &lt;span class=hpl_mathjax_inline&gt; 标签，最后调用 MathJax.Hub.Queue 处理数学公式。 经过这样一番处理，This is an example: `$f_i = f_{i + 1}$` 就可以被正确处理为「This is an example: $f_i = f_{i + 1}$」了。]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>MathJax</tag>
        <tag>Conflict</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Nginx 搭建反向代理以访问 Gist]]></title>
    <url>%2F2015%2F09%2F07%2Freverse-proxy-to-get-access-to-gist%2F</url>
    <content type="text"><![CDATA[嗯，这么久没更新博文，是因为有一篇文章写了很久但一直没写完。真是哔了狗了。 今天想说的是一件更加哔了狗的事情。 Gist 是 GitHub 推出的代码片段分享服务，是最好用的代码片段分享服务没有之一。但是，它被天杀的围墙挡在了外面；而挡住它的理由更是无厘头——有人在白宫上发起了一个针对围墙的请愿活动，使用 Gist 提供了一份围墙制作人员的名单。 没办法，学习工作都需要用到 Gist，于是决定用 Nginx 在 EC2 上搭建一个针对 Gist 服务的反向代理服务器。 反向代理想必大家对代理服务器并不陌生，但是对「反向代理」这个名词却不一定了解。 实际上，代理服务器按照起到的功能作用可以分为两种：正向代理服务器和反向代理服务器。我们用得比较多的是正向代理服务器：它横在客户端前面，代理客户端的行为，向服务器发出请求。反向代理服务器则与之相反：它横在服务器面前，代理服务器的行为，接受客户端的请求，然后向服务器请求资源后，以服务器的身份将资源内容返回给客户端。 对于大型网站来说，反向代理可以作为 DMZ 服务器，承担屏蔽外网访问的功能。此时，外网所有的访问，都通过 DMZ 转发到内网相应的服务器上，从内网服务器获取内容后，再经由 DMZ 返回给外网的客户端。这样，外网客户端无法获知内网的网络拓扑结构，这对内网是一种保护。 现在我们希望在对于围墙可信的某计算机上搭建一个反向代理服务器，并赋予它一个特定的域名（比如 example.com）。这样，我们访问 example.com 就相当于访问了 gist.github.com。 编译安装 NginxNginx 是俄罗斯大神 Igor Sysoev 开发的网页服务器，稳定、高效、并发能力好；最关键的是，用它来配置反向代理服务器非常方便。 首先我们来编译安装 Nginx。 前期准备编译安装需要 gcc 和 g++ 之类的编译器，文章之后的内容都默认你的服务器上已经安装了这些工具。 我的 EC2 服务器用的是 Ubuntu Server，安装这些工具可以用 apt-get。 12sudo apt-get install build-essentialsudo apt-get install libtool 接下来，我们需要安装 PCRE、zlib 以及 openssl 库。PCRE 是用 Perl 写的正则表达式库，zlib 库在 gzip 压缩的时候会用到，openssl 则是著名的 SSL 库。 我们将源码保存在 /usr/local/src，然后开始下载和编译 PCRE、zlib 和 openssl 库。 1234567891011121314151617181920# PCREcd /usr/local/srcsudo wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.37.tar.gzsudo tar -zvxf pcre-8.37.tar.gzcd pcre-8.37sudo ./configuresudo makesudo make install# zlibcd /usr/local/srcsudo wget http://zlib.net/zlib-1.2.8.tar.gzsudo tar -zvxf zlib-1.2.8.tar.gzcd zlib-1.2.8sudo ./configuresudo makesudo make install# opensslcd /usr/local/srcsudo wget http://www.openssl.org/source/openssl-1.0.0s.tar.gzsudo tar -zvxf openssl-1.0.0s.tar.gz 安装 NginxNginx 最新的版本是 1.9.4。我们下载并安装它。 1234567891011121314cd /usr/local/srcsudo wget http://nginx.org/download/nginx-1.9.4.tar.gzsudo tar -zvxf nginx-1.9.4.tar.gzcd nginx-1.4.2sudo ./configure --sbin-path=/usr/local/nginx/nginx\--conf-path=/usr/local/nginx/nginx.conf\--pid-path=/usr/local/nginx/nginx.pid\--with-http_ssl_module --with-http_sub_module\--with-http_stub_status_module\--with-pcre=/usr/local/src/pcre-8.37\--with-zlib=/usr/local/src/zlib-1.2.8\--with-openssl=/usr/local/src/openssl-1.0.0ssudo makesudo make install 这里，./configure 配置的时候： --sbin-path 指定了二进制文件的位置 --conf-path 指定了配置文件的位置 --pid-path 指定了 pid 文件存放的位置 --with-http_ssl_module 将会安装 SSL 模块 --with-http_sub_module 将会安装替换模块，之后的 URL 替换会用到它 --with-http_stub_status_module 将会安装性能监视模块 --with-pcre 链接 PCRE 库 --with-zlib 链接 zlib 库 --with-openssl 链接 openssl 库 测试运行首先确定 80 端口没有被占用： 1netstat -ano | grep 80 然后执行命令，运行 Nginx： 1sudo /usr/local/nginx/nginx 查看 80 端口的情况： 1netstat -ano | grep 80 出现下列结果，则说明 Nginx 已成功运行，并且正在监听 80 端口： 1tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN off (0.00/0/0) 配置反向代理Nginx 的配置文件是用花括号对 {} 嵌套而成的结构化配置文件。这里我们不讲 Nginx 配置文件的详细内容，关于它的详细说明可以参见这篇博客。 按照安装时指定的内容，我们需要找到 /usr/local/nginx/nginx.conf 中的 http 块，在其中添加以下内容： 1234567891011121314151617181920# server, gist reverse proxyserver &#123; listen 80; server_name gist.example.com; access_log off; resolver 8.8.8.8; location / &#123; proxy_pass https://gist.github.com; proxy_cache_valid 200 302 1h; proxy_cache_valid 404 1m; proxy_cache_use_stale error timeout invalid_header updating http_500 http_502 http_503 http_504; proxy_set_header Accept-Encoding &quot;&quot;; proxy_set_header Accept-Language &quot;zh-CN&quot;; proxy_set_header User-Agent $http_user_agent; sub_filter https://gist-assets.github.com/ http://gist.example.com; sub_filter https://gist.github.com/ http://gist.example.com; sub_filter_once off; &#125;&#125; 这里对它做一个解释。 井号开头的行是注释 server 开始了 server 块 listen 表明 Nginx 将会在 80 端口监听 server_name 是我们给反向代理配置的域名，访问这个域名就相当于访问 Gist access_log 是日志文件的配置，这里为了简化我将它关掉了 resolver 是 DNS 服务器 location 块具体配置反向代理的行为 proxy_pass 说明将会将请求转发至 Gist proxy_cache_valid 配置缓存 proxy_cache_valid 同上 proxy_cache_use_stale 同上 proxy_set_header 设置 HTTP 请求头，Accept-Encoding &quot;&quot; 表示拒绝任何压缩，这保证了服务器返回给反向代理的内容是未经压缩的，以便进行 URL 替换 proxy_set_header 设置 HTTP 请求头，语言设置 proxy_set_header 设置 HTTP 请求头，设置 UA sub_filter URL 替换 sub_filter 同上 sub_filter_once 被关闭，替换所有可替换的内容 这样，访问 http://gist.example.com 就相当于访问了 https://gist.github.com。最后，我们需要让 Nginx 载入新的配置文件： 1sudo /usr/local/nginx/nginx -t]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Reverse Proxy</tag>
        <tag>Nginx</tag>
        <tag>Gist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTeX 中的宽度]]></title>
    <url>%2F2015%2F08%2F17%2Fwidth-in-latex%2F</url>
    <content type="text"><![CDATA[使用 LaTeX 的过程中，如果需要插入图片、表格，我们有时会用到页面宽度。那么，在 LaTeX 中都有哪些常用的宽度？它们有什么区别？分别又该在什么时候使用呢？ LaTeX 里存在一些长度宏，保存着与页面尺寸有关的长度。涉及到页面宽度，有这么几个： \linewidth - 当前行的宽度 \columnwidth - 当前分栏的宽度 \textwidth - 整个页面版芯的宽度 \paperwidth - 整个页面纸张的宽度 \hsize - Plain TeX 的宏，是 TeX 在行末考虑分词换行时使用的宽度 这些宽度里，\hsize 是 Plain TeX 的宏，不推荐 LaTeX 用户使用，简单地当它不存在就好了。在单栏文本中，\columnwidth 和 \textwidth 保持一致；在多栏文本中 \textwidth = n * \columnwidth + (n - 1) * \columnsep（其中 n 是分栏数）。 在 minipage 环境中，除了 \paperwidth 之外，其它三个 \****width 都会根据 minipage 的宽度发生改变（因为虚拟出了一个小的纸张页面），然后在 minipage 环境结束的时候恢复原样。在 parbox 中，\textwidth 和 \columnwidth 不会改变，不过 \linewidth 会发生变化。 \linewidth 是相对最灵活的宽度值。在 list 环境里（包括 enumerate 和 itemize 等环境），在 \parbox 里，\linewidth 都会发生变化。 总的来说，当 需要在列表环境中使用表格、图片等宽度的时候，用 \linewidth 需要充满整个页面宽度的时候，用 \textwidth （比如 figure/table 等） 需要充满整个分栏的时候，用 \columnwidth （比如 figure/table/tabularx/tabu 等）]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Width</tag>
        <tag>Figure</tag>
        <tag>Minipage</tag>
        <tag>Table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MD5 散列函数的结果是均匀分布吗？]]></title>
    <url>%2F2015%2F08%2F12%2Fdoes-the-result-of-md5-hash-function-uniform%2F</url>
    <content type="text"><![CDATA[今天，大学同学昊轩在微信群里问到「MD5 散列函数的结果是不是均匀分布的」。询问之后才知道，昊轩在工作中需要一个快速的、均匀分布的 8 – 16 bytes 的散列函数。 回忆本科学过的内容，似乎并没有提及散列函数的结果服从何种统计分布。不过，一个合格的散列函数应当包含三个特征： 单向性：容易计算输入的散列结果，但是从散列结果无法推出输入内容； 抗碰撞性：很难找到两个不同的输入内容，得到相同的输出结果； 映射均匀性和差分均匀性：散列结果中 bit 位上的 0 的数量和 1 的数量应当大致相等；改变输入内容的 1 个 bit 信息会导致散列结果一半以上的 bit 位变化（雪崩效应）。 雪崩效应的本质就是散列结果的均匀性，因此，基本上可以说 MD5 散列函数的结果应当服从均匀分布。 受篇幅所限，这里无法给出详细的证明。不过我们可以以大量测试来说明这一结果。 如果我们将 MD5 的散列结果以十六进制的形式表达出来，那么表达的结果中可能出现 1234567890abcdef 这十六个可能的结果。如果十六个可能的结果等可能出现（均匀），那么对于某个十六进制位来说，它的信息熵等于 $\sum_0^{15} - \frac{1}{16} \log_2 \frac{1}{16} = 4$。 这就是说，如果我们将 MD5 的散列结果以十六进制的形式表达出来，计算每一个数位的信息熵，如果（约）等于 4，就说明 MD5 的散列结果是（接近）均匀的。为此，我用 Python 写了一份代码作为测试。这份代码用到了 Python 的 hashlib 库，可能需要额外安装。 1234567891011121314151617181920212223from hashlib import md5from math import logdef entropy(wkList): wkSet = set(wkList) rate = &#123;&#125; lenList = len(wkList) for i in wkSet: rate[i] = float(wkList.count(i)) / lenList return sum([-p * log(p, 2) for p in rate.values()])if __name__ == '__main__': wkDict = &#123;&#125; # key: index number; value: list of appeared chars for i in xrange(1000000): s = md5(str(i)).hexdigest() for j in xrange(32): if not j in wkDict: wkDict[j] = [s[j]] else: wkDict[j].append(s[j]) for j in xrange(32): print j, '\t', entropy(wkDict[j]) 运行之后结果如下： 12345678910111213141516171819202122232425262728293031320 3.999972520091 3.999993027862 3.999995196083 3.999988830094 3.999991981395 3.999992771516 3.999986017457 3.999989136628 3.999984031449 3.9999899745110 3.999988837211 3.9999916756112 3.9999897377513 3.9999878868914 3.9999846503115 3.9999902667116 3.9999895134617 3.999992550518 3.9999914586319 3.9999911861520 3.9999942966221 3.9999866191922 3.9999917258823 3.9999837562324 3.9999956294325 3.9999853441126 3.999989224727 3.9999862749928 3.9999907225129 3.9999908882230 3.9999910799731 3.99998905455 经过一百万次的计算，我们发现，MD5 散列值的每一个十六进制位的信息熵都大致相等，且它们的值都约等于 4。根据之前的讨论，我们可以认为「MD5 散列函数的结果服从均匀分布」。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Hash</tag>
        <tag>MD5</tag>
        <tag>Uniform Distribution</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 hypcap 宏包修复图表超链接不准的问题]]></title>
    <url>%2F2015%2F07%2F27%2Fusing-hypcap-to-justify-the-link-point%2F</url>
    <content type="text"><![CDATA[LaTeX 中的 hyperref 宏包是一个非常强大的宏包，它提供了和超链接的各种接口。特别地，对于 LaTeX 原生的交叉引用，hyperref 宏包能够在引用位置生成一个超链接——点击之后跳转到相关位置。 不过，如果你将 \caption 放在 \includegraphics 后面，然后在文中对图片进行引用的话，点击超链接后将跳转到图片标题位置。此时，图片本身会被挡住。这多少有点不方便。 德国的 LaTeX 大牛 Heiko Oberdiek 写了一个叫做 hypcap 的宏包，专门用来解决这个问题。加载这个宏包之后，对浮动体（包括 figure/table 等）的引用链接会跳转至浮动体开始的地方。这样一来，figure 环境里的图片就不会被挡住了。 具体用法如下： 1234567891011121314151617\documentclass&#123;article&#125;\usepackage&#123;graphicx&#125;\usepackage&#123;hyperref&#125;\usepackage[all]&#123;hypcap&#125;\usepackage&#123;mwe&#125; % for dummy text\begin&#123;document&#125;\begin&#123;figure&#125;[!htb]\centering\includegraphics[width = 0.6\linewidth]&#123;example-image.jpg&#125;\caption&#123;dummy figure&#125;\label&#123;fig:test&#125;\end&#123;figure&#125;\blindtext\clearpage\blindtextThis is the hyper-reference of Figure \ref&#123;fig:test&#125;.\end&#123;document&#125; 注意，这里我给 hypcap 宏包加上了 all 选项，说明 hypcap 宏包会处理全部类型的浮动体（详情请阅读其说明手册）；mwe 宏包（是 Minimal Working Example 的缩写）是为了产生无意义的测试文字而加载的宏包，实际使用时可以去掉。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Hyperref</tag>
        <tag>Hypcap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自然语言处理的数学原理（二）]]></title>
    <url>%2F2015%2F07%2F26%2Fmathematics-theory-of-natural-language-processing-2%2F</url>
    <content type="text"><![CDATA[本系列的上一篇文章介绍了 NLP 中处理分词的两种方法，其中基于统计语言模型的方法以巨大的优势胜出。 在上一篇文章的末尾，我们讲了优秀的算法模型在形式上应该是简洁优雅的。具体来说： 一个正确的数学模型在形式上应该是简洁优雅的。 一个正确的数学模型，在刚开始的时候可能还不如一个经过精心调教的错误模型准确。但是错误模型不论如何调教，因为方向错了，所以终究会有处理不了实际问题的时候。 正确的数学模型可能因为受到干扰而不准确。此时应该找出干扰、噪音，并解决它们，而不是简单凑合去修修补补。 这篇文章我们继续讲分词和统计语言模型。不过，这次的内容会比上次要深入、深奥，并且会涉及到一些数学推导，以及一些工程上的 Dark Side。不过，其中有些非常 Tricky 的技巧对于大多数读者来说没有必要阅读，而剩下的部分中简单的数学推导也不致枯燥。 统计语言模型的具体描述上一篇文章简单介绍了统计语言模型的思想，这里将给出统计语言模型的具体描述和简化。不过，在此之前，我们先看一个更简单直观的例子。 一个简单的例子下面这个例子我们已经见过，在文法上，这是一个比较复杂的句子。不过，虽然这个句子在文法上比较复杂，但是对于人类来说，理解它并不费劲。 由于理解自然语言，需要关于外在世界的广泛知识以及运用操作这些知识的能力，自然语言认知，同时也被视为一个人工智能完备的问题。 现在我们对句子略作修改，变成下面这样，理解起来就有些费劲了，但是勉强还能理解。 自然语言由于理解，需要知识广泛关于外在世界的以及运用这些知识操作的能力，认知自然语言，也被视为同时人工只能完备的一个问题。 如果对句子继续变形，变成下面这样，基本上就没人搞得懂这是在说什么了。 然自语言由理于解，需知要关泛识需广关泛于外在界世以及的运用及的些这识知操运用些的作能力，认语知自然语知言，也视被为同备时的人被工个问只视能完的备一个题问。 从文法上说，第一个句子合乎文法，因而容易理解；第二个句子虽然不合文法，但是勉强有迹可循；第三个句子则完全莫名其妙，自然就没法读懂。 上一篇文章告诉我们，这样基于文法的解释是合情合理的，但是在实际应用上却迈不开步子、走不出实验室。要解释这三个句子的情况，终究还是要依靠统计的方法。 我们把这三个句子分别记作 $S_1$, $S_2$, $S_3$，用 $P(S_k)$ 表示三个句子在人类交流中出现的概率（可能性）。于是事情就变得简单起来：$P(S_k)$ 越大，说明句子出现在人类交流中的概率越大；换言之，这个句子越符合人类交流的习惯（特别是文法规则），因此也就容易读懂。就实际情况来说， \begin{align}P(S_1)\approx 10^{-20}\notag\\P(S_2)\approx 10^{-25}\notag\\P(S_3)\approx 10^{-70}\notag\\\end{align} 亦即，第一个句子出现的概率是第二个句子的一万倍，是第三个句子的 $10^{50}$ 倍。我已经不想去数 $10^{50}$ 这个数字写作中文后会有多少个「亿」字了。 统计语言的描述上一小节我们看到根据句子的概率判断句子合理性效果是十分显著的。为了能将这个方法用于实际，我们必须解决概率的计算问题。 假定 $S$ 是一个有意义的句子，它由一串排序确定的词组成，即 $$S = w_1,\,w_2,\,\ldots,\,w_n$$ 这里每个 $w_k$ 表示一个词语，$n$ 是句子包含词语的数量，即句子的长度。 显而易见，把 $S$ 放在从古至今所有的语境里去检查概率是不可行的，因此我们需要做一个模型来估算。我们把 $P(S)$ 展开，得到 \begin{equation}P(S) = P(w_1,\,w_2,\,\ldots,\,w_n)\label{eq:sentence-exp}\end{equation} 考虑到 $w_1,\,w_2,\,\ldots,\,w_n$ 是有特定顺序的。因此，记 $m = n-1$，则 \eqref{eq:sentence-exp} 可以展开成 \eqref{eq:contional-prob-sent} 中的条件概率形式。 \begin{equation}\begin{aligned}P(S) = {}&amp; P(w_1,\,w_2,\,\ldots,\,w_n) \\ = {}&amp; P(w_1)\cdot P(w_2\mid w_1)\cdot P(w_3\mid w_1,\,w_2)\cdot\cdots\cdot P(w_n\mid w_1,\,w_2,\,\ldots,\, w_m)\end{aligned}\label{eq:contional-prob-sent}\end{equation} 其中 $P(w_k\mid w_1,\,w_2,\,\ldots,\, w_i),\quad (i = k - 1)$ 表示 $w_k$ 接在序列 $w_1,\,w_2,\,\ldots,\, w_i$ 之后的条件概率。不难看出，$w_k$ 的概率，取决于它本身在整个语言中出现的概率，以及它前面 $i=k-1$ 个词顺序出现的概率。 学过概率论的读者应该知道，计算三元的条件概率（即计算类似 $P(w_3\mid w_1,\,w_2)$）已经很困难了，更别说计算整个句子最后一个词的条件概率。因此，我们需要对模型进行简化。 数学专业的读者可能会发现，这样的条件概率，实际上是一个随机过程的概率。在随机过程中，为了简化分析，对此类过程有一个马尔科夫假设（Markov Hypothesis），即假设 $ w_k $ 的概率只和 $w_i,\quad (i = k - 1)$ 有关。即假设 $$ P(w_k\mid w_1,\,w_2,\,\ldots,\, w_i) = P(w_k\mid w_i),\quad (i = k - 1). $$ 这样一来，我们就有 \begin{equation}\begin{aligned}P(S) = {}&amp; P(w_1,\,w_2,\,\ldots,\,w_n) \\ = {}&amp; P(w_1)\cdot P(w_2\mid w_1)\cdot P(w_3\mid w_1,\,w_2)\cdot\cdots\cdot P(w_n\mid w_1,\,w_2,\,\ldots,\, w_m) \\ = {}&amp; P(w_1)\cdot P(w_2\mid w_1)\cdot P(w_3\mid w_2)\cdot\cdots\cdot P(w_n\mid w_m)\end{aligned}\label{eq:bigram-model}\end{equation} \eqref{eq:bigram-model} 即是二元统计语言模型（Bigram Model）。在形式上，二元模型是非常简洁优雅的，这正符合了我们之前对模型形式的预期。 条件概率的估算模型已经构建完毕，接下来需要考虑如何解模，而核心问题就是如何估算条件概率 $P(w_k\mid w_i),\quad(i = k - 1)$。根据条件概率的定义 $$ P(w_k\mid w_i) = \frac{P(w_i,\,w_k)}{P(w_i)},\quad(i = k - 1), $$ 我们只需要在语料库（Corpus）中统计 $w_i,\,w_k$ 和 $w_i$ 出现的次数，再除以语料库的体积，就能算出 $w_i,\,w_k$ 和 $w_i$ 的频率。如果语料库足够大，我们就有大数定律作支撑，得到 \begin{equation}P(w_k\mid w_i) = \frac{\langle w_i,\,w_k\rangle/\langle\text{Corpus}\rangle}{\langle w_i\rangle/\langle\text{Corpus}\rangle} = \frac{\langle w_i,\,w_k\rangle}{\langle w_i\rangle}\label{eq:con-prob-solu}\end{equation} \eqref{eq:con-prob-solu} 给出了计算二元条件概率的一般方法，其中 $\langle w_i\rangle$ 表示 $w_i$ 在语料库中出现的次数。 至此，二元统计语言模型已经构建完毕，基本原理也已介绍完毕。数学在此展现了非凡的简洁和优雅，同时带给了我们极高的效率。当然，这个模型还很粗糙，要想让二元模型走出实验室，走向实际应用，还有很多细节需要讨论。接下来的讨论会有一些枯燥乏味，不过对数学细节不感兴趣的读者可以略过数学推导，把注意力放在模型的原理之上。 统计语言模型用于分词的细节讨论二元模型的扩展马尔科夫假设将当前词语的概率限定只与之前一个词有关。这样的假设能在很大程度上降低计算的复杂性，但是却和实际生活的情况相差甚远。比如 小明的铅笔 在这里「铅笔」之前的词是结构助词「的」。考虑到结构助词「的」的后面几乎可以出现任何名词，如果我们约定「铅笔」出现的概率只和「的」有关，那显然是不合理的。 为了解决这个问题，比较显然的办法是对马尔科夫假设做扩展。即，从假设当前词只与之前的一个词有关，扩展到与之前的 $p$ 个词有关。也就是将模型从二元模型扩展到 $p$-元模型。很显然，$p$ 的值越大，模型越接近真实情况；同时，计算量和计算的复杂度以及耗费的算力都会大大提升。因此，在实际使用中，需要在真实性和计算量之间取一个平衡点，互相取舍。 经过前人的大量实验，当 $p = 3$ 时，模型的效果比较好，算力要求也在容忍范围之内。当 $p$ 的取值从 $3$ 增加到 $4$ 的时候，效果的增长不太明显，算力的要求却大大增加。因此，在实际使用过程中，大都是三元模型；对准确性要求高，且不差钱的时候，一般会选择使用四元模型。 统计语言模型的局限性统计语言模型的主要思想是通过统计人类的语言习惯，代替文法分析，判断某个句子的「合理性」（这个合理性通过概率的大小来量化）。 统计语言模型的局限性一个主要的方面来自计算机算力和容量的限制。这一点上一小节已经讨论过了。 另一方面，也有一些人为创造的歧义句子。这类句子，让真实的人类来阅读，也是可以有多种理解的；因此，统计语言模型也就不可能完美处理这类句子。比如 有小便宜 得大解脱 这是李淡愚先生妙笔生花，将污浊之地「净化」成「道场」的俗联。根据句读不同（还有多音字），可以理解出不同的意思。 有 | 小便（pian）宜，得（de） | 大解脱。 有小便（bian） | 宜，得（dei）大解 | 脱。 两种断句都有道理，都可以理解出通顺的意思。好在这类句子在生活中并不常见，对统计语言模型影响甚小。 统计语言模型的训练问题根据之前的分析，我们知道，在统计语言模型正式工作之前，需要用一个足够大的语料库进行训练。训练的目的就是得到各个 $\langle w_k\rangle$ 和 $\langle w_i,\,w_k\rangle$ 的值备用。 但是，在实际运用过程中，还需要解决一个棘手的问题。我们考虑以下问题： 如果 $w_i, w_k$ 是一个极其罕见的词组，它在实际生活中可能遇到，但是并未包含在语料库中。根据 \eqref{eq:con-prob-solu}，我们会认为 $P(w_k\mid w_i) = 0$。再根据 \eqref{eq:bigram-model}，$P(w_k\mid w_i) = 0$ 会导致整个 $P(S) = 0$。在这种情况下，语料库不够大导致了模型失真，而语料库的不足是一个无法解决的问题。所以我们必须接受模型在某些情况下可能失真，并找出办法消除（或者至少是减弱）这种失真给模型带来的影响。 在实际动手之前，我们先来分析一下实际情况，搞清楚我们到底要修复什么。 问题的根源在于语料库不够大，不足以反映真实语境的具体情况。而罕见词语未在语料库中出现，导致整句话的概率为零，这样的失真现象，只不过是语料库不够大的一个表现而已。那么，很自然地，我们需要思考一下，语料库不够大，只是会导致这一种失真的情况吗？如果我们只对未出现在语料库中的罕见词语进行适当的处理，而忽略了其他可能的失真情况，那么模型依旧不够好。 所谓「未出现」，其实是「出现次数为 0」的另一种表达方式。我们现在对出现次数为 0 的那些词语产生了怀疑，怀疑语料库是否能够真实反映这部分词语的情况；那么我们很自然地会怀疑那些出现次数为 1 甚至为 2 的词语：由于语料库不够大，这些词语在语料库中的出现次数，是否足以反映它们在真实语境中出现的频率呢？ 于是我们发现，我们对出现次数较少的那些词语产生了一定的怀疑。特别地，出现次数越少，我们怀疑它的程度就越高。这样一来，我们的修复方案必须满足一些要求： 对出现次数为 0 的那些词语，我们应该赋予它们一个不为零但非常小的概率； 对于出现次数较少的那些词语，我们应该对它们的统计结果做适当的折算，出现的次数越少，可疑程度越大，因此折算程度也应该越大。 现在我们假设，语料库中共有 $N$ 个词语，在语料库中有 $N_r$ 个词语出现了 $r$ 次。特别地，有 $N_0$ 个词语出现了 $0$ 次。显然我们有： $$ N = \sum_{r = 0}^{\infty}r\cdot N_r. $$ 此外，一般来说，我们有： $$ \text{revise}(r) = N_{r + 1}/N_r \lt 1. $$ 即出现 $k$ 次的词语的数量，一般来说会比出现 $k + 1$ 次词语的数量要多。并且 $k$ 越小，$\text{revise}(r)$ 越大。于是我们可以这样定义 \begin{equation}d_r = (r + 1)\cdot \text{revise}(r).\label{eq:d-r}\end{equation} 如果我们将 $d_r$ 作为折算后的频次，那么显然有： $$ N = \sum_{r = 0}^{\infty}d_r\cdot N_r, $$ 即，这样的折算依然满足全概率为 1。注意到，$d_0$ 是一个大于零的值；而且随着 $r$ 的增大，$\text{revise}(r)$ 会减小，也就是说折算的比例会减小。这些特性正符合我们对折算规则的预期要求。 尽管这样的折算方案符合我们的预期要求，但它有点过于粗暴了。实际上，通常我们会认为，在语料库中出现频次大于某一个阈值 $T$ 的词不需要进行折算。而 \eqref{eq:d-r} 则囫囵地修改了所有词的频次。对于 $P(w_k)$ 来说，这样粗暴的折算问题不太大，但是对于条件概率 $P(w_k\mid w_i),\quad (i = k - 1)$ 来说，不考虑阈值 $T$ 地这样囫囵地折算，误差就比较大了。 基于这样的分析，我们对于二元条件概率的折算修正如下： \begin{equation}P(w_k\mid w_i) = \begin{cases}\frac{\langle w_i,\,w_k\rangle}{\langle w_i\rangle} &amp; \text{if $\langle w_i,\,w_k\rangle \gt T$,}\\d_r\cdot\frac{\langle w_i,\,w_k\rangle}{\langle w_i\rangle} &amp; \text{if $0 \lt \langle w_i,\,w_k\rangle \leq T$,}\\Q(w_i)\cdot\frac{\langle w_k\rangle}{\langle \text{Corpus}\rangle} &amp; \text{otherwise.}\end{cases}\label{eq:bi-d-r}\end{equation} 这里，$r = \langle w_i,\,w_k\rangle$ 而 $d_r$ 是据 \eqref{eq:d-r} 计算出的值。$Q(w_i)$ 是一个修正函数，其定义为： $$A = \sum_{w_k\in \text{Corpus}} P(w_k\mid w_i),$$ $$B = \sum_{w_k\notin \text{Corpus}} P(w_k),$$ $$Q(w_i) = \frac{1 - A}{B}.$$ 至此，二元统计语言模型的修正就结束了。 语料库的选取上一小节我们修正了当出现频次很低时，统计结果不准确，导致的模型失真的问题。这一小节我们讨论可能导致模型不准确的另一个方向的问题。 仔细观察 \eqref{eq:con-prob-solu} 你会发现，模型计算语句 $S$ 的概率，是依据语料库中各个词汇出现的频次的。也就是说，最终的计算结果 $P(S)$ 是和语料库紧密相关的。 众所周知，中国有很多所谓的「网络流行语」。在网络上发帖交流的网友，他们的说话习惯和正式的新闻稿的语言习惯是有很大差别的。如果我们以新闻稿件为语料库去训练模型，然后用于网络语言的分词，那么效果显然不会太好。而如果用网络语言作为语料库，虽然其中可能包括一些杂七杂八的奇怪单词，但是由于语料库与实际使用的类型一致，效果反而会更好。 分词一致性与颗粒度我们回到最初的分析方法，先来看两个词： 清华大学 山东大学 这是两个大学的名字。在这里，对山东大学的分词不会有什么分歧，它就是一个词，不可分割。但是对清华大学的分词就存在分歧了。有的人认为清华大学是密不可分的，也有人认为清华和大学应该分开：清华作为修饰部分修饰大学二字。 这实际上是人们对于词语颗粒度大小认知不同导致的分词不一致。对清华大学的两种分词方法都不能说错，关键是要看语言的使用场合。 在平时写文章的时候，没有必要把清华和大学分开，它们就是一个词。但是在做搜索引擎的时候，就有必要把分词的颗粒度调整一下，变得小一些，认为清华和大学是两个词。毕竟，如果用户搜索「清华」而无法获得和清华大学有关的结果，这样的搜索引擎显然是不合格的。 这样的分析对我们是有启发的。我们没有必要纠结哪一种分词颗粒度更好，实际情况告诉我们，在某些时候大颗粒度更好，某些时候小颗粒度更好。 那么，是否有必要为不同的颗粒度搭建不同的模型呢？答案是否定的。实际上，不管是大颗粒度的分词，还是小颗粒度的分词，模型方法都是一样的，差别只在于对词语的认知问题。如果站在模型的角度上去考虑：模型是不了解词汇的含义的，具体应该用何种颗粒度去构建分词，只取决于语料库中对词语的划分。 因此，解决方案呼之欲出：我们不需要设计两套模型，只需要一套模型就可以完成工作。我们需要做的，是对「清华大学」这类复合词做一个统计，做成两个词表 $L_1$ 和 $L_2$。其中 $L_1$ 包含小颗粒度的分词结果，比如「清华」和「大学」；$L_2$ 包含颗粒度较大的分词结果，比如「清华大学」。在实际使用的过程中，根据需求，分别将 $L_1$ 或者 $L_2$ 与语料库合并，交由模型去训练就好了。 小结这篇文章接着第一篇文章，讨论了统计语言模型，特别是二元模型，在分词方面的应用。这篇文章给出了二元模型的具体描述，以及模型的具体解法。 之后，文章讨论了二元模型不可避免的一些困难，同时对一些可以修复的问题做了讨论。 总的来说，运用统计语言模型解决分词是一个成熟的方案。实际运用时效果的好坏，主要取决于以下几个方面： 工程实现的精度； 语料库的选取； 复合词表的完整度。 下一篇文章将简单介绍统计模型和信息理论在自然语言处理其他领域的应用情况。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Statistic Language Model</tag>
        <tag>Natural Language Processing</tag>
        <tag>Stochastic Process</tag>
        <tag>Markov Process</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自然语言处理的数学原理（一）]]></title>
    <url>%2F2015%2F07%2F25%2Fmathematics-theory-of-natural-language-processing-1%2F</url>
    <content type="text"><![CDATA[一个基本的搜索引擎的工作，基本上可以分成以下三个部分： 利用网络爬虫下载网页，分析网页关键词，制成索引备用； 理解用户输入，确定检索关键词； 根据关键词和网页索引，按照相关性排序列出搜索结果。 第一个部分主要涉及网络爬虫技术、图论、自然语言处理等技术；第二个部分主要涉及自然语言处理；第三个部分同样涉及自然语言处理。 自然语言，即是人类用来交流的语言。 由此可见，自然语言处理（NLP, Natural Language Processing）是现代搜索引擎很重要的内容，其终极目的是将自然语言转化为计算机容易处理的形式。 从分词的角度来看文法分析与统计模型分词是 NLP 需要解决的基础问题，分词算法的好坏直接影响 NLP 的结果。 这里我们先从一个简单的例子说起，逐步探讨合理的分词算法。 从一个简单的句子说起现在有一个句子，比如： 我去电脑城买了一台电脑。 如果要让计算机对这个句子做分词处理，进而理解这个句子，你会有怎样的思路呢？ 大多数人首先会思考一下自己是怎么理解这个句子的。对于中国人来说，这样一个简单的句子，可能不需要什么特殊的思维过程。句子的文字形式和句子背后的含义可以在瞬间反映出来。稍有汉语文法知识的读者，可能会想： 句子可以分成几个部分 我 - 主语 去电脑城买了一台电脑 - 谓语 去电脑城 - 状语 买了 - 谓语动词 一台电脑 - 动词宾语（名词短语） 。 - 句子结束的标识 分别理解每个部分的意思 将意思拼合起来，变成完整的句意 它先通过文法分析，将句子拆分成一个二维的语法树，然后再理解各个部分的含义，最后做拼接。 这样的方案（或者说是算法）是基于文法规则的，清晰明了，也易于实现（在计算机里就是几个循环判断）。对于程序员来说，这样的算法也特别亲切。因为程序员使用的高级编程语言（比如 C++）的语法规则和这样的方案非常相似。 由于这样的算法直观、易于实现，所以人们相信在有了愈加全面的文法概括和愈加强大的计算能力时，人们就能彻底解决自然语言处理的问题了。 文法分析的困境然而，如果你仔细观察文法分析的过程就会发现，这么一个简单的句子被分成了一个这样复杂的二维树状结构，耗费了六条注释。用计算机来处理这样一个过程当然不难，但是要处理现实生活中遇到的真实句子，往往就不那么容易了： 由于理解（understanding）自然语言，需要关于外在世界的广泛知识以及运用操作这些知识的能力，自然语言认知，同时也被视为一个人工智能完备（AI-complete）的问题。 这个句子依然可以用上述方法来处理： 先分成主谓部分 再仔细拆分谓语部分 比如： 自然语言认知 - 主语 - 偏正短语 自然语言 - 名词作定语修饰 认知 - 名词 由于理解（understanding）自然语言，需要关于外在世界的广泛知识以及运用操作这些知识的能力 … 同时也被视为一个人工智能完备（AI-complete）的问题 - 谓语 由于理解（understanding）自然语言，需要关于外在世界的广泛知识以及运用操作这些知识的能力 - 原因状语 … … 同时也被视为 - 谓语动词短语 同时 - 状语 也被视为 - 谓语动词 一个人工智能完备（AI-complete）的问题 - 动词宾语 一个 - 定语 人工智能完备的 - 定语 问题 - 名词 。 - 句子结束的标志 这个句子的语法分析树我没有写完，因为实在太复杂了。显而易见，单纯基于文法分析的分析器是很难处理生活中的真实句子的。 那么问题出在哪里？我认为至少有两个问题。 文法规则数量巨大，上万条语法规则才只能覆盖约 20% 的真实句子；且有些为了处理特殊情况的语法规则和其他规则相互矛盾。 自然语言与程序设计语言不同，自然语言中词汇的具体含义与上下文相关，而程序设计语言则没有这样的歧义性。 从算法复杂度的角度来说，单纯基于文法分析的分析器，用于分析自然语言，其复杂度比分析程序设计语言要高出四个量级。从直观的印象来说，上述句子在一台现代计算机上用文法分析的方式处理，也需要至少一分钟的时间。这种低效是无法接受的。 查字典分词法在之前的文法分析方法里，分词依赖于文法分析的结果。程序要先输出语法树，然后才能得到分词结果。而这样的方法已经被证明是低效的。 这样的低效来源于复杂的文法分析过程。为了提高效率，人们很自然地想到：是否有办法绕开文法分析，直接尝试分词呢？对于中文分词，北京航空航天大学的梁南元教授提出了查字典分词法。做法相当简单，比如对于下列句子： 山东大学数学学院是中国最好的数学基础教育基地之一。 我们让计算机从左到右扫描整个句子，每扫到一个字，就往字典里查询，遇到字典里有的词就标注出来。于是整个句子就被分割成了这样： 山东|大学|数学|学院|是|中国|最好的|数学|基础|教育|基地|之一。 看起来结果不错。不过细心的读者很快就会发现：山东大学和基础教育都是完整的词，在它们之间不应该再做划分。会出现这种情况也不意外，我们要求计算机从左到右扫描。当计算机遇到「山东」二字的时候，就认为这是一个词了，自然不会再去寻找下一个字去寻求匹配。同理基础教育。 梁教授提出了一个方案，即总是搜寻尽可能长的分词。这在计算机科学领域叫做「贪婪」。运用贪婪的办法，上述句子的分词就会变成： 山东大学|数学|学院|是|中国|最好的|数学|基础教育|基地|之一。 看起来就没什么问题了。 不过，汉语博大精深，这种办法也不能一劳永逸。比如： 大学生活区 正确的分词应该是： 大学|生活区 但是按照贪婪的办法，会被分词成： 大学生|活|区 这就不对了。 又比如： 发展中国家 正确的分词应该是： 发展中|国家 而不是： 发展|中国|家 可见，查字典的办法虽然效率很高，但是时有出错，并不牢靠。 查字典的办法遇到的困境来自于自然语言的歧义性。人类在阅读自然语言时，会结合上下文判断有多个意向的词汇在文中的具体含义，但是计算机却没有这个能力。实际上，中国传统文学里说的「句读」，其目的就是通过分词断句来消除歧义。那么，怎么让计算机具备这样的能力呢？ 千呼万唤始出来的统计模型行文至此，数学终于要第一次展现其威力和美丽。 我们之前提到，对一个句子做分词，其正确与否和词汇的二义性紧密相关。由于计算机无力综合上下文判断词汇含义，解决二义性，所以查字典的办法陷入了困境。 数学中有所谓的「反证法」。在这里我们不讲反证法，但是要讲讲反证法的思想。反证法的核心思想就是「正难则反」：正面突破很困难，那就不走大路，开个后门照样进城。在这里，既然计算机没有能力综合上下文解决词汇的二义性，那么我们就不依赖计算机智能去解决，转而借助人工的力量解决。当然，我说的不是找一个工人实时干预程序的运行，帮助程序作出正确的判断；而是说，让计算机经过大量的文本训练，吸取人类的「分词经验」。而这个方法，就是统计模型。 假定一个句子 $S$ 可以有几种分词的方案，比如有以下三种： \begin{align} A_1,\,A_2,\,A_3,\,\ldots,\,A_j \label{eq:fenci-1}\\ B_1,\,B_2,\,B_3,\,\ldots,\,B_k \\ C_1,\,C_2,\,C_3,\,\ldots,\,C_l \\\end{align} 其中，$A_1$, $A_2$, $B_1$, $B_2$, $C_1$, $C_2$ 等都是汉语的词汇。这样一来，如果 \eqref{eq:fenci-1} 是最好的分词，那么 \eqref{eq:fenci-1} 出现的概率应该最大。也就是说，分词方案 \eqref{eq:fenci-1} 应该满足 \eqref{eq:stat-req}。 \begin{equation}\label{eq:stat-req}\begin{cases} P(A_1,\,A_2,\,A_3,\,\ldots,\,A_j) \gt P(B_1,\,B_2,\,B_3,\,\ldots,\,B_k) \\ P(A_1,\,A_2,\,A_3,\,\ldots,\,A_j) \gt P(C_1,\,C_2,\,C_3,\,\ldots,\,C_l) \\\end{cases}\end{equation} 答案就是这么简单。 当然，如何处理 \eqref{eq:stat-req} 需要一点统计知识和技巧；得到这些分词方案也需要依靠动态规划算法（不然计算量太大）；还有诸如分词颗粒大小之类的细节问题需要处理。这些内容我们放在后续的小节里讨论，在这里，读者只需要知道这种利用统计的方法处理分词效果好、效率高就可以了。 小结对于分词来说，统计模型的方法效率比文法分析的方法高，同时效果也要好。这里效率的提升是十分显著的。 此外，我们发现一个优秀算法背后的数学模型是十分简洁优美的。统计模型只需要一个概率不等式组就可以描述，而文法分析模型几乎无法构建一个可读的数学模型。我们在设计算法的时候，要尽可能追求简洁优美的数学模型，从简单粗暴做起，逐步完善完美。正如牛顿爵士所言「真理在形式上总是简单的，而不是复杂含混的」。 最后，文法分析方法是十分容易想到的，十分自然的处理方法，然而这种「自然」也使人误入歧途。这提醒我们，不可固执，不可迷信经验。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Statistic Language Model</tag>
        <tag>Natural Language Processing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反编译 Android 程序小记]]></title>
    <url>%2F2015%2F07%2F21%2Fdecompile-android-application%2F</url>
    <content type="text"><![CDATA[使用 QQ 这么多年，管理的群越来越多。现在每天被入群申请搞得烦不胜烦，于是萌生了写一个 QQ 机器人的想法。 要想实现一个 QQ 机器人，首先是要在程序里模拟登录。经过整理，可用的思路有两个： 使用 WebQQ 的方式登录，模拟浏览器的行为； 使用 Android QQ 的方式登录，模拟 Android 客户端的行为。 二者各有利弊。使用 WebQQ 方式登录协议相对简单，网络上也有相关分析；但是 WebQQ 不能与电脑上的 QQ 共存：登录 WebQQ 就会将电脑上的登录踢下线。使用 Android QQ 的方式登录，由于没有现成的资料可供查询，实现起来十分复杂；但是 Android QQ 是手机端 QQ，可以与电脑端 QQ 共存。 「要做就做好」。思前想后，我还是决定使用 Android QQ 的方式登录。于是问题来了，怎样去抓取 Android QQ 的行为呢？ 在 Android QQ 外围进行抓包分析，然后让程序伪装成 Android QQ 向腾讯的服务器发包； 直接读 Android QQ 的源代码，然后仿照着相关内容重新实现。 方案 1 是常规方法，若能顺利实施，无非是不断重复抓包 - 分析 - 伪造的步骤。不过 QQ 的通信信息是加密处理过的，抓包分析比较费劲。因此，我决定尝试反编译 Android 程序，直接阅读源代码。 这里我介绍反编译安卓程序，得到 Java 代码的详细方法。 请尊重他人劳动成果，勿将此方法用于恶意活动。 解包 .apkAPK 是 Application Package File 的缩写。.apk 文件的实质是一个 .zip 压缩包，包含 Android 运行 APP 所需以下内容： 编译好的代码文件 .dex assets 目录 证书 文件资源（resources.arsc） 文件清单（AndroidManifest.xml） 想要得到源码，首先需要解包 .apk 文件。我们只需要将后缀名从 .apk 改为 .zip，然后按照常规方式解压即可。 处理 AndroidManifest.xmlAndroidManifest.xml 是一个传统的Android清单文件，用于描述该应用程序的名字、版本号、所需权限、注册的服务、链接的其他应用程序。为了搞清楚程序到底做了什么，我们有必要知道这个文件的具体内容。 如果用文本编辑器打开 AndroidManifest.xml，我们会发现其中是一堆乱码。 实际上，AndroidManifest.xml 已经被处理成二进制格式，我们用文本模式打开它乱码是理所应当的。为了正确读取其中内容，我们需要用 AXMLPrinter2 这个工具对它进行处理，将它还原成文本格式。 AXMLPrinter2 官方下载 预防 Google Code 关闭准备的备用链接 之后我们需要运行 1java -jar AXMLPrinter2.jar AndroidManifest.xml &gt; AndroidManifest.txt 将二进制格式的 AndroidManifest.xml 转换为文本格式，并保存在 AndroidManifest.txt 之中。这样我们就能阅读其中信息了。 处理 .dex 文件.dex 文件是 Java 标准的 classes 文件通过 DEX 编译后的文件格式，是用于在 Dalvik 虚拟机上运行的主要代码部分。显而易见，这是我们需要处理的重头戏。 处理 .dex 文件就是要将其还原为 Java 标准的 .jar 文件。为此我们需要用到 dex2jar 这个工具。 dex2jar 官方下载 预防 GitHub 不能用的备用链接（版本 2.0，a9126a9） 解压后，我们在命令行中运行 1/path/to/dex-tools/d2j-dex2jar.sh *.dex Windows 用户运行 1\path\to\dex-tools\d2j-dex2jar.bat *.dex 就能得到 classes.dex 相应的 classes-dex2jar.jar 文件。 处理 .jar 文件，得到 Java 源码.jar 文件是 .class 文件的封装。jd-gui 这个小工具可以以图形化的界面查看 .jar 当中 .class 文件对应的 Java 源码。所得结果可读性非常高。 下载地址： Windows 版 - 官方 - 备用 Mac 版 - 官方 - 备用 使用 jd-gui 打开上一步得到的 .jar 文件，就能看到 .class 对应的 Java 源码了。 按下快捷键 Command + Option + S 保存源码就好啦。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Decompile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修复 MacTeX 2015 无法按字体文件名调用系统字体的问题]]></title>
    <url>%2F2015%2F07%2F11%2Fmactex-2015-system-font%2F</url>
    <content type="text"><![CDATA[XeLaTeX 是 eTeX 的扩展。它直接支持 Unicode 字符，并且能够调用安装在操作系统的字体。这些特性解决了以往 TeX 切换字体不便的问题，对于中文 TeX 用户来说，更是福音。 前段时间，TeX Live 更新到了 TeX Live 2015 版本，Mac OS X 上相应的也更新到了 MacTeX 2015 版本。不过此次更新之后，XeLaTeX 却无法通过字体文件名调用系统字体。亦即，下列代码无法通过编译（提示 font-not-found）： 123456\documentclass&#123;article&#125;\usepackage&#123;fontspec&#125;\setmainfont&#123;GillSans.ttc&#125;\begin&#123;document&#125;GillSans Test.\end&#123;document&#125; XeLaTeX 通过字体文件名调用字体需要 kpathsea 库的协助。默认情况下，kpathsea 会搜索 MacTeX 自己的目录树（TEXMF）。如果希望 kpathsea 搜索系统字体目录的话，还需要配置 OSFONTDIR 这个环境变量。 在 MacTeX 2014 中，这个变量是默认配置好了的。但是在 MacTeX 2015 中，不知为何，这个变量没有预先配置。因此，需要用户自行配置。 具体的配置方法如下： 打开目录：/usr/local/texlive/2015 编辑目录下的文件：texmf.cnf 在文件末尾新建一行，加上：OSFONTDIR = /Library/Fonts//:~/Library/Fonts// 保存文件 重新编译上述代码即可成功]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>MacTeX</tag>
        <tag>Font</tag>
        <tag>XeLaTeX</tag>
        <tag>System</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 LaTeX 的 book 类中实现章节间空白页「This page is intetionally left blank」的效果]]></title>
    <url>%2F2015%2F07%2F03%2Fcleardoublepage-this-page-is-intentionally-left-blank%2F</url>
    <content type="text"><![CDATA[很多书籍在设计版式的时候，会要求 \chapter 从奇数页码开始：上一章节在奇数页结束则留白一页，而后再从奇数页码继续排版。为了避免给读者造成「这里的内容缺失了」的印象，通常会写上「This page is intetionally left blank」的字样。 本文来实现这种效果。 LaTeX 的 book 文档类实现章首页从奇数页码开始，是借助 \cleardoublepage 命令实现的。原始的 \cleardoublepage 命令首先会调用 \clearpage 结束当前页，然后会检查页码状态： 如果是奇数页码，那么什么也不做，直接开始排版 如果是偶数页码，则再一次另起一页，从下一页开始排版 我们可以在 source2e.pdf 中找到这一定义： 我们只需要修改这一定义即可。 1234567891011121314151617\documentclass[UTF8]&#123;ctexbook&#125;\usepackage&#123;tikz&#125;\makeatletter\renewcommand&#123;\cleardoublepage&#125;&#123;\relax \clearpage \if@twoside \ifodd\c@page\relax\else \thispagestyle&#123;empty&#125;% \tikz[remember picture, overlay] \node at (current page.center) &#123;\large 广告位招租&#125;;\newpage\fi\fi&#125;\makeatother\begin&#123;document&#125;\chapter&#123;测试&#125;\chapter&#123;测试&#125;\clearpage测试\chapter&#123;测试&#125;\end&#123;document&#125; 在这里，我们重定义了 \cleardoublepage 命令： 用 \clearpage 结束当前页 检测文档类模式，如果是双面模式，则继续检测，反之则结束操作 继续检测当前页码，当前页码是奇数，则继续排版，反之则将当前页面风格设置为 empty 并用 TikZ 在页面中心写下「广告位招租」几个字 注意，需要编译两遍才能得到正确的结果。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Chapter</tag>
        <tag>Cleardoublepage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[升级 Ubuntu，解决登录时提示有软件包可以更新的问题]]></title>
    <url>%2F2015%2F06%2F27%2Fubuntu-server-packages-can-be-updated%2F</url>
    <content type="text"><![CDATA[Ubuntu 系统在用户登录时会显示欢迎信息。有时用户会看到「有 xx 个软件包可以更新，其中有 xx 个安全更新」。 12345678910111213141516171819Welcome to Ubuntu 14.04.2 LTS (GNU/Linux 3.13.0-48-generic x86_64) * Documentation: https://help.ubuntu.com/ System information as of Sat Jun 27 01:12:04 UTC 2015 System load: 0.0 Processes: 98 Usage of /: 10.6% of 9.71GB Users logged in: 0 Memory usage: 10% IP address for eth0: 192.168.12.233 Swap usage: 0% Graph this data and manage this system at: https://landscape.canonical.com/ Get cloud support with Ubuntu Advantage Cloud Guest: http://www.ubuntu.com/business/services/cloud91 packages can be updated.39 updates are security updates. 对于一般的更新，如果不影响使用，一般也就罢了。但是通常，如果系统提示有安全更新，大多数用户（特别是服务器管理员）还是会去更新的。不过，面对 Ubuntu 的这些提示，很多用户经常遇到「不管怎么 apt-get updage &amp;&amp; apt-get upgrade 也不见好」的问题。 升级命令虽然 apt-get 经常被人诟病，但实际上它还是个挺好用的软件包管理器。在 Ubuntu 14.04 以后的系统中，apt-get 相关的升级更新命令有四个： 1234apt-get updateapt-get upgradeapt-get full-upgradeapt-get dist-upgrade 那么，这四个升级命令都有什么差别呢？ 根据 apt-get 的官方手册： update - 从服务器更新可用的软件包列表。 upgrade - 根据列表，更新已安装的软件包。upgrade 不会删除在列表中已经没有的软件包，也不会安装有依赖需求但尚未安装的软件包。 full-upgrade - 根据列表，更新已安装的软件包。full-upgrade 可能会为了解决软件包冲突而删除一些已安装的软件包。 dist-upgrade - 根据列表，更新已安装的软件包。dist-upgrade 可能会为了解决软件包冲突而删除一些已安装的软件包，也可能会为了解决软件包依赖问题安装新的软件包。 我们应该怎么做？依次执行如下命令即可： 1234sudo apt-get updatesudo apt-get upgradesudo apt-get dist-upgradesudo reboot]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Update</tag>
        <tag>Ubuntu</tag>
        <tag>Server</tag>
        <tag>apt-get</tag>
        <tag>Upgrade</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 TeX Live 测试期间跨版本更新宏包]]></title>
    <url>%2F2015%2F06%2F02%2Ffake-tlpretest-to-update-packages%2F</url>
    <content type="text"><![CDATA[TeX Live 是由国际 TeX 用户组（TUG）维护的 TeX 发行版，一般被认为是 TeX 发行版的「正统」，具有稳定、更新快、维护足的特点。 不过，使用 TeX Live 也有麻烦的地方——TeX Live 每年都更新，而更新版本之后旧版本就无法再从 CTAN 上自动更新宏包。这样一来，TeX Live 用户就不得不每年都重新安装一次，相当麻烦。而且，在新版测试期间更新的宏包，旧版本的用户就无法通过 tlmgr 来更新了。对于中国的用户而言，TeX Live 2014 向 TeX Live 2015 的过渡期尤为难熬，因为 CTeX 宏集的新版本 发布了。 这篇文章中，我将介绍如何在旧版本的 TeX Live 中跨版本更新宏包。 原理虽然听上去麻烦，但实际上还是还是很简单的。 默认情况下，TeX Live 通过新建一个以年份数字为名的目录来区分当前的 TeX Live 版本。比如，对于安装了 TeX Live 2014 的用户，会有这样的目录结构： 123- texlive|- 2014|- texmf-local 按照 TUG 的意图，如果用户在此基础上安装 TeX Live 2015，那么目录结构会变成： 1234- texlive|- 2014|- 2015|- texmf-local 这样做的好处是，用户可以自由地在不同版本之间切换，同时多个版本共用一个 texmf-local 目录（用户配置目录）。只是，对于大多数人的大多数情况来说，这是没有必要的。 因此，为了将 TeX Live 2014 伪装成正在参与测试的 TeX Live 2015，我们首先要将目录名字修改成 2015。修改过目录之后，我们还需要正确处理 TeX 系统的二进制文件和系统 PATH 变量。在这之后，我们只需要将 tlmgr 的远程仓库设置为 tlpretest 仓库就好了。 实际操作看看这里我们以 TeX Live 2014 升级到 TeX Live 2015 pretest 为例，未来版本的升级步骤与此类似。 对于 MacTeX 2014 用户，可以在终端下进行如此操作： 1234567cd /usr/local/texlive/sudo mv ./2014 ./2015cd ./2015/bin/x86_64-darwinsudo ./tlmgr option sys_bin /usr/texbin/sudo ./tlmgr path addsudo tlmgr option repository http://ctan.ijs.si/mirror/tlpretest/sudo tlmgr update --self --all 在这里： 将工作目录切换到 texlive 目录 修改年份目录的名字，从 2014 修改为 2015 由于修改目录名字破坏了 TeX 系统的二进制文件和系统 PATH 之间的关联，在进行下一步操作之后，我们需要切换到二进制文件目录 运行当前目录下的 tlmgr 工具，配置系统二进制文件的目录为 /usr/texbin/ 同样是运行当前目录下的 tlmgr 工具，将 TeX 系统的二进制文件和系统 PATH 重新关联起来 将 tlmgr 的远程仓库设置为 tlpretest 仓库，因为已经配置好上述关联，所以不需要用 ./ 来指明当前目录 使用 tlmgr 更新宏包和其他相关组件 Linux 系统的操作和 Mac OS X 下的操作基本相同，不再赘述。 Windows 用户的操作基本可以在图形界面下操作： 首先进入 TeX Live 的安装目录 然后修改文件夹的名字 在系统设置中，修改 PATH 变量的值 然后打开命令提示符窗口（cmd） 执行命令 tlmgr option repository http://ctan.ijs.si/mirror/tlpretest/ 执行命令 tlmgr update --self --all]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Fake</tag>
        <tag>tlpretest</tag>
        <tag>TeX Live</tag>
        <tag>Update</tag>
        <tag>Packages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[驱动选项错误导致「returned exit code (1)」的错误]]></title>
    <url>%2F2015%2F06%2F01%2Freturned-exit-code-not-0%2F</url>
    <content type="text"><![CDATA[TeX 是一个相当庞大的系统，其中的程序、格式、宏包和工具繁多。新手比较容易接受直观的现象，对于 TeX 系统中繁琐抽象的概念则了解甚少。 比如说，新手听闻「LaTeX」之名，于是在编译的时候看见 pdfLaTeX 或 XeLaTeX 的时候就会犹豫：「这是不是我听说的那个 LaTeX 呢」。于是，新手可能会倾向于使用 LaTeX 去编译。编译完成之后，又面临着将 DVI 文件转化为 PDF 文件的问题，这时候新手又会面临两个选择： 使用 dvips 先转换为 PS 文件，再使用 ps2pdf 转换为 PDF 文件 使用 DVIPDFMx 直接转换为 PDF 文件 两种方式在新手眼中的差异直观而明显：「前一种方式多了 PS 文件这个中间步骤」。诚然，这是对的，但是却忽略了一些细节但关键的东西。这样不经意的忽略往往为后来的错误埋下了根源，比如新手经常会遇到下列一些错误： 使用 WinEdt 时，弹出对话框提示「returned exit code (1)」 编译完成后不报错，但是插入的图片显示异常 编译完成后不报错，但是纸张尺寸或超链接异常 这些错误往往是驱动选项错误导致的，准确地说，是驱动选项和实际使用的驱动不一致导致的。而所谓驱动，就是 dvips 和 DVIPDFMx 这些转换工具。 不同的生成 PDF 文件的路径，会用到不同的工具（我们称之为「驱动」）。这里给一个简单的列表： DVI - PS - PDF：LaTeX -&gt; dvips -&gt; ps2pdf，要用到 dvips 这个驱动 DVI - PDF: LaTeX -&gt; DVIPDFMx，要用到 DVIPDFMx 这个驱动 PDF (Directly): pdfLaTeX，驱动就是它自己（pdfTeX） xDV - PDF: XeLaTeX -&gt; xDVIPDFMx，驱动是 xDVIPDFMx（默认自动调用） 常见的编译方式，至少涉及到 dvips、DVIPDFMx、pdfTeX、xDVIPDFMx 四种驱动。这四种驱动对插图、PDF 书签、页面纸张大小等内容进行处理的时候，语法有细微的差别。为了让驱动正常工作，在 (pdf/Xe)LaTeX 编译的时候，就必须让相应的宏包按照驱动的要求工作。 现在的问题是，宏包怎么知道应当怎么工作？ 如果你有注意到，就会发现，对于 pdfLaTeX 和 XeLaTeX 来说，能使用的驱动就只有一种情况；但是对于 LaTeX 来说，可以选择 dvips 和 DVIPDFMx 两种驱动。因此，如果用户选择 pdfLaTeX 或者 XeLaTeX 编译，那么宏包是可以自己检测到的，此时不需要进行特别的设置。但是，如果用户选择 LaTeX 编译，那么宏包就不知道应该怎么工作了。为了简化代码（也由于历史原因），这些宏包在用户使用 LaTeX 编译的时候，「默认使用」dvips 这个驱动；而如果希望使用 DVIPDFMx 的话，就需要在加载宏包的时候以宏包选项的方式给出说明。 那么什么时候会出错呢？ 其实很简单：当实际使用的驱动和宏包的工作模式（取决于驱动选项）不一致的时候，就会出错。 比如，如果使用 \usepackage[pdftex]{graphicx} 载入 graphicx 宏包，那么就只能使用 pdfLaTeX 编译。此时使用 LaTeX 或者 XeLaTeX 都会报错。又比如，如果使用 \usepackage[dvipdfmx]{hyperref} 载入 hyperref 宏包，那么就只能使用 LaTeX - DVIPDFMx 的方式编译。此时使用 pdfLaTeX、XeLaTeX 或者 LaTeX - dvips 的话就会报错。 更有甚者，如果是这样子： 12\usepackage[pdftex]&#123;graphicx&#125;\usepackage[dvipdfmx]&#123;hyperref&#125; 两个宏包使用的驱动选项不一致，那么不管怎么编译，都会报错。喜欢「抄代码」的新手，经常遇到这样的问题：东抄抄西抄抄，结果两个作者没商量好，写出来的代码一个需要 pdfLaTeX 编译，另一个需要 LaTeX - DVIPDFMx 编译，于是就坑死了新手。所以：代码自己写，不要抄代码。 总结一下，要想得到正确的结果，就必须根据使用的驱动来填写正确的宏包驱动选项。常见的情况记录如下： LaTeX - dvips：默认情况，可以不给驱动选项，也可以给驱动选项 dvips LaTeX - DVIPDFMx：无法自动检测，必须手工给出驱动选项 dvipdfm 或者 dvipdfmx （详情查阅相应宏包文档） pdfLaTeX：可以自动检测，因此可以不给驱动选项，也可以给驱动选项 pdftex XeLaTeX：可以自动检测，因此可以不给驱动选项，也可以给驱动选项 xetex]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Driver</tag>
        <tag>Exit Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTeX 2.0 发布 · 新功能简介]]></title>
    <url>%2F2015%2F05%2F16%2Fctex-20-released%2F</url>
    <content type="text"><![CDATA[CTeX 2.0 的代码主要是 李清 用 LaTeX 3 的语法书写的。之后 刘海洋 对代码做了一些调整，并构建了第一个版本的宏集手册。再之后，在测试版本发布之后，我重构了宏集手册，成为你们现在看到的这个样子。 现在，新版宏集已经上传，CTAN 地址是：http://www.ctan.org/pkg/ctex 首先说一下关于 CTeX 这个名字。CTeX 的 C 是 China 或者 Chinese 的意思，在纯文本环境下，应该写作 CTeX。CTeX 宏集是由 CTeX社区 发起并维护的 LaTeX 宏包和文档类集合。社区另有发布名为 CTeX 套装 的 TeX 发行版。ctex 是本宏集中 ctex.sty 的名字。这一小写的名字过去被用来代指整个 CTeX 宏集，不过现在则专指 ctex.sty 这一宏包。不过，在一些特殊的情况下，由于历史原因，为了与 CTeX 套装做区分，也会用 ctex 来代指整个 CTeX 宏集。 本次更新的是 CTeX 宏集，版本号从 1.02d 升级到 2.0 （当前修复了一些问题，版本号是 2.0.2）。CTeX 套装的最新版本是 2.9.2.164，已有若干年未更新，将来可能也不会再更新，也不推荐使用。 CTeX 2.0 里比较重大的改变有四个： 对底层引擎的支持，放弃了 CCT，新增了 LuaLaTeX（基于 LuaTeX-ja）； 增强了字库选择，新增了华文、Fandol、方正等字库，并提供了基于操作系统自动选择字库的功能； 增强了 ctex.sty 的功能，用键值列表的方式提供选项支持，并提供全新的 \ctexset 接口； 关于字号的部分，在 ctexsize.sty 中单独列出，可独立于 CTeX 宏包或文档类使用。 除此之外，特别有意义的一点是，新版宏集可以做到「只提供中文支持，不改变版式风格」。只需要这样： 1\usepackage[scheme = plain]&#123;ctex&#125; 特别适用于在英文文档中需要添加少许汉字的情况。 除此之外，用户可能会比较关心新版宏集对旧版宏包的兼容性问题。CTeX 2.0 对使用时间较长的稳定版本 1.02c 和 1.02d 做了尽可能的兼容。基于这两个旧版本的宏包书写的文档，在新版本下可以不作任何修改地编译，并且效果几乎一致，但有一些过时选项需要注意。这些选项在新版宏集中基于兼容性考虑被保留，但在将来可能被移除。完整的兼容性可参看宏集手册 12.2 节，这里列出部分比较重要的： cs4size 和 c5size：旧版宏包用于选择文档全局字号的选项，已过时，相当于新版宏集 zihao = -4 和 zihao = 5 的功能。 cap 和 nocap：旧版宏包用于选择排版风格的选项，已过时，相当于新版宏集 scheme = chinese 和 scheme = plain 的功能。 fancyhdr, hyperref 和 fntef：旧版宏包的兼容性选项，均已过时。新版宏集默认打开兼容性，不过需要用户手工载入相关宏包（fancyhdr 和 hyperref）。出于兼容性考虑，选项保留，功能是载入相关宏包。 ctexcap.sty：过时宏包，相当于 \usepackage[heading = true]{ctex}，不推荐使用。 具体的内容，烦请参看新版宏集手册。关于 \ctexset，有不少「很犀利」的用法哦~]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>CTeX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hyperref 宏包 psdextra 选项的 bug 及其 quick fix]]></title>
    <url>%2F2015%2F05%2F11%2Fbug-of-the-hyperref-package-with-mu-in-section-heading%2F</url>
    <content type="text"><![CDATA[今天有人问到下列代码报错： 12345678\documentclass&#123;article&#125;%\listfiles\usepackage[unicode,psdextra]&#123;hyperref&#125;\usepackage&#123;unicode-math&#125;\setmathfont&#123;Asana Math&#125;\begin&#123;document&#125;\section&#123;$\mu$&#125;\end&#123;document&#125; 提示： 1Improper alphabetic constant 看了一下，是 hyperref 宏包的 bug。 实际上，在处理 PDF 书签的时候，很多数学命令要被定义成相应的文本模式，比如 \geq 要被定义为 \textgeq。这个工作在 NFSS 里完成。 但是，数学符号那么多，总有 NFSS 定义不全的时候。于是 hyperref 提供了 psdextra 选项。该选项会载入 psdextra.def 这个文件，提供更多的定义。 不过 \mu 在 NFSS 里和 psdextra.def 里都处理错了。psdextra 里是处理了 \mugreek，而实际上应该是 \mu。于是就出问题了。 解决方法也很简单，自己处理一下就好了。 12345678910\documentclass&#123;article&#125;%\listfiles\usepackage[unicode, psdextra]&#123;hyperref&#125;\usepackage&#123;unicode-math&#125;\setmathfont&#123;Asana-Math.otf&#125;\usepackage&#123;etoolbox&#125;\appto&#123;\psdmapshortnames&#125;&#123;\let\mu\textmugreek&#125;\begin&#123;document&#125;\section&#123;$\mu$&#125;\end&#123;document&#125; 这里 \appto 命令接受两个参数，\appto{&lt;需要修补的命令&gt;}{&lt;填在命令最后的内容&gt;}。这里我们将 \let\mu\textmugreek 添加在命令 \psdmapshortnames 的最后，这样在处理 PDF 书签的时候，\mu 就能被正确处理了。 该 bug 已提交给 hyperref 宏包的作者。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Bug</tag>
        <tag>Hyperref</tag>
        <tag>Psdextra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 Python 生成随机的邀请码]]></title>
    <url>%2F2015%2F05%2F07%2Fgenerator-of-invitation-code-in-python%2F</url>
    <content type="text"><![CDATA[在很多场合，我们都需要生成一系列固定长度的字符串，分发给用户，作为邀请码或者兑换码。 关于邀请码，最容易想到的特征有二：一是足够长，二是不具有规律性。这两个特征主要是为了防止用户伪造邀请码，简单来说，就是让用户「猜对」正确邀请码的可能性足够小。不过，作为邀请码来说，仅有这两个特征还不够。 邀请码并不是发放给用户就结束了，还涉及到验证的过程。用户在收到邀请码之后，将邀请码提交给系统。系统在收到提交之后，要在数据库里查询是否有匹配的记录。所以生成邀请码时除了要防止用户伪造，还要方便后期的校验。这就要求我们能够从邀请码中，经过简单的变换，提取出「主键」。 这篇文章我们讨论一下如何用 Python 生成随机的邀请码。 产生随机数Python 有自带的随机库，其名为 random。random 库中的 randint(inf, sup) 函数可以在指定的范围内产生一个随机整数；choice(sequence) 可以在一个有序的类型中（比如 list、tuple 或 string）随机选取一个元素。 这里我们需要产生一个 15 位的随机串，可以包含数字和大小写字母。 123456# import random, stringpoolOfChars = string.ascii_letters + string.digitsrandom_codes = lambda x, y: ''.join([random.choice(x) for i in range(y)])print random_codes(poolOfChars, 15) 填充空位为了方便统计，主键通常是一个递增的整数序列。如果主键的值从 1 增加到 1000，那么主键的「（十进制）位数」就会从 1 增加到 4。对于邀请码来说，我们需要固定其总长度。反应到主键上，我们就需要固定主键的长度。最简单的办法，就是用 0 填充（pad）空位。 12345678910111213141516171819class LengthError(ValueError): def __init__(self, arg): self.args = argdef pad_zero_to_left(inputNumString, totalLength): ''' takes inputNumString as input, pads zero to its left, and make it has the length totalLength 1. calculates the length of inputNumString 2. compares the length and totalLength 2.1 if length &gt; totalLength, raise an error 2.2 if length == totalLength, return directly 2.3 if length &lt; totalLength, pads zeros to its left ''' lengthOfInput = len(inputNumString) if lengthOfInput &gt; totalLength: raise LengthError("The length of input is greater than the total\ length.") else: return '0' * (totalLength - lengthOfInput) + inputNumString 拼接至此，我们已经得到了主键和随机序列产生的方法，剩下的问题就是要拼接起来。拼接两个字符串很容易，但是我们在拼接完成之后，还要保证能够很容易地找到主键的部分。 为了达成这个目的，我们只需要在主键和随机串之间加上一个固定的字母，比如 L，作为标识符。 bGH49U63p5zy3ULL0123 这样我们就知道，整个邀请码子串最后一个 L 之后，就是主键部分。我们有代码： 123456789101112131415def invitation_code_generator(quantity, lengthOfRandom, LengthOfKey): ''' generate `quantity` invitation codes ''' placeHoldChar = "L" for index in range(quantity): tempString = "" try: yield random_codes(poolOfChars, lengthOfRandom) + placeHoldChar + \ pad_zero_to_left(str(index), LengthOfKey) except LengthError: print "Index exceeds the length of master key."for invitationCode in invitation_code_generator(200, 15, 4): print invitationCode 这样，我们就生成了 200 个邀请码。其中随机串长度为 15，主键长度为 4，分隔符为字母 L。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Invitation Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让所有的公式都使用正文直立字体]]></title>
    <url>%2F2015%2F05%2F07%2Fmake-every-equations-in-your-document-upright%2F</url>
    <content type="text"><![CDATA[首先说明，这是邪道，除非你知道自己在干什么，请不要使用这篇文章提到的方法。这篇文章纯粹是一个技巧的记录，在某些时候可能会有用。 有时候我们会需要将公式字体修改为正文的 \rmfamily\upright\normalsize 的样式。虽然看起来很复杂，其实却很简单。我们只需要在导言区末尾添加以下两行代码： 12\everymath\expandafter&#123;\the\everymath\mathgroup0&#125;\everydisplay\expandafter&#123;\the\everydisplay\mathgroup0&#125; 解释这里实际起作用的是 \mathgroup0。它将数学字体设置为第 0 组字体，也就是正文字体。 而 \expandafter{\the\everymath 能在外层的 \everymath 起作用之前，先将内层的 \everymath 展开。这样可以将 \everymath 的结果保留。若不然，比如有代码： 12\everymath&#123;\displaystyle&#125;\everymath&#123;\mathgroup0&#125; 作者的本意是将每个行内数学公式都是用 \displaystyle，同时设置字体为正文字体。但实际上，由于第二行的存在，第一行的效果被覆盖掉了。为了保证我们添加的代码不影响已有的设置，所以要用 \expandafter{\the\everymath 的方式对已有的设置进行保护。例如，下面的代码则可以达到目的： 12\everymath&#123;\displaystyle&#125;\everymath\expandafter&#123;\the\everymath\mathgroup0&#125;]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Font</tag>
        <tag>Equation</tag>
        <tag>Upright</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PIL 简明教程 - 在现有的图片上涂涂改改]]></title>
    <url>%2F2015%2F05%2F05%2Fpil-tutorial-imagedraw-and-imagefont%2F</url>
    <content type="text"><![CDATA[这是系列文章的第二篇，参见系列中的相关内容。 上一篇文章 介绍了 PIL 的基本情况，以及 Image 模块的基本用法。这篇文章，我们讨论一下 ImageDraw 和 ImageFont 两个模块的基本用法，说说如何用 PIL 在现有的图片上涂涂改改。 ImageDraw 模块ImageDraw 模块提供了 Draw 类，它能在 Image 实例上进行简单的 2D 绘图。当然复杂的绘图动作是由简单的动作合成而得的，理论上这些动作 ImageDraw 模块也能做，只是相对复杂。如果你想在 Image 实例上做复杂的绘图动作，最好是自行对 ImageDraw 模块提供的各种方法做一些封装。 创建一个 Draw 类的实例要在 Image 实例上绘制新的图样，首先要做的就是创建一个 Draw 类的实例。 1234from PIL import Image, ImageDrawsourceFileName = "source.png"avatar = Image.open(sourceFileName)drawAvatar = ImageDraw.Draw(avatar) 代码前三行我们已经见过，唯一的差别在于 import 之后除了我们已经见过的 Image 模块，还有今次我们要使用的 ImageDraw 模块。 从画两条平行线开始Draw 类提供了 line(xy, options) 方法绘制直线。 其中 xy 表示坐标列表，其形式可以是 [(x1, y1), (x2, y2), ...] - 包含若干个元组的列表 [x1, y1, x2, y2, ...] - 按照顺序包含坐标信息的列表 [x1, y1, (x2, y2), ...] - 以上两种情况的混合 ((x1, y1), (x2, y2), ...) - 包含若干个元组的元组 (x1, y1, x2, y2, ...) - 按照顺序包含坐标信息的元组 (x1, y1, (x2, y2), ...) - 以上两种情况的混合 options 中可用的选项有 fill = (R, G, B) - 用于指定线条的颜色，其中 R、G、B 都是 0 – 255 的整数 width = integer - 用于指定线条的宽度，单位是像素 1234567891011121314from PIL import Image, ImageDrawsourceFileName = "source.png"avatar = Image.open(sourceFileName)drawAvatar = ImageDraw.Draw(avatar)xSize, ySize = avatar.sizedrawAvatar.line([0, 0.33 * ySize, xSize, 0.33 * ySize],\ fill = (255, 100, 0), width = 3)drawAvatar.line([0, 0.67 * ySize, xSize, 0.67 * ySize],\ fill = (255, 0, 0), width = 3)del drawAvataravatar.show() 这里我们在图片的两个三等分位置分别画了一条宽度为 3 像素的平行线。一条颜色为 (255, 100, 0)，另一条则是 (255, 0, 0)。 值得注意的是代码的第 14 行，我们直接用 avatar.show() 来展现绘图的结果。可见Draw 类的实例将直接在 Image 实例上进行操作。 画一段弧Draw 类也提供了 arc(xy, start, end, options) 方法来绘制弧。 这里的 xy 是一个长度为 4 的列表，用来表示一个 bounding box（参考上一篇文章）。start 和 end 则是弧的起止角度，单位是 °。其中水平向右的方向为 0°，竖直向下的方向为 90°，水平向左的方向为 180°，竖直向上的方向为 270°。 options 中可用的选项有 fill = (R, G, B) - 用于指定线条的颜色，其中 R、G、B 都是 0 – 255 的整数 arc 方法将在内切于 bounding box 的椭圆中，按照给定的起止角度切下一段弧，并绘制于 Image 示例之上。 123456789101112from PIL import Image, ImageDrawsourceFileName = "source.png"avatar = Image.open(sourceFileName)drawAvatar = ImageDraw.Draw(avatar)xSize, ySize = avatar.sizedrawAvatar.arc([0, 0, xSize, ySize], 0, 90,\ fill = (255, 100, 255))del drawAvataravatar.show() 在图片上写字Draw 类提供了 text(position, string, options) 方法，该方法可以在 Image 实例上写字。 需要说明的是，position 指定的是文本左上角的顶点，而不是文本中心。这里可用的 options 有 font = ImageFont instance - 指定字体，接受一个 ImageFont 的实例 fill = (R, G, B) - 用于指定线条的颜色，其中 R、G、B 都是 0 – 255 的整数 123456789101112from PIL import Image, ImageDrawsourceFileName = "source.png"avatar = Image.open(sourceFileName)drawAvatar = ImageDraw.Draw(avatar)xSize, ySize = avatar.sizedrawAvatar.text([0.9 * xSize, 0.1 * ySize - drawAvatar.textsize("3")[1]],\ "3", fill = (128, 0, 128))del drawAvataravatar.show() 由于没有用 font 选项指定字体，这里使用了 ImageDraw 的默认字体。不难发现，相对图片，字体太小了。为了调整字体，我们需要借助 ImageFont 模块。 ImageFont 模块ImageFont 模块很简单，它定义了一个同名的类。ImageFont 类的实例可以传给 ImageDraw 中 text 方法的 font 的参数，起到字体选择的作用。 ImageFont 模块中的 load 函数可以加载一个 Image 格式的字体，并返回 ImageFont 实例；其中的 truetype(fontfile, fontsize) 函数则可以加载 TrueType 或 OpenType 格式的字体，并返回 ImageFont 参数。不过 truetype 函数需要额外安装 _imagingft 模块。 配置好之后，我们可以对上一节末尾的代码稍作修改： 12345678910111213141516from PIL import Image, ImageDraw, ImageFontsourceFileName = "source.png"avatar = Image.open(sourceFileName)drawAvatar = ImageDraw.Draw(avatar)xSize, ySize = avatar.sizefontSize = min(xSize, ySize) // 11myFont = ImageFont.truetype("/Library/Fonts/OsakaMono.ttf", fontSize)drawAvatar.text([0.9 * xSize, 0.1 * ySize - fontSize],\ "3", fill = (255, 0, 0), font = myFont)del drawAvataravatar.show() 这里我们引入了 ImageFont 模块，并且创建了 myFont 实例。创建实例的时候，传入的字体尺寸由图片大小决定。最后在图片上写字的位置也与字体大小有关。 这样以来，我们就在图片的右上角写了一个红色的数字，就好像微信未读消息提示的那种效果。 小结ImageDraw 模块还有许多其他的功能，比如绘制椭圆、多边形、矩形等。限于篇幅，这里就不一一介绍了。感兴趣的读者可以参看官方文档： http://effbot.org/imagingbook/imagedraw.htm#methods]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PIL</tag>
        <tag>ImageDraw</tag>
        <tag>ImageFont</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语语法之三：动词时态]]></title>
    <url>%2F2015%2F05%2F03%2Ftense-of-verb%2F</url>
    <content type="text"><![CDATA[这个系列的 上一篇文章 已经快一年了。我真是懒啊…… 中文的谓语动词不在时间、状态、语态上作区分。在中文中，这些功能由其它副词提供。在英文中，动词的形态需要根据时间、状态、语态发生改变。对于中国人来说，这样的变化确实有些不自然；选错时态也是中国人讲英文时经常犯的错误。 在这里，语态和说话人的态度相关，比较容易感受。同时，语态反应在动词形态上的变化也相对简单，只需要加上合适的 be 动词，配上动词的过去分词即可。时态和动作发生的时间相关，也相对直观。因此，如果我们能对状态做一些简化，从状态出发去讨论时态，则问题会简单得多。 状态的简化在现代英语中，状态分为 一般状态（如：一般现在式） 进行状态（如：一般进行式） 完成状态（如：现在完成式） 其中，进行状态的语法特征是 be + 动词的现在分词（V-ing）。如果我们「暂时忘掉」进行状态这个概念，把上述结构看做是 be 动词加上补语（表语）的结构，那这个结构和传统语法中的「一般状态」就没什么区别了。只不过，进行状态的动词是个 be 动词而已。也就是说，我们完全可以把进行状态看做是一种特殊的一般状态，它的谓语动词是个空的 be 动词。 因此，我们可以将一般状态和进行状态合并在一起，称之为「简单式」。为了统一称呼，我们把完成状态叫做「完成式」。 注意，这里的简化并不受语态影响。相对主动语态，被动语态不过是 be + 动词的过去分词（V-ed）而已。我们依然可以把被动语态当做 be 动词加上补语（表语）的结构。这样，语态完全不影响上述简化过程。 简单式简单式有几个重要的特征： 简单式的动作，其发生的具体时间是一个特定的时间段 动作发生的时间段可大可小，可以延伸至无穷远的过去或无穷远的将来，也可以缩小至一个具体的时间点 如果动作发生的时间段 包括「现在」这个时间点，那么用现在时态 不包括「现在」这个时间点，且位于现在之前，那么用过去时态 不包括「现在」这个时间点，且位于现在之后，那么用将来时态 第一个特征，给了我们明确的信息来确定我们是否应该使用简单式（而不是完成式）。第二和第三个特征，则为我们选择时态提供了依据。 过去时态 The U.S.A established diplomatic relations with the P.R.C in 1979. 动作发生的时间段是 1979 年，这是一个特定的时间段，所以应该用简单式 这个时间段不包括现在这个时间点，且位于现在之前，所以应该用过去时态 这里不涉及到被动的语态，也不涉及到「持续」或者「正在发生」的含义，所以不需要额外的 be 动词 因此，动词 establish 应该用过去式 established。这是传统语法的「一般过去式」。 The movable print was introduced to England in 1485. 动作发生的时间段是 1485 年，这是一个特定的时间段，所以应该用简单式 这个时间段不包括现在这个时间点，且位于现在之前，所以应该用过去时态 这里涉及到被动的语态，但不涉及到「持续」或者「正在发生」的含义，所以需要用 be + V-ed 的形态 因此，我们需要用 be 动词的过去形态 was，以及 introduced 这个过去分词。这是传统语法的「一般过去式被动语态」。 I was visiting clients the whole day yesterday. 动作发生的时间段是 昨天一整天，这是一个特定的时间段，所以应该用简单式 这个时间段不包括现在这个时间点，且位于现在之前，所以应该用过去时态 这里不涉及到被动的语态，但涉及到「持续」的含义，所以需要用 be + V-ing 的形态 因此，我们需要用 be 动词的过去形态 was，以及 visiting 这个现在分词。这是传统语法的「过去进行式」。 I was watching TV, when I heard the door bell. 动作发生的时间段是 听到门铃响的瞬间，这是一个特定的时间段，退化为一个时间点，所以应该用简单式 这个时间段不包括现在这个时间点，且位于现在之前，所以应该用过去时态 这里不涉及到被动的语态，但涉及到「正在发生」的含义，所以需要用 be + V-ing 的形态 因此，我们需要用 be 动词的过去形态 was，以及 watching 这个现在分词。这是传统语法的「过去进行式」。 The witness was being questioned in court when he had a heart attack. 动作发生的时间段是 心脏病发作的瞬间，这是一个特定的时间段，退化为一个时间点，所以应该用简单式 这个时间段不包括现在这个时间点，且位于现在之前，所以应该用过去时态 这里涉及到被动的语态，所以需要用 be + V-ed；同时，这里也涉及到「正在发生」的含义，所以需要用 be + V-ing 的形态 因此，我们需要用 be 动词的过去形态 was，同时还需要 being 作为 V-ing 部分，然后还需要 question 的过去分词 questioned。这是传统语法的「过去进行式被动语态」。 现在时态 Obama is the U.S. President. 动作发生的时间段是 几年前奥巴马上任之时到几年后奥巴马卸任之时，这是一个特定的时间段，所以应该用简单式 这个时间段包括现在这个时间点，所以应该用现在时态 这里不涉及到被动的语态，也不涉及到「持续」或者「正在发生」的含义，所以不需要额外的 be 动词 因此，我们需要用 is。这是传统语法的「一般现在式」。 Kyrie steals the ball and passes it to LeBron. 这是体育解说员在播报克利夫兰骑士队的比赛，动作发生的时间段是 现在，这是一个特定的时间段，所以应该用简单式 这个时间段包括现在这个时间点，所以应该用现在时态 这里不涉及到被动的语态，也不涉及到「持续」或者「正在发生」的含义，所以不需要额外的 be 动词 因此，我们分别需要用 steal 和 pass 单数第三人称形式 steals 和 pass。这是传统语法的「一般现在式」。 All mothers love their children. 动作发生的时间段是 无穷远的过去到无穷远的将来，也就是所谓的真理，这是一个特定的时间段，所以应该用简单式 这个时间段包括现在这个时间点，所以应该用现在时态 这里不涉及到被动的语态，也不涉及到「持续」或者「正在发生」的含义，所以不需要额外的 be 动词 因此，我们需要用 love 的原型。这是传统语法的「一般现在式」。 这就是为什么，传统语法说「真理要用一般现在式」。其实理解了我们的原理，就不需要被这些「特例」了。 Walmart is selling big cokes at a discount this mouth. 动作发生的时间段是 这个月，这是一个特定的时间段，所以应该用简单式 这个时间段包括现在这个时间点，所以应该用现在时态 这里不涉及到被动的语态，但涉及到「持续」的含义，所以需要用 be + V-ing 形式 因此，我们需要用 be 动词的单三形式 is，跟着 sell 的现在分词 selling。这是传统语法的「现在进行式」。 According to the NASA survey, the ozone layer is being depleted. 动作发生的时间段是 从臭氧层开始被消耗的时候到将来臭氧层不在被消耗的时候，这是一个特定的时间段，所以应该用简单式 这个时间段包括现在这个时间点，所以应该用现在时态 这里涉及到被动的语态，所以需要用 be + V-ed；同时，这里也涉及到「正在发生」的含义，所以需要用 be + V-ing 的形态 因此，我们需要用 be 动词的单三形态 is，同时还需要 being 作为 V-ing 部分，然后还需要 deplete 的过去分词 depleted。这是传统语法的「现在进行式被动语态」。 未来时态 There will be a major election in April. 动作发生的时间段是 下一个四月份，这是一个特定的时间段，所以应该用简单式 这个时间段不包括现在这个时间点，且位于现在之后，所以应该用将来时态 这里不涉及到被动的语态，也不涉及到「正在发生」的含义，所以不需要额外的 be 因此，我们需要用 will 来表示将来时态，同时用 be 的原型，在这里表示「存在」的含义。这是传统语法的「一般将来式」。 Don’t call me at six tomorrow. I will still be sleeping then. 动作发生的时间段是 明早六点，这是一个特定的时间段，退化为一个时间点，所以应该用简单式 这个时间段不包括现在这个时间点，且位于现在之后，所以应该用将来时态 这里不涉及到被动的语态，但不涉及到「正在发生」的含义，所以需要用 be + V-ing 的形态 因此，我们需要用 will 来表示将来时态，用 be 动词的原型，同时接上 sleep 的现在分词 sleeping。这是传统语法的「将来进行式」。 The building will be razed next month. 动作发生的时间段是 下个月，这是一个特定的时间段，所以应该用简单式 这个时间段不包括现在这个时间点，且位于现在之后，所以应该用将来时态 这里涉及到被动的语态，所以需要用 be + V-ed 的形态；但不涉及到「正在发生」的含义 因此，我们需要用 will 来表示将来时态，用 be 动词的原型，同时接上 raze 的过去分词 razed。这是传统语法的「一般将来式被动语态」。 完成式完成式也有几个重要的特征： 完成式的动作，其发生的时间有一个明确的截止时间点，表示「在这之前」或者「至此为止」 如果这个时间点 是「现在」这个时间点，那么用现在时态 是「过去」的某个时间点，那么用过去时态 是「将来」的某个时间点，那么用将来时态 第一个特征，给了我们明确的信息来确定我们是否应该使用完成式（而不是简单式）。第二个特征，则为我们选择时态提供了依据。 现在时态 I’m sure that I have seen this face somewhere. 动作发生的时间不是一个特定的时间段，但有明确的截止时间点，所以应该用完成式 截止时间点是「现在」，所以应该用现在时态 这里不涉及到被动的语态，也不涉及到「持续」或者「正在发生」的含义，所以不需要额外的 be 动词 因此，我们需要用 have 来表示完成时态，接上 see 的过去分词 seen。这是传统语法的「现在完成式」。 We have been working overtime for a week to fill your order. 动作发生的时间不是一个特定的时间段，但有明确的截止时间点（至今已有一周），所以应该用完成式 截止时间点是「现在」，所以应该用现在时态 这里不涉及到被动的语态，但涉及到「持续」的含义，所以需要用 be + V-ing 的形式 因此，我们需要用 have 来表示完成时态，接上 be 的过去分词 been，再加上 work 的现在分词 working。这是传统语法的「现在完成进行式」。 The house has been redecorated twice since they moved in. 动作发生的时间不是一个特定的时间段，但有明确的截止时间点（从他们搬入到现在为止），所以应该用完成式 截止时间点是「现在」，所以应该用现在时态 这里涉及到被动的语态，所以需要用 be + V-ed 的形式；但不涉及到「持续」的含义 因此，我们需要用 have 的单三形式 has 来表示完成时态，接上 be 的过去分词 been，在加上 redecorate 的过去分词 redecorated。这是传统语法的「现在完成式被动语态」。 过去时态一般来说，没有特别说明之时，说「在这之前」就是「在现在这个时间点之前」，所以需要用现在完成式。如果要用过去完成式，则需要有一个明确的过去时间截止点。 Many soldiers had died from pneumonia before the discovery of Penicilin. 动作发生的时间不是一个特定的时间段，但有明确的截止时间点（青霉素被发现之前），所以应该用完成式 截止时间点是「过去」，所以应该用过去时态 这里不涉及到被动的语态，也不涉及到「持续」或「正在发生」的含义，所以不需要用额外的 be 动词 因此，我们需要用 have 的过去式 had 表示过去完成式，接上 die 的过去分词 died 表示实际的动作。这是传统语法的「过去完成式」。 I had been smoking three packs of cigarettes a day before I decided to quit. 动作发生的时间不是一个特定的时间段，但有明确的截止时间点（我决定戒烟之前），所以应该用完成式 截止时间点是「过去」，所以应该用过去时态 这里不涉及到被动的语态，但涉及到「持续」的含义，所以需要用 be + V-ing 的形式 因此，我们需要用 have 的过去式 had 表示过去完成式，接上 be 的过去分词 been 表示进行状态，最后加上 smoke 的现在分词 smoking 来表示实际的动作。这是传统语法的「过去完成进行式」。 In the World War II, Japan had not been defeated yet by the time Germany surrendered unconditionally. 动作发生的时间不是一个特定的时间段，但有明确的截止时间点（德国无条件投降之前），所以应该用完成式 截止时间点是「过去」，所以应该用过去时态 这里涉及到被动的语态，所以需要用 be + V-ed 的形式；但不涉及到「持续」或「正在发生」的含义 因此，我们需要用 have 的过去式 had 表示过去完成式，接上 be 的过去分词 been 表示被动，最后加上 defeat 的现在分词 defeated 来表示实际的动作。这是传统语法的「过去完成式被动语态」。 将来时态和完成式的过去时态一样，将来时态中的完成式需要一个位于将来的时间截止点。 Next April, I will have worked here for 2 years. 动作发生的时间不是一个特定的时间段，但有明确的截止时间点（到下个四月为止），所以应该用完成式 截止时间点是「将来」，所以应该用将来时态 这里不涉及到被动的语态，也不涉及到「持续」或「正在发生」的含义，所以不需要用额外的 be 动词 因此，我们需要用 will have 表示将来完成式，接上 work 的过去分词 worked 表示实际的动作。这是传统语法的「将来完成式」。 Come back at 17:00. Your car will have been fixed by then. 动作发生的时间不是一个特定的时间段，但有明确的截止时间点（下午五点之前），所以应该用完成式 截止时间点是「将来」，所以应该用将来时态 这里涉及到被动的语态，所以需要用 be + V-ed 的形式；但不涉及到「持续」或「正在发生」的含义 因此，我们需要用 will have 表示将来完成式，接上 be 的过去分词 been 表示被动，再加上 fix 的过去分词 fixed 表示实际的动作。这是传统语法的「将来完成式被动语态」。 In another two more minutes, she will have been talking on the phone for three hours. 动作发生的时间不是一个特定的时间段，但有明确的截止时间点（到两分钟之后），所以应该用完成式 截止时间点是「将来」，所以应该用将来时态 这里不涉及到被动的语态，但不涉及到「持续」的含义，所以需要用 be + V-ing 的形式 因此，我们需要用 will have 表示将来完成式，接上 be 的过去分词 been 表示进行，再加上 talk 的现在分词 talking 表示实际的动作。这是传统语法的「将来完成进行式」。]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>Grammar</tag>
        <tag>Tense</tag>
        <tag>Verb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 hexo new 之后立即打开新建的 Markdown 文稿]]></title>
    <url>%2F2015%2F05%2F01%2Fopen-editor-after-hexo-new-immediately%2F</url>
    <content type="text"><![CDATA[自己的博客是用 Hexo 搭建的。Hexo 是其时尚为大学生的台湾人 Tommy 开发的轻量级静态博客生成器，具有简洁、快速、扩展性好等特点。 在 Hexo 中新建一篇博文非常简单，只需要在命令行中执行 1hexo new "the title of your blog" 即可。Hexo 会在后台自动帮你创建名为 yyyy-mm-dd-the-title-of-your-blog.md 的文件，供你撰写博文。不过，也有不方便的地方。通常你需要依次打开 hexo-home/source/_post 目录，然后在成堆的 Markdown 文件中找到刚才创建的文档。 简单搜索之后，我发现在 Hexo 的 GitHub 项目里，有人提出了类似的需求： https://github.com/hexojs/hexo/issues/1007 Tommy 指出，可以在 Hexo 目录下的 scripts 目录（若没有，则新建一个）中创建一个 JavaScript 脚本，监听 hexo new 这个动作。并在检测到 hexo new 之后，执行编辑器打开的命令。 Tommy 给出的代码如下： 1234567891011var spawn = require('child_process').spawn;// Hexo 2.xhexo.on('new', function(path)&#123; spawn('vi', [path]);&#125;);// Hexo 3hexo.on('new', function(data)&#123; spawn('vi', [data.path]);&#125;); 我使用的 Hexo 是 2.5.4 版本，然而，测试过 Tommy 给出的代码之后并没有顺利地打开编辑器。不过精髓已经理解，需要的就只是细节的改变了。 简单翻阅了一下 JavaScript 的语法规则，我尝试了下列 JavaScript 代码： 123456var exec = require('child_process').exec;// Hexo 2.xhexo.on('new', function(path)&#123; exec('open -a "/Applications/Sublime Text.app" ' + path);&#125;); 注意，我这里执行的系统命令，是 OS X 下的 open。换到 Windows 中，可能需要改为 start。 在命令行中敲下 1hexo new "open editor after hexo new immediately" 之后，Sublime Text 顺利打开了相应的 Markdown 文稿。接下来的事情，就是愉快地写作啦！]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用合适的字体回退机制（Fallback）改善网页在 Windows 平台的字体显示效果]]></title>
    <url>%2F2015%2F04%2F30%2Fusing-font-fallback-to-enhance-the-appreance-on-windows%2F</url>
    <content type="text"><![CDATA[昨天在群里提起 Windows 平台下坑爹的中易宋体之屏显效果，今日忽而想起自己的博客在 Windows 平台下显示的也是宋体。当然，这不是我的错。原本的字体机制，博客会按照顺序选择一款无衬线字体，直到无可选择时采用系统默认的无衬线字体。但是坑死人不偿命的云都死系统，把 SimSun （中易宋体）这个带有衬线（好吧，严格来说中文没有这个概念，我们跟着西文勉强这么称呼它）的字体也放进了系统 sans serif 字族里面去。其结果就是，不能丑陋更多。 作为一个强迫症患者，我们来看看如何修复这个问题。 字体选择配置字体回退机制，两个主要的原则就是： 屏显效果好的字体放前面 适用范围小的字体放前面 两条原则共同的作用就是：在尽可能多的平台下，获得相对更好的字体屏显效果。 对于中文来说，安装在作业系统中的主流黑体，屏显效果有大致如下的排序： Hiragino Sans GB - 冬青黑体 Source Han Sans CN - 思源黑体 Microsoft YaHei - 微软雅黑 (On Windows) STXihei - 华文细黑 WenQuanYi Micro Hei - 文泉驿米黑 SimHei - 中易黑体 其中冬青黑体和华文细黑，默认安装在 OS X 作业系统上；微软雅黑和中易黑体则主要安装在 Windows 作业系统上；思源黑体和文泉驿米黑则是 Linux 系统的主流中文黑体。 参考这一屏显效果排序，再结合一些实际情况（比如，在 OS X 作业系统中可能会因为安装 MS Office 而获得微软雅黑和中易宋体），我们给出了这样一个字体回退机制： Hiragino Sans GB STXihei Source Han Sans CN Microsoft YaHei WenQuanYi Micro Hei SimHei 这样，再加上西文的字体和系统默认的 sans serif，我们就得到了完整的字体回退列表： 1font-sans = &quot;Helvetica Neue&quot;, &quot;Helvetica&quot;, &quot;Hiragino Sans GB&quot;, &quot;Source Han Sans CN&quot;, &quot;STXihei&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, &quot;SimHei&quot;, &quot;Arial&quot;, sans-serif 修改 modernist 主题的字体回退配置网页的字体回退机制一般写在样式表（CSS）文件中。hexo 的样式表文件是从一些 styl 文件中产生的，每一个主题的 styl 文件结构都不大一样，所以这篇文章以我使用的 modernist 为准讲述。 modernist 的作者很有心，将一些可能需要个性化配置的变量专门储存在名为 variable.styl 的文件里。这个文件位于 ./theme/modernist/source/css/_base/variable.styl，我们打开它，然后将 font-default 和 font-title 的值改为： 1&quot;Helvetica Neue&quot;, &quot;Helvetica&quot;, &quot;Hiragino Sans GB&quot;, &quot;Source Han Sans CN&quot;, &quot;STXihei&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, &quot;SimHei&quot;, &quot;Arial&quot;, sans-serif 之后，我们在命令行运行 1hexo clean &amp;&amp; hexo d -g 就能将修复好的 CSS 文件推送到仓库了。 之后在 Windows 中打开，就会依照上述字体顺序去检索字体。对于新版的 Windows 系统，一般会以微软雅黑打开；对于旧版的 Windows 字体，一般会以中易黑体打开。]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Font</tag>
        <tag>Fallback</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Git 中 Checkout 历史版本]]></title>
    <url>%2F2015%2F04%2F29%2Fgit-checkout-history-version%2F</url>
    <content type="text"><![CDATA[昨天写代码的时候，误删了一个文件。今天发现的时候，commit 已经 push 到版本库了。本想用 git reset 回退版本，找回文件后重新提交。但是想起 Git 是一个版本控制系统哎，直接从版本库里 checkout 出某个文件的历史版本不就好了？ 想法挺好，但是很久没用这个功能，自己已经不记得具体的命令了。于是查了下手册，把和 checkout 历史版本有关的几个命令都记录一下。 从某个历史版本创建新的分支在 Git 中从当前分支创建并检出新分支的命令是 1git checkout -b name-of-new-branch 这个命令实际上是 1git checkout -b name-of-new-branch current-branch 的简写形式。也就是说，当我们不指定 checkout 起点时，Git 默认从当前活动分支开始创建新的分支。 Git 的每个提交都有一个 SHA1 散列值（Hash 值）作为 ID。我们可以在 checkout 命令中使用这些 ID 作为起点。比如： 1git checkout -b name-of-new-branch 169d2dc 这样，Git 的活动分支会切换到 name-of-new-branch 这个分支上，而它的内容与 169d2dc 这个分支一致。 注意：SHA1 的散列值有 40 个字母，相当长。所以 Git 允许我们在不引起歧义的情况下，使用散列值的前几位作为缩写。 提示：你也可以用 git branch name-of-new-branch 169d2dc 来创建一个历史分支，而不切换到该分支。 将某个历史版本 checkout 到工作区首先说明，这样做会产生一个分离的 HEAD 指针，所以个人不推荐这么做。 如果我们工作在 master 分支上，希望 checkout 到 dev 分支上，我们会这么做： 1git checkout dev 这里 dev 实际上是一个指针的别名，其本质也是一个 SHA1 散列值。所以，我们很自然地可以用 1git checkout &lt;sha1-of-a-commit&gt; 将某个历史版本 checkout 到工作区。 将某个文件的历史版本 checkout 到工作区大多数时候，我们可能只需要对某一个文件做细小的修补，因此只 checkout 该文件就行了，并不需要操作整个 commit 或分支。 上一节我们介绍了如何将某个历史版本完整地 checkout 到工作区。实际上，我们只需要在上一节的命令之后加上需要 checkout 的文件即可。 1git checkout &lt;sha1-of-a-commit&gt; &lt;/path/to/your/file&gt; 当然，有时候你需要将某个文件的历史版本 checkout 出来，并以一个新的名字保存。这时候可以这么做： 1git show &lt;sha1-of-a-commit&gt;:&lt;/path/to/your/file&gt; &gt; &lt;/new/name/of/the/file&gt;]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apple 词典·再要你命 3000 | 美国传统大辞典 | Merriam Webster Collegiate Dict]]></title>
    <url>%2F2015%2F04%2F24%2Fapple-dictionaries-download%2F</url>
    <content type="text"><![CDATA[Apple 为 OS X 设计的词典非常好用，在不进行任何配置的情况下，就可以在全系统范围内进行选词查询。遗憾的是，Apple 并没有为用户提供太多可选的词典。 我用 Python 写了一个程序，将 Babylon 词典软件的 BGL 格式，转换为 Apple Dictionaries 的格式。由于 Babylon 的词典众多，于是 Apple 自带的词典也就多了起来。 这里转换好的有五个词典： 再要你命 3000 美国传统大词典 英汉双解版 柯林斯高阶英汉双解学习词典 美林韦氏大学词典 英汉数学名词词典 英语用法词典 下载后，将 ZIP 归档解包，将得到的 .dictionary 文件（实际上是文件夹）移动到下列目录： 1~/Library/Dictionaries 打开系统里的词典程序，在配置中，就能看到新增的词典了。 下载链接: http://pan.baidu.com/s/1gdIgK0b提取密码: nsp0 文章已转载至知乎：http://www.zhihu.com/question/27098318/answer/46110189]]></content>
      <categories>
        <category>GRE</category>
      </categories>
      <tags>
        <tag>3000</tag>
        <tag>AHD</tag>
        <tag>Merriam Webster</tag>
        <tag>Apple Dictionaries</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PIL 简明教程 - 基本用法]]></title>
    <url>%2F2015%2F04%2F22%2Fpil-tutorial-basic-usage%2F</url>
    <content type="text"><![CDATA[这是系列文章的第一篇，参见系列中的相关内容。 PIL (Python Image Library) 是 Python 平台处理图片的事实标准，兼具强大的功能和简洁的 API。这篇文章将从 PIL 的安装开始，介绍 PIL 的基本情况和基本用法。 安装虽然本篇介绍的是 PIL，但实际上安装的却是 Pillow。PIL 的更新速度很慢，而且存在一些难以配置的问题，不推荐使用；而 Pillow 库则是 PIL 的一个分支，维护和开发活跃，Pillow 兼容 PIL 的绝大多数语法，推荐使用。 在安装 Pillow 之前，需要安装好一些开源库。对于 Mac OS X 而言，可以用 HomeBrew 来安装： 123sudo chown -R $USER:admin /usr/localbrew install libtiff libjpeg libpng webp little-cms2 freetypesudo pip install Pillow 安装好之后，打开 Python 解释器，输入 from PIL import Image 来测试是否安装成功。 新建一个 Image 类的实例PIL 的主要功能定义在 Image 类当中，而 Image 类定义在同名的 Image 模块当中。使用 PIL 的功能，一般都是从新建一个 Image 类的实例开始。新建 Image 类的实例有多种方法。你可以用 Image 模块的 open() 函数打开已有的图片档案，也可以处理其它的实例，或者从零开始构建一个实例。 123from PIL import ImagesourceFileName = "source.png"avatar = Image.open(sourceFileName) 上述代码引入了 Image 模块，并以 open() 方法打开了 source.png 这个图像，构建了名为 avatar 的实例。如果打开失败，则会抛出 IOError 异常。 接下来你可以使用 show() 方法来查看实例。注意，PIL 会将实例暂存为一个临时文件，而后打开它。 1avatar.show() 查看实例的属性Image 类的实例有 5 个属性，分别是： format: 以 string 返回图片档案的格式（JPG, PNG, BMP, None, etc.）；如果不是从打开文件得到的实例，则返回 None。 mode: 以 string 返回图片的模式（RGB, CMYK, etc.）；完整的列表参见 官方说明·图片模式列表 size: 以二元 tuple 返回图片档案的尺寸 (width, height) palette: 仅当 mode 为 P 时有效，返回 ImagePalette 示例 info: 以字典形式返回示例的信息 我们接着上面的代码： 1print avatar.format, avatar.size, avatar.mode 这里我们看到返回了图片的格式 PNG、图片的大小 (400, 400) 和图片的模式 RGB。 实例的方法Image 类定义了许多方法，这里无法一一列出（也无必要）。如果有需要，可以参看 官方说明·Image 模块。这里仅列出几个有趣的应用。 图片 IO - 转换图片格式Image 模块提供了 open() 函数打开图片档案，Image 类则提供了 save() 方法将图片实例保存为图片档案。 save() 函数可以以特定的图片格式保存图片档案。比如 save(&#39;target.jpg&#39;, &#39;JPG&#39;) 将会以 JPG 格式将图片示例保存为 target.jpg。不过，大多数时候也可以省略图片格式。此时，save() 方法会根据文件扩展名来选择相应的图片格式。 我们以一个转换图片格式的脚本进行分析。 1234567891011import os, sysfrom PIL import Imagefor infile in sys.argv[1:]: f, e = os.path.splitext(infile) outfile = f + ".jpg" if infile != outfile: try: Image.open(infile).save(outfile) except IOError: print "cannot convert", infile 这里，f 是除去扩展名之外的文件名。在 try 语句中，我们尝试打开图片档案，然后以 .jpg 为扩展名保存图片档案。save() 方法会根据扩展名，将图片以 JPG 格式保存为档案。如果图片档案无法打开，则在终端上打印无法转换的消息。 制作缩略图Image 类的 thumbnail() 方法可以用来制作缩略图。它接受一个二元数组作为缩略图的尺寸，然后将示例缩小到指定尺寸。 12345678910111213import os, sysfrom PIL import Imagefor infile in sys.argv[1:]: outfile = os.path.splitext(infile)[0] + ".thumbnail" if infile != outfile: try: im = Image.open(infile) x, y = im.size im.thumbnail((x//2, y//2)) im.save(outfile, "JPEG") except IOError: print "cannot create thumbnail for", infile 这里我们用 im.size 获取原图档的尺寸，然后以 thumbnail() 制作缩略图，大小则是原先图档的四分之一。同样，如果图档无法打开，则在终端上打印无法执行的提示。 剪裁图档以前也写过 一篇博客，讲述如何用 PIL 批量剪裁图档，供参考。 变形与粘贴transpose() 方法可以将图片左右颠倒、上下颠倒、旋转 90°、旋转 180° 或旋转 270°。paste() 方法则可以将一个 Image 示例粘贴到另一个 Image 示例上。 我们尝试将一张图片的左半部分截取下来，左右颠倒之后旋转 180°；将图片的右半边不作更改粘贴到左半部分；最后将修改过的左半部分粘贴到右半部分。 1234567891011121314151617181920212223242526272829303132from PIL import ImageimageFName = 'source.png'def iamge_transpose(image): ''' Input: a Image instance Output: a transposed Image instance Function: * switches the left and the right part of a Image instance * for the left part of the original instance, flips left and right\ and then make it upside down. ''' xsize, ysize = image.size xsizeLeft = xsize // 2 # while xsizeRight = xsize - xsizeLeft boxLeft = (0, 0, xsizeLeft, ysize) boxRight = (xsizeLeft, 0, xsize, ysize) boxLeftNew = (0, 0, xsize - xsizeLeft, ysize) boxRightNew = (xsize - xsizeLeft, 0, xsize, ysize) partLeft = image.crop(boxLeft).transpose(Image.FLIP_LEFT_RIGHT).\ transpose(Image.ROTATE_180) partRight = image.crop(boxRight) image.paste(partRight, boxLeftNew) image.paste(partLeft, boxRightNew) return imageavatar = Image.open(imageFName)avatar = iamge_transpose(avatar)avatar.show() image_transpose() 函数定义之前的部分很简单，而函数本身也由文档叙述得比较清楚。 这里我们以 xsize 和 ysize 接收图片的宽和高，然后以 xsizeLeft 计算得到左半边图片的大小。需要注意的是，我们构建了四个元组，并命名为盒子。这个盒子用直角坐标的值在 image 的画布上框定了一个区域。注意，Image 模块以图片的左上角为直角坐标原点，向右为 x 轴正方向，向下为 y 轴正方向。元组中的前两个数，代表区域左上角的坐标值；后两个数代表区域右下角的坐标值。 接下来的代码相当易懂。我们先用 crop() 方法将原图 boxLeft 的区域（也就是原图的左半边）切下来，然后用 transpose() 方法先后进行左右颠倒和旋转 180° 的工作，并最周公将它保存在 partLeft 这个实例中。而 partRight 的操作更为简单。 函数的最后，我们用 paste() 方法，将前两步得到的 partLeft 和 partRight 分别粘贴到指定的区域；并最终返回 image 示例。 代码片段的最后，我们用 show() 方法展示图片。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PIL</tag>
        <tag>Image</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[避免 \chapter 命令分页]]></title>
    <url>%2F2015%2F04%2F22%2Fcancle-clearpage-in-chapter%2F</url>
    <content type="text"><![CDATA[LaTeX 的 book 类中，\chapter 命令用来标记章节。在生成的 PDF 文稿中，\chapter 总是另起一页；在打开（默认）openright 选项的时候，可能还会空白一页。在实际使用过程中，很多人希望 \chapter 不要换页，紧接着当前页的内容排版。 传统工具没有提供此功能，因此用户需要自行修改 \chapter 的定义。 找到 \chapter 的定义LaTeX 标准文档类的定义写在 classes.pdf 这个文档中，你可以在命令行下使用 texdoc classes 来打开这份文档。 你可以在文档的 7.2.6 节中找到 \chapter 的定义。和我们的问题相关的，就是 \chapter 定义的第一行。 得益于 文学编程，我们看到文档中明确地写着「章节总是应该从新的一页开始，因此我们需要调用 \clearpage」。 显然，为了达到目的，我么只需要令 \chapter 定义的第一行失效就好了。 打补丁xpatch 宏包可以用来打补丁。它的 \xpatchcmd 命令接受五个参数：\xpatchcmd{命令}{搜索}{替换}{成功}{失败} 命令：待处理的命令 搜索：需要被替换的部分 替换：将被替换的内容 成功：替换成功执行的内容 失败：替换失败执行的内容 这里我们需要将 \if@openright\cleardoublepage\else\clearpage\fi 替换掉。用于替换的内容则是：\par\relax。因此我们有代码： 123456\usepackage&#123;xpatch&#125;\makeatletter\xpatchcmd&#123;\chapter&#125; &#123;\if@openright\cleardoublepage\else\clearpage\fi&#125;&#123;\par\relax&#125; &#123;&#125;&#123;&#125;\makeatother 注意，符号 @ 是一个保留符号。它在用户编写 .tex 文档的时候和开发者编写宏包/文档类的时候具有不同含义。我们用 \makeatletter 将 @ 的含义切换到开发者模式；在进行修改之后，用 \makeatother 将 @ 的含义切换到用户模式。 这样，\chapter 定义中的换行部分，就被替换成了分段。 完整的示例代码： 123456789101112\documentclass&#123;book&#125;\usepackage&#123;xpatch&#125;\makeatletter\xpatchcmd&#123;\chapter&#125; &#123;\if@openright\cleardoublepage\else\clearpage\fi&#125;&#123;\par\relax&#125; &#123;&#125;&#123;&#125;\makeatother\usepackage&#123;blindtext&#125;\begin&#123;document&#125;\blindtext\chapter&#123;test&#125;\end&#123;document&#125;]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Chapter</tag>
        <tag>Pagebreak</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 MacTeX 中使用中文模板]]></title>
    <url>%2F2015%2F04%2F14%2Fusing-chinese-templates-in-mactex%2F</url>
    <content type="text"><![CDATA[中国人使用 LaTeX 的一大问题就是为文档添加中文支持。国内很多学校、期刊都有自己的模板，更多的是一些个人配置的勉强成型的小模板。Mac 用户安装 MacTeX 之后，可能会很头疼如何将这些模板移植到自己的电脑上。这篇文章对此做一个方法上的讨论。 在 LaTeX 中使用中文，不严谨地说，主要需要解决编码和字体调用的问题。 国内 LaTeX 圈子流行过 GBK 编码和 UTF-8 编码。前者是国标，是过去的主流，但是问题多多。现在推荐使用后者。 字体调用方面，原来的 CCT（新版）、CJK 还有现在的 xeCJK、LuaTeX-ja 和李阿玲的 pTeX-ng 在 TeX Live（MacTeX）底下都能正常工作。只不过，Mac 默认的字体和 Windows 默认的字体有一些不同，在这方面需要做一些调整。 国内期刊的模板大多数是 CCT 和 CJK 方式，其他一些模板可能比较先进，使用 xeCJK 方式。LuaTeX-ja 国内用的少，使用方法和 xeCJK 比较类似；pTeX-ng 尚在开发中。所以这里只介绍使用 CCT、CJK 或 xeCJK 三种中文支持方式在 TeX Live 里如何进行调整。 xeCJKxeCJK 通过 \setCJKmainfont 等命令（luatexja-fontspec 则是 \setmainjfont）来调用操作系统内的字体，并设置为文档字体。在 Windows 底下编写的中文模板，惯常使用 Windows 自带的中易系列字体，比如 123\setCJKmainfont[Boldfont = SimHei, ItalicFont = KaiTi]&#123;SimSun&#125;\setCJKsansfont&#123;SimHei&#125;\setCJKmonofont&#123;FangSong&#125; 这种情况下，可以打开模板文件（.tex、.sty 或 .cls），找到字体设置部分，将其内容改为 Mac 的字体设置即可。比如可以参考配置： 123\setCJKmainfont[BoldFont=STZhongsong, ItalicFont=STKaiti]&#123;STSong&#125;\setCJKsansfont[BoldFont=STHeiti]&#123;STXihei&#125;\setCJKmonofont&#123;STFangsong&#125; 具体的含义可参考：为 MacTeX 配置中文支持 使用 xeCJK 的模板，应该都保存为 UTF-8 编码，所以不需要进行编码调整。（部分模板使用 GBK 编码，在文档头会有 \XeTeXinputencoding &#39;CP936&#39; 的 XeTeX 原语。此时最好将文件另存为 UTF-8 编码，并删除这些原语。） CJK在不适用 zhmetrics 技术的时候，CJK 需要 Type 1 字体。将中易字体拆分成许多 sub-fonts 并转换为 Type 1 字体是个费时费力的工作。CTeX 套装打包了已经配置好的 CJK 字体，它的 song、hei、kai、fs、li 和 you 等六套字体，流传甚广。国内使用 CJK 的模板，大都使用了这几套字体。 不过，CJK 宏包本身并不含有这些字体，所以在使用 TeX Live 的时候，直接编译这些模板会报错。 我们看一段最简单的使用 CJK 宏包做中文支持的例子。 12345678\documentclass&#123;article&#125;\usepackage&#123;CJKutf8&#125;\begin&#123;document&#125;\begin&#123;CJK*&#125;&#123;UTF8&#125;&#123;song&#125;中文。\clearpage\end&#123;CJK*&#125;\end&#123;document&#125; 对于 Windows 系统的 TeX Live 用户而言，最简单的办法是使用 zhmetrics 技术。为此我们只需要在导言区添加一行命令即可，代码变为： 123456789\documentclass&#123;article&#125;\usepackage&#123;CJKutf8&#125;\AtBeginDvi&#123;\input&#123;zhwinfonts&#125;&#125;\begin&#123;document&#125;\begin&#123;CJK*&#125;&#123;UTF8&#125;&#123;song&#125;中文。\clearpage\end&#123;CJK*&#125;\end&#123;document&#125; 此时，使用 pdfLaTeX 或 LaTeX - DVIPDFMx 编译文档，即可得到正确的结果。 对于 Mac/Linux 系统的 TeX Live（MacTeX）用户而言，简单地加载 zhwinfonts.tex 是不会奏效的。zhwinfonts.tex 是为 Windows 系统配置的文件，在 Mac/Linux 系统中缺少这些字体。我自己买了方正系列字体在 Mac 上使用，所以写了一个 zhfzfonts.tex 来调用这些字体。 需要做的事情： 安装下列字体（涉及到版权，这里就不提供了） 方正书宋 GBK：FZSSK.TTF 方正楷体 GBK：FZKTK.TTF 方正黑体 GBK：FZHTK.TTF 方正仿宋 GBK：FZFSK.TTF 华文隶体：STLITI.ttf（Mac 自带） 华文琥珀：STHUPO.TTF（Mac 自带） 下载 zhfzfonts.tex 将 zhfzfonts.tex 保存在 TEXMFLOCAL/tex/generic/zhmetrics/ 目录下 使用 texhash 刷新文件名数据库（可能需要 root 权限） 调整代码 这里 TEXMFLOCAL 指的是 TeX Live 供用户使用的 TDS 根目录，在 MacTeX 里是 /usr/local/texlive/texmf-local。 CJK 支持 GBK，也支持 UTF-8。请注意将文档编码保存为与 CJK 环境相同的编码格式。 CCT以系统工程理论与实践为代表的一些国内期刊，使用 CCT 模板。前年为此写过一篇博客，专门讨论此类模板。参见：国内期刊 CCT 模板编译经验 CCT 只支持 GBK 编码。 ctex 宏包/文档类ctex 宏包/文档类在使用 XeLaTeX 编译的时候，使用 xeCJK 作为中文支持方式；在使用 LaTeX/pdfLaTeX 的时候使用 CJK 作为中文支持方式。因此，使用 ctex 宏包/文档类的模板，在 TeX Live 系统下的配置方式需要根据所选的编译方式做调整。 使用 XeLaTeX 的时候，需要给 ctex 加上 nofonts 选项（将来的 2.0 版本则是 fontset = none），然后再用 \setCJKmainfont 配置字体。 使用 LaTeX/pdfLaTeX 的时候，则可以使用 zhfzfonts.tex 来映射字体。 使用 ctex 宏包/文档类的时候，需要根据所选的编译方式和宏包/文档类选项来确定源文件的编码格式。 使用 XeLaTeX 的时候，不论选项为何，源文件都需要保存为 UTF-8 编码。 使用 LaTeX/pdfLaTeX 的时候，则需要根据宏包/文档类选项来确定源文件的编码格式。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Template</tag>
        <tag>Chinese</tag>
        <tag>MacTeX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 LaTeX 中将不编号的章节列入目录]]></title>
    <url>%2F2015%2F04%2F10%2Fhow-to-list-unnumbered-section-in-the-table-of-contents%2F</url>
    <content type="text"><![CDATA[LaTeX 标准文档类提供了 \section 和 \section* 等两组命令，用于排版章节标题。其中不带星号的版本有章节编号，会列入目录，同时修改章节标记。带星号的版本只有章节标题格式而不编号，不列入目录，也不会修改章节标记。 有时，我们会希望将不编号的章节标题列入目录。这种情况使用 \section 或 \section* 都不大合适。本文将对这些问题做出分析，并给出解决方案。 LaTeX 标准文档类的 \section 命令做四件事情： 编号自增 1 输出章节标题 处理目录（和 PDF 书签） 做页眉的章节标记 相应地，\section* 命令只做上述第二件事情，其余三件都不做。 因此，我们的思路很简单，有两个方向。第一，使用 \section*，手工做目录的处理；第二，使用 \section，但是抑制编号。 思路一LaTeX 处理目录需要编译两次。在第一次编译的过程中，\section 命令将目录信息写入 .aux 文件。随后，在第二次编译的过程中，LaTeX 读取 .aux 文件中的相应信息，形成目录。因此，我们只需要模仿 \section 写入 .aux 文件的过程就可以了。 LaTeX 提供了 \addcontentsline{&lt;辅助文件后缀&gt;}{&lt;章节等级&gt;}{名字} 命令来做这样的工作。我们来看一个例子。 123456\documentclass&#123;ctexart&#125;\begin&#123;document&#125;\tableofcontents\section*&#123;不编号的章节标题&#125;\addcontentsline&#123;toc&#125;&#123;section&#125;&#123;不编号的章节标题&#125;\end&#123;document&#125; 思路二LaTeX 标准文档类中的 \appendix 命令，会使得后续的章节标题从 0 开始编号，同时将编号格式从阿拉伯数字修改为大写英文字母。\appendix 命令虽然不符合我们的需求，但是产生的效果却和我们需要的效果类似：修改了章节标题编号。我们可以对这个命令做适当的修改，达成我们的目的。 我们来看一下 article.cls 里的 \appendix 是如何定义的。 1234\newcommand\appendix&#123;\par \setcounter&#123;section&#125;&#123;0&#125;% \setcounter&#123;subsection&#125;&#123;0&#125;% \gdef\thesection&#123;\@Alph\c@section&#125;&#125; 接下来，我们仿造它，定义一个新的命令 \specialsectioning。 1234567891011\documentclass[hyperref]&#123;ctexart&#125;\newcommand\specialsectioning&#123;\par \setcounter&#123;section&#125;&#123;0&#125;% \setcounter&#123;subsection&#125;&#123;0&#125;% \renewcommand\thesection&#123;\relax&#125;&#125;\begin&#123;document&#125;\tableofcontents\section&#123;正常编号的章节标题&#125;\specialsectioning\section&#123;不编号的章节标题&#125;\end&#123;document&#125; 编译之后我们会发现，在 \specialsectioning 之后的 \section 虽然不带星花，但已然不编号了，并且出现在了目录当中。 不过，正常标题的编号和标题正文之间是有一定的空距的。我们现在虽然将编号取消了，但是这个空距依然存在。虽然它不明显，但是毕竟是个问题。作为一个精益求精的完美主义者，我们要解决它。 正文中编号的格式由 LaTeX 内部宏 \@seccntformat 控制，默认是在编号后面加一个 \quad，我们把它去掉。 1\def\@seccntformat##1&#123;\@nameuse&#123;the##1&#125;&#125; 此外，目录中的编号和章节标题之间也有距离，我们通过 tocloft 宏包来将这个距离设置为 0pt。 1\addtocontents&#123;toc&#125;&#123;\def\cftsecnumwidth&#123;0pt&#125;&#125; 这样，完整的代码变成： 12345678910111213141516\documentclass&#123;ctexart&#125;\usepackage&#123;tocloft&#125;\makeatletter\newcommand\specialsectioning&#123;\par \setcounter&#123;section&#125;&#123;0&#125;% \setcounter&#123;subsection&#125;&#123;0&#125;% \renewcommand\thesection&#123;\relax&#125;% \def\@seccntformat##1&#123;\@nameuse&#123;the##1&#125;&#125;% \addtocontents&#123;toc&#125;&#123;\def\cftsecnumwidth&#123;0pt&#125;&#125;&#125;\makeatother\begin&#123;document&#125;\tableofcontents\section&#123;正常编号的章节标题&#125;\specialsectioning\section&#123;不编号的章节标题&#125;\end&#123;document&#125; 问题解决了，不过思路二这样做未免麻烦。在这个思路下，会不会有更简单的方法呢？答案是肯定的。 在 LaTeX 标准文档类中，secnumdepth 这个计数器是用来控制章节编号深度的。在 article 中，这个计数器的值默认是 3，对应的章节命令是 \subsubsection。也就是说，默认情况下，article 将会对 \subsubsection 及其之上的所有章节标题进行编号，也就是 \part, \section, \subsection, \subsubsection。 LaTeX 标准文档类中，最大的标题是 \part。它在 book 和 report 类中的层级是「-1」，在 article 类中的层级是「0」。因此，我们只需要将计数器设置为 -2，之后章节命令都不会编号了，从而解决问题。 我们来看一下代码。 12345678910\documentclass&#123;ctexart&#125;\makeatletter\newcommand\specialsectioning&#123;\setcounter&#123;secnumdepth&#125;&#123;-2&#125;&#125;\makeatother\begin&#123;document&#125;\tableofcontents\section&#123;正常编号的章节标题&#125;\specialsectioning\section&#123;不编号的章节标题&#125;\end&#123;document&#125; 怎么样？是不是简单多了？]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Section</tag>
        <tag>Sectioning</tag>
        <tag>Numbering</tag>
        <tag>Table of Contents</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将微信上的文章推送到 Kindle 上]]></title>
    <url>%2F2015%2F03%2F23%2Fpush-articles-to-kindle-from-wechat%2F</url>
    <content type="text"><![CDATA[微信是近几年发展起来的社交网络。微信公众号和微信朋友圈的出现，让微信变成了一个优秀的信息发布和传播平台。有甄别能力的同好，往往能在微信上找到不少好的文章。但是，一来用手机查看文章伤眼，二来微信上的文章不变保存，三来用手机看文章需要网络支持。总之，是有诸多不便。 昨天思考到这个问题之后，我有做一些搜索，而后就有了欣喜的发现：可以将微信里的文章、好友发来的文字消息免费推送到 Kindle 设备上。 原理激活 Kindle 之后，亚马逊都会为每一台 Kindle 设备分配一个电邮地址。向这个电邮地址里发送包含电子书的邮件，就可以将电子书推送到 Kindle 上了。当然，如此的话，可能会造成垃圾信息泛滥。因为如果不加限制，任何人都能往用户的 Kindle 上推送文件，结果会是一团糟。基于这些考虑，在亚马逊官网的后台里，提供了「认可的电邮地址」的设置。亚马逊在收到邮件之后，会检查这个认可的电邮列表。只有来信电邮在列表当中，亚马逊才会将电子书推送到 Kindle 上。 简单来说，亚马逊将 Kindle 和一个特定的电邮地址关联在一起，通过可信邮箱往上述电邮地址发送邮件，就能把附件中的电子书推送到 Kindle 上。 有了这样的基础知识，就不难理解微信推送的原理了。 亚马逊官方在微信上设立了一个公众平台，平台的后端就是一个电子邮箱。我们将微信上的文章保存在公众平台里，后端邮箱就会把文章发送到 Kindle 邮箱中，最后再推送到 Kindle 设备上。 明确原理之后，我们来进行设置。 亚马逊官网这里以中国亚马逊为例，如果你的 Kindle 使用的是美国亚马逊账号，请登录美国亚马逊网站进行相应操作。 登录中亚之后，点击下面的链接，进入 Kindle 管理页面。 https://www.amazon.cn/mn/dcw/myx.html 进入「我的设备」一栏，找到你的 Kindle 设备对应的图标。页面下方会显示出该设备对应的 Kindle 邮箱，请记下来。 进入「设置」一栏，在页面底部，点击「添加认可的电子邮箱」，将 `kindle@eub-inc.com` 添加到列表当中。 微信首先我们要关注亚马逊的微信公众平台。搜索公众号 cn_Kindle 并关注「亚马逊 Kindle 服务号」。 接下来，进入服务号界面，向服务号发送消息 绑定+你的 Kindle 邮箱地址。比如 绑定+myemail@kindle.cn。 实际使用看看周筠老师今天分享了一篇文章，我们把它推送到 Kindle 上看看。 打开这篇文章后，点击右上角的 ···，选择「亚马逊 Kindle 服务号」。 将你的 Kindle 设备连上网络，过一会儿，就能收到推送了。]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Kindle</tag>
        <tag>WeChat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么我乐于分享？]]></title>
    <url>%2F2015%2F03%2F19%2Fwhy-i-love-to-share%2F</url>
    <content type="text"><![CDATA[今天在知乎上第一次尝试回答了一个感情类问题，得到了周筠老师的赞同。虽说是感情类问题，但主要想提及的是关于分享和共同进步的问题。无奈这个话题相对提问来说有些偏，所以只能另开文章讨论。 媳妇儿是个文科生，偏偏和我这个理科生看对了眼。我喜欢文学，却不得要领。每次看见媳妇儿写的文章，都羡慕嫉妒并着抓耳挠腮。媳妇儿是典型的文科生，对现象和规律不如理科生那么敏感。正赶着媳妇儿要学开车，对离合器一无所知有些犯怵。走在张家界的澧水大桥上，我就给她从她接触过的几个简单的物理公式讲起，借着变速自行车的例子把离合器和变速箱的原理讲了一遍。我不知道媳妇儿有没有都听明白，但是我讲完扭头看着她，分明是一脸崇拜的花痴样（我已经做好了跪搓衣板的准备，笑）。 媳妇儿说，她前男友是学语言的。偏偏媳妇儿是一个上进的姑娘，那时见着男朋友懂这门语言，就想请教。然而他却怎么也不肯教，问起原因，说是「担心教会了之后就没有吸引力了」。于是媳妇儿就问我，为什么我愿意将我所知道的知识分享给她。我说，「我把这些东西教给你，帮你打开思路，那样每天就能看见一个更好的你了，而且我也有向你学习啊」。 其实，两个人学习的专业不同、从事的行业不同、经历的人生不同，这些不同必然造成思维方式和处事模式的差异。两个人互相从对方身上学习，互相进步，这样日子才会过得越来越好，关系也会越来越亲密。 后来回到住处，媳妇儿给我说「你知道嘛，爱情就是两个人互相促进共同进步，所以我和你在一起特别有安全感」。文科生就是文科生，不对，媳妇儿不愧是我媳妇儿，我对媳妇儿这句话深表赞同，而且我认为在工作上也是如此。 父亲在我小的时候，因为工作的关系，去过不少公司工厂。每次出差回来，父亲都会讲讲所见所闻。虽然大多数的故事我都记不得了，但是有一则故事我一直记到现在。 父亲说，那次去的化工厂的技术部副主任以前是个技术过硬的老师傅，靠着自己的技术一步步走到这个位置。但是，现在的主任比他年轻得多，而且是以前还在他手下干过活。其实按照老师傅的资历和技术，他早就可以得到提拔。只是老师傅当年掌握着关键技术，因为害怕被人取代，所以不真心实意地教徒弟。这样一来，很长时间里都没有人能代替老师傅的位置。因此虽然薪资加了不少，但是领导一直不怎么提拔他。他就只能看着自己曾经的手下一步步超越自己。 其实，一方面，总结和分享的过程对自己也是一种学习；另一方面，学习是相互的，在自己分享的过程中，也会从对方身上学到自己不具备的东西；再者，给对方机会也最终是给自己机会。所以，真正自信的人都不会害怕分享自己的知识和技能，他们的着眼点永远是共同进步，一起变得更好。 所以啊，在被请教的时候，以及，更多地在生活的细微末节上，都不要吝惜自己的知识不乐于分享，更不要自觉高人一等盛气凌人。我一直认为，成长不是变得势利，而是变得温柔，对全世界都温柔。乐于分享，乐于共同进步，就是一种温柔呢。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Share</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 LaTeX 中进行文学编程]]></title>
    <url>%2F2015%2F01%2F23%2Fliterate-programming-in-latex%2F</url>
    <content type="text"><![CDATA[文学编程是 TeX 的作者高德纳提出的编程方式，主张程序员在编写代码的过程中详细地记录自己的思维方式和内在逻辑。 这种编程方式注重编码的逻辑而将编码本身放在更次要的位置，因而不充分的设计在这种编程方式下无所遁形。文学编程的另一个优点是它产生的代码文档能帮助程序员在任意时候重新会想起当时编码的思路。 在 LaTeX 中，可以用 Doc 和 DocStrip 这两个工具来实现文学编程。 对于程序员来说，最重要的有三个部分： 代码； 代码文档； 用户手册。 使用 Doc 和 DocStrip 可以将这三个部分集中到一个 .dtx 文件当中。这篇文章将分三个部分讲述如何构建这样一个 .dtx 文件。 .ins 文件INS 三个字母是「Install」的缩写，顾名思义，这个文件是和安装相关的。.ins 文件通常用来控制 TeX 从 .dtx 文件里释放宏包文件，它的结构最为简单，大概是这样的。 作为注释的版权信息 载入 docstrip.tex 写入 DocStrip 的控制命令 编写将写入生成文件的版权信息 生成文件指令 写入提示信息用以完成安装 结束安装文件 这里粗体标记的是必不可少的部分，其他部分或多或少都可以省略。 我们逐步构建一个完整的 .ins 文件。 123456789101112131415161718%% Copyright (C) 2003--2015%% CTEX.ORG and any individual authors listed elsewhere in this file.%% --------------------------------------------------------------------------%%%% This work may be distributed and/or modified under the%% conditions of the LaTeX Project Public License, either%% version 1.3c of this license or (at your option) any later%% version. This version of this license is in%% http://www.latex-project.org/lppl/lppl-1-3c.txt%% and the latest version of this license is in%% http://www.latex-project.org/lppl.txt%% and version 1.3 or later is part of all distributions of%% LaTeX version 2005/12/01 or later.%%%% This work has the LPPL maintenance status `maintained'.%%%% The Current Maintainers of this work are Leo Liu, Qing Lee and Liam Huang.%% -------------------------------------------------------------------------- 这是 ctex 宏包的版权声明信息。 这里的每一行都以百分号开头，因此在声明版权的同时不会影响正常的编译流程。 版权声明部分，首先是声明版权的归属。 接下来，声明许可协议为 LPPL。大多数 TeX 相关的宏包或软件，都在 LPPL 协议下发布。 1\input docstrip.tex 载入 docstrip.tex。 1\keepsilent 这是 DocStrip 的控制命令之一，其作用是关闭 DocStrip 的日志输出功能。默认情况下，DocStrip 会详细输出它的每一步操作。对于大多数人来说，成百上千行的日志徒惹人嫌弃，因此我们关闭它。 更多的控制命令可以参考 DocStrip 的文档。 12345678910111213141516171819202122\preamble Copyright (C) 2003-2015 CTEX.ORG and any individual authors listed in the documentation.------------------------------------------------------------------------------ This work may be distributed and/or modified under the conditions of the LaTeX Project Public License, either version 1.3c of this license or (at your option) any later version. This version of this license is in http://www.latex-project.org/lppl/lppl-1-3c.txt and the latest version of this license is in http://www.latex-project.org/lppl.txt and version 1.3 or later is part of all distributions of LaTeX version 2005/12/01 or later. This work has the LPPL maintenance status `maintained'. The Current Maintainers of this work are Leo Liu, Qing Lee and Liam Huang.------------------------------------------------------------------------------\endpreamble 在 \preamble 和 \endpreamble 之间的部分，将被写入由 DocStrip 生成的所有文档（默认情况下）。比如上面这段 ctex 宏包的版权信息将写入每一个生成的文件。 下面的内容是整个 .ins 文件里最重要的部分，它控制着如何生成最终的宏包文件。 123456789101112131415\generate &#123; \usedir&#123;tex/latex/ctex&#125; \file&#123;ctex.sty&#125; &#123;\from&#123;\jobname.dtx&#125;&#123;package,style&#125;&#125; \file&#123;ctexcap.sty&#125; &#123;\from&#123;\jobname.dtx&#125;&#123;package,ctexcap&#125;&#125; \file&#123;ctexsize.sty&#125; &#123;\from&#123;\jobname.dtx&#125;&#123;package,ctexsize&#125;&#125; \file&#123;ctexart.cls&#125; &#123;\from&#123;\jobname.dtx&#125;&#123;class,article&#125;&#125; \file&#123;ctexbook.cls&#125; &#123;\from&#123;\jobname.dtx&#125;&#123;class,book&#125;&#125; \file&#123;ctexrep.cls&#125; &#123;\from&#123;\jobname.dtx&#125;&#123;class,report&#125;&#125; \file&#123;ctexspa.def&#125; &#123; \from&#123;\jobname.dtx&#125; &#123;ctexspa&#125; \from&#123;ctexpunct.spa&#125; &#123;&#125; &#125; &#125; \generate 命令中的\file{⟨filename⟩}{\from{⟨sourcefilename⟩}{⟨optionlist⟩}} 用来指定宏包文件的生成方式。这里的含义是，从 ⟨sourcefilename⟩ 中抽取含有 ⟨optionlist⟩ 标记的部分，生成 ⟨filename⟩ 这个文件。 一个 \generate 里可以有多个 \file 命令。一个 \file 命令里可以有多个 \from 命令。一个 \from 命令里的 ⟨option⟩，组成 ⟨optionlist⟩。其中 ⟨option⟩ 需要用逗号隔开，\file 之间和 \from 之间则不需要。 12345678910111213141516171819202122\obeyspaces\Msg&#123;*************************************************************&#125;\Msg&#123;* *&#125;\Msg&#123;* To finish the installation you have to move the following *&#125;\Msg&#123;* file into proper directories searched by TeX: *&#125;\Msg&#123;* *&#125;\Msg&#123;* The recommended directory is TDS:tex/latex/ctex *&#125;\Msg&#123;* *&#125;\Msg&#123;* ctex.sty *&#125;\Msg&#123;* ctexcap.sty *&#125;\Msg&#123;* ctexsize.sty *&#125;\Msg&#123;* ctexart.cls *&#125;\Msg&#123;* ctexbook.cls *&#125;\Msg&#123;* ctexrep.cls *&#125;\Msg&#123;* ctexspa.def *&#125;\Msg&#123;* *&#125;\Msg&#123;* To produce the documentation run the file ctex.dtx *&#125;\Msg&#123;* through XeLaTeX. *&#125;\Msg&#123;* *&#125;\Msg&#123;* Happy TeXing! *&#125;\Msg&#123;* *&#125;\Msg&#123;*************************************************************&#125; 这里的内容会在处理完 .ins 文件之后显示在控制台，用来提示使用者将文件置入指定的目录。TeX 会忽略连续的空格，第一行的 \obeyspaces 则会让 TeX 输出这些空格。 1\endbatchfile 显式地结束安装文件，此后的所有内容都会被忽略。 将上面的代码依次粘贴到一起，就是一个最简单的 .ins 文件了。 .dtx 文件.dtx 文件比 .ins 文件复杂得多。.ins 文件在整个过程中会被读取一次，而 .dtx 文件却会被读取三次。下面是对此三个步骤的简略描述。如果暂时看不懂也没有关系，下一节我们将会化身人肉编译器，逐行分析示例。 处理 .ins 文件的时候，会载入 .dtx 文件。这时候 .dtx 文件中以 % 开头的行将被全部忽略，而以 % 开头的行则会用于记录 ⟨option⟩。程序会根据 .ins 文件中 \generate 命令里 \from 的指示的 ⟨option⟩ 抽取 .dtx 文件中 ⟨option⟩ 相关内容。这个过程中，没有以 % 开头的行会根据 ⟨option⟩ 写入文件，而 % 开头的行则被抑制并保护起来。最终生成宏包文件。 第二遍处理 .dtx 文件的时候，在读入 \documentclass{ltxdoc} 之前，所有的内容与通常意义上的 LaTeX 代码完全一致。因此需要依靠 \iffalse 和 % \iffalse 来保护相关代码，这些代码通常是 README 文件和 LICENSE 文件。在读入 \DocInput{filename.dtx} 之后，.dtx 文件会被第三次载入处理。处理完成之后遇到 \end{document}，后续的内容被全部忽略。最终生成说明文档。 第三遍处理 .dtx 是被 \DocInput 载入的。此时，文档内（几乎）所有的 % 都被忽略。因为 LaTeX 只能有一个 \documentclass 以及一对 \begin{document} 和 \end{document}，所以 \end{document} 之前的所有内容都应当在这一次处理的时候被忽略。因此这部分内容应该被 \iffalse 和 \fi 保护起来。 .dtx 文件由以下部分组成。 包含在 % \iffalse 和 % \fi 中间的版权信息 包含在 % \iffalse 和 % \fi 中间的宏包基本信息 包含在 %&lt;*driver&gt; 和 %&lt;/driver&gt; 中间的 ltxdoc 文档类及相关代码，这部分代码也应包含在 % \iffalse 和 % \fi 中间 在 \end{document} 之后的说明文档，这部分文档应该隐藏在行首的 % 之后 在说明文档最后的代码说明，以及间杂在代码说明中间的代码，其中代码说明也应该隐藏在行首的 % 之后，而代码本身则不应该被 % 保护 示例 .dtx 文件的具体内容，可以参看下一节。 人肉编译器我们来看两个文件，分别是 dtxtut.ins 和 dtxtut.dtx。你可以下载这两个文件，然后跟着我的思路一起分析。 首先我们要生成宏包文件，在命令行中运行 1xelatex dtxtut.ins 注意，这里的后缀名不可省略。 文件读入之后，直到 12 行都是注释，直接忽略。接着到了第 13 行，读入了 docstrip.tex 这个文件。随后进行了一些设置之后来到了第 26 行. 1\generate&#123;\file&#123;\jobname.sty&#125;&#123;\from&#123;\jobname.dtx&#125;&#123;package&#125;&#125;&#125; 这里 \jobname 是当前文件的名字（不含后缀），即 dtxtut。所以这里会从 dtxtut.dtx 文件中，抽取 package 的部分，组成名为 dtxtut.sty 这个文件。 现在我们读取 dtxtut.dtx。前 18 行都是注释，忽略。19 – 21 行是 package 部分，输出。23 行开始了名为 driver 的部分，直到 32 行结束。接下来一直到 81 行都是注释，忽略。82行开始了名为 package 的部分，于是程序将 82 行开始到 100 行中没有注释掉的部分抽出来，输出。这样，输出的内容接在 \preamble 之后，保存为 dtxtut.sty 文件。 接下来我们生成宏包文档，在命令行中运行 1xelatex dtxtut.dtx 同样，这里的后缀名不可省略。 前 23 行都是注释，忽略。24 行载入了 ltxdoc 文档类，随后载入了刚刚生成的 dtxtut.sty 宏包。26 行的 \EnableCrossrefs 打开了代码索引的生成（如果你将来不需要，可以用 \DisableCrossrefs 打开）。27 行的 \CodelineIndex 则使得索引指向代码行号，而不是页码。28 行的 \RecordChanges 则会让文档类记录宏包的变化记录。 接下来，30 行的 \DocInput{\jobname.dtx} 重新载入了这个文件本身，但（几乎）所有的 % 符号都被忽略。第 1 行遇到 \iffalse，直到 16 行的 \fi，中间的内容都被忽略。17 行是空行。18 行又遇到 \iffalse，直到 33 行的 \fi，中间的内容都被忽略。注意，这里正好跳过了 driver 部分。 接下来的 \CheckSum 和 \CharacterTable 是为了检测 .dtx 文件完整性的两个工具。众所周知，.dtx 文件包含了一个宏包的几乎所有信息，如果文件在网络传输的过程中出错，则宏包安装必然失败。因此，检测文件的完整性就变得很有必要。 \CheckSum 采用了一个很简单的方案来检验完整性。它将从 \StopEventually 开始到 \Finale 结尾的，在 macrocode 环境里的反斜杠 \ 计数，将计数的值作为校验和。在生成文档的过程中，程序将会计算这个值，并于 \CheckSum{} 中的值进行比对。若二者不一致，则说明传输过程中可能出现错误。 \CharacterTable 更为直接一点。程序将检查代码中出现的符号均包含在 \CharacterTable 之中。若不然，则认为传输过程中可能出错。 接下来的内容，直到第 76 行都很好理解。77 行出现了 \StopEventually 命令，并在参数中启动了 \PrintIndex 命令。我们刚才说了 \StopEventually 会开启校验和的检查，而 \PrintIndex 则会在此处打印代码索引。 macrocode 环境是一个特殊的环境，它有点类似于 LaTeX 原生的 verbatim 环境。它在大多数情况下的行为和 verbatim 环境相同，大体上是将代码输出到最终的文档当中。 这样持续运行到 103 行，遇到 \Finale 命令，校验和计算的终点。此时，程序将会计算出校验和，并与文档中给出的校验和进行比较。如果 \CheckSum 不存在，或者给出的值为 0，那么程序会给出正确的值，让你填入文档。如果 \CheckSum 存在，但值与程序计算的不符，那么程序会报错，并给出正确的值。改正后重新编译才能得到文档。如果 \CheckSum 存在，且校验和通过，那么程序会继续运行。 104 行是 \endinput，结束整个文件，本次对 dtxtut.dtx 的处理结束，回到上一次的断点。 30 行之后，31 行就是 \end{document}，文档处理结束，之后的内容全都被忽略。输出文档，退出。 将 .dtx 和 .ins 合二为一细心的读者会发现，整个过程中，.dtx 文件承担了几乎所有的功能，而 .ins 文件只是一个「指路人」。这些读者可能会思考，是不是有办法将 .ins 文件并入 .dtx 文件呢？答案是肯定的。 对于这类合二为一的 .dtx 文件，使用 Plain TeX 格式编译，会启动 DocStrip 工具，得到宏包文件；使用 LaTeX 格式编译，则会生成文档。 这里给出一个来自知乎提问的示例（略有修改），你可以在我的答案里看到对此的具体分析。 最后的最后今天是 W 的生日。祝你生日快乐~]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Macro</tag>
        <tag>Literate Programming</tag>
        <tag>dtx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧洲史·三：浪漫主义与古希腊哲学]]></title>
    <url>%2F2015%2F01%2F22%2Fhistory-of-europ-03%2F</url>
    <content type="text"><![CDATA[前两篇文章（第一篇、第二篇）讨论了欧洲文明发源的三股力量，以及欧洲思想发源的几次思想运动。今次，我们将暂别对理性的讨论，转而讨论与理性相对的浪漫主义；同时我们也会一睹古希腊三大哲人的风采。 浪漫主义浪漫主义运动从德国发端我们前面说到，欧洲这个混合体由希腊罗马、教会和日耳曼民族组成。前面说到的浪漫主义运动、宗教改革、科学革命还有启蒙运动主要都是前两个部分相互作用的结果。今次要谈的浪漫主义运动则发短语继承自日耳曼民族的德意志民族。（公元 919 年之后建国的国家中的人民称德意志，之前称日耳曼） 18 世纪末，法国爆发了大革命，传统的君主制阶层观念、贵族以及天主教会统治制度在三年内被推翻；新的自由、平等、博爱等原则被建立起来。尽管人们对理性的期望很高，但是法国大革命废除了君主和教会之后，并没有迎来民智开启的时代，反而因为激进的思想，迎来了流血、暴政和独裁。 针对法国启蒙运动的观点，发端于德意志的浪漫主义运动崇尚感受、情绪和强烈的情感。德国人认为理性但抽象的词语不能用来描绘人类和社会，这完全是空谈；他们相信自己的历史和文化根治于自己体内，因此与法国人是不同的，所以法国人在沙龙里谈论的普世理性是不存在的；他们希望知道早期日耳曼民族在进入结合体之前是什么状态，喜欢他们的活力和补拙。 浪漫主义认为文明是人为的，因此文明会束缚和局限我们。因此，超脱这些束缚，活在传统文化当中，才算是活得完整。至此，知识分子才开始尊重并对文化开始有兴趣，开始收集民俗文化和乡村歌谣。并且从此，这些观念深植于欧洲人的思想之中。 民主主义源自浪漫主义浪漫主义对自己民族历史和文化的尊重被扩大强化之后，就形成了民族主义。民族主义者认为拥有相同历史、文化和语言的人们组成的民族应当生活在一起，并组建自己的政府。民族主义者认为，多民族的国家里，任何一个民族都无法充分表达自己的观点，无法充分伸张自己的文化，因此任何民族的智慧都无法开花结果。 教会的结局中世纪结束之后，文艺复兴、宗教改革、科学革命、启蒙运动以及浪漫主义运动分别在不同的角度削弱了教会的权威。事实上，现代理性、科学和进步的思想从文艺复兴、科学革命和启蒙运动一脉相承自古希腊；而现在对文化、解放思想的崇尚则从浪漫主义运动继承自日耳曼民族。反观教会，留下的则是一片空白。 理性和浪漫的撕扯理性和浪漫是两股根植在欧洲人心中的截然相反的力量。这两股力量往往对立，互相撕扯。 我们先来看一个例子。如果在学校里给学生讲述下面这段故事，并将之奉为真理，你会怎么看待？这个故事来自旧约圣经的第一篇：创世纪。 耶和华上帝用地上的尘土造人，将生气吹在他鼻孔里，他就成了有灵的活人，名叫亚当。 如果你的孩子是这个学校里的一个学生，你会怎么想呢？作为一个现代社会的文明人，你一定会反对学校这样的做法，你会认为学校在胡说八道误人子弟。 那么反过来，再看另外一个故事。这个故事是澳大利亚土著人的一个传说。 很久很久以前，有个老人非常疼爱他的侄儿。年轻的侄儿远赴异国，爱上了一个年轻女孩儿。这对情侣后来不顾长辈的反对，私奔出走。但女孩儿已被许配给另外一个人，所以女孩儿的部落派人追到他们，杀死了他的侄儿。老人听到噩耗非常伤心，不顾年老体弱，跋涉到这个国家，打算将侄儿的尸体带回故土。 侄儿已经成年，然而老人年事已高。将侄儿的尸体从异国运回故土，对于老人来说是个沉重的负担。但是老人办到了，它将尸体带回，妥善安葬。至今你仍然能够看到老人跋涉的足迹，仍然能看到他中途休息的地方，仍然能看到他的泪水汇成的水潭。 同样的假设，你会怎么想呢？尽管你知道这个故事浪漫主义色彩浓厚，肯定不是真实的，但是你可能仍然会希望学校将这个「美好」的故事讲给学生们听。 两个故事都有明显不真实的地方，但是我们对它们的态度却截然不同。面对第一个故事的时候，理性占了上风；而面对第二个故事的时候，浪漫主义的情怀却占了上风。 若然生活在启蒙时代，可能会有人对你说：「如果你的孩子想知道水潭的来源，那你可以送他去学地质学」。可能还有人会对你说：「这些土著人的思想已经被黑暗和魔法带来的恐惧束缚住了，你不要相信这些」。这感觉很别扭不是吗？对于我们来说，我们往往会迷失在浪漫主义的情怀之中，潜意识地认为土著人的生活方式更加纯粹、健全和自然，不由自主地希望这些「信仰」传承下去。 这样的撕扯就是理性和浪漫对立的一面。这样的撕扯源自于启蒙运动和浪漫主义运动的冲突，而追根究底的原因是欧洲文明那个奇怪的混合体的矛盾。这样的撕扯不断困扰和瓦解着欧洲的道德观念和智识生活，并成为欧洲人的「宿命」之一。 古希腊三大哲人的风采让我们「重归」理性。 前文已经提到，文艺复兴时期的人们认为「古典就是最好的」。这样的观点在 17 世纪才因古希腊人的宇宙观（地心说）被打破而逐渐缓解。自那时起，人们慢慢将目光从古希腊已有的成就上转移开来，开始关注现代人可能达成的成就。 不过，尽管如此，在一些领域里我们的成就依然坐落在希腊人打下的基石上。而对后世影响甚深的人就是古希腊的三大哲人：苏格拉底、柏拉图和亚里士多德。 苏格拉底苏格拉底是一个，呃……，对思辨的向往近乎疯魔的人。他作为古希腊最伟大的哲人之一，并没有给出真理，但是去做了更伟大的事：给出了迈向真理的方法。 苏格拉底认为真理切实存在，但平常人的心智并不足以理解真理。因此，渴望得到真理的人必须耕耘其心智。而这种方法其实就是「有理有据地怀疑一切」。 苏格拉底问答法是类似于这样的对话： 老师：什么是革命？ 学生：用武力推翻政府就是革命。 老师：如果国王的弟弟弑君篡位，那么这样以武力推翻的行为是革命吗？ 学生：不是。 老师：那除了武力推翻之外，还需要怎样的条件才能算是革命呢？ 苏格拉底问答法实际是在不断地举出反例的过程中，修正已有的观点。这样的方法能不断剔除谬误的部分，使得结论逐渐趋向真理。 柏拉图柏拉图是苏格拉底的弟子。如今有关苏格拉底的实际，一部分就是出自柏拉图之手。苏格拉底「怀疑一切」的主张影响了雅典的统治者，因此被最终处死。在柏拉图的描述中，苏格拉底平静地面对死亡，对无法思辨的苟且无法容忍，从容地结束了自己的生命。 然而，如若换过一个角度，人们对苏格拉底的崇敬可能就会大打折扣。比如，如果公诉苏格拉底的检察官之子因为听信苏格拉底的言论，怀疑一切，最终成为一个不务正业的酒鬼；然后检察官认为苏格拉底是妖言惑众，应当处死。 这样的思辨，其实正是苏格拉底崇尚的「怀疑一切」。而对一切事物都充满怀疑，会让我们迷失方向；我们不可能靠纯粹的理性生活、工作并组成社会，我们在理性的同时，也需要有风俗、习惯甚至是宗教来指引方向。 柏拉图认为，我们在世间的所思所想，其实只是另一个崇高世界里的影子。因此，单纯地依靠思辨，单纯地怀疑一切，并不能求得真理。柏拉图为了说明他的观点，举了一个例子。 假设有一群人，被关在暗无天日的深邃山洞。山洞只有一个洞口，被铁门锁死。洞口的外面是长长的走廊，走廊的尽头有一只火把。 火把摇曳的火光将经过的人和动物投影在山洞里的墙壁上，于是这些人在山洞里为看到的影子评头论足，进行推理辩论，相信这就是这个世界上真实的存在。 这其实就是中国「坐进观天」故事的翻版，很可笑不是吗？当你身锁牢笼却不自知，目光局限在其中，光靠思辨是不可能获得真理的。 亚里士多德亚里士多德是柏拉图的学生，没错他是苏格拉底的徒孙。亚里士多德在许多方面都有重大贡献，他总结整理了很多已有的知识，并根据自己的观察得出了很多精彩的结论。诚然，受于条件所限（身处某个牢笼），他的结论在如今看来并不完全正确（比如地心说）；但是，亚里士多德对与清晰思考的理论却依然闪耀。这就是「亚里士多德三段论」。 亚里士多德的三段论将论述分为三个部分，前两个部分是前提，第三个部分是结论。第一个部分是抽象的概述；第二个部分是对具体实例的描述；第三个部分则针对实例做出推论。如果前提正确，并且推论过程符合逻辑，那么结论就必然是正确的。 比如： 每一只正常的猫都有四条腿。 Kitty 是一只正常的猫。 Kitty 有四条腿。 这就是一个成立的结论。首先，前两个前提是正确的；其次，两个前提之间有「连续的主宾判断逻辑」；因此，结论成立。 再比如： 每一只正常的猫都有四条腿。 Kitty 有四条腿。 Kitty 是一只正常的猫。 这是一个不成立的结论。尽管两个前提是正确的，但是两个前提之间并没有连续的逻辑，因此结论是站不住脚的。比如，Kitty 可能是一只兔子，或是一只狗。 再比如： 每一只猫都是黑色的。 Kitty 是一只猫。 Kitty 是黑色的。 这也是一个不成立的结论。尽管两个前提之间有连续的逻辑，但是第一个前提是错误的，因此结论也是站不住脚的。 尽管举出的例子很简单，但是却反映了亚里士多德三段论的威力。三段论的意义在于 它给出了推理的一般规则：严谨遵循这个规则就能求得真理； 它给出了检验推论的标准：从前提的正确性和推理的逻辑性两方面检查推论，若然有一方面错误，则结论不成立。 小结欧洲的文明发端于古代希腊和罗马与教会和日耳曼民族混合成为的一个不稳定的混合体。这个混合体随着文艺复兴运动而逐渐瓦解，经历宗教改革、科学革命、启蒙运动和浪漫主义运动，宗教的力量被削弱，逐渐形成我们如今看到的欧洲。 理性和浪漫的力量彼此对立，互相撕扯。这份根植在欧洲人文化血脉里的矛盾，煎熬着欧洲人的同时，也成为欧洲不断进步的动力。 尽管在科学革命之后，人们已不再将古希腊的学术奉为圭臬，但实际上是人们重新走在了由希腊人奠基的理性思辨道路上。苏格拉底为人们展现了通往真理的道路；他的弟子柏拉图用经典的比喻警醒人们不能坐进观天；柏拉图的弟子亚里士多德则在前辈的基础上整理了很多知识，并总结出了威力强大的「三段论」。 真想去欧洲看看呀~ : )]]></content>
      <categories>
        <category>Literature and Social Sciences</category>
      </categories>
      <tags>
        <tag>History</tag>
        <tag>Europe</tag>
        <tag>Greece</tag>
        <tag>Romantic</tag>
        <tag>Philosophy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧洲史·二：欧洲的思潮]]></title>
    <url>%2F2015%2F01%2F06%2Fhistory-of-europe-02%2F</url>
    <content type="text"><![CDATA[上一次讲到欧洲文明发端的三股力量和古典、中世纪和近代在事件和时间上的划分。今次写一写和思想有关的东西。 上述三股力量组成的混合体经历了长达一千年的中世纪时期。然而，尽管持续时间很长，这个混合体内部却并不稳定。伴随着文艺复兴的开始，从公元 1400 年左右开始，这个混合体逐渐崩毁，并开始建立起新的秩序。 文艺复兴前一篇文章里提到，中世纪时期，基督教会保留了许许多多的古希腊科学文化知识。然而，基督教会却没有将这些科学文化知识公开；而是藏起来，选择其中对维护自己教义有利的知识，甚至是曲解其中的含义来维护自己的教义。这实际上是对人的思想的一种控制。基督教会利用这些知识，将人们日常生活中能够观察到的现象和基督教的神学联系起来，控制人们的思想，巩固自己的地位。 文艺复兴运动的意义在于，当时有许多游离于教会之外的学者，将这些知识从神学当中剥离开来。它将人们的生活从神圣的教会的光辉中解脱出来，认为宗教只是私人事情的一部分，不应该左右社会，也不应该控制人们的思想。总而言之，它将社会逐渐世俗化。 将知识从教会的手中解放出来本来应当是一件好事。可是，当时的学者认可古希腊的科技知识，向往其时的社会状态，并对此达到了一种狂热的地步。他们认为古希腊的科技文化知识是经典的、最好的、无与伦比无法超越的。也就是说，他们继承了古希腊的知识，却未能继承古希腊人们辩证的思想。 在文艺复兴运动中，思想得以从教会的控制中解放，然而将古希腊当做是「上限」却又阻碍了欧洲「再进一步」。 事实上，「古典」、「中世纪」和「近代」这样的划分就是文艺复兴时期的观点。那时候人们认为古典世界已然臻至完美，却在中世纪被基督教会掌控逐渐偏离正道，而文艺复兴又重新回到了正轨。古希腊人曾经认为人体是完美的，在艺术上的裸体展现得是人体的力量和美。而中世纪的绘画雕塑则对裸体遮遮掩掩，反映的是基督教的原罪，认为裸体是邪恶的。到了文艺复兴，米开朗琪罗的雕塑作品，当然是裸体塑像，则被认为是尊贵、高尚和美丽的化身。 而反过来，欧洲人至今以基督诞生的那年作为纪年起点。前一种对年代的划分明显排斥基督教，实际的纪元却又与基督教密不可分。 此间的矛盾一方面反映了欧洲继承自「混合体」，另一方面反映出文艺复兴虽然是思想的一次革命，但却不够彻底。 宗教改革前文提到，在进入罗马帝国的几百年间，基督教发展出了庞大而完善的体制；在罗马帝国灭亡之后，教皇与君主平起平坐，管理文武百官。最终的结果就是前文提到的「基督教变成了罗马人的宗教」。 实际上，教会发展到最后，变成了这样一种怪物：教义由教会制定、整个社会也受教会管理、对犯错的人的审判也由教会进行。你没看错，立法权、行政权、司法权都被教会一手掌握。这种畸形的怪物发展到什么地步呢？如果你是一个富商，在你将死的时候，会有神父告诉你，你必须把钱捐出来给教会，不然你就进不了天堂。 马丁·路德是一名虔诚的基督教徒，他对自己的原罪感到无可奈何，对如何救赎毫无头绪，终日煎熬。他不知道自己一个浑身罪恶的人，如何才能得到救赎。有一天，马丁·路德读到《圣经》中保罗写给罗马教会的书信，信中说：「只要你相信耶稣基督，就能得到救赎」。也就是说，你其实什么也不用做，不用遵循教会制定的法度，不用对神父言听计从，只要相信上帝，坚守自己的信仰，就能得到救赎。 马丁·路德认为，《圣经》是唯一的权威：凡是圣经上没有写的，教会就没有理由去制定或者执行哪个「训令」。马丁·路德意识到，人们的思想为教会所控制，根本原因在于《圣经》是由拉丁文所写，并不是人人都能阅读的。于是马丁·路德将《圣经》翻译成德文，使得人人都能从《圣经》中得到自我救赎的力量。 马丁·路德的基督教后来从罗马教会的基督教中分离出来。遵循「因信称义」的观点的马丁·路德教派，后来发展为「基督新教」，而罗马教会的基督教，则被称为「天主教」。 宗教改革的核心观点在于，《圣经》是唯一的权威，基督教并不是罗马人的，要让基督教回到中世纪之前的样子。 有意思的是，马丁·路德从天主教那里拿来《圣经》把它翻译出来，变得人人都可以读，人人都可以从中得到自己的见解。于是，原本唯一的、权威的解读不复存在了，各种解读并立而起，马丁·路德自己的解释也被攻击。经过百余年的争吵，谁也无法说服谁，天主教和基督新教慢慢变得和平共处。 文艺复兴和宗教改革在一定意义上都是「回到过去」。文艺复兴从罗马教会那里拿来古希腊和古罗马的文化知识，来对抗教会对知识的钳制；宗教改革则从罗马教会那里拿来圣经，颠覆天主教的神学和权威。接下来 17 世纪的科学革命则整个颠覆了过去人们的观念。 科学革命由于观测手段的限制，希腊人认为地球是宇宙的中心——有谁能推动地球呢？17 世纪，这个观点终于被推翻。地球环绕着太阳运行，太阳才是这个天体系统的中心。 首先是观测。随着观测手段的不断进步，人们对星体运行的轨迹描绘得越来越精确。与此同时，这些轨迹与地心说的轨迹误差越来越大，地心说的维护者不得不去不断进行修正，使得地心说的模型变得越来越复杂。其次时理论。牛顿的万有引力定律和相应的数学手段为日心说提供了有力的理论武器。人们精确地计算出了地球绕太阳运转的轨道，与观测事实符合得很好。 这样一来，地心说终于招架不住，教会不得不低头，承认日心说。在科学发展的过程中，人们产生了两种情绪： 希腊人错了，古典并不是完美的 自以为特别的我们在宇宙中其实很普通 好在，那个时代的人并没有因为日心说、进化论之类的发现而妄自菲薄，贬低自己的重要性。相反，他们认为，如果人们能够借由理性，探索出整个自然体系的运作规律、用数学模型精确表达，再将这些成果反馈到人类生活上，人类就会发生巨大的改变。这种渴望，成为了启蒙运动的原动力。 启蒙运动启蒙运动于 18 世纪从法国开始，其目的是弘扬理性，用理性改造神学、政府和社会观念。 启蒙运动时期的人们认为，当时的法国有两大非理性势力。其一是教会。教会到处宣传神迹故事，控制人们的思想，威胁他们说如果不听话就要去地狱受苦。其二是法国国王。国王说自己是受上帝神谕管理这个国家的，质疑王权就是违反教义。（奉天承运什么的……） 启蒙运动过程中，有一部百科全书被人们汇总出来。它是第一部现代意义上的百科全书。其将理性运用于一切事物，将神、宗教和其他概念并列于同一个层级。这传达出一个信息：宗教是迷信。 从文艺复兴到宗教改革，从科学革命到启蒙运动，曾经主导欧洲社会的基督教会地位被不断削弱，欧洲走上了理性、进步的道路。]]></content>
      <categories>
        <category>Literature and Social Sciences</category>
      </categories>
      <tags>
        <tag>History</tag>
        <tag>Europe</tag>
        <tag>Christianity</tag>
        <tag>Romantic</tag>
        <tag>God</tag>
        <tag>Reason</tag>
        <tag>Science</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧洲史·一：欧洲文明开端的三股力量]]></title>
    <url>%2F2014%2F12%2F30%2Fhistory-of-europe-01%2F</url>
    <content type="text"><![CDATA[欧洲文明的发端，有三股力量： 古希腊和古罗马的科学文化； 作为犹太民族宗教的分支的基督教； 征服了罗马帝国的日耳曼战士文化。 希腊和罗马一句话概括的话，希腊人在科学文化上极其聪明；而罗马人则相对更加骁勇善战，治国、治军、工程建筑比希腊人更优秀。 希腊人的聪明不需多说：哲学、艺术、文学、数学、科学、医学、政治，这些学科的源头都可以追溯到希腊。现代数学中，随处可见的「希腊字母」，实际上也是对此的一种「纪念」。 罗马人的骁勇也不需多说：古罗马的版图疆域横跨亚欧非，环绕整个地中海。 这样一来的结果就是，罗马人统治了欧洲，但是罗马人却以懂的希腊的语言和文化为荣。 基督教的力量基督教是犹太教的一个分支。 在犹太人的眼里，「上帝」是唯一的神，而自己的族群（犹太人）则是上帝的选民。此外，犹太人相信遵守上帝的条律，也就是上帝借由「摩西」的口说出来的「摩西十诫」，就能得到上帝的优待。摩西十诫的要求实际上是一种道德的约束，这些约束在犹太人的发展中逐渐成为律法。 犹太教的一些特点和古希腊和古罗马人的信仰是有很多不同的。首先，犹太教只承认耶和华为唯一的真神；其次，犹太教中，道德和律法是密不可分的，古希腊和古罗马却非是如此（希腊神话里的神各种乱伦什么的）。 耶稣是一个犹太人。在耶稣传道的时候，巴勒斯坦已经被罗马帝国纳入版图。耶稣在传道过程中，修改、发扬了犹太教的教义；特别是，耶稣把犹太人严苛的道德训诫转化成了「宇宙大爱」。 大家都说：「你应当爱你的亲人，应当恨你的仇人」。我却要说：「你们应当爱你的仇人」。——《马太福音书》 由于耶稣作为讲道人传播的教义与犹太教的教义有相悖的地方，所以犹太教的领导人和罗马帝国练手杀死了耶稣——将他钉在十字架上。 耶稣的死留下了一个分歧，即：只有先变成犹太人，才可以信奉基督教；还是承认耶稣关于「爱」的教会凌驾与一切之上，人人都可以信奉基督教？如果前一个派系获得胜利，那么如今的基督教将只是犹太教的一个小小分支；而显然，后一个派系获得了胜利。 日耳曼民族日耳曼民族最开始居于罗马帝国的北方。日耳曼人骁勇善战，甚至可以说是「为了打仗而生」：日耳曼人认为「可以用流血去换得的东西，用流汗这样的方式去换得，是没骨气的表现，是下等人才会做的事情」。 从公元 400 年之后开始，日耳曼人开始入侵罗马帝国；而到了公元 476 年前后，这样的蛮族取代了整个罗马帝国。 三者的联结对于犹太人，罗马人只是把他们当做是一群稀奇古怪的人，所以对信奉犹太教的人，作为统治者的罗马人并不怎么关心。但是在罗马人眼里，信奉基督教的人是一群反动分子——因为他们认为上帝是唯一的神，而不愿意对君主行礼——欲要除之而后快。 就这样，罗马人对基督教打压了三百多年。 不过，在公元 313 年，君士坦丁大帝公开表示支持基督教会。于是基督教成为了罗马帝国正式而唯一的宗教，基督教的发展走上正轨。于是，罗马帝国变成了基督教的天下。 这时候的基督教，在「地下工作」的三四百年间，发展出了自己的法度并设有法庭和监狱；教会也同时掌管婚姻、继承和税收。基督教会俨然是「第二个政府」。在罗马帝国灭亡之后，基督教会保留了下来。教皇和君主平起平坐，管理文武百官。二者结合，基督教会变成了罗马人的教会。 与此同时，基督教会在罗马帝国的灭亡过程中，保留了相当的古希腊和古罗马的科学文化技术。教会的人，利用这些先进的科技文化，对自己的教义进行解读，以维护自己的权利。诚然，基督教曲解了相当的科学成就，但是客观上，基督教将古希腊和古罗马的文明保存了下来。 日耳曼蛮族在侵略罗马帝国的过程中逐渐发现一个棘手的问题：他们目不识丁，不懂得如何统治自己的国家。日耳曼民族的首领在打仗的过程中，化身为国王，将征服的土地分给手下的士兵；这些士兵化身为贵族，条件是在过往需要用兵的时候要出兵。 基督教的教主对国王表示自己并不需要土地，避免了与国王和贵族的冲突；同时表示愿意帮助管理国家，赢得了国王的支持。同时，主教们对士兵说，「如果你认可基督教的上帝，那么就能变得更勇武」。最终，日耳曼蛮族支持基督教。 小结从古希腊和古罗马开始，到罗马帝国覆灭，这段时间称为古典时期；从这三者的联结开始，到 14 世纪三者联结的崩毁，称为中世纪；中世纪之后则称为近代。 番外教会虽然最终称为了日耳曼蛮族的搭档，但是基督教并不是一个好战的宗教。虽然在先后和罗马、日耳曼民族的合作中变得渐渐支持「正义的战争」，但是却依旧不能接受日耳曼民族的好战的价值观。 不过日耳曼蛮族毕竟目不识丁，妥妥地被继承了希腊罗马科技文化的教会坑了。 教会鼓励他们对战斗的热爱，却改造他们的思想，让他们只参与「正义的战斗」。而何为正义，则全凭教会说了算。比如教会鼓励十字军东征，去夺回陷入伊斯兰教手中的东方的圣地。 同时，教会也要求骑士尊重出身贵族的女士，保护她们、敬重他们。 在骑士绝迹之后，这些被教会改造的中世纪遗风转化成为了所谓的「绅士风度」。]]></content>
      <categories>
        <category>Literature and Social Sciences</category>
      </categories>
      <tags>
        <tag>History</tag>
        <tag>Europe</tag>
        <tag>Greece</tag>
        <tag>Rome</tag>
        <tag>Germanic</tag>
        <tag>Christianity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[订制 Sublime Text 下 LaTeXTools 插件的编译脚本]]></title>
    <url>%2F2014%2F12%2F14%2Fadvanced-builder-latextools%2F</url>
    <content type="text"><![CDATA[LaTeXTools 是 Sublime Text 上的一个插件，用以增强在 Sublime Text 上编辑和编译 LaTeX 文档的体验。但是其自带的编译脚本比较难用，缺点如下： 调用 LaTeXmk 或者 TeXify，多次编译，速度缓慢，难以切换。 无法在编译时方便地添加命令行参数，导致依赖 \write18 命令的宏包（比如 minted）无法使用。 为了解决这个问题，我自己写了一个编译脚本，命名为 advancedBuilder.py。 安装方法 在这里下载编译脚本； 打开 Sublime Text 目录； 将脚本拷贝至 ./Packages/LaTeXTools/builders/； 编辑 ./Packages/User/LaTeXTools.sublime-settings，将 &quot;builder&quot; 值从原来的 traditional 改为 advanced，即：&quot;builder&quot;: &quot;advanced&quot;； 重启 Sublime Text。 使用方法基本的使用方法和原本的 traditionalBuilder.py 相同，即使用快捷键 Ctrl + B 编译（Mac OS X 是 CMD + B）。但在文档开头的注释中，增加了更多的用法。 改变编译流程可以在主文档开头的注释中，使用下列语法改变编译流程。 1%!TEX builder = BUILDER 其中 BUILDER 的可选值有： SIMPLE LATEXMK TEXIFY 大小写不论，默认是 SIMPLE，即只编译一遍。 选择编译引擎 此功能继承自默认编译脚本，有增强。 可以在主文档开头的注释中，使用下列语法改变编译引擎。 1%!TEX program = PROGRAM 其中 PROGRAM 的可选值有： pdflatex xelatex lualatex platex-ng pdftex xetex luatex ptex-ng 大小写敏感，默认值是 pdflatex。 选择编译参数可以在主文档开头的注释中，使用下列语法添加编译参数。 1%!TEX option = OPTION 其中 OPTION 的可选值为对 PROGRAM 合法的任意参数。大小写敏感，默认为空。 另外，强制启动 -interaction=nonstopmode 和 -synctex=1 两个参数，不允许更改。 指定主文档 此功能完整继承自默认编译脚本。 可以在子文档的开头注释中，使用下列语法指定主文档。 1%!TEX root = ROOT 其中 ROOT 为主文档相对当前子文档的路径。指定主文档之后，可以在子文档中直接使用快捷键编译主文档，而不用将 Sublime Text 标签页切换到主文档再进行编译。 示例foo1234\documentclass&#123;article&#125;\begin&#123;document&#125;Hello world!\end&#123;document&#125; 对应的命令行为： 1pdflatex -interaction=nonstopmode -synctex=1 foo.tex foo12345%!TEX builder = latexmk\documentclass&#123;article&#125;\begin&#123;document&#125;Hello world!\end&#123;document&#125; 对应的命令行为： 1latexmk -cd -e $pdflatex = 'pdflatex -interaction=nonstopmode -synctex=1 %S %O' -f -pdf foo.tex foo1234567%!TEX builder = latexmk%!TEX program = xelatex%!TEX option = -shell-escape\documentclass&#123;article&#125;\begin&#123;document&#125;Hello world!\end&#123;document&#125; 对应的命令行为： 1latexmk -cd -e $pdflatex = 'xelatex -interaction=nonstopmode -synctex=1 -shell-escape %S %O' -f -pdf foo1234567%!TEX builder = latexmk%!TEX program = xelatex%!TEX option = -shell-escape\documentclass&#123;article&#125;\begin&#123;document&#125;\input&#123;bar.tex&#125;\end&#123;document&#125; bar12%!TEX root = foo.texHello world! 在 bar.tex 的窗口编译，命令行为： 1latexmk -cd -e $pdflatex = 'xelatex -interaction=nonstopmode -synctex=1 -shell-escape %S %O' -f -pdf]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>LaTeXTools</tag>
        <tag>Python</tag>
        <tag>Compile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日文 LaTeX 系统介绍 - 最简示例]]></title>
    <url>%2F2014%2F12%2F11%2Fptex-intro-and-tutorial-03%2F</url>
    <content type="text"><![CDATA[本文为译文，原文载于这里。欢迎关注本系列的文章。 上一篇文章（译文）我们探讨了关于字符集和编码的一些细节，今次我们继续讨论如何在 LaTeX 中书写日文。今天的内容需要动手操作试试，要用不同的引擎和宏包写一些 Hello world 类型的文档。 今天的内容同样会涉及到一些配置 TeX 环境的内容，会讲一讲如何在 TeX Live 里配置书写日文的环境。 配置日文 TeX 环境我们假设，你已经在计算机上安装好了类似 TeX Live 2014 的 TeX 系统。你可以在下列 TeX 系统中选择其一安装。 TeX Live 的原始版本 (Upstream TeX Live installation) - 完整的安装步骤，请参考 TeX Live 的文档（中文版）的第三章。对于 Linux 和 Windows 系统，也可以参照相应的快速安装教程。对于 Mac OS X 的用户，则建议安装基于 TeX Live 的 MacTeX。 发行版里的 TeX Live (Distribution’s TeX Live) - 具体的安装取决于你使用的发行版。如果你用的是 Debian/jessie 或者 Debian/sid，那么你只需要运行 apt-get install texlive-full 即可。其他发行版 (Fedora, RedHat, SuSE) 的用户请注意检查发行版里当前的 TeX Live 版本。在老版本的环境下，后文中的例子可能无法得到预期的结果。 W32TeX - W32TeX 是 Akira KAKUTO 针对 Windows 系统制作的 TeX 发行版，其中的宏包也专门为 Windows 系统筛选过。W32TeX 对日文的配置可能是最周全的，不过我没有亲身体验过。 其他 TeX 发行版 - MiKTeX 是另一个重要的 TeX 发行版。MiKTeX 是 Windows 平台上高度集成的优秀发行版。不过因为打包和依赖脚本的差异，特别是涉及到 udpmap 的部分与 TeX Live 完全不同，MiKTeX 在我手头的一些设备上并不能很好地运行。 我的建议是，如果你的发行版足够新，那最好使用软件源里的 TeX Live；不然的话最好是使用 TUG 上的 TeX Live，包括 MacTeX。 最简示例言归正传。接下来我们来写几个「Hello world」文档。当然，「Hello world」这几个字母里并没有日文字，所以文章的正文部分看起来会是这个样子： 123\begin&#123;document&#125;\LaTeX で日本語を書きましょう！\end&#123;document&#125; 在进行下一步之前，有必要说一下关于编码的问题。请按以下规则，在保存文件的时候选择正确的编码： Unix-like 系统以及 Mac OS X 系统：总是保存为 UTF-8 编码 Windows 系统：在测试 pLaTeX 的时候使用 ShiftJIS 编码，其他时候使用 UTF-8 编码 这样做的原因在于：在 Windows 系统上，pTeX 以 ShiftJIS 编码作为默认编码；在其他系统上以 UTF-8 编码作为默认编码。当然，你也可以在 Windows 上把 pLaTeX 的测试文档以 UTF-8 编码保存，但是在编译的时候你得加上 -kanji utf8 这样的参数。 pLaTeX 以及 upLaTeX这是最简单的情况，我们只需要加上 \documentclass 就好了。 1234\documentclass&#123;article&#125;\begin&#123;document&#125;\LaTeX で日本語を書きましょう！\end&#123;document&#125; 以正确的编码将其保存为 hello-ptex.tex，然后运行 platex，UTF-8 编码的控制台会有类似于如下的输出： 12345678910111213$ platex hello-ptex.texThis is e-pTeX, Version 3.14159265-p3.5-130605-2.6 (utf8.euc) (TeX Live 2014) (preloaded format=platex) restricted \write18 enabled.entering extended mode(./hello-ptex.texpLaTeX2e &lt;2006/11/10&gt; (based on LaTeX2e &lt;2014/05/01&gt; patch level 0)Babel &lt;3.9k&gt; and hyphenation patterns for 79 languages loaded.(/home/norbert/tl/2014/texmf-dist/tex/latex/base/article.clsDocument Class: article 2007/10/19 v1.4h Standard LaTeX document class(/home/norbert/tl/2014/texmf-dist/tex/latex/base/size10.clo)) (./hello-ptex.aux) [1] (./hello-ptex.aux) )Output written on hello-ptex.dvi (1 page, 384 bytes).Transcript written on hello-ptex.log. Windows 系统上的输出与此类似，只不过在版本号后面的不是 utf8.euc 而是 sjis。 如你所见，输出结果是一个 DVI 文件。注意，此处不要使用 dvips 将其转换为 PostScript 文件，dvips 也许能够工作，但是 PS 文件却无法正常显示；请总是使用 dvipdfmx 将 pTeX/upTeX 输出的 DVI 文件转换为 PDF 文件。 因此，我们输入命令 1234$ dvipdfmx hello-ptex.dvihello-ptex.dvi -&gt; hello-ptex.pdf[1]7636 bytes written 接下来，使用 PDF 阅读器打开得到的 PDF 文档，效果类似于下： 如果觉得字体效果看起来稍有不同，也暂时不用担心，之后对此会有解释。但不论如何，你应该能看到日文字符，不然就说明有哪里错了。 类似的步骤在 upTeX 下同样奏效： 1234567891011121314151617$ uplatex hello-ptex.texThis is e-upTeX, Version 3.14159265-p3.5-u1.11-130605-2.6 (utf8.uptex) (TeX Live 2014) (preloaded format=uplatex) restricted \write18 enabled.entering extended mode(./hello-ptex.texpLaTeX2e &lt;2011/05/07u00&gt;+0 (based on LaTeX2e &lt;2014/05/01&gt; patch level 0)Babel &lt;3.9k&gt; and hyphenation patterns for 79 languages loaded.(/home/norbert/tl/2014/texmf-dist/tex/latex/base/article.clsDocument Class: article 2007/10/19 v1.4h Standard LaTeX document class(/home/norbert/tl/2014/texmf-dist/tex/latex/base/size10.clo)) (./hello-ptex.aux) [1] (./hello-ptex.aux) )Output written on hello-ptex.dvi (1 page, 380 bytes).Transcript written on hello-ptex.log.$ dvipdfmx hello-ptex.dvihello-ptex.dvi -&gt; hello-ptex.pdf[1]7638 bytes written 输出结果与之前应当完全相同。 多简单啊~ XeLaTeX如果你用 XeLaTeX 编译同样的代码，输出结果里就不会有日文字符。这里我们要多写一点代码。这里我会展示使用 xeCJK 和 ZXjatype 的最简示例。这两个宏包在 TeX Live 里都有，你可以选择其一。 不管你用哪个宏包，你都得选择一个日文字体，不然的话日文字符就不会输出。 xeCJK对于 xeCJK 来说，你得这么写： 123456\documentclass&#123;article&#125;\usepackage&#123;xeCJK&#125;\setCJKmainfont&#123;ipaexm.ttf&#125;\begin&#123;document&#125;\LaTeX で日本語を書きましょう！\end&#123;document&#125; 将其以 UTF-8 编码保存为 hello-xetex.tex，之后运行 xelatex: 1234567891011121314151617$ xelatex hello-xetex.texThis is XeTeX, Version 3.14159265-2.6-0.99991 (TeX Live 2014) (preloaded format=xelatex) restricted \write18 enabled.entering extended mode(./hello-xetex.texLaTeX2e &lt;2014/05/01&gt;Babel &lt;3.9k&gt; and hyphenation patterns for 79 languages loaded.(/home/norbert/tl/2014/texmf-dist/tex/latex/base/article.clsDocument Class: article 2007/10/19 v1.4h Standard LaTeX document class(/home/norbert/tl/2014/texmf-dist/tex/latex/base/size10.clo))(/home/norbert/tl/2014/texmf-dist/tex/xelatex/xecjk/xeCJK.sty(/home/norbert/tl/2014/texmf-dist/tex/latex/l3kernel/expl3.sty.....(./hello-xetex.aux) (/home/norbert/tl/2014/texmf-dist/tex/latex/tipa/t3cmr.fd)[1] (./hello-xetex.aux) )Output written on hello-xetex.pdf (1 page).Transcript written on hello-xetex.log. 直接就能得到 PDF 文档。 ZXjatype对于 ZXjatype 来说，你得这么写： 123456\documentclass&#123;article&#125;\usepackage&#123;zxjatype&#125;\setjamainfont&#123;ipaexm.ttf&#125;\begin&#123;document&#125;\LaTeX で日本語を書きましょう！\end&#123;document&#125; pdfLaTeX接下来，我们看看在 pdfLaTeX 底下怎么使用。pdfTeX 引擎可能是全球范围内使用最广泛的引擎了。这里，我们也将讨论两个宏包的使用方法：Werner Lemberg 的 CJK 宏包和 Takayuki Yato 的 BXcjkjatype。 CJK译注：这里作者用了一个很别扭的方式来构建文档，已改用通常习惯的方式。 1234567\documentclass&#123;article&#125;\usepackage&#123;CJKutf8&#125;\begin&#123;document&#125;\begin&#123;CJK*&#125;&#123;UTF8&#125;&#123;min&#125;\LaTeX で日本語を書きましょう！\end&#123;CJK*&#125;\end&#123;document&#125; 将其以 UTF-8 编码保存为 hello-cjk.tex，之后运行 pdflatex: 12345678910111213141516$ pdflatex hello-cjk.texThis is pdfTeX, Version 3.14159265-2.6-1.40.15 (TeX Live 2014) (preloaded format=pdflatex) restricted \write18 enabled.entering extended mode(./hello-cjk.texLaTeX2e &lt;2014/05/01&gt;Babel &lt;3.9k&gt; and hyphenation patterns for 79 languages loaded.(/home/norbert/tl/2014/texmf-dist/tex/latex/base/article.clsDocument Class: article 2007/10/19 v1.4h Standard LaTeX document class(/home/norbert/tl/2014/texmf-dist/tex/latex/base/size10.clo))(/home/norbert/tl/2014/texmf-dist/tex/latex/cjk/texinput/CJKutf8.sty...t/fonts/type1/wadalab/dmj/dmjkk.pfb&gt;&lt;/home/norbert/tl/2014/texmf-dist/fonts/type1/wadalab/dmj/dmjsy.pfb&gt;Output written on hello-cjk.pdf (1 page, 29574 bytes).Transcript written on hello-cjk.log. 如果你仔细观察的话，你会发现：LaTeX 几个字母后的空距和之前的输出不大一样。尽管代码看起来有些麻烦，不过，如果你只是想在非日文的文档里嵌入一小段日文，这仍然是个不错的方案。 译者注：实际上，用下面的代码，也能得到正确的 CJK-western 空距。这应该是原作者不熟悉 CJK 导致的。 12345678\documentclass&#123;article&#125;\usepackage&#123;CJKutf8&#125;\usepackage&#123;CJKspace&#125;\begin&#123;document&#125;\begin&#123;CJK*&#125;&#123;UTF8&#125;&#123;min&#125;\LaTeX&#123;&#125; で日本語を書きましょう！\end&#123;CJK*&#125;\end&#123;document&#125; BXcjkjatype如果上面的代码看起来十分冗长，那么 BXcjkjatype 则提供了一种更简洁也更好的封装。这里只需要用下面简单的代码就能得到输出了： 12345\documentclass&#123;article&#125;\usepackage[whole]&#123;bxcjkjatype&#125;\begin&#123;document&#125;\LaTeX で日本語を書きましょう！\end&#123;document&#125; 输出结果和之前 CJK 方式的结果类似。不过，嵌入的字体和之前有所不同。BXcjkjatype 默认使用 IPAex 字体。使用此方式请注意：不要在文档中使用任何非 ASCII 字符。 LuaLaTeXLuaTeX 是一个嵌入了 Lua 解释器的新的 TeX 引擎，这使得我们可以使用 Lua 语言来控制和调整许多 TeX 内部的行为。尽管它还不能完全取代 pdfTeX，但是至少拿来输出文档还是可以的。一些日本 TeX 同好为其开发了 LuaTeX-ja 宏包，用以在 LuaTeX 里使用日文。最简示例是这样的： 12345\documentclass&#123;article&#125;\usepackage&#123;luatexja&#125;\begin&#123;document&#125;\LaTeX で日本語を書きましょう！\end&#123;document&#125; 运行 lualatex 之后，你可能要等上不少时间。这是因为第一次运行 LuaLaTeX 的时候，系统需要刷新字体，耐心等待就好。最终在控制台终端上，你大概会得到下面的输出内容： 12345678910111213141516171819$ lualatex hello-luatexja.texThis is LuaTeX, Version beta-0.79.1 (TeX Live 2014) (rev 4971) restricted \write18 enabled.(./hello-luatexja.texLaTeX2e &lt;2014/05/01&gt;Babel &lt;3.9k&gt; and hyphenation patterns for 79 languages loaded.(/home/norbert/tl/2014/texmf-dist/tex/latex/base/article.clsDocument Class: article 2007/10/19 v1.4h Standard LaTeX document class(/home/norbert/tl/2014/texmf-dist/tex/latex/base/size10.clo))(/home/norbert/tl/2014/texmf-dist/tex/luatex/luatexja/luatexja.sty... 1923 words of node memory still in use: 6 hlist, 1 vlist, 3 rule, 3 glue, 10 kern, 1 glyph, 241 attribute, 299 glue_spec, 16 attribute_list, 1 write nodes avail lists: 1:1,2:888,3:5,4:40,5:4,6:25,7:3,9:12&lt;&lt;/home/norbert/tl/2014/texmf-dist/fonts/type1/public/amsfonts/cm/cmr10.pfb&gt;&lt;&lt;/home/norbert/tl/2014/texmf-dist/fonts/type1/public/amsfonts/cm/cmr7.pfb&gt;Output written on hello-luatexja.pdf (1 page, 17058 bytes).Transcript written on hello-luatexja.log. 输出结果同样取决于你系统里的默认字体，但和之前的截图应该差不多。 总结文章介绍了在不同 TeX 引擎和宏包下的最简日文示例。如果你能够运行这些示例，那么更复杂的文档你也应该能够运行，你的 TeX 系统完全可以进行日文排版。 不过，仍然还有不少问题需要讨论。比如：字体选择，插图，多语种混排以及非 ASCII 字符的使用。这些我们之后再讨论。 译者续在 pdfLaTeX 编译的情况下，还有一种排版 CJK 文字的方法。可以使用刘海洋前辈的 zhmCJK 宏包。这个宏包因为一些原因暂时没有收录到 TeX Live 中，不过，这系列文章的作者正好是 TeX Live 的开发者之一，我最近正在和他沟通这件事情。 zhmCJK 宏包提供了类似于 xeCJK 宏包的接口，相应的功能也完全类似。因此可以看做是不能使用 XeLaTeX 而必须使用 pdfLaTeX 的情况下的一个替代。对应于文章中 xeCJK 的例子，最简示例是： 123456\documentclass&#123;article&#125;\usepackage&#123;zhmCJK&#125;\setCJKmainfont&#123;ipaexm.ttf&#125;\begin&#123;document&#125;\LaTeX&#123;&#125; で日本語を書きましょう！\end&#123;document&#125; LaTeX 新手可以将宏包内的文件解压，释放到和你的 .tex 文件同目录下；有经验的 LaTeX 使用者，可以按照宏包文档，将宏包文件放在 TEXMF 中的合适位置，然后刷新 TeX 系统。 另外，正如刘海洋前辈和李清前辈（他们是当前 xeCJK 宏包的维护者）所言，xeCJK 虽然取名如此，但实际上只是对中文的支持比较完善。因此用 xeCJK 来排版日文在细节上还是会有一些问题的，特别是对日文排版规则的处理。此外，原作者提到的 ZXjatype 宏包，实际上是在 xeCJK 基础上再开发的结果。由于 xeCJK 的局限，ZXjatype 也不可避免地会有一些问题。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>pTeX</tag>
        <tag>Japanese</tag>
        <tag>Demo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日文 LaTeX 系统介绍 - 字符与编码]]></title>
    <url>%2F2014%2F12%2F08%2Fptex-intro-and-tutorial-02%2F</url>
    <content type="text"><![CDATA[本文为译文，原文载于这里。欢迎关注本系列的文章。 上一篇文章（译文）简单介绍了在 LaTeX 中排版日文的一些情况，今次我们会探讨一些关于字符和编码的技术细节。 这篇文章我们将讨论字符集和编码。在书写欧洲文字的时候，人们就已经需要用到非 ASCII 字符了；诸如日文这样的有成千上万个表义字符的书写系统，其字符数量更是远超 ASCII 所能涵盖的数量。同时我们也会琢磨一下为什么在日文文档里的转义字符为什么不是反斜线（\），而是日本货币标志（￥）。 首先，我并不精于此道。因此，文中讲解的内容十分简单，并且不可避免地会有谬误。如有发现请指出。 字符集和编码对于 ASCII 来说，这事儿很简单。比如，在计算机中表示「A」这个字母，我们只需要用 65 这个十进制数来表示即可。并且，65 对应的二进制数，也正是字母「A」在计算机中的样子。因此，对于 ASCII 来说，它既是字符集又是编码。 对于非 ASCII 字符来说，这事儿就变得复杂起来了。 对于欧洲的字符来说可能还好。比如常用的 Latin1 字符集中，字符「Ö」的码位是 214。由于一个字节可以表示 256 个不同的值，所以勉强能装下整个 Latin1 字符集。 但是对于成千上万的日文汉字 (Kanji) 来说，这就不行了。首先需要有一个统一的方式将字形 (glyph) 编号，每个字形对应一个 ID (数字)。然后再寻找一个合适的方式去编码这些字形。 字符集标准 JIS - 实践中有一些日本工业标准 (Japanese Industrial Standards)。比如，JIS X 0201 在 ASCII 字符集的基础上，增加了 64 个半宽 (half-width) 的片假名；又比如，JIS X 0208 是最常见的汉字字符集，它包含 6879 个字符，其中有 6355 个汉字，另有 524 个其他类型的字符。 UCS - 通用字符集 (Universal Character Set) 中包含了近十万个抽象字符，它试图将有史以来所有的字符都包含进来。涉及到日语的部分有一些特殊，对应的标准是统一汉码 (Han Unification)，这个字符集将中日韩表意相同的形近字统一映射到一个码位上。 编码有了字符集标准，接下来需要考虑如何在计算机中用二进制和字节表示这些字符。编码和字符集是两个不同的概念，但因为总是一起提及，所以经常有人混淆。 对于现代计算机和 TeX 来说，有以下一些常见的编码。其中前三个编码了 JIS 字符集；最后一个编码了 Unicode 字符集。 SJIS (Shift JIS) - SJIS 编码了 JIS X 0201 和 JIS X 0208 两个字符集。它很好地兼容了 ASCII 和 JIS X 0201，这使得它在老的计算机上工作正常；但是它也有一些奇怪的性质，并因此在一些通用解析器上工作不正常。 JIS X 0202 - 通称 JIS 的编码标准，它编码了 JIS X 0208。这个编码在诸如电子邮件的 7-bit 信道上的传输性能良好；老的 Emacs 也将其当做内部编码。 EUC(-JP) Extanded Unix Code - 实际上是符合 ISO 2022 标准的字符集的编码族。这种编码在日本的 Unix-affine 计算机上流行多年。 UTF-8 - 编码了 UCS 字符集，是 Unicode 标准的一部分，先行与几乎所有现代计算机操作系统上。 最后我们来看一个例子。 1234LanguageÄ á日本語ひらがな 注意观察他们在不同编码规则情况下对应的十六进制数据。 UTF-8 第一行的「Language」在 UTF-8 编码中对应的十六进制与 ASCII 完全相同，用一个字节表示一个字符；第二行的注音字母则用两个字节来编码，其中 0x20 是单字节的空格；第三行的日文汉字和第四行的平假名都用三个字符来编码。 12344c 61 6e 67 75 61 67 65c3 84 20 c3 a1e6 97 a5 e6 9c ac e8 aa 9ee3 81 b2 e3 82 89 e3 81 8c e3 81 aa SJIS SJIS 编码就有点意思了。首先，第一行保持相同，与 ASCII 兼容。第二行的「Ä」并不在字符集当中，于是 SJIS 把它当做是「”A」，编码成「0x22 0x41」；另一方面，「á」在字符集当中，SJIS 用三个字节将它编码成「0x81 0x4c 0x61」。注意第一行的编码，「0x4c」是字母「L」，「0x61」是字母「a」。它们连在一起与「á」的第二和第三个字节完全相同。这样「La」的编码就出现了歧义，一些解析器就无法正常工作了。 接下来的日文汉字和平假名分别用两个字节来编码。 12344c 61 6e 67 75 61 67 6522 41 20 81 4c 6193 fa 96 7b 8c ea82 d0 82 e7 82 aa 82 c8 ISO2022-JP 同样由于「Ä」不在字符集当中，ISO2022-JP 把它当做是「”A」来进行编码；但「á」却花了 9 个字节来编码。同时汉字和平假名的编码方式也是不固定的。 12344c 61 6e 67 75 61 67 6522 41 20 1b 24 42 21 2d 1b 28 42 611b 24 42 46 7c 4b 5c 38 6c 1b 28 421b 24 42 24 52 24 69 24 2c 24 4a 1b 28 42 EUC-JP EUC-JP 编码对应的字符集是 JIS X 0212，比之前的 JIS X 0201 和 JIS X 0208 大得多。这次「Ä」能够正确编码了。两个变音的拉丁字符被分别编码成三个字节；汉字和假名则是两个字节。 12344c 61 6e 67 75 61 67 658f aa a3 20 8f ab a1c6 fc cb dc b8 eca4 d2 a4 e9 a4 ac a4 ca 从这里可以看到，UTF-8 编码汉字和假名需要用到三个字节。因此用 UTF-8 编码来处理文档，得到的文件体积要大上不少。同时，旧有的编码沿用多年，惯性很大。因此 UTF-8 编码在日本用了很多年才得以推广。 我的计算机在用什么编码？这取决于你的计算机操作系统。 Linux: 大多数情况下，Linux 系统使用 UTF-8 编码。在终端里执行 locale 命令，输出结果中的 LC_CTYPE 字段里可以看到系统语言和使用编码的信息。比如，en_US.utf8。 Mac: 在 OS X 之前，Mac 使用的是苹果公司修改的 SJIS 版本，其名为 MacJapanese。从 OS X 开始，Mac 使用的是 UTF-8。 Windows: 老版本使用 M$ 家修改的 SJIS 版本，其名为 CP932 （代码页 932，简体中文系统则是 CP936)。不过，新版本的 Windows 也有可能使用 UTF-8。 BSD: 据我所知，用的是 UTF-8。 小结在 LaTeX 里些日文文档之前，你先要确定你使用的是什么编码。不同的 TeX 引擎对编码支持的情况不同，你应该根据需要选择合适的编码和 TeX 引擎。目前被 TeX 引擎支持最好的编码（译注：原文是字符集）是 UTF-8。新版本的 pTeX 接受 UTF-8 编码；upTeX, XeTeX, LuaTeX 原生支持 UTF-8 编码；使用 BXcjkjatype 时，也应当使用 UTF-8 编码。 不过，不少老版本的文档使用 SJIS 编码。此时你应该使用 pTeX，用 pLaTeX 来编译；或者将他们转换为 UTF-8 编码后使用。 关于 \ 和 ￥以下内容来自维基百科 ShiftJIS 词条： The single-byte characters 0x00 to 0x7F match the ASCII encoding, except for a yen sign (U+00A5) at 0x5C and an overline (U+203E) at 0x7E in place of the ASCII character set’s backslash and tilde respectively. 也就是说，在 SJIS 中，符号「¥」的编码与 ASCII 里的反斜线「\」的编码相同，都是 0x5C；与此同时，TeX 将 0x5C 当做是转义符。于是，在使用 SJIS 编码的计算机里，TeX 控制序列就都变成了类似 ¥hfill 的样子。 下一篇文章，我们将正式开始编写 LaTeX 代码！ 译者续SJIS 在日本的地位和 GBK 在中国的地位差不多。在早期的 Windows 系统里，使用的 CP936 与 GBK 几乎相同。同时，中文 LaTeX 早期的支持方式也都是基于 GBK 编码的。 为了避免不必要的麻烦，我们的口号是：「珍爱生命，远离 GBK」。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>pTeX</tag>
        <tag>Encoding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日文 LaTeX 系统介绍 - 简介]]></title>
    <url>%2F2014%2F12%2F07%2Fptex-intro-and-tutorial-01%2F</url>
    <content type="text"><![CDATA[本文为译文，原文载于这里。尽请关注本系列的文章。 对于日本人来说，在 LaTeX 里面写日文很简单。但是由于文档的缺乏，外国人（相对日本）想要这样做就不容易了。更何况日语里面会混合罗马字母、假名、汉字。 这里我想总结一下我自己写日文 LaTeX 文档的经验。这些经验一方面来自我自己的实践，另一方面来自我的日本朋友的各种帮助。系列文章的第一部分简介了日文排版的一些情况，特别是关于 TeX 的介绍。在这里，我会对用于排版日文的 TeX 引擎和宏包做一个简单的比较。 日文书写系统日文中至少有四种书写系统： 罗马字母 平假名：平假名共有 45 个，一般来说用于连接汉字。 片假名：片假名和平假名一一对应，一般用来音译外文。 日文汉字：来自中文的表意文字，书面语里有很多汉字。 通常来说，日文文章里这四种书写系统会混杂在一起。下面的截图来自日文维基百科的「日本」词条。 日文书写系统的的规则繁复。Haruhiko Okumura (奥村 晴彦) 先生对此有过一个不错的介绍；如果你想了解详细的规则，可以看这里。TeX 本身并没有支持这些规则，于是 1987 年 NTT 的 Yasuki Saito (斉藤 康己) 先生编写了 NTT jTeX 这个引擎；1990 年，ASCII 公司 的 Shunji Ohno (大野 俊治) 先生和 Ryoichi Kurasawa (倉沢 良一) 先生修改了 NTT jTeX，增加了出版业所必须的竖排功能，命名为 pTeX (publishing TeX)。对此，Okumura 先生的文章里有详细的叙述。 日文排版日本自己开发了 pTeX，但这些年也有其他的一些 TeX 引擎可以用来排版日文。据我所知，有以下一些。 e(p)(la)tex: 从原始的 pTeX 而来，增加了 e-TeX 的补丁以适应现代 LaTeX 的需要 up(la)tex: 同样从原始的 pTeX 发展而来，增加了 e-TeX 的补丁并增加了 UTF-8 编码支持 xe(la)tex: 另一个系统，同样支持 UTF-8 编码以及其他一些先进的技术 pdf(la)tex with CJK package: 支持中日韩文字，但已过时 pdf(la)tex with bxcjkjatype package: 一个易用的新宏包，有一些功能上的限制 lua(la)tex with luatex-ja package: 最新的日文支持方式，提供了不少优秀的特性 需求在 LaTeX 里书写日文有以下需求。 e-TeX 原语：e-TeX 是原始 TeX 的扩展，后逐渐成为主流，现在它的原语成为 LaTeX 强制要求的一部分 日文排版禁则：如前所述 竖排：许多非技术文本都会用到竖排 UTF-8 支持：pTeX 使用的编码不大好，有不少问题，现代计算机大都使用 UTF-8 编码 能够使用商业字体：在文章里能够自由切换字体 插图支持 在这里，pTeX 不支持 e-TeX、UTF-8 编码，插图功能孱弱；e-pTeX 完善了 e-TeX 支持，但仍不支持 UTF-8 编码且插图功能依旧孱弱；upTeX 又克服了 UTF-8 编码支持的问题；XeTeX 对竖排的支持能力有限；pdfTeX + CJK 对日文禁则处理不好，也不支持竖排；pdfTeX + bxcjkjatype 对日文禁则处理不好，不支持竖排，也无法比较好地处理商业字体；LuaTeX + LuaTeX-ja 对竖排的支持不甚良好。 （至今为止的）结论最近我都在使用 LuaTeX-ja，以下是我对此的一些总结。 (u)ptex: 如果你想要竖排功能，这是唯一的选择；此外，由于 pTeX 系源自日本，它对日文排版禁则的支持最好 xe(la)tex: 目前功能相对完善的宏包是 xeCJK，但其实只是对中文支持良好；日本有同好对此做了扩展，效果一般 pdf(la)tex + CJK: 过时了，不推荐 pdf(la)tex + bxcjkjatype: 很好用，但是有一个很重要缺点：所有非 ASCII 字符都被当做汉字对待 luatexja: 最打动我的宏包，强烈推荐。 下一篇文章里我会介绍一下各种方式底下的最简日文示例。 谢谢！ 译者续马起园 (Clerk Ma) 的 pTeX-ng 是下一代的 pTeX。pTeX-ng 从 Y&amp;Y TeX 发展而来，是纯 C 编写的 TeX 引擎。它带有 e-TeX, pTeX 的补丁，并原生支持 Unicode 编码，对字体支持良好，并且能够直接输出 PDF 文档。pTeX-ng 的前景十分喜人。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>pTeX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 LaTeX 里定义一个类似 proof 的环境]]></title>
    <url>%2F2014%2F12%2F03%2Fhow-to-define-a-proof-like-environment%2F</url>
    <content type="text"><![CDATA[美国数学协会（AMS）是 TeX 发展中的一支重要的力量。AMS 定义的 proof 环境非常好用，能在证明结束的末尾，自动添加一个「证毕」的符号。 有时我们需要类似的环境，比如这里的题主希望用两个环境区分「证明」和「解答」，并且都需要自动添加结束符号。这时我们可以仿照 amsthm 宏包的做法，自己定义一套环境。 proof 环境的原始定义是这样的： 12345678\newenvironment&#123;proof&#125;[1][\proofname]&#123;\par \pushQED&#123;\qed&#125;% \normalfont \topsep6\p@\@plus6\p@\relax \trivlist \item[\hskip\labelsep \itshape #1\@addpunct&#123;.&#125;]\ignorespaces&#125;&#123;\popQED\endtrivlist\@endpefalse&#125; 这里 \pushQED{\qed} 把 \qed 压入了 QED 这个堆栈，然后在环境结束的地方，通过 \popQED 把压入堆栈的最后一个元素弹出来。这样的设计是非常合理的。比如，如果在证明的过程中，需要分别证明两个小的情形，这样就能按照次序依次给出证明的结束符号。此外，证明开始的标题通过 \proofname 来控制。 通过这些分析，我们知道定义一个新的环境，我们需要从两个方面入手。其一是 \proofname 的位置需要改变，其二是压入堆栈的内容需要更改。 下面的代码我们定义了一个名为 \fooname 的宏，来替代 \proofname。 1\providecommand&#123;\fooname&#125;&#123;Foo&#125; 下面的代码我们定义了名为 \bxz 的宏，来替换原本压入堆栈的 \qed。其中 \bxz 具体的符号内容用 \bxzsymbol 这个宏来控制。 12345678\DeclareRobustCommand&#123;\bxz&#125;&#123;\ifmmode \mathbxz \else \leavevmode\unskip\penalty9999 \hbox&#123;&#125;\nobreak\hfill \quad\hbox&#123;\bxzsymbol&#125;% \fi&#125;\newcommand&#123;\mathbxz&#125;&#123;\quad\hbox&#123;\bxzsymbol&#125;&#125;\providecommand&#123;\bxzsymbol&#125;&#123;\fbox&#123;\footnotesize B.X.Z&#125;&#125; 最后，重新定义一个名为 foo 的环境。 12345678\newenvironment&#123;foo&#125;[1][\fooname]&#123;\par \pushQED&#123;\bxz&#125;% \normalfont \topsep6\p@\@plus6\p@\relax \trivlist \item[\hskip\labelsep \itshape #1\@addpunct&#123;.&#125;]\ignorespaces&#125;&#123;\popQED\endtrivlist\@endpefalse&#125; 完整的测试代码如下： 12345678910111213141516171819202122232425262728293031323334\documentclass&#123;article&#125;\usepackage&#123;amsthm&#125;\makeatletter\DeclareRobustCommand&#123;\bxz&#125;&#123;\ifmmode \mathbxz \else \leavevmode\unskip\penalty9999 \hbox&#123;&#125;\nobreak\hfill \quad\hbox&#123;\bxzsymbol&#125;% \fi&#125;\newcommand&#123;\mathbxz&#125;&#123;\quad\hbox&#123;\bxzsymbol&#125;&#125;\newenvironment&#123;foo&#125;[1][\fooname]&#123;\par \pushQED&#123;\bxz&#125;% \normalfont \topsep6\p@\@plus6\p@\relax \trivlist \item[\hskip\labelsep \itshape #1\@addpunct&#123;.&#125;]\ignorespaces&#125;&#123;\popQED\endtrivlist\@endpefalse&#125;\providecommand&#123;\bxzsymbol&#125;&#123;\fbox&#123;\footnotesize B.X.Z&#125;&#125;\providecommand&#123;\fooname&#125;&#123;Foo&#125;\makeatother\begin&#123;document&#125;\begin&#123;proof&#125;\begin&#123;foo&#125; The foo goes here.\end&#123;foo&#125;\begin&#123;foo&#125; \[ E = mc^&#123;2&#125;.\qedhere \]\end&#123;foo&#125;This is the conclusion that we need.\end&#123;proof&#125;\end&#123;document&#125;]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Proof</tag>
        <tag>Environment</tag>
        <tag>Macros</tag>
        <tag>AMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 LaTeX 中使用含有中文的 PDF 书签避免乱码的正确姿势]]></title>
    <url>%2F2014%2F11%2F22%2Flatex-pdf-cjk-bookmarks%2F</url>
    <content type="text"><![CDATA[LaTeX 的 hyperref 宏包能够在 PDF 文件里生成 PDF 书签，然而「书签乱码」是困扰很多 LaTeX 使用者的麻烦问题。 早年李树钧和张林波老师共同开发了名为 gbk2uni 的小工具，用以将 filename.out 中的 GBK 编码的字符转换成八进制数据；刘海洋和李清在 ctex 宏包/文档类对此做了处理，使得 ctex 宏包/文档类能够正确处理大部分的情况；后来李清编写了 xCJK2uni 宏包，使得在 pdfLaTeX 编译方式下用 CJK 的 GBK 编码模式也能正确输出 PDF 书签，而不必借用额外的工具。 这里对全部正确的方式做一个总结。 推荐的方式最好的办法是将中文支持和版式处理都交给 ctex 宏包/文档类，只需要开启 hyperref 选项即可。 适用情况 UTF-8 + XeLaTeX（目前最最最最最最最最推荐的方式，看到它请星星眼） UTF-8 + pdfLaTeX UTF-8 + LaTeX - DVIPDFMx 12345\documentclass[hyperref, UTF8]&#123;ctexart&#125;\begin&#123;document&#125;\section&#123;中文书签不会乱码&#125;UTF-8 编码，Xe\LaTeX&#123;&#125;/pdf\LaTeX&#123;&#125;/\LaTeX&#123;&#125; - DVIPDFMx 编译。\end&#123;document&#125; 123456\documentclass&#123;article&#125;\usepackage[hyperref, UTF8]&#123;ctex&#125;\begin&#123;document&#125;\section&#123;中文书签不会乱码&#125;UTF-8 编码，Xe\LaTeX&#123;&#125;/pdf\LaTeX&#123;&#125;/\LaTeX&#123;&#125; - DVIPDFMx 编译。\end&#123;document&#125; 适用情况（除非必要，不要使用 GBK 编码） GBK + LaTeX - DVIPDFMx GBK + pdfLaTeX （CTeX 宏集 2.x 版本支持，旧版本不支持） 12345\documentclass[hyperref, GBK]&#123;ctexart&#125;\begin&#123;document&#125;\section&#123;中文书签不会乱码&#125;GBK 编码，pdf\LaTeX&#123;&#125;/\LaTeX&#123;&#125; - DVIPDFMx 编译。\end&#123;document&#125; 123456\documentclass&#123;article&#125;\usepackage[hyperref, GBK]&#123;ctex&#125;\begin&#123;document&#125;\section&#123;中文书签不会乱码&#125;GBK 编码，pdf\LaTeX&#123;&#125;/\LaTeX&#123;&#125; - DVIPDFMx 编译。\end&#123;document&#125; 折腾星人的方式如果不想使用 ctex 宏包/文档类，也可以选择自己写代码进行中文支持。这时候需要做额外的代码配置，保证 PDF 书签不会乱码。 适用情况 UTF-8 + XeLaTeX 12345678\documentclass&#123;article&#125;\usepackage&#123;xeCJK&#125;\usepackage&#123;hyperref&#125;\setCJKmainfont&#123;SimSun&#125;\begin&#123;document&#125;\section&#123;中文书签不会乱码&#125;UTF-8 编码，Xe\LaTeX&#123;&#125; 编译。\end&#123;document&#125; 适用情况 UTF-8 + pdfLaTeX 123456789101112\documentclass&#123;article&#125;\usepackage&#123;CJKutf8&#125;\usepackage&#123;hyperref&#125;\hypersetup&#123;unicode&#125;\AtBeginShipoutFirst&#123;\input&#123;zhwinfonts.tex&#125;&#125;\begin&#123;document&#125;\begin&#123;CJK*&#125;&#123;UTF8&#125;&#123;song&#125;\section&#123;中文书签不会乱码&#125;UTF-8~编码，pdf\LaTeX&#123;&#125;~编译。\clearpage\end&#123;CJK*&#125;\end&#123;document&#125; 适用情况 UTF-8 + LaTeX - DVIPDFMx 123456789101112\documentclass&#123;article&#125;\usepackage&#123;CJKutf8&#125;\usepackage[dvipdfmx]&#123;hyperref&#125;\hypersetup&#123;unicode&#125;\AtBeginShipoutFirst&#123;\input&#123;zhwinfonts.tex&#125;&#125;\begin&#123;document&#125;\begin&#123;CJK*&#125;&#123;UTF8&#125;&#123;song&#125;\section&#123;中文书签不会乱码&#125;UTF-8~编码，\LaTeX&#123;&#125; - DVIPDFMx~编译。\clearpage\end&#123;CJK*&#125;\end&#123;document&#125; 适用情况 GBK + pdfLaTeX （谁特么还在用 GBK 啊！摔！） 请大家将感谢信发送至 李清 的邮箱~ 123456789101112\documentclass&#123;article&#125;\usepackage&#123;CJK&#125;\usepackage&#123;xCJK2uni&#125; % 请大家将感谢信发送至 李清 的邮箱~ : )\usepackage&#123;hyperref&#125;\AtBeginShipoutFirst&#123;\input&#123;zhwinfonts.tex&#125;&#125;\begin&#123;document&#125;\begin&#123;CJK*&#125;&#123;GBK&#125;&#123;song&#125;\section&#123;中文书签不会乱码&#125;GBK~编码，pdf\LaTeX&#123;&#125;~编译。\clearpage\end&#123;CJK*&#125;\end&#123;document&#125; 适用情况 GBK + LaTeX - DVIPDFMx（谁特么还在用 GBK 啊！摔！） 12345678910111213\documentclass&#123;article&#125;\usepackage&#123;CJK&#125;\usepackage[dvipdfmx]&#123;hyperref&#125;\hypersetup&#123;CJKbookmarks&#125;\AtBeginShipoutFirst&#123;\input&#123;zhwinfonts.tex&#125;&#125;\AtBeginShipoutFirst&#123;\special&#123;pdf:tounicode GBK-EUC-UCS2&#125;&#125;\begin&#123;document&#125;\begin&#123;CJK*&#125;&#123;GBK&#125;&#123;song&#125;\section&#123;中文书签不会乱码&#125;GBK~编码，\LaTeX&#123;&#125; - DVIPDFMx~编译。\clearpage\end&#123;CJK*&#125;\end&#123;document&#125;]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>PDF</tag>
        <tag>CJK</tag>
        <tag>Bookmarks</tag>
        <tag>Error Codes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为 MacTeX 配置中文支持]]></title>
    <url>%2F2014%2F11%2F02%2Flatex-mactex-chinese-support%2F</url>
    <content type="text"><![CDATA[最近有人问到如何在 MacTeX 里配置中文支持，这里一并回答。 目前来说，结合 xeCJK 宏包使用 XeLaTeX 编译，应该是最方便的方式了。 XeLaTeX 要求 .tex 文档保存为 UTF-8 编码。所以要做的事情只有两件： 配置一个 UTF-8 的编辑环境； 用 xeCJK 的语法选择合适的字体。 配置 UTF-8 的编辑环境MacTeX 自带了名为 TeXshop 的编辑器，这里以它为例配置 UTF-8 的编辑环境。其他编辑器也有类似配置。 打开 TeXshop，按下 cmd + , 打开偏好设置。在「源代码」标签下找到编码设置，调整为 UTF-8。然后单击「好」保存即可。 查找字体信息XeTeX 在 Mac OS X 下的行为和 Windows/Linux 下不大一样。Mac 底下，XeTeX 并不使用 fontconfig 库来搜索字体，所以我们没法在终端里通过 fc-list 命令来查看可用的字体列表。不过 Mac 里提供了名为「字体册」的程序，来列出系统中所有可用的字体信息。 其实这样的设计挺讨厌的，TeX Live 自带了许多开源字体，因此没有办法很好地使用。必须用字体名而不是字族名来调用这些字体，实在是不太方便。当然，如果有需要，我们可以把 TeX 里自带的这些开源字体用硬链接的方式，添加到 Mac 的字体目录下。 打开字体册程序，找到需要的字体信息： 这里的 PostScript 名称就是我们需要的信息，我们记下华文宋体的名字：「STSong」。你还可以按需找到其他字体的名字，比如华文中宋、华文楷体、华文黑体等字体的名字。 用 xeCJK 的语法配置字体使用下列代码，配置中文字体。 1234\usepackage&#123;xeCJK&#125;\setCJKmainfont[BoldFont=STZhongsong, ItalicFont=STKaiti]&#123;STSong&#125;\setCJKsansfont[BoldFont=STHeiti]&#123;STXihei&#125;\setCJKmonofont&#123;STFangsong&#125; 这里， 文档中文主字体是华文宋体，对应的 bfseries 字体是华文中宋，对应的 itshape 字体是华文楷体； 文档的「无衬线」中文字体是华文新黑，对应的 bfseries 是华文黑体； 文档的「等宽」中文字体是华文仿宋。 完整代码的编译效果截图如下： 使用 ctex 宏包和文档类 [2015-05-21 更新]xeCJK 之解决了中文支持问题，以及一些关于标点的处理，并没有提供和中文版式相关的解决方案。ctex 宏包和文档类封装了 xeCJK，同时提供了中文版式的相关支持。新版的 ctex 宏包和文档类能够自动检测用户使用的操作系统，自动选择合适的字体配置，十分方便。 1234\documentclass[UTF8]&#123;ctexart&#125;\begin&#123;document&#125;中文\end&#123;document&#125; 测试截图如下： 如果希望 ctex 只提供中文支持的功能不对版式做任何修改，也可以这样使用： 12345\documentclass&#123;article&#125;\usepackage[UTF8, heading = false, scheme = plain]&#123;ctex&#125;\begin&#123;document&#125;中文\end&#123;document&#125;]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>CJK</tag>
        <tag>MacTeX</tag>
        <tag>OS X</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后会无期于后会有期的平凡之路]]></title>
    <url>%2F2014%2F09%2F28%2Freview-of-the-continent%2F</url>
    <content type="text"><![CDATA[我始终是认为，真正体会到的美好，不是一瞬间的事情，而是伴随美好到底的经历。于是我是很不喜欢「后会无期」这个词的，这种只能将美好放在记忆中的状态让我很不舒服。因为我总觉得记忆这种东西是带着一点悲凉和悲哀的色彩的。不论多么美好和美丽的事物，保存在记忆中都会随着时间慢慢被抹去。 我是第一次接触这种类型的电影，接触韩寒的作品是第二次（第一次是中学时代看过他写的《长安乱》）。记得和《长安乱》同时期还有一部很火热的小说，是郭敬明的《幻城》。两部小说我都是从同学处借来阅读的，先是看了《幻城》，然后才是《长安乱》。我很少看小说，当时感觉幻城这种类型的小说还蛮有意思的，但是直觉还是更喜欢长安乱。虽然我一直觉得没看懂长安乱写得是什么，而且到现在其实已经忘记了其中的内容。 和《长安乱》一样，后会无期这部电影也是有些「表意不明」的作品。于是每个人看到的东西都不一样吧。我曾经痴迷于另一部表意不明的作品，庵野秀明先生的 EVA。EVA 这部作品其实给人一种神神秘秘的感觉，从作品的设定到表达的世界观，都蛮奇怪的。有两年我十分痴迷，为此去学习了日语，去翻阅日文资料。然后在国内第一次完整整理了它的设定和世界观的文档，也写了很多自己的感想。不过后来再看这些文字，觉得有些矫情。于是慢慢也就不再写了，转而躲在屏幕背后，看这一批一批的人如何去体会 EVA。慢慢就会发现，其实所有人都在作品中寻找自己的身影，寻找适合自己的那个影子覆盖之处的光亮（希望）。 归因于最近的经历，我大概是以一种比较「麻木」的状态去看这电影的。当然这种麻木不是「不仁」，而是一种「嗯，这样也挺好的」这种接受一切的态度。这可能正好切合了韩寒想要表达的情感也未可知。 对这部电影，我自己的感受，其实就是那句西班牙语「Que Sera Sera」，也觉得这就是韩寒自己想传达出的意思。这句西语，应该是「Whatever will be」的意思。看起来有点消极，但是其实取决于个人选择的行为方式。电影中意外出现的那只小狗代表着电影世界里的真善美。这种「意外」代表着「无处不在」的可能性，正如世界的美好一样。电影的最后小狗「无意识」地选择了江河，反过来映衬了江河的选择：用自己的方式相信这个世界，相信这个世界的真善美。我觉得这就是所谓「平凡之路」，这不是读万卷书或者行万里路之后「悟」出来的路，而是内心向善，简单而平凡坚信的一条路。 简单地相信一些美好的东西，坚定地走着自己平凡的路。对比马浩汉希望振兴家乡旅游业的强烈愿望不同，这种平凡而坚定的信念，反而带给了江河一个不错的结局。而在这「出乎预料」的结局里，江河表现得还是一如既往地平凡：「导游」在宣传江河的作品的时候，画面中的江河不正是在平静地走着他的平凡之路吗…… 这种接受世界、感受世界、行走在这个世界的行为方式，就是韩寒想传达的行为方式：不甘于平庸，回归于平凡，不脱离现实而又不服于现实。]]></content>
      <categories>
        <category>Literature and Social Sciences</category>
      </categories>
      <tags>
        <tag>Movie</tag>
        <tag>Han Han</tag>
        <tag>The Continent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matplotlib 教程]]></title>
    <url>%2F2014%2F09%2F11%2Fmatplotlib-tutorial-zh-cn%2F</url>
    <content type="text"><![CDATA[Matplotlib 教程 本文为译文，原文载于此，译文原载于此。本文欢迎转载，但请保留本段文字，尊重作者和译者的权益。谢谢。: ) 介绍Matplotlib 可能是 Python 2D-绘图领域使用最广泛的套件。它能让使用者很轻松地将数据图形化，并且提供多样化的输出格式。这里将会探索 matplotlib 的常见用法。 IPython 以及 pylab 模式IPython 是 Python 的一个增强版本。它在下列方面有所增强：命名输入输出、使用系统命令（shell commands）、排错（debug）能力。我们在命令行终端给 IPython 加上参数 -pylab （0.12 以后的版本是 --pylab）之后，就可以像 Matlab 或者 Mathematica 那样以交互的方式绘图。 pylabpylab 是 matplotlib 面向对象绘图库的一个接口。它的语法和 Matlab 十分相近。也就是说，它主要的绘图命令和 Matlab 对应的命令有相似的参数。 初级绘制这一节中，我们将从简到繁：先尝试用默认配置在同一张图上绘制正弦和余弦函数图像，然后逐步美化它。 第一步，是取得正弦函数和余弦函数的值： 1234from pylab import *X = np.linspace(-np.pi, np.pi, 256,endpoint=True)C,S = np.cos(X), np.sin(X) X 是一个 numpy 数组，包含了从 $-\pi$ 到 $+\pi$ 等间隔的 256 个值。C 和 S 则分别是这 256 个值对应的余弦和正弦函数值组成的 numpy 数组。 你可以在 IPython 的交互模式下测试代码，也可以下载代码（下载链接就是这些示例图），然后执行： 1python exercise_1.py 使用默认配置Matplotlib 的默认配置都允许用户自定义。你可以调整大多数的默认配置：图片大小和分辨率（dpi）、线宽、颜色、风格、坐标轴、坐标轴以及网格的属性、文字与字体属性等。不过，matplotlib 的默认配置在大多数情况下已经做得足够好，你可能只在很少的情况下才会想更改这些默认配置。 123456789from pylab import *X = np.linspace(-np.pi, np.pi, 256,endpoint=True)C,S = np.cos(X), np.sin(X)plot(X,C)plot(X,S)show() 默认配置的具体内容下面的代码中，我们展现了 matplotlib 的默认配置并辅以注释说明，这部分配置包含了有关绘图样式的所有配置。代码中的配置与默认配置完全相同，你可以在交互模式中修改其中的值来观察效果。 1234567891011121314151617181920212223242526272829303132333435# 导入 matplotlib 的所有内容（nympy 可以用 np 这个名字来使用）from pylab import *# 创建一个 8 * 6 点（point）的图，并设置分辨率为 80figure(figsize=(8,6), dpi=80)# 创建一个新的 1 * 1 的子图，接下来的图样绘制在其中的第 1 块（也是唯一的一块）subplot(1,1,1)X = np.linspace(-np.pi, np.pi, 256,endpoint=True)C,S = np.cos(X), np.sin(X)# 绘制余弦曲线，使用蓝色的、连续的、宽度为 1 （像素）的线条plot(X, C, color="blue", linewidth=1.0, linestyle="-")# 绘制正弦曲线，使用绿色的、连续的、宽度为 1 （像素）的线条plot(X, S, color="green", linewidth=1.0, linestyle="-")# 设置横轴的上下限xlim(-4.0,4.0)# 设置横轴记号xticks(np.linspace(-4,4,9,endpoint=True))# 设置纵轴的上下限ylim(-1.0,1.0)# 设置纵轴记号yticks(np.linspace(-1,1,5,endpoint=True))# 以分辨率 72 来保存图片# savefig("exercice_2.png",dpi=72)# 在屏幕上显示show() 改变线条的颜色和粗细首先，我们以蓝色和红色分别表示余弦和正弦函数，而后将线条变粗一点。接下来，我们在水平方向拉伸一下整个图。 12345...figure(figsize=(10,6), dpi=80)plot(X, C, color="blue", linewidth=2.5, linestyle="-")plot(X, S, color="red", linewidth=2.5, linestyle="-")... 设置图片边界当前的图片边界设置得不好，所以有些地方看得不是很清楚。 1234...xlim(X.min()*1.1, X.max()*1.1)ylim(C.min()*1.1, C.max()*1.1)... 更好的方式是这样： 12345678xmin ,xmax = X.min(), X.max()ymin, ymax = Y.min(), Y.max()dx = (xmax - xmin) * 0.2dy = (ymax - ymin) * 0.2xlim(xmin - dx, xmax + dx)ylim(ymin - dy, ymax + dy) 设置记号我们讨论正弦和余弦函数的时候，通常希望知道函数在 $\pm\pi$ 和 $\pm\frac{\pi}{2}$ 的值。这样看来，当前的设置就不那么理想了。 1234...xticks( [-np.pi, -np.pi/2, 0, np.pi/2, np.pi])yticks([-1, 0, +1])... 设置记号的标签记号现在没问题了，不过标签却不大符合期望。我们可以把 $3.142$ 当做是 $\pi$，但毕竟不够精确。当我们设置记号的时候，我们可以同时设置记号的标签。注意这里使用了 LaTeX。 1234567...xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi], [r'$-\pi$', r'$-\pi/2$', r'$0$', r'$+\pi/2$', r'$+\pi$'])yticks([-1, 0, +1], [r'$-1$', r'$0$', r'$+1$'])... 移动脊柱坐标轴线和上面的记号连在一起就形成了脊柱（Spines，一条线段上有一系列的凸起，是不是很像脊柱骨啊~），它记录了数据区域的范围。它们可以放在任意位置，不过至今为止，我们都把它放在图的四边。 实际上每幅图有四条脊柱（上下左右），为了将脊柱放在图的中间，我们必须将其中的两条（上和右）设置为无色，然后调整剩下的两条到合适的位置——数据空间的 0 点。 123456789...ax = gca()ax.spines['right'].set_color('none')ax.spines['top'].set_color('none')ax.xaxis.set_ticks_position('bottom')ax.spines['bottom'].set_position(('data',0))ax.yaxis.set_ticks_position('left')ax.spines['left'].set_position(('data',0))... 添加图例我们在图的左上角添加一个图例。为此，我们只需要在 plot 函数里以「键 - 值」的形式增加一个参数。 123456...plot(X, C, color="blue", linewidth=2.5, linestyle="-", label="cosine")plot(X, S, color="red", linewidth=2.5, linestyle="-", label="sine")legend(loc='upper left')... 给一些特殊点做注释我们希望在 $2\pi/3$ 的位置给两条函数曲线加上一个注释。首先，我们在对应的函数图像位置上画一个点；然后，向横轴引一条垂线，以虚线标记；最后，写上标签。 12345678910111213141516171819...t = 2*np.pi/3plot([t,t],[0,np.cos(t)], color ='blue', linewidth=2.5, linestyle="--")scatter([t,],[np.cos(t),], 50, color ='blue')annotate(r'$\sin(\frac&#123;2\pi&#125;&#123;3&#125;)=\frac&#123;\sqrt&#123;3&#125;&#125;&#123;2&#125;$', xy=(t, np.sin(t)), xycoords='data', xytext=(+10, +30), textcoords='offset points', fontsize=16, arrowprops=dict(arrowstyle="-&gt;", connectionstyle="arc3,rad=.2"))plot([t,t],[0,np.sin(t)], color ='red', linewidth=2.5, linestyle="--")scatter([t,],[np.sin(t),], 50, color ='red')annotate(r'$\cos(\frac&#123;2\pi&#125;&#123;3&#125;)=-\frac&#123;1&#125;&#123;2&#125;$', xy=(t, np.cos(t)), xycoords='data', xytext=(-90, -50), textcoords='offset points', fontsize=16, arrowprops=dict(arrowstyle="-&gt;", connectionstyle="arc3,rad=.2"))... 精益求精坐标轴上的记号标签被曲线挡住了，作为强迫症患者（雾）这是不能忍的。我们可以把它们放大，然后添加一个白色的半透明底色。这样可以保证标签和曲线同时可见。 12345...for label in ax.get_xticklabels() + ax.get_yticklabels(): label.set_fontsize(16) label.set_bbox(dict(facecolor='white', edgecolor='None', alpha=0.65 ))... 图像、子图、坐标轴和记号到目前为止，我们都用隐式的方法来绘制图像和坐标轴。快速绘图中，这是很方便的。我们也可以显式地控制图像、子图、坐标轴。Matplotlib 中的「图像」指的是用户界面看到的整个窗口内容。在图像里面有所谓「子图」。子图的位置是由坐标网格确定的，而「坐标轴」却不受此限制，可以放在图像的任意位置。我们已经隐式地使用过图像和子图：当我们调用 plot 函数的时候，matplotlib 调用 gca() 函数以及 gcf() 函数来获取当前的坐标轴和图像；如果无法获取图像，则会调用 figure() 函数来创建一个——严格地说，是用 subplot(1,1,1) 创建一个只有一个子图的图像。 图像所谓「图像」就是 GUI 里以「Figure #」为标题的那些窗口。图像编号从 1 开始，与 MATLAB 的风格一致，而于 Python 从 0 开始编号的风格不同。以下参数是图像的属性： 参数默认值描述num1图像的数量figsizefigure.figsize图像的长和宽（英寸）dpifigure.dpi分辨率（点/英寸）facecolorfigure.facecolor绘图区域的背景颜色edgecolorfigure.edgecolor绘图区域边缘的颜色frameonTrue是否绘制图像边缘 这些默认值可以在源文件中指明。不过除了图像数量这个参数，其余的参数都很少修改。 你在图形界面中可以按下右上角的 X 来关闭窗口（OS X 系统是左上角）。Matplotlib 也提供了名为 close 的函数来关闭这个窗口。close 函数的具体行为取决于你提供的参数： 不传递参数：关闭当前窗口； 传递窗口编号或窗口实例（instance）作为参数：关闭指定的窗口； all：关闭所有窗口。 和其他对象一样，你可以使用 setp 或者是 set_something 这样的方法来设置图像的属性。 子图你可以用子图来将图样（plot）放在均匀的坐标网格中。用 subplot 函数的时候，你需要指明网格的行列数量，以及你希望将图样放在哪一个网格区域中。此外，gridspec 的功能更强大，你也可以选择它来实现这个功能。 坐标轴坐标轴和子图功能类似，不过它可以放在图像的任意位置。因此，如果你希望在一副图中绘制一个小图，就可以用这个功能。 记号良好的记号是图像的重要组成部分。Matplotlib 里的记号系统里的各个细节都是可以由用户个性化配置的。你可以用 Tick Locators 来指定在那些位置放置记号，用 Tick Formatters 来调整记号的样式。主要和次要的记号可以以不同的方式呈现。默认情况下，每一个次要的记号都是隐藏的，也就是说，默认情况下的次要记号列表是空的——NullLocator。 Tick Locators下面有为不同需求设计的一些 Locators。 类型 说明NullLocatorNo ticks.IndexLocatorPlace a tick on every multiple of some base number of points plotted.FixedLocatorTick locations are fixed.LinearLocatorDetermine the tick locations.MultipleLocatorSet a tick on every integer that is multiple of some base.AutoLocatorSelect no more than n intervals at nice locations.LogLocatorDetermine the tick locations for log axes. 这些 Locators 都是 matplotlib.ticker.Locator 的子类，你可以据此定义自己的 Locator。以日期为 ticks 特别复杂，因此 Matplotlib 提供了 matplotlib.dates 来实现这一功能。 其他类型的图接下来的内容是练习。请运用你学到的知识，从提供的代码开始，实现配图所示的效果。具体的答案可以点击配图下载。 普通图123456789from pylab import *n = 256X = np.linspace(-np.pi,np.pi,n,endpoint=True)Y = np.sin(2*X)plot (X, Y+1, color='blue', alpha=1.00)plot (X, Y-1, color='blue', alpha=1.00)show() 散点图12345678from pylab import *n = 1024X = np.random.normal(0,1,n)Y = np.random.normal(0,1,n)scatter(X,Y)show() 条形图123456789101112131415from pylab import *n = 12X = np.arange(n)Y1 = (1-X/float(n)) * np.random.uniform(0.5,1.0,n)Y2 = (1-X/float(n)) * np.random.uniform(0.5,1.0,n)bar(X, +Y1, facecolor='#9999ff', edgecolor='white')bar(X, -Y2, facecolor='#ff9999', edgecolor='white')for x,y in zip(X,Y1): text(x+0.4, y+0.05, '%.2f' % y, ha='center', va= 'bottom')ylim(-1.25,+1.25)show() 等高线图123456789101112from pylab import *def f(x,y): return (1-x/2+x**5+y**3)*np.exp(-x**2-y**2)n = 256x = np.linspace(-3,3,n)y = np.linspace(-3,3,n)X,Y = np.meshgrid(x,y)contourf(X, Y, f(X,Y), 8, alpha=.75, cmap='jet')C = contour(X, Y, f(X,Y), 8, colors='black', linewidth=.5)show() 灰度图（Imshow）123456789from pylab import *def f(x,y): return (1-x/2+x**5+y**3)*np.exp(-x**2-y**2)n = 10x = np.linspace(-3,3,4*n)y = np.linspace(-3,3,3*n)X,Y = np.meshgrid(x,y)imshow(f(X,Y)), show() 饼状图12345from pylab import *n = 20Z = np.random.uniform(0,1,n)pie(Z), show() 量场图（Quiver Plots）12345from pylab import *n = 8X,Y = np.mgrid[0:n,0:n]quiver(X,Y), show() 网格123456789from pylab import *axes = gca()axes.set_xlim(0,4)axes.set_ylim(0,3)axes.set_xticklabels([])axes.set_yticklabels([])show() 多重网格1234567from pylab import *subplot(2,2,1)subplot(2,2,3)subplot(2,2,4)show() 极轴图123456789101112131415from pylab import *axes([0,0,1,1])N = 20theta = np.arange(0.0, 2*np.pi, 2*np.pi/N)radii = 10*np.random.rand(N)width = np.pi/4*np.random.rand(N)bars = bar(theta, radii, width=width, bottom=0.0)for r,bar in zip(radii, bars): bar.set_facecolor( cm.jet(r/10.)) bar.set_alpha(0.5)show() 3D 图1234567891011121314from pylab import *from mpl_toolkits.mplot3d import Axes3Dfig = figure()ax = Axes3D(fig)X = np.arange(-4, 4, 0.25)Y = np.arange(-4, 4, 0.25)X, Y = np.meshgrid(X, Y)R = np.sqrt(X**2 + Y**2)Z = np.sin(R)ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap='hot')show() 手稿 结束篇Matplotlib 能有今天这样强大的功能和广泛的使用得益于大量的文档和社区开发者。这里提供一些有益的链接。 入门教程 Pyplot tutorial Image tutorial Text tutorial Artist tutorial Path tutorial Transforms tutorial Matplotlib 文档 用户指南 常见问题及回答 截屏 随代码分发的文档Matplotlib 的代码是自文档（Self-documented）的。你可以在 Python 中快速查询某个命令的用法。 12345678910111213141516171819&gt;&gt;&gt; from pylab import *&gt;&gt;&gt; help(plot)Help on function plot in module matplotlib.pyplot:plot(*args, **kwargs) Plot lines and/or markers to the :class:`~matplotlib.axes.Axes`. *args* is a variable length argument, allowing for multiple *x*, *y* pairs with an optional format string. For example, each of the following is legal:: plot(x, y) # plot x and y using default line style and color plot(x, y, 'bo') # plot x and y using blue circle markers plot(y) # plot y using x as index array 0..N-1 plot(y, 'r+') # ditto, but with red plusses If *x* and/or *y* is 2-dimensional, then the corresponding columns will be plotted. ... 画廊Matplotlib 画廊 也非常有用。其中的例子都有配图和对应的代码，当你不知道某一个效果如何实现的时候，你可以在这里找找。 哦，这里还有一个小一点的画廊。 邮件列表你可以在用户邮件列表提问，或者在开发者邮件列表里交流技术。 译注：邮件列表是一个很正式的交流平台，其内的每一封邮件，列表的收听者都会看到，所以请不要在邮件列表灌水或发表质量低劣的文章。 快速查询你可以在这里找到 Matplotlib 主要的属性表，以便按照需求个性化配置你的输出图样。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Tutorial</tag>
        <tag>Matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一份其实很短的 LaTeX 入门文档]]></title>
    <url>%2F2014%2F09%2F08%2Flatex-introduction%2F</url>
    <content type="text"><![CDATA[优雅的 LaTeX有很多 Geeks 或者 LaTeX’s Fanatical Fans 过分地强调了 LaTeX 的一些并非重点的特性，以至于很多初学者会觉得 LaTeX 很神秘很复杂，从而引发了初学者的畏难情绪甚至是负面情绪。尽管这些 Fans 说得并没有错，我是说在事实上，但是他们的表达方式和内心态度却间接阻碍了 LaTeX 的发展，我想这也是和他们的初衷相悖的。 我曾经也受到过这些言论的影响，但幸运的事，至今为止我已经越过了这些障碍，并更加坚信了他们所言（LaTeX 的优点）的正确性。因此我想以我自己的方式，向更多的人介绍 LaTeX —— 这个优雅，但有着自己高傲，却绝不复杂甚至神秘的东西。 欢迎从校内转移过来的同学们，因为校内的技术原因，文章无法在校内继续更新。尽管非我之故，但还是给各位同学说声抱歉。同时，欢迎各位来到我的博客。: ) 你将从这里看到 （几乎是）最简洁的 (La)TeX 编辑器——TeXworks——的基本使用方法； 如何使用 (Xe)LaTeX 进行简单的中英混排； 简单的文章组织结构； 如何用 (Xe)LaTeX 进行数学公式的排版； 如何在 (Xe)LaTeX 的文档中插入图片/表格； 如何进行简单的版面设置； 几个最常见的带有 TeX 的单词的含义； 出现问题应当如何处理/怎样聪明地提出你的问题——怎样从这里毕业。 你不会从这里看到 如何安装 TeX 发行； 特殊需求（特殊宏包）的解决方法； 关于若干 TeX 发行的好坏比较； 关于各种 TeX 编辑器的好坏比较； 过多的废话。 你应当如何阅读本文事实上本文在行文过程中，会有相当多的提示帮助你以正确的方式阅读。因此有必要在此先介绍一下最常用的一些标记。 斜体：使用斜体 意味着如果忽略掉这些文字，你可能在逻辑 上很难理解后面某处的知识； 粗体：使用粗体意味如果忽略掉这些文字，你可能在TeX 的概念上很难理解后面某处的知识； 粗斜体：使用粗斜体 基本是最重要的部分，是上述两种情况的合并； 引用：使用引用， 表明这些文字在你第一次阅读本文的时候不需要 了解，其中的内容可能过于深奥，或者过于琐碎。对于第一次接触 TeX 的你（如果你是 TeX 资深使用者当然不在此列），如果了解到这些内容可能会使你困惑，并且不会从实际上增加你对 TeX 的领悟以及对 TeX 的好感。 关于编辑器的简单介绍TeX 的源代码是后缀为 .tex 的纯文本文件。使用任意纯文本编辑器，都可以修改 .tex 文件：包括 Windows 自带的记事本程序，也包括专为 TeX 设计的编辑器（TeXworks, TeXmaker, TeXstudio, WinEdt 等），还包括一些通用的文本编辑器（Sublime Text, Atom, Visual Studio Code 等）。你可以在这些能够编辑纯文本文件的编辑器中任选其一作为你的 TeX 编辑器，也可以使用 TeX 发行自带的编辑器。最流行的两个 TeX 发行（TeX Live 和 MiKTeX）都带有 TeXworks 编辑器。 所谓 TeX 发行，也叫 TeX 发行版、TeX 系统或者 TeX 套装，指的是包括 TeX 系统的各种可执行程序，以及他们执行时需要的一些辅助程序和宏包文档的集合。 本文只介绍 TeXworks 的使用，原因有以下一些： TeXworks 是 TeX Live 自带的编辑器，而 TeX Live 是 TeX User Group 出品的跨平台发行版，各个操作系统都可以使用； 几乎所有 TeX 发行版都带有 TeXworks； TeXworks 十分简洁，除了最基本的功能之外，没有其他复杂的东西，能使你将注意力集中在 TeX 的学习上。 启动 TeXworks启动 TeXworks 很简单，你可以在 Windows 启动对话框中输入 texworks 按回车。具体步骤是： 按下键盘上的 Windows 徽标键，同时按下 R 键 —— &lt;Win&gt; + R; 键入 texworks； 回车。 如果这样打不开 TeXworks，你可能需要从开始菜单找到 TeXworks 图标以启动；或者进入 TeX 系统的安装目录找到 TeXworks。 启动之后，TeXworks 的界面，会默认占据你屏幕的左半边，右半边留空。效果如下图： 图中空白的部分，就是输入编辑文本的编辑框；在编辑框的右下角，显示有三个按钮，最左边的是换行符模式，中间是编码模式，右边标示当前光标所在位置；编辑框的上方是工具栏，工具栏的右半部分使大家熟悉的功能（新建、打开、保存、撤消、恢复、剪切、复制、黏贴、查找、替换），工具栏的左边则是编译按钮 （TeXworks 也称其为「排版工具」）；工具栏在往上，则是菜单栏，此处按下不表。 Windows，Unix 等操作系统对待「换行符」是有不同的。索性 TeXworks 为我们做了足够的提示，方面我们的选择（点击一下那个按钮就知道了）。一般而言，保持默认即可。 字符（包括英文字符和中文字符）在计算机中，经过编码以二进制的形式存储在计算机中。如果编辑器编码和计算机内部编码不一致，则会导致所谓「乱码」的现象。TeXworks 默认使用 UTF8 编码，在我们的文档中不需要进行任何更改，而对于一些其他的文档可能需要按照要求更改编码。 排版工具TeXworks 为我们预设了若干排版工具（pdfTeX, pdfLaTeX, XeTeX, XeLaTeX 等），本文主要用到其中的 XeLaTeX。关于这些排版工具的细节，讲解起来会有些复杂。因此此处按下不表，若有兴趣，可以参看后文。当你对 TeX 系统相当熟悉之后，也可以不使用 TeXworks 预设的工具，自己配置排版工具。 TeXworks 默认的排版工具是 pdfLaTeX。如果你希望更改这个默认值，可以在编辑 - 首选项 - 排版 - 处理工具 - 默认 中修改。 第一篇文档Hello, world!在编辑框中，输入如下内容： helloworld.tex12345\documentclass&#123;article&#125;% 这里是导言区\begin&#123;document&#125;Hello, world!\end&#123;document&#125; 将文档保存在你希望的位置，然后在排版工具的下拉选框中选中 XeLaTeX 后，按下绿色的编译按钮。一会儿，如果没有意外，屏幕的右边就会出现编译之后结果。如下图： 请注意，由于操作系统编码和 TeX 内部实现的限制，在 Windows 平台上，TeX 涉及到的文件（包括 .tex, .jpg 等各类文件）都不要包含中文名字。否则，在编译时可能会因为编码问题导致稀奇古怪的报错。 很容易发现，输入进编辑框的五行文字，在最终输出的 pdf 档中只显示了 1 行。事实上，交付 TeX 处理的文档内容，并不会全部输出。 此处的第一行 \documentclass{article} 中包含了一个控制序列（或称命令/标记）。所谓控制序列，是以反斜杠 \ 开头，以第一个空格或非字母 的字符结束的一串文字。它们不被输出，但是他们会影响输出文档的效果。这里的控制序列是 documentclass，它后面紧跟着的 {article} 代表这个控制序列有一个必要的参数，该参数的值为 article。这个控制序列的作用，是调用名为 article 的文档类。 请注意，TeX 对控制序列的大小写是敏感的。 部分控制序列还有被方括号 [] 包括的可选参数。 所谓文档类，即是 TeX 系统预设的（或是用户自定的）一些格式的集合。不同的文档类在输出效果上会有差别。 此处的第二行以 % 开头。TeX 以百分号 % 作为注释标记。具体来说，TeX 会忽略从 % 开始到当前行末尾的所有内容。这些内容不会被输出，也不影响最终排版效果，只供人类阅读。若要输出 % 字符本身，则需要在 % 之前加上反斜杠 \ 进行转义（escape）。例如： 1今年的净利润为 20\%，比去年高。 此处 % 被当做正常的百分号处理，其后的文字也将被正常输出。 我们继续分析第一篇文档的内容。在注释行之后出现了控制序列 begin。这个控制序列总是与 end 成对出现。这两个控制序列以及他们中间的内容被称为「环境」；它们之后的第一个必要参数总是一致的，被称为环境名。 只有在 document 环境中的内容，才会被正常输出到文档中去或是作为控制序列对文档产生影响。也就是说，在 \end{document} 之后插入任何内容都是无效的。 从 \documentclass{article} 开始到 \begin{document} 之前的部分被称为导言区。你可以将导言区理解为是对整篇文档进行设置的区域——在导言区出现的控制序列，往往会影响整篇文档的格式。 比如，我们通常在导言区设置页面大小、页眉页脚样式、章节标题样式等等。 实现中英文混排 关于 LaTeX 的中文支持，首先要说的是：在现在，一切教你使用 CJK 宏包的模板、人、网页、书，都是糟糕的、有害的、恼人的、邪恶的和应该摒弃的。 成功编译输出第一个文档之后，中国 TeX 用户面临的第二个普遍问题大概就是「实现中英文混排」了。众所周知，TeX 系统是高教授开发的。在 TeX 开发当初并没有考虑到亚洲文字的问题。因此早期的 TeX 系统并不能直接支持中文，必须要用其他工具先处理一下（或者是一些宏包之类的）。但是现在，XeTeX 原生支持 Unicode，并且可以方便地调用系统字体。可以说解决了困扰中国 TeX 使用者多年的大问题。至此，我们只需要使用几个简单的宏包，就能完成中文支持了。 所谓宏包，就是一系列控制序列的合集。这些控制序列太常用，以至于人们会觉得每次将他们写在导言区太过繁琐，于是将他们打包放在同一个文件中，成为所谓的宏包（台湾方面称之为「巨集套件」）。\usepackage{} 可以用来调用宏包。 除去中文支持，中文的版式处理和标点禁则也是不小的挑战。好在由吴凌云和江疆牵头，现在主要由刘海洋、李清和我维护的 CTeX 宏集一次性解决了这些问题。CTeX 宏集的优势在于，它能适配于多种编译方式；在内部处理好了中文和中文版式的支持，隐藏了这些细节；并且，提供了不少中文用户需要的功能接口。我们来看如何使用 CTeX 宏集来处理中英文混排的文档。 请注意，CTeX 宏集和 CTeX 套装是两个不同的东西。CTeX 宏集本质是 LaTeX 宏的集合，包含若干文档类（.cls 文件）和宏包（.sty 文件）。CTeX 套装是一个过时的 TeX 系统。 新版 CTeX 宏集的默认能够自动检测用户的操作系统，并为之配置合适的字库。对于 Windows 用户、Mac OS X 用户和 Linux 用户，都无需做任何配置，就能使用 CTeX 宏集来排版中文。[2015-05-20 更新] 在 TeXworks 编辑框中输入以下内容，以 UTF-8 编码保存，使用 XeLaTeX 编译： EC-mix.tex1234\documentclass[UTF8]&#123;ctexart&#125;\begin&#123;document&#125;你好，world!\end&#123;document&#125; 如果没有意外，你将会看到类似下图的输出结果。 相较于之前的例子，这份代码只有细微的差异： 文档类从 article 变为 ctexart； 增加了文档类选项 UTF8。 你也可以直接使用 xeCJK 宏包来支持中英文混排。不过大多数情况是不推荐这样做的。因此，如果你能抑制住你小小的好奇心，可以暂时略过这一段，回头再看不迟。:) 在 TeXworks 编辑框中输入以下内容，保存，使用 XeLaTeX 编译： xeCJK-demo.tex123456\documentclass&#123;article&#125;\usepackage&#123;xeCJK&#125; %调用 xeCJK 宏包\setCJKmainfont&#123;SimSun&#125; %设置 CJK 主字体为 SimSun （宋体）\begin&#123;document&#125;你好，world!\end&#123;document&#125; 如果一切顺利，你将会在屏幕右边的窗口，看见类似下图的输出结果。 除了 “document” 环境中同时出现了中文和英文，和最原始的 Hello, world! 不同点在于，导言区中多出了两条控制序列。他们的作用我已经用注释标出了。 \setCJKmainfont{·}是定义在 “xeCJK” 宏包中的控制序列，它可以用来设置 CJK 主字体。 如果你的 TeX 系统提示找不到字体，请按以下提示操作。 Mac OS X 用户请参照这篇博客中的方法，使用系统自带的字体册程序来查看系统字体。 非 Mac OS X 用户请按照如下步骤打开系统命令行（*nix系统请打开终端）： 按下&lt;win&gt; + R； 键入cmd, 回车。 在系统命令行中输入如下命令： fc-list :lang=zh-cn &gt; C:\font_zh-cn.txt （相信使用 *nix 的你，一定知道如何修改上述命令达到你想要的效果） 打开 C 盘根目录下的 C:\font_zh-cn.txt 纯文本文档，里面的内容就是你当前系统可用的全部中文字体，形如： 每一个小黑框之间的内容，就对应着一个可用的字体。这些小黑框实际上是换行符，但是由于 Windows 系统的原因，他们没有被正常显示。如果看着不爽，你可以尝试用 TeXworks 打开这个文件查看（放心，能够打开的）。以下是我用 gVim 打开的效果： 其中的每一行，都代表着一个可用的字体。其形式如下： &lt;字体文件路径&gt;: &lt;字体标示名1&gt;, &lt;字体表示名2&gt;:Style=&lt;字体类型&gt; 我们可以看到图中的倒数第四行 C:/WINDOWS/fonts/simsun.ttc: 宋体,SimSun:style=Regular 出现了之前文档里调用的字体SimSun，此处表明该字体有两个表示名：宋体和SimSun，我们在\setCJKmainfont{·}中填入任意一个都有同样的效果。 因此，如果之前的文档无法编译通过，请在你的操作系统字体中，选取一个自己喜欢的，将它的字体表示名填入到\setCJKmainfont{·}中去。 组织你的文章作者、标题、日期保存并用 XeLaTeX 编译如下文档，查看效果： 12345678\documentclass[UTF8]&#123;ctexart&#125;\title&#123;你好，world!&#125;\author&#123;Liam&#125;\date&#123;\today&#125;\begin&#123;document&#125;\maketitle你好，world!\end&#123;document&#125; 导言区复杂了很多，但和之前的文档主要的区别只有一处：定义了标题、作者、日期。 在 document 环境中，除了原本的你好，world!，还多了一个控制序列 maketitle。这个控制序列能将在导言区中定义的标题、作者、日期按照预定的格式展现出来。 使用titling宏包可以修改上述默认格式。参考TeXdoc。 章节和段落保存并用 XeLaTeX 编译如下文档，查看效果： 123456789101112131415161718\documentclass[UTF8]&#123;ctexart&#125;\title&#123;你好，world!&#125;\author&#123;Liam&#125;\date&#123;\today&#125;\begin&#123;document&#125;\maketitle\section&#123;你好中国&#125;中国在East Asia.\subsection&#123;Hello Beijing&#125;北京是capital of China.\subsubsection&#123;Hello Dongcheng District&#125;\paragraph&#123;Tian'anmen Square&#125;is in the center of Beijing\subparagraph&#123;Chairman Mao&#125;is in the center of 天安门广场。\subsection&#123;Hello 山东&#125;\paragraph&#123;山东大学&#125; is one of the best university in 山东。\end&#123;document&#125; 在文档类 article/ctexart 中，定义了五个控制序列来调整行文组织结构。他们分别是 \section{·} \subsection{·} \subsubsection{·} \paragraph{·} \subparagraph{·} 在report/ctexrep中，还有\chapter{·}；在文档类book/ctexbook中，还定义了\part{·}。 插入目录在上一节的文档中，找到 \maketitle，在它的下面插入控制序列 \tableofcontents，保存并用 XeLaTeX 编译两次，观察效果： 12345678910111213141516171819\documentclass[UTF8]&#123;ctexart&#125;\title&#123;你好，world!&#125;\author&#123;Liam&#125;\date&#123;\today&#125;\begin&#123;document&#125;\maketitle\tableofcontents\section&#123;你好中国&#125;中国在East Asia.\subsection&#123;Hello Beijing&#125;北京是capital of China.\subsubsection&#123;Hello Dongcheng District&#125;\paragraph&#123;Tian'anmen Square&#125;is in the center of Beijing\subparagraph&#123;Chairman Mao&#125;is in the center of 天安门广场。\subsection&#123;Hello 山东&#125;\paragraph&#123;山东大学&#125; is one of the best university in 山东。\end&#123;document&#125; 试试交换 \maketitle 和 \tableofcontents 的顺序，看看会发生什么，想想为什么。 请注意，在「你好中国」这一节中，两次「中国在East Asia.」中夹有一个空行，但输出却只有一个换行并没有空行。这是因为 LaTeX 将一个换行当做是一个简单的空格来处理，如果需要换行另起一段，则需要用两个换行（一个空行）来实现。 插入数学公式首先恭喜你看到这里。如果前面的几个文档你都认真编译过了，那么你已经可以胜任许多文档的排版工作。下面我们进入 LaTeX 最为犀利的部分。 这部分的演示中，为了节省篇幅，将取消导言区中中文支持的部分。在实际使用中，你只需要将导言区中的相关部分加上，就可以同时使用中文和编写数学公式了。 为了使用 AMS-LaTeX 提供的数学功能，我们需要在导言区加载 amsmath 宏包： 1\usepackage&#123;amsmath&#125; 数学模式LaTeX 的数学模式有两种：行内模式 (inline) 和行间模式 (display)。前者在正文的行文中，插入数学公式；后者独立排列单独成行，并自动居中。 在行文中，使用 $ ... $ 可以插入行内公式，使用 \[ ... \] 可以插入行间公式，如果需要对行间公式进行编号，则可以使用 equation 环境： 123\begin&#123;equation&#125;...\end&#123;equation&#125; 行内公式也可以使用 \(...\) 或者 \begin{math} ... \end{math} 来插入，但略显麻烦。无编号的行间公式也可以使用 \begin{displaymath} ... \end{displaymath} 或者 \begin{equation*} ... \end{equation*} 来插入，但略显麻烦。（equation* 中的 * 表示环境不编号）也有 plainTeX 风格的 $$ ... $$ 来插入不编号的行间公式。但是在 LaTeX 中这样做会改变行文的默认行间距，不推荐。请参考我的回答。 上下标示例代码（请保存后，使用 XeLaTeX 编译，查看效果）： 1234567891011\documentclass&#123;article&#125;\usepackage&#123;amsmath&#125;\begin&#123;document&#125;Einstein 's $E=mc^2$.\[ E=mc^2. \]\begin&#123;equation&#125;E=mc^2.\end&#123;equation&#125;\end&#123;document&#125; 在这里提一下关于公式标点使用的规范。行内公式和行间公式对标点的要求是不同的：行内公式的标点，应该放在数学模式的限定符之外，而行间公式则应该放在数学模式限定符之内。 在数学模式中，需要表示上标，可以使用 ^ 来实现（下标则是 _）。它默认只作用于之后的一个字符，如果想对连续的几个字符起作用，请将这些字符用花括号 {} 括起来，例如： 1\[ z = r\cdot e^&#123;2\pi i&#125;. \] 根式与分式根式用 \sqrt{·} 来表示，分式用 \frac{·}{·} 来表示（第一个参数为分子，第二个为分母）。 示例代码（请保存后，使用 XeLaTeX 编译，查看效果）： 123456789\documentclass&#123;article&#125;\usepackage&#123;amsmath&#125;\begin&#123;document&#125;$\sqrt&#123;x&#125;$, $\frac&#123;1&#125;&#123;2&#125;$.\[ \sqrt&#123;x&#125;, \]\[ \frac&#123;1&#125;&#123;2&#125;. \]\end&#123;document&#125; 可以发现，在行间公式和行内公式中，分式的输出效果是有差异的。如果要强制行内模式的分式显示为行间模式的大小，可以使用 \dfrac, 反之可以使用 \tfrac。 在行内写分式，你可能会喜欢 xfrac 宏包提供的 \sfrac 命令的效果。 排版繁分式，你应该使用 \cfrac 命令。 运算符一些小的运算符，可以在数学模式下直接输入；另一些需要用控制序列生成，如 12\[ \pm\; \times \; \div\; \cdot\; \cap\; \cup\;\geq\; \leq\; \neq\; \approx \; \equiv \] 连加、连乘、极限、积分等大型运算符分别用 \sum, \prod, \lim, \int 生成。他们的上下标在行内公式中被压缩，以适应行高。我们可以用 \limits 和 \nolimits 来强制显式地指定是否压缩这些上下标。例如： 1234$ \sum_&#123;i=1&#125;^n i\quad \prod_&#123;i=1&#125;^n $$ \sum\limits _&#123;i=1&#125;^n i\quad \prod\limits _&#123;i=1&#125;^n $\[ \lim_&#123;x\to0&#125;x^2 \quad \int_a^b x^2 dx \]\[ \lim\nolimits _&#123;x\to0&#125;x^2\quad \int\nolimits_a^b x^2 dx \] 多重积分可以使用 \iint, \iiint, \iiiint, \idotsint 等命令输入。 1\[ \iint\quad \iiint\quad \iiiint\quad \idotsint \] 定界符（括号等）各种括号用 (), [], \{\}, \langle\rangle 等命令表示；注意花括号通常用来输入命令和环境的参数，所以在数学公式中它们前面要加 \。因为 LaTeX 中 | 和 \| 的应用过于随意，amsmath 宏包推荐用 \lvert\rvert 和 \lVert\rVert 取而代之。 为了调整这些定界符的大小，amsmath 宏包推荐使用 \big, \Big, \bigg, \Bigg 等一系列命令放在上述括号前面调整大小。 有时你可能会觉得 amsmath 宏包提供的定界符放大命令不太够用。通常这意味着你的公式太过复杂。此时你应当首先考虑将公式中的部分提出去，以字母符号代替以简化公式。如果你真的想要排版如此复杂的公式，你可以参考我这篇博文。 123456789\[ \Biggl(\biggl(\Bigl(\bigl((x)\bigr)\Bigr)\biggr)\Biggr) \]\[ \Biggl[\biggl[\Bigl[\bigl[[x]\bigr]\Bigr]\biggr]\Biggr] \]\[ \Biggl \&#123;\biggl \&#123;\Bigl \&#123;\bigl \&#123;\&#123;x\&#125;\bigr \&#125;\Bigr \&#125;\biggr \&#125;\Biggr\&#125; \]\[ \Biggl\langle\biggl\langle\Bigl\langle\bigl\langle\langle x\rangle\bigr\rangle\Bigr\rangle\biggr\rangle\Biggr\rangle \]\[ \Biggl\lvert\biggl\lvert\Bigl\lvert\bigl\lvert\lvert x\rvert\bigr\rvert\Bigr\rvert\biggr\rvert\Biggr\rvert \]\[ \Biggl\lVert\biggl\lVert\Bigl\lVert\bigl\lVert\lVert x\rVert\bigr\rVert\Bigr\rVert\biggr\rVert\Biggr\rVert \] 省略号省略号用 \dots, \cdots, \vdots, \ddots 等命令表示。\dots 和 \cdots 的纵向位置不同，前者一般用于有下标的序列。 12\[ x_1,x_2,\dots ,x_n\quad 1,2,\cdots ,n\quad\vdots\quad \ddots \] 矩阵amsmath 的 pmatrix, bmatrix, Bmatrix, vmatrix, Vmatrix 等环境可以在矩阵两边加上各种分隔符。 12345\[ \begin&#123;pmatrix&#125; a&amp;b\\c&amp;d \end&#123;pmatrix&#125; \quad\begin&#123;bmatrix&#125; a&amp;b\\c&amp;d \end&#123;bmatrix&#125; \quad\begin&#123;Bmatrix&#125; a&amp;b\\c&amp;d \end&#123;Bmatrix&#125; \quad\begin&#123;vmatrix&#125; a&amp;b\\c&amp;d \end&#123;vmatrix&#125; \quad\begin&#123;Vmatrix&#125; a&amp;b\\c&amp;d \end&#123;Vmatrix&#125; \] 效果图： 使用 smallmatrix 环境，可以生成行内公式的小矩阵。 1Marry has a little matrix $ ( \begin&#123;smallmatrix&#125; a&amp;b\\c&amp;d \end&#123;smallmatrix&#125; ) $. 效果图： 多行公式有的公式特别长，我们需要手动为他们换行；有几个公式是一组，我们需要将他们放在一起；还有些类似分段函数，我们需要给它加上一个左边的花括号。 长公式不对齐无须对齐的长公式可以使用 multline 环境。 1234\begin&#123;multline&#125;x = a+b+c+&#123;&#125; \\d+e+f+g\end&#123;multline&#125; 效果： 如果不需要编号，可以使用 multline* 环境代替。 对齐需要对齐的公式，可以使用 aligned 次环境来实现，它必须包含在数学环境之内。 1234\[\begin&#123;aligned&#125;x =&#123;&#125;&amp; a+b+c+&#123;&#125; \\&amp;d+e+f+g\end&#123;aligned&#125;\] 效果图： 公式组无需对齐的公式组可以使用 gather 环境，需要对齐的公式组可以使用 align 环境。他们都带有编号，如果不需要编号可以使用带星花的版本。 12345678\begin&#123;gather&#125;a = b+c+d \\x = y+z\end&#123;gather&#125;\begin&#123;align&#125;a &amp;= b+c+d \\x &amp;= y+z\end&#123;align&#125; 效果： 请注意，不要使用 eqnarray 环境。原因可以参考： eqnarray 是糟糕的 eqnarray 是有害的 eqnarray 是恼人的 eqnarray 是邪恶的 分段函数分段函数可以用cases次环境来实现，它必须包含在数学环境之内。 1234\[ y= \begin&#123;cases&#125;-x,\quad x\leq 0 \\x,\quad x&gt;0\end&#123;cases&#125; \] 效果图： 插入图片和表格图片关于 LaTeX 插图，首先要说的是：「LaTeX 只支持 .eps 格式的图档」这个说法是错误的。 在 LaTeX 中插入图片，有很多种方式。最好用的应当属利用 graphicx 宏包提供的 \includegraphics 命令。比如你在你的 TeX 源文件同目录下，有名为 a.jpg 的图片，你可以用这样的方式将它插入到输出文档中： 12345\documentclass&#123;article&#125;\usepackage&#123;graphicx&#125;\begin&#123;document&#125;\includegraphics&#123;a.jpg&#125;\end&#123;document&#125; 图片可能很大，超过了输出文件的纸张大小，或者干脆就是你自己觉得输出的效果不爽。这时候你可以用 \includegraphics 控制序列的可选参数来控制。比如 1\includegraphics[width = .8\textwidth]&#123;a.jpg&#125; 这样图片的宽度会被缩放至页面宽度的百分之八十，图片的总高度会按比例缩放。 \includegraphics 控制序列还有若干其他的可选参数可供使用，一般并用不到。感兴趣的话，可以去查看该宏包的文档。 表格tabular 环境提供了最简单的表格功能。它用 \hline 命令表示横线，在列格式中用 | 表示竖线；用 &amp; 来分列，用 \\ 来换行；每列可以采用居左、居中、居右等横向对齐方式，分别用 l、c、r 来表示。 12345678910111213\begin&#123;tabular&#125;&#123;|l|c|r|&#125; \hline操作系统&amp; 发行版&amp; 编辑器\\ \hlineWindows &amp; MikTeX &amp; TexMakerX \\ \hlineUnix/Linux &amp; teTeX &amp; Kile \\ \hlineMac OS &amp; MacTeX &amp; TeXShop \\ \hline通用&amp; TeX Live &amp; TeXworks \\ \hline\end&#123;tabular&#125; 效果： 浮动体插图和表格通常需要占据大块空间，所以在文字处理软件中我们经常需要调整他们的位置。figure 和 table 环境可以自动完成这样的任务；这种自动调整位置的环境称作浮动体(float)。我们以 figure 为例。 123456\begin&#123;figure&#125;[htbp]\centering\includegraphics&#123;a.jpg&#125;\caption&#123;有图有真相&#125;\label&#123;fig:myphoto&#125;\end&#123;figure&#125; htbp 选项用来指定插图的理想位置，这几个字母分别代表 here, top, bottom, float page，也就是就这里、页顶、页尾、浮动页（专门放浮动体的单独页面或分栏）。\centering 用来使插图居中；\caption 命令设置插图标题，LaTeX 会自动给浮动体的标题加上编号。注意 \label 应该放在标题命令之后。 图片和表格的各种特殊效果，限于篇幅此处无法详叙。请查看最后一章推荐的文档。 如果你想了解 LaTeX 的浮动体策略算法细节，你可以参考我博客中关于浮动体的系列文章 如果你困惑于「为什么图表会乱跑」或者「怎样让图表不乱跑」，请看我的回答。 版面设置页边距设置页边距，推荐使用 geometry 宏包。可以在这里查看它的说明文档。 比如我希望，将纸张的长度设置为 20cm、宽度设置为 15cm、左边距 1cm、右边距 2cm、上边距 3cm、下边距 4cm，可以在导言区加上这样几行： 123\usepackage&#123;geometry&#125;\geometry&#123;papersize=&#123;20cm,15cm&#125;&#125;\geometry&#123;left=1cm,right=2cm,top=3cm,bottom=4cm&#125; 页眉页脚设置页眉页脚，推荐使用 fancyhdr 宏包。可以在这里查看它的说明文档。 比如我希望，在页眉左边写上我的名字，中间写上今天的日期，右边写上我的电话；页脚的正中写上页码；页眉和正文之间有一道宽为 0.4pt 的横线分割，可以在导言区加上如下几行： 1234567891011\usepackage&#123;fancyhdr&#125;\pagestyle&#123;fancy&#125;\lhead&#123;\author&#125;\chead&#123;\date&#125;\rhead&#123;152xxxxxxxx&#125;\lfoot&#123;&#125;\cfoot&#123;\thepage&#125;\rfoot&#123;&#125;\renewcommand&#123;\headrulewidth&#125;&#123;0.4pt&#125;\renewcommand&#123;\headwidth&#125;&#123;\textwidth&#125;\renewcommand&#123;\footrulewidth&#125;&#123;0pt&#125; 首行缩进CTeX 宏集已经处理好了首行缩进的问题（自然段前空两格汉字宽度）。因此，使用 CTeX 宏集进行中西文混合排版时，我们不需要关注首行缩进的问题。 如果你因为某些原因选择不适用 CTeX 宏集（不推荐）进行中文支持和版式设置，则你需要做额外的一些工作。 调用 indentfirst 宏包。具体来说，中文习惯于每个自然段的段首都空出两个中文汉字的长度作为首行缩进，但西文行文习惯于不在逻辑节（\section 等）之后缩进。使用改宏包可使 LaTeX 在每个自然段都首行缩进。 设置首行缩进长度 \setlength{\parindent}{2\ccwd}。其中 \ccwd 是 xeCJK 定义的宏，它表示当前字号中一个中文汉字的宽度。 行间距我们可以通过 setspace 宏包提供的命令来调整行间距。比如在导言区添加如下内容，可以将行距设置为字号的 1.5 倍： 12\usepackage&#123;setspace&#125;\onehalfspacing 具体可以查看该宏包的文档。 请注意用词的差别： 行距是字号的 1.5 倍； 1.5 倍行距。 事实上，这不是设置 1.5 倍行距的正确方法，请参考这篇博文。另外，RuixiZhang 开发了 zhlineskip 宏包，提供了对中西文混排更细致的行距控制能力。 段间距我们可以通过修改长度 \parskip 的值来调整段间距。例如在导言区添加以下内容 1\addtolength&#123;\parskip&#125;&#123;.4em&#125; 则可以在原有的基础上，增加段间距 0.4em。如果需要减小段间距，只需将该数值改为负值即可。 TeX 家族恭喜你终于看到了这里。如果你认真完成了上面所有的练习，并琢磨了其中的意义，相信你已经可以用 LaTeX 排版出漂亮的文档了。现在我们说一点历史，帮助你更好地理解 TeX 这个系统。 带有 TeX 的词，仅仅是本文就已经提到了 TeX, LaTeX, XeLaTeX。通常中国学生面对不了解意思的一群形近单词，都会有一种「本能的恐惧」（笑~）。因此，「大神们」在为新手介绍 TeX 的时候，如果互相争论 「XXTeX 比 YYTeX 好」或者是「XXTeX 的 YYTeX 如何如何」，往往会蹦出下面这些带有 TeX 的词汇：TeX, pdfTeX, XeTeX, LuaTeX, LaTeX, pdfLaTeX, XeLaTeX … 事实上，这部分的内容太过复杂，我自己的了解也实在有限。所以下面这部分的内容也只能是对我了解到的知识的一个概括，甚至可能有些许谬误。所以大家只需要将这部分的内容当做是一个参考就可以了。 TeX - LaTeXTeX 是高德纳（Donald Ervin Knuth，1938年1月10日 –）教授愤世嫉俗追求完美做出来的排版引擎，同时也是该引擎使用的标记语言（Markup Language）的名称。这里所谓的引擎，是指能够实现断行、分页等操作的程序（请注意这并不是定义）；这里的标记语言，是指一种将控制命令和文本结合起来的格式，它的主体是其中的文本而控制命令则实现一些特殊效果（同样请注意这并不是定义）。 你可以在这里找到关于 TeX 引擎的具体描述； 你可以在这里找到关于标记语言的具体描述。 而 LaTeX 则是 L. Lamport （1941年2月7日 – ） 教授开发的基于 TeX 的排版系统。实际上 LaTeX 利用 TeX 的控制命令，定义了许多新的控制命令并封装成一个可执行文件。这个可执行文件会去解释 LaTeX 新定义的命令成为 TeX 的控制命令，并最终交由 TeX 引擎进行排版。 实际上，LaTeX 是基于一个叫做 plain TeX 的格式的。plain TeX 是高德纳教授为了方便用户，自己基于原始的 TeX 定义的格式，但实际上 plain TeX 的命令仍然十分晦涩。至于原始的 TeX 直接使用的人就更少了，因此 plain TeX 格式逐渐就成为了 TeX 格式的同义词，尽管他们事实上是不同的。 因此在 TeX - LaTeX 组合中， 最终进行断行、分页等操作的，是 TeX 引擎； LaTeX 实际上是一个工具，它将用户按照它的格式编写的文档解释成 TeX 引擎能理解的形式并交付给 TeX 引擎处理，再将最终结果返回给用户。 pdfTeX - pdfLaTeXTeX 系统生成的文件是 dvi 格式，虽然可以用其他程序将其转换为例如 pdf 等更为常见的格式，但是毕竟不方便。 dvi 格式是为了排版而产生的，它本身并不支持所谓的「交叉引用」，pdfTeX 直接输出 pdf 格式的文档，这也是 pdfTeX 相对 TeX 进步（易用性方面）的地方。 为了解决这个问题，Hàn Thế Thành 博士在他的博士论文中提出了 pdfTeX 这个对 TeX 引擎的扩展。二者最主要的差别就是 pdfTeX 直接输出 pdf 格式文档，而 TeX 引擎则输出 dvi 格式的文档。 pdfTeX 的信息可以查看wiki. pdfLaTeX 这个程序的主要工作依旧是将 LaTeX 格式的文档进行解释，不过此次是将解释之后的结果交付给 pdfTeX 引擎处理。 XeTeX - XeLaTeX高德纳教授在实现 TeX 的当初并没有考虑到中日韩等字符的处理，而只支持 ASCII 字符。这并不是说中日韩字符就无法使用 TeX 引擎排版了，事实上 TeX 将每个字符用一个框包括起来（这被称为盒子）然后将一个个的盒子按照一定规则排列起来，因而 TeX 的算法理论上适用于任何字符。ASCII 字符简单理解，就是在半角模式下你的键盘能直接输出的字符。 在 XeTeX 出现之前，为了能让 TeX 系统排版中文，国人曾使用了 天元、CCT、CJK 等手段处理中文。其中 天元和CCT 现在已经基本不用，CJK 因为使用时间长且效果相对较好，现在还有人使用。 不同于 CJK 等方式使用 TeX 和 pdfTeX 这两个不直接支持 Unicode 字符的引擎，XeTeX 引擎直接支持 Unicode 字符。也就是说现在不使用 CJK 也能排版中日韩文的文档了，并且这种方式要比之前的方式更加优秀。 XeLaTeX 和 XeTeX 的关系与 pdfLaTeX 和 pdfTeX 的关系类似，这里不再赘述。 使用 XeTeX 引擎需要使用 UTF-8 编码。 所谓编码就是字符在计算机储存时候的对应关系。例如，假设有一种编码，将汉字「你」对应为数字「1」；「好」对应为数字「2」，则含有「你好」的纯文本文件，在计算机中储存为「12」（读取文件的时候，将「12」再转换为「你好」显示在屏幕上或打印出来）。 UTF-8 编码是 Unicode 编码的一种，可以参考它的 wiki. LuaTeXLuaTeX 是正在开发完善的一个 TeX 引擎，相对它的前辈们还相当的不完善，这里不赘述。 CTeX - MiKTeX - TeX Live之前介绍了 TeX, LaTeX, pdfTeX, pdfLaTeX, XeTeX, XeLaTeX, LuaTeX 等，他们都是 TeX 家族的一部分。但是作为一个能够使用的 TeX 系统，仅仅有他们还是不够的。CTeX, MiKTeX, TeX Live 都是被称为「发行」的软件合集。他们包括了上述各种引擎的可执行程序，以及一些文档类、模板、字体文件、辅助程序等等。其中 CTeX 是建立在 MiKTeX 的基础之上的。 总结TeX - pdfTeX - XeTeX - LuaTeX 都是排版引擎，按照先进程度递增（LuaTeX 尚未完善）。 LaTeX 是一种格式，基于 TeX 格式定义了很多更方便使用的控制命令。上述四个引擎都有对应的程序将 LaTeX 格式解释成引擎能处理的内容。 CTeX, MiKTeX, TeX Live 都是 TeX 的发行，他们是许许多多东西的集合。 出现问题应当如何处理/怎样聪明地提出你的问题——怎样从这里毕业这篇文章原来的名字叫做慢慢爱上 LaTeX，后来行文的过程中发觉 LaTeX 实在是有太多的内容可以讲述，越发地没有把握让大家仅仅通过这一篇短小的文章就喜欢上 LaTeX，于是改成了现在这个名字。 限于篇幅，还有我的精力，这篇文章事实上还有许多的问题没有讲明白。它仅仅是提供了一些，在你学习使用 LaTeX 可能遇到的问题的解决方案，并不完全，而且没有教会你如何处理编译过程中可能遇到的形形色色的错误。所以这最终只能是一篇小文，而不可能成为一篇正式的文档。 因此，如果通过我这篇小文，体验到了 LaTeX 带给你的一些乐趣，有了对 LaTeX 的兴趣（如果是这样，我就已经能够无比开心了~），请务必去阅读一些正式的 LaTeX 文档。 去读文档关于 LaTeX 的文档有很多，其中有些内容过时地很快。所以有必要告诉大家，哪些文档应该看，那些文档不应该看。索性，这个问题，刘海洋(milksea)前辈已经叙述得很清楚了。前段时间，我和几个朋友，将现在看起来还未过时的文档打包上传到了我的博客。参考：ZIP 归档。 遇到问题怎么办 绝对的新手，先读完一本入门读物，了解基本的知识； 无论如何，先读文档！绝大部分问题都是文档可以解决的； 利用 Google 搜索你的问题； 在各个论坛或者 LaTeX 交流群里聪明地提出你的问题。 参考：https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md CTeX 论坛提问版：https://github.com/CTeX-org/forum/issues 提供一个 Telegram 交流群：https://t.me/chinesetex 提供一个 QQ 交流群：141877998]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Introduction</tag>
        <tag>ctex</tag>
        <tag>TeXworks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Windows 下批量将位图转为 EPS 格式的图档]]></title>
    <url>%2F2014%2F08%2F21%2Fbitmap-convert-to-eps-batch%2F</url>
    <content type="text"><![CDATA[虽然「LaTeX 只能识别 EPS 格式的图档」是多年的误传，但是仍有许多杂志和期刊只接受 EPS 格式的图档。所以，尽管在日常使用中，我们很少会用到 EPS 格式，但是有时候不得不用。 今天帮朋友排版论文的时候，就又遇到了这样无节操的期刊。没办法，转呗。结果一看傻眼了，一共五六十个图片，手工得弄到猴年马月……于是动了动脑，写了个批处理搞定。 在现在的 TeX 发行版中，一般都带有一个 bmeps 的小程序，它能将 png, jpg 和 bmp 等格式的位图转换成 EPS 格式的图档。我们用它来处理图片是最好不过了，以 png 格式为例，批处理命令如下 12345for /f %%i in (&apos;dir /b *.png&apos;) do ( @echo %%i bmeps -c %%i %%~ni.eps @echo Finished ) 这里用到了 for 循环，在当前目录下遍历所有后缀为 png 的文件，然后对当前文件依次执行 bmeps 命令。 我写了一个完整的批处理文件，可以在这里下载，置于位图所在的目录，双击运行即可。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Bitmap</tag>
        <tag>EPS</tag>
        <tag>Windows Batch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《失明症漫记》读后感]]></title>
    <url>%2F2014%2F08%2F20%2Fbook-review-blindness%2F</url>
    <content type="text"><![CDATA[《失明症漫记》（又名《盲流感》）是诺贝尔文学奖获得者，葡萄牙作家萨拉马戈的作品，中文翻译版本由范维信先生译著。 整本书都在尝试营造一种压抑的气氛，哪怕是最后看起来是大团圆的结局也是如此，而压抑的气氛中四处弥漫着隐喻。 小说篇幅中等，中译本能有两百多页。但是，作者以一种奇怪的方式来行文——书中出现的所有角色，包括动物，都没有明确的名称。我认为这样的手法是有意义的。其一，「偷车贼」、「戴墨镜的女人」这些称呼过于随意，读者可以在生活中简单地遇到，这种简单的指代予读者以代入感。其二，不赋姓名的未知感和不安全感，与书中所提及的「白色失明症」特征一致，相辅相成。其三，在探讨人性的时候，以不明确地指代，泛指某一类人，如王穆荣所说，这就像「面向对象编程中的类名，在这里不需要实例化」。 剧透，慎。 小说以指代的方式来行文，必然的一个结果就是其剧情不会复杂。事实上，其剧情和典型的「灾难大片」类似：未知的疾病突然出现，政府紧张民众恐慌将病患隔离，疫情不受控制地爆发同时隔离区内沦丧的人类尊严和道德约束勾出人性中恶的一面，最终全国沦陷一群人重获新生。 然而，这不是一部大团圆的作品，而是一部残酷的作品。 第一个失明者感受到人情温暖，被人送回家中；陪护者因为对方失明无惧暴露而大胆盗车。 政府隔离失明者的根本动机不是治愈疾病，而是为了「避免麻烦」；隔离区内定期响起的冠冕堂皇的「训令」无疑是对此的讽刺。 隔离区内的人们因为失明而无所顾忌，人性恶的一面完全爆发出来；贪婪、淫欲、麻木、虚伪和自私充斥着整个隔离区。 逃出隔离区，等待盲人们的却不是美好的世界，整个国家变得不再熟悉：基础设施瘫痪、卫生条件极差；所有人已无有人形，以兽的方式苟活于世。 如果仅止于此，那么这部小说不配称为世界级的小说。 小说的最后，也是点睛之笔在于，当所有人的失明症逐渐消失能够看清世界的时候，作为失明症期间唯一一个看得见的人，医生的妻子抬头看见蓝天白云，恍惚以为失明症终于找上了自己。这是想说明医生的妻子害怕失明吗？我想不是的。如果她会害怕失明，那她就不会在隔离区内不断给大家以勇气；如果她害怕失明，那她就不会在隔离区内奋起杀掉荒淫的统治者；如果她害怕失明，她就不会在满目疮痍的城市里四处奔波，为伙伴们寻找食物。然而她终究是害怕的。她害怕在隔离区里大家失去生的勇气；她害怕隔离区里的统治者将所有人变得麻木而不再为人；她害怕伙伴们死去留下她一个人孤苦伶仃。 那么她究竟害怕什么？我认为，作为唯一一个看遍整个事件体现出的人性所有的恶的她，害怕经过恶的洗礼的城市无法在闪烁人性的光辉！ 这绝不是一个大团圆的结局，只有神经衰弱者，才需要大团圆。]]></content>
      <categories>
        <category>Literature and Social Sciences</category>
      </categories>
      <tags>
        <tag>Book review</tag>
        <tag>Blindness</tag>
        <tag>Humanity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[禁止 Kindle Paperwhite2 在连接 WiFi 的情况下静默升级]]></title>
    <url>%2F2014%2F08%2F17%2Fkindle-paperwhite2-stop-slient-updating%2F</url>
    <content type="text"><![CDATA[又是关于 Kindle 的文章呢，不过心情和上一篇可谓截然相反。嘛，生活还要继续，不想了。 Kindle 的原生系统实在是欠调教，想要用得顺手不得不自己安装插件。若是如此也就罢了，恼人的是，Amazon 会在 Kindle 链接 WiFi 的情况下为 Kindle 推送更新，而这些不经过用户同意静默安装的升级，会使得不少插件失效。这样一来，每次升级就得重新安装优化不少插件，着实浪费时间，于是禁止静默升级变得十分有必要。 BackDoorLock 介绍BackDoorLock 是 mobileread 论坛 上的 dsmid 前辈制作的插件，其作用只有一个：禁止 Amazon 在不经用户同意的情况下静默升级 Kindle 的固件。 BackDoorLock 并不会阻止 Kindle 从 Amazon 上取得升级所需的安装文件，它会在 Kindle 尝试安装升级的时候打断这个过程。这样设计是有意义的，因为如果阻止 Kindle 下载升级文件，则 Kindle 在联网的情况下会不断尝试下载，从而造成耗电量剧增，并最终影响电池寿命。 BackDoorLock 的安装首先保证你的 Kindle PW2 已经越狱（参考这篇文章中关于越狱的部分）。dsmid 提供了两种方法安装 BackDoorLock。其一是下载 .bin 文件，放在 Kindle 根目录，使用「更新您的 Kindle」的方式安装。其二是先安装 KUAL (Kindle Unified Application Launcher) 安装，然后以查件的方式运行。这里推荐使用第二种方法。 安装 MKKKUAL 需要 MKK (Mobileread Kindlet Kit) 的支持，所以先安装 MKK。 到这里下载 MKK 的安装包。 使用 USB 数据线将 Kindle 与计算机连接。 ZIP 归档中有名为 Update_mkk-20140214-k5-ALL_install.bin 的文件，将其解压到 Kindle 根目录。 断开 Kindle 与计算机的 USB 连接。 依次进行如下操作 主页按钮（[Home]） 菜单按钮（[Menu]） 设置选项（Settings） 菜单按钮（[Menu]） 更新您的 Kindle（Update Your Kindle） 安装 KUAL 到这里下载 KUAL 的安装包。 使用 USB 数据线将 Kindle 与计算机连接。 ZIP 归档中有名为 KUAL-KDK-2.0.azw2 的文件，将其解压到 Kindle 的 documents 目录。 安装 BackDoorLock 到这里下载 MKK 的安装包。 使用 USB 数据线将 Kindle 与计算机连接。 ZIP 归档中有名为 backdoorlock 的目录，将其完整地解压到 Kindle 的 extensions 目录（若不存在则新建）。 启用 BackDoorLock将 Kindle 从电脑中退出后，在 Kindle 首页能看到如下图所示的图标，标有「Kindle Launcher」的就是 KUAL 启动图标了。 点击 KUAL 图标，进入 KUAL 界面。 点击 BackDoorLock，打开 BackDoorLock。 这里 Lock the back door 是禁用静默升级， Unlock the back door 是启用静默升级， Lock state 是查看 BackDoorLock 的工作状态， Delete update file(s) 是删除升级文件，以腾出空间， Move update file(s) 则是移动升级文件。]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Kindle</tag>
        <tag>BackDoorLock</tag>
        <tag>KUAL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步加载多说评论框以加快页面访问速度]]></title>
    <url>%2F2014%2F07%2F22%2Fduoshuo-delay%2F</url>
    <content type="text"><![CDATA[多说评论框可以让静态博客实现评论功能，对于搭在 GitHub Pages 上的博客来说是非常好用的功能。美中不足的是，多说评论框的加载速度有些慢；默认情况下，多说评论框总是随页面一起加载，拖慢了整个页面的加载速度。 本希望用自动异步加载的方式，在页面加载完成之后，再加载多说评论框。奈何多说没有提供所需的 API。于是只能退而求其次，采用手动的方法。 多说在其官博提出了一种异步加载的方式。经测试，这个方法可用——只需要点击按钮，多说评论框就会弹出来。但是，官博提供的方法只能弹出，不能缩回，有些恼人。于是自己写了几行代码，解决了这个问题。 详细步骤首先，我们需要加载多说的 embed.js 基础代码，并设置 duoshuoQuery。多说官博希望我们把这段代码放在网页的 head 中，我不推荐这样做。因为我们使用异步加载的原因，就是希望提高速度，而如果将多说的代码放在 head 中，又拖慢了速度。所以我们将代码放在多说评论框加载之前就可以了。 12&lt;script&gt;var duoshuoQuery = &#123;short_name:"你的多说二级域名"&#125;;&lt;/script&gt;&lt;script src="http://static.duoshuo.com/embed.js"&gt;&lt;/script&gt; 多说二级域名是指你注册多说时，填写的 abc.duoshuo.com 中的 abc 部分。 紧接其后之后，我们要写入 JavaScript 函数，实现多说评论框的缩放功能。 12345678910111213&lt;script type="text/javascript"&gt;function toggleDuoshuoComments(container, id, url)&#123; if(jQuery(container).has("div").length&gt;0)&#123; jQuery(container).empty(); return; &#125; var el = document.createElement('div'); el.setAttribute('data-thread-key', id); el.setAttribute('data-url', url); DUOSHUO.EmbedThread(el); jQuery(container).append(el);&#125;&lt;/script&gt; 在需要插入按钮的地方，我们建立一个 click 事件。 1&lt;a href="javascript:void(0);" onclick="toggleDuoshuoComments('#comment-box', &lt;%= item.title %&gt;, &lt;%- config.url %&gt;&lt;%- config.root %&gt;&lt;%- item.path %&gt;);"&gt;查看评论&lt;/a&gt; 其中 &lt;%= item.title %&gt; 和 &lt;%- config.url %&gt;&lt;%- config.root %&gt;&lt;%- item.path %&gt; 是 hexo 的语法。 最后，在需要弹出评论框的地方，插入一个 div 标签。 1&lt;div id="comment-box" &gt;&lt;/div&gt; 这样就大功告成啦！]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Duoshuo</tag>
        <tag>Async Loading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语语法之二：名词短语]]></title>
    <url>%2F2014%2F06%2F22%2Fnoun-phrase-and-articles%2F</url>
    <content type="text"><![CDATA[语法是语言的规范，制定语法的目的是为了让表达清晰、意思完整、不致有歧义。人类活动中的情形千差万别，为了表达清晰等目的，会形成许多特例。因此如果尝试通过列举语法现象及特例来描述语法，可想见是非常繁琐的，并且这种行为有舍本逐末之嫌。 在看过旋元佑先生写的《语法俱乐部》之后，我更坚定了这个想法，并尝试将自己对该书的理解结合自己的经验和思考写出来，成为一个系列。 这是这个系列的第二篇，主要讨论名词短语以及冠词的使用。 名词短语的基本形态名词短语可以充当句子中的主语、宾语、补语等成分，出现的频率相当高。同时，在名词短语中充当限定词的冠词涉及到许多规则，也是容易弄错的地方。涉及到名词短语的语法规则有很多，特例也有很多。基本属于「有二十条规则，又有二十条特例」的情况，令人烦不胜烦。但其实，在表达清晰、意思完整、无有歧义的要求下，这些规则并不需要死记硬背，借由客观地讨论就能形成完整的体系。 完整的名词短语由三个部分组成：限定词、修饰词、名词。比如（下划线部分是限定词，加粗部分是修饰词）： a new book. many good students. his beautiful wife. the bast answer. those sweet roses. 名词短语的三个部分并非每一次都要同时出现，在特定场合下，这三个部分都有可能省略。 修饰词可能是名词短语中最不重要的部分，如果不需要描述名词的状态特征则完全可以省略。比如「a book」同样是正确的名词短语。如果说话人确信听众知道自己在讨论什么东西，则名词也可以省略。比如「Of those answers, this one is the best.」，这里的「the best」指得就是「the best answer」。在面对面交流的时候，修饰词和名词有时甚至可以一起省略。假设你在花店，用手指向一捧玫瑰花，对花店老板说「I want those.」的话，花店老板很清楚你想要什么。 限定词任何事物出现都是有原因的，那么英语里为什么要有限定词呢？限定词作为名词短语的一部分存在，而名词短语的主体是名词。所以在讨论限定词之前，有必要讨论一下名词。 名词的分类从名词指代的对象来说，名词可以分为「抽象名词」和「普通名词」。抽象名词指代的对象看不见摸不着，通常表示方式方法、状态品质等概念。普通名词则相反，它们指代的对象看得见摸得着，是实际存在的事物。 从名词是否可以计数的方面，名词可以分为「可数名词」和「不可数名词」。可数名词指代的对象通常具有固定的形体，因此可以计数。不可数名词则正好相反，它们指代的对象通常无有固定形体，因此你没法拿起其中的「一个」，对朋友说「嘿，这是一个XX，你手边上也有一个」。 从名词指代的对象的状态来说，名词可以分成「专有名词」和「非专有名词」。所谓专有名词，就是名词指代的对象，天上地下独一份，没有第二个。而非专有名词则正好相反，它们指代的对象都不止存在一个。 抽象名词指代的对象显然不具有固定的形体或者明确的界限，因此抽象名词都是不可数名词。反过来，它的逆否命题显然成立，可数名词都是普通名词。 名词是否专有，是在可数名词的范围之内进行讨论的。因为如果名词不可数，也就无从定义「只有一个」，从而讨论是否专有就没有意义了。此外，名词是否专有，有时也要依情况而定。比如，医院都有院长，在医院内部讨论的时候，院长是唯一的，此时可以看做是专有名词；而在医院之间讨论，或者横向比较的时候，院长就不唯一了，此时是非专有名词。 对名词做这样的分类是有意义的。如果一个名词是可数的，并且它是非专有名词，这就意味着它指代的对象在世界上并不唯一，有许多个。以对于「书本」的讨论为例。如果笼统地讨论而不加限定，那么听者就不知道讲话者说得是什么——究竟是说所有的书本组成的这个整体，还是说某一本特定的书呢？显然，对于这样的名词，在讨论的时候需要加以限定，这就是限定词存在的意义。 一个例子我们继续上面关于成分省略的话题。如果我们将「many good students」的限定词 many 去掉，形成的「good students」仍然是一个正确的名词短语。但是，将「a new book」的限定词 a 去掉，形成的「new book」就不正确了。 我们对两个短语进行了同样的操作，但是结果却不相同。按照上一小节的讨论，学生和书本都是非专有名词。这种情况下，作为复数存在的 students 表意是明确的，它表示学生这个群体；而作为单数存在的 book 表意就不明确了。 冠词的使用限定词有很多，我们先简单地看一下。 冠词：a, an, the 表示指代：this, that, these, those 所有格：my, your, his, her, their, Jason’s 表示否定：no, neither 表示全部：every, each 表示不确定：some, any, either 表示数量：基数词、序数词以及 many, much, little, few 表示数量的范围、倍数等：all, both, half, one-third, double, twice, three times, such 等 行文时有关限定词的错误，要么是漏掉限定词，要么是限定词误用。除掉冠词之外的其余几类限定词都有相对明确的含义，在实际使用中不容易出错。所以我们只需要着重讨论冠词就可以。 从语源学（etymology）的角度说，不定冠词 a(n) 以及定冠词 the 分别是数次 one 和指示代词 that 和 those 的弱化。也就是说，a(n) 就是 one 的意思，the 就是 that 或者 those 的意思，只不过语气上比较弱。 因此，当后面的名词在叙述上有「一个」的含义时，应该加上不定冠词；当后面的名词在上下文有特指「那个」的时候，应该加上不定冠词；当后面的名词不适合以「一个」或「那个」来交代，就不加冠词。 举例分析如下： Unmaried men are a rare species these days. 名词短语 Unmaried men 中 men 是复数形态，没法说「一个」或者「那个」，所以不用冠词。 Honesty is necessarily the best policy. Honesty 是表达品质的抽象名词，没有复数形态，不能用「一个」来描述，所以不用冠词。 Fresh water is a precious resource in Saudi Arabia. Fresh water 是不可数的，没有复数形态，不能用「一个」来描述，所以不用冠词。 I have an appointment on Sunday. 这里 Sunday 在讨论范围内是唯一的，确指这周日，是专有名词，不能用「一个」或者「那个」来描述，所以冠词位置留空。 I would have an appointment on a Sunday next month. 这里 Sunday 在讨论范围内（下个月）里是不唯一的，因此要保留冠词。 I need a book to read on my trip. I have finished the book you lent me. 第一句中，a book 不做特指，「随便哪一本书我都乐意读」，因此用不定冠词。 第二句中，the book 特指「你借给我的那一本」，上下文中有暗示的「那个」，所以用定冠词。 Modern history is my favorite subject. The history of recent China is a sorry record. 第一句中，modern history 是抽象名词，没有办法用「一个」或者「那个」来表述，所以冠词位留空。 第二句中，因为特指「中国的『那一段』历史」，所以要用定冠词。 He should be home; I saw a light in his house. Turn off the portal light. 第一句中，屋子里的灯可能不止一盏，所以不适合用「那个」来表述，只能用不定冠词。 第二局中，等特指门口的「那一盏」，所以用定冠词。 Genghis Khan is hero. 这里 Genghis Khan 是成吉思汗，古今就这一位，是专有名词。如果用「一个」来描述，就表示还有另一个成吉思汗，这不合适，所以冠词位置留空。对于短语 hero 来说，它在句中是 Genghis Khan 的补语，和 Genghis Khan 等同，因此也应当做专有名词来对待。 Someone said that Genghis Khan is a greater hero than Napoleon. 这里的名词短语 a greater hero 同样是 Genghis Khan 的补语，二者地位等同，但是却没有当做专有名词来处理。这是因为后面还出现了拿破仑，此时 hero 就不唯一了，所以必须加冠词。 The five-year-old Genghis Khan was a breezy boy. 成吉思汗只有一个，但是句中特指「五岁的『那个』成吉思汗」，将成吉思汗的一生展开讨论，于是有了多个时期的成吉思汗。此时成吉思汗不再作为专有名词，又因为讨论时特指「那个」，所以要加上定冠词。 I always go to school by bus. Bus 本是个可数的普通名词，按理应加上冠词。但是这里出现在介词 by 之后，表示方式手段，意思是「坐车这种方式」，是抽象名词。这里的 bus 没办法用「一个」或者「那个」去理解，所以冠词位置留空。 the Pacific Ocean 「太平洋是专有名词，但是一个特例，要加上定冠词」，这是一般语法书的论调。但事实上，如果把 the Pacific Ocean 理解为「叫做 Pacific 的『那个』海洋」的话，就不需要背这个特例了，加定冠词也就显而易见了。 这篇文章不做类似「专有名词前面不加冠词」或是「抽象名词前面不加冠词」之类的总结。因为如你所见，一个名词是否是专有名词或者抽象名词，是需要依情况而定的。如例子里的成吉思汗，尽管它在大多数情况下是专有名词，但是在某些讨论中，它也可以是非专有名词。对这些规则的死记硬背通常导致不加思考的「错误套用」，更将引出无数例外，实不可取。 总结 名词短语包括限定词、修饰词和名词三个部分。任一部分在合适的情况下都可以省略。 名词短语中没有冠词限定的情况，是因为名词在上下文中不适合理解为「一个」或者「那个」。 a(n) 和 the 分别是 one 和 that/those 的弱化。 这些规律在理解的基础上是很自然的，不需要死记硬背。吃透文章中的这些分析，足以涵盖「二十条规则和二十条例外」的语法细则。]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>Grammar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语语法之一：基本句型、动词分类、补语]]></title>
    <url>%2F2014%2F06%2F21%2Fbasic-sentence-and-the-complement%2F</url>
    <content type="text"><![CDATA[语法是语言的规范，制定语法的目的是为了让表达清晰、意思完整、不致有歧义。人类活动中的情形千差万别，为了表达清晰等目的，会形成许多特例。因此如果尝试通过列举语法现象及特例来描述语法，可想见是非常繁琐的，并且这种行为有舍本逐末之嫌。 在看过旋元佑先生写的《语法俱乐部》之后，我更坚定了这个想法，并尝试将自己对该书的理解结合自己的经验和思考写出来，成为一个系列。 这是这个系列的第一篇，主要讨论动词分类与补语的关系。 基本句型英语中的基本句型有五种： S + V S + V + O S + V + C S + V + O + O S + V + O + C 从意思上说，一个完整句子表达的无非是「一个人/一个东西怎么样了」。这里「一个人/一个东西」称为主语部分（subject），告诉人们「这个句子讨论的是『一个人或者一个东西』」；「怎么样了」称为谓语部分（predicate，也称「述语部分」），它可以是「做了什么事情」或者「具有某种特性」。主语部分形式比较单一，通常由名词性的结构来担任。谓语部分的形式变化较多，五种基本句型实际就是通过不同的谓语部分结构来表达五种类型的含义。 不过，不管谓语部分如何变化，它都由动词起头，并承担主要的表意功能。因此讨论基本句型就有必要讨论谓语动词。 动词的特性及分类动词的特性分成两个部分。其一是「是否及宾（transitive/intransitive）」，其二是「是否完全（complete/incomplete）」。 及宾与不及宾第一个特性是从动词意思的层面上说的。如果一个动词和其他人或事物没有关系，那它就是不及宾动词；而如果一个动词被做出来必须有一个承担者，那它就是及宾动词。 His father died in the war. His father had killed three enemy soldiers before his father died in the war. 例子中的 die 表示「死亡」，是一个不及宾动词。这是因为死亡这个动作只与他的父亲有关，和别人无关——他的父亲一个人就可以执行死亡这个动作了。不及宾动词后面不能与作为受词的宾语（object）直接相连。 例子中的 kill 表示「杀死」，是一个及宾动词。这是因为杀死这个动作必须有一个承受者（在句子中就是受词）——如果句子去掉 kill 的宾语，变成 His father had *killed* before his father died in the war. 的话，句意就不完整了。及宾动词后面必须有作为受词的宾语。 完全与不完全第二个特性是从表意功能上说的。如果一个谓语动词在句子当中只能起到连接主语和谓语部分的后续结构的作用，而在表意上功能不完全，则这个动词就是「不完全」的；反之若谓语动词能够完整地表意，那它就是「完全」的。 判断动词是否完全比判断动词是否及宾要容易许多。不完全的动词有一个非常明显的特征——它们都是判断动词「是」的变形，都表示某种意义上的「是」。举例如下： I am a boy. The soup tastes pretty good. That man looks weak. 三个句子中的动词「am」、「taste」、「look」都是不完全的动词，它们分别译作「是」、「尝起来是」、「看起来是」。如果把他们后面的内容去掉，变成： I am. The soup tastes. That man looks. 句子表意就不完整了。「我是」，我究竟是什么呢？「汤尝起来」，究竟怎么样呢？「那个男人看起来」，究竟怎么了？ 总而言之，不完全的动词在句子当中都是判断动词「是」的变形，在句子当中起到连接主语和谓语部分其他内容的作用，但表意功能弱。因此，这些动词被称为「联系动词（Link-verb）」。也因此，当这些句子出现在句中的时候，需要有称为补语的部分将表意功能补足。 英语中，除去「be」之外，常见的联系动词有： look 看起来是 seem 似乎是 appear 显得像是 sound 听起来是 feel 摸起来像是 taste 尝起来是 stay 仍然是 remain 依旧是 turn 转变为 prove 证实为 become 成为 make 作为 补语补语是和表意不完全的动词息息相关的。在第三种基本句型中，联系动词将主语和补语在某个意义层面上对等起来。 我们先来讨论主语的补语，而后将宾语的补语作为一种变形来讨论。 主语的补语 S + V + C在前一节的讨论中，我们已经见过补语这个结构了。为了更清晰地讨论补语，我们尝试将主语统一。 The dog was a mastiff. The dog was mean. The dog was there. 在这里，「a mastiff」、「mean」和「there」分别是三句话的补语，他们分别是名词、形容词和方位副词。 在这里，第一句话翻译为「这只狗是一只獒」，可以明显看到判断动词的存在；第二句话翻译成「这只狗很凶」，判断动词不见了。这实际上是翻译上作出的调整。第二个句子逐字翻译（Verbatim Translation）的结果应该是「这只狗是凶恶的」，但这不符合汉语的说话习惯。这个事实从另一个角度说明了，联系动词表意上是不完全的，在翻译上甚至可以将它们丢掉。 另一方面，尝试将下面句子中的联系动词替换为相应的「be」动词，我们会发现，这些句子的表意基本没有发生变化。这也说明，联系动词在表以上是不完全的。 The house looks big. The question seems easy. The man appears to be a gentleman. The music sounds of equanimity. The book feels old. The soup tastes hot. This two men stayed friends for their whole life. The woman remains single. The player turned professional. The drug proved effective. The little boy became a super star. A nurse makes a good wife. 宾语的补语 S + V + O + C主语的补语用来表示主语是什么。类似地，宾语的补语用来表示宾语是什么。在 S + V + O + C 这个句型当中，宾语和补语之间虽然没有动词存在。但是句子可以变形成：S + V + that + O + V + C 的形式，也就是将原本的宾语和补语以从句的形式出现。因此，可以认为宾语和补语之间有「隐藏的」判断动词「是」的存在。 上一小节的最后，我们举出了 12 个主语补语的句子，我们可以按照下面的方法轻易地变成宾语补语的句子。 The house looks big. I found that the house looks big. I found the house big. 这也说明了主语补语和宾语补语之间的关系。 补语的词类除了前述的名词和形容词性结构可以充当补语之外，表示方位的副词也可以充当补语。比如： The car is there. I find the key here. 这里，表示方位的副词「there」和「here」分别作为「The car」和「the key」的补语。 额外的内容特殊的 be 动词一些情况下，be 动词后面不带补语。我们知道 be 动词表示「是」的时候不带补语是表意不完全的，因此这些不带补语的 be 动词并不是系动词，而是作为有实际意义的动词，表示「存在」。 比如，被认为是现代哲学开端的笛卡尔先生的名言「我思故我在」中的 be 动词：I think; therefore I am. 又比如，莎翁名作《哈姆雷特》中，王子哈姆雷特在母亲与叔父通奸害死父王之后思考人生的名句：To be or not to be, that is the question. 这里的 be 也应该理解为存在，引申为「活着」，翻译为「要不要活下去，这是个问题」。 S + V + O + O 与 S + V + O + C这是两组结构相似的基本句型，对一些中国学生来说，辨识起来稍有困难。我们知道，五种基本句型的区别在于谓语部分的差别，而谓语部分的差别实际上是谓语动词的差别引起的。所以为了在这两种句型中作出辨析，就应着重探讨谓语动词的特征。 先看两个例子。 Jason’s wife gave him a jar of honey. Jason’s wife called him honey. 这里前句是一个 S + V + O + O 的句型，后句是一个 S + V + O + C 的句型。 前句的谓语动词「give」首先是一个及宾动词，因为必须要「把什么东西给出去」。其次，它还必须有一个额外的接收者，因为必须要有人接受，东西才给得出去。所以，动词 give 出现，就必须有两个宾语来承受这个动作，因此是 S + V + O + O 的句型。此外，「him」和「a jar of honey」中不存在对等的概念，也即没有「He is a jar of honey」的意味在其中，所以这不可能是宾语和补语的关系。 后句中，「him」和「honey」隐含着对等的概念，所以这是一个 S + V + O + C 的句型。 表语还是补语？文首列出的第三种基本句型，在中国大陆地区通常称为「主系表结构」。主语和系动词很好理解，那么表语是什么？ 在大陆地区的语法书中，表语是这样定义的： 表语是用来表明主语的身份、性质、品性、特征和状态的，表语常由名词、形容词、副词、介词短语、不定式、动词的-ing、从句来充当，它常位于系动词的后面。 显而易见，它就是我们讨论中所言的「主语的补语」，二者是相同的概念。]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>Grammar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Virtual Audio Cable 解决 CamStudio 在部分 ThinkPad 机型上无法内录的问题]]></title>
    <url>%2F2014%2F05%2F23%2FCamStudio-WaveoutGetSelectControl-Virtual_Audio_Cable%2F</url>
    <content type="text"><![CDATA[最近因为一些缘故，需要在 Win7 上实现录屏和声音内录功能：前者记录计算机屏幕的内容变化，后者记录通过计算机扬声器或耳机线路发出的声音（Speaker 的声音）。在朋友圈中问了一圈，结合自己搜索之后，决定使用开源的 CamStudio 来录屏。 CamStudio 十分优秀，视频上支持多种区域方式（全屏、区域、固定大小、窗口），声音上支持计算机内录和从麦克风输入录制，甚至可选鼠标和键盘操作的录制。但在实际操作中 CamStudio 的内录功能无法正常进行，提示 WaveoutGetSelectControl() failed 的错误，并且官方似乎也没有定位问题所在，导致在多个版本中都存在这个错误（见官方论坛的讨论）。 Woedge 在上述讨论中给出了一个解决方案，帮助一些用户解决了问题。这个方案的关键步骤，是打开 Windows 系统录音设备中的禁用设备——立体声混响（Stereo Mix）功能，然后使用立体声混响将系统内部声音和麦克风声音混在一起，交付给 CamStudio 进行录制。 这个方案无疑帮很多用户解决了问题，但在许多 ThinkPad 机型上却不行。原因是部分 ThinkPad 安装的声卡并不支持 Stereo Mix 功能，故而上述关键步骤无法执行。 经过一番研究之后，决定使用 Virtual Audio Cable 来解决问题。 需求分析 将计算机扬声器/耳机音频信号直接输入计算机麦克风 在内录进行时，保证计算机扬声器的正常工作（不能静音） 解决思路大约是十年前，中国大陆地区流行 MP3 播放器的时候，部分播放器就提供了这种「内录」功能。这些 MP3 播放器大都随机提供了一只内录电缆（Line-in Cable）——类似常见的耳机，只不过正常耳机一头是插头另一头是耳机，而内陆电缆两头都是一模一样的插头，将电缆的一头插入朋友的 MP3 耳机插口中，一头插入自己 MP3 的麦克风插口中，开启录音模式就能录制朋友 MP3 中的歌曲了。当年可是用这个办法节省了不少上网费用（当年家里还是 56K 的拨号上网，一小时六块钱，可贵了）。 这种方式对我来说固然好，但是不免要浪费朋友的时间——内录进行过程中朋友是无法使用 MP3 听音乐的。作为一个爱动手的好孩子，我制作了一个音频分线器，起作用大约就相当于大家普遍使用的 USB 分线器（当计算机 USB 接口不够时，将它接到计算机的 USB 上，然后让其他设备，比如 U 盘，插入到分线器上）。当然，后来才知道这东西到处都有卖，也很便宜。 今次我们要做的事情和十年前我曾经做过的事情如出一辙。我们当然也可以用一个分线器加一条内录电缆来达到目的，更好的办法无疑是在计算机内部使用软件来模拟分线器和内录电缆的效果来达到目的。为此，我们需要 Virtual Audio Cable. 配置 Virtual Audio Cable我将我使用的版本上传到了这里，你可以下载安装。 接下来我们模拟「内录电缆」的效果。Virtual Audio Cable 在默认设置下，为计算机配置了一些新的输入输出设备。我们暂时不需要修改 Virtual Audio Cable 的设置，直接使用默认设置提供的这些设备即可。 右键 Windows 任务栏上的音量合成器按钮，选择「播放设备」，将「Line 1」设备设置为默认。 然后切换到「录制」标签，同样，将「Line 1」设备设置为默认。 这样 Virtual Audio Cable 就接管了操作系统音频的输入与输出，相当于将一条 Line-in 电缆接在了计算机耳机和麦克风的接口上。 这时，因为计算机的音频输出完全由 Virtual Audio Cable 的虚拟设备「Line 1」接管，计算机的扬声器/耳机中是没有音频信号的，因此我们听不到任何声音。为此，我们需要打开 Virtual Audio Cable 的中继器功能，来模拟前文所述的音频分线器。Virtual Audio Cable 提供了两个中继器模式，分别是 MME 和 KS, 你需要根据你的设备型号来选择。如果你不清楚你的设备型号，不知道选择哪一个的话，也不用担心。因为二者内部的配置完全相同；并且如果当前模式不支持你的硬件，Virtual Audio Cable 就会报错，这时候换另一个就行了。 打开中继器窗口之后，将 Wave In 设置为「Line 1」，将 Wave Out 设置为你的系统扬声器。这样就相当于我们用音频分线器将「Line 1」中的信号分流到了系统扬声器之中，同时又输入到了麦克风信号当中。而这正是我们希望的效果。此时点击 Start 启动中继器，计算机的扬声器就会照常工作了。 这样我们就成功模拟了「内录电缆」和「分线器」的功能，打开 CamStudio 开始录屏吧！]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>ThinkPad</tag>
        <tag>CamStudio</tag>
        <tag>Virtual Audio Cable</tag>
        <tag>Vitual Sound Card</tag>
        <tag>WaveoutGetSelectControl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Koreader 阅读 PDF 让 Kindle Paperwhite 如虎添翼]]></title>
    <url>%2F2014%2F05%2F20%2Fkoreader-on-kindle-paperwhite%2F</url>
    <content type="text"><![CDATA[Kindle 的墨水瓶看书十分舒服；不过，也会有「甜蜜的烦恼」。6 英寸的屏幕对付 A4 纸张大小的 PDF 文件，特别是扫描版的 PDF 文件总是让人不快；尤其 Kindle 原生的阅读器还要在 PDF 文件周边加上白边。好在经过一番搜索和折腾，终于找到了合适的解决方案——神器 Koreader. Koreader 简介Koreader 是用 Lua 这个脚本语言开发的 Kindle 插件，它基于 GPLv3 协议发布，可以运行在 Kindle 原生系统上，并支持 PDF, DJVU, EPUB 等格式。 Koreader 通过 KPVBooklet 与原生系统集成。成功安装后，将会默认使用 Koreader 打开 PDF, EPUB, DJVU, FB2, CHM 和 DOC 文档，MOBI, AZW, TXT 等格式则会默认使用原生阅读器打开。如果希望通过原生阅读器打开 PDF 等（默认使用 Koreader 的）格式，可以长按文档图标/标题，在弹出的窗口中选择「GOTO…/前往…」。二者的切换十分方便。 Koreader 的重排（Text Reflow）功能实际上是对另一个开源项目 K2pdfopt 的移植以及再开发。K2pdfopt 使用完全基于图像处理的方法对文字重新排版：把原始 PDF/DJVU 页面放大，而后再分割成以词为单位的像素区域，把这些像素区域重新排列到目标宽度的页面中（原理如下图）。所以理论上只要能够读取文档的页面像素就可以对其中的文字进行重新排版。 对 K2pdfopt 的移植和再开发，使得在 Kindle 上实时重排、交互式地微调效果成为可能，而这几乎就完美地解决了 Kindle 用户对 PDF 阅读的全部需求。 Koreader 文字重排效果可以参见 Huang Xin 博客上的一篇文章。 在 Kindle Paperwrite 上的安装要在 Kindle 上安装插件必须对设备进行越狱（Jailbreak）；而后需要安装 Koreader 依赖的 KPVBooklet；最后安装 Koreader。 越狱不同于 iOS 系统越狱的极度困难，Kindle 的越狱相对简单许多。 到 MobileRead 论坛上的这个帖子中下载 kindle-jailbreak-x.x.N.zip（x.x.N 是版本号）。当前版本为 1.10.N, 能够胜任 Kindle 固件版本 5.0.x - 5.4.4.2 的越狱工作。 使用 USB 数据线将 Kindle 与计算机连接。 ZIP 归档中有名为 kindle-5.4-jailbreak.zip 的文件，解压其中的三个文件到 Kindle 根目录。 bridge.sh jb.sh Update_jb_$(cd mnt &amp;&amp; cd us &amp;&amp; sh jb.sh).bin 断开 Kindle 与计算机的 USB 连接。 依次进行如下操作 主页按钮（[Home]） 菜单按钮（[Menu]） 设置选项（Settings） 菜单按钮（[Menu]） 更新您的 Kindle（Update Your Kindle） 几秒钟后屏幕下方出现「* JAILBREAK *」字样表示越狱成功。 安装 KPVBooklet 到这里下载 KPVBooklet 的安装包。 使用 USB 数据线将 Kindle 与计算机连接。 ZIP 归档中有名为 update_kpvbooklet_x.x.x_install.bin 的文件，将其解压到 Kindle 根目录。 断开 Kindle 与计算机的 USB 连接。 依次进行如下操作 主页按钮（[Home]） 菜单按钮（[Menu]） 设置选项（Settings） 菜单按钮（[Menu]） 更新您的 Kindle（Update Your Kindle） 安装 Koreader 到这里下载 Koreader 的安装包，其中最新的版本在最上方，依次向下可以回溯各个版本。 对于使用 Kindle 原生系统的用户，应当下载名为 koreader-kindle-arm-linux-gnueabi-*.zip 的文件。 使用 USB 数据线将 Kindle 与计算机连接。 ZIP 归档中有三个目录，将它们全都解压到 Kindle 根目录。 extensions koreader launchpad 断开 Kindle 与计算机的 USB 连接。 至此，安装完毕，在 Kindle 主界面即可直接用 Koreader 打开 PDF 和 EPUB 文档。 关于原生系统固件升级开启 WIFI 的情况下原生系统可能会在后台自动升级固件。不管手动固件升级还是自动固件升级都会擦除 KPVBooklet 启动器造成 Koreader 无法启动，解决这个问题只需要升级完成后重新安装 KPVBooklet 即可，Koreader 无需重新安装。]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Kindle</tag>
        <tag>PDF</tag>
        <tag>Koreader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么一些种类的听力损失是不可逆转的？]]></title>
    <url>%2F2014%2F05%2F10%2Fhearing-impairment%2F</url>
    <content type="text"><![CDATA[原文发布在我在知乎上的回答，有节选。 在未获得本人书面许可的情况下，禁止任何形式的「合理使用」、转载、分享以及将链接发至知乎主站外任何网站或 App （包括知乎日报），外泄斩立决。智商欠奉，中文阅读障碍或微博控患者, 请在监护人及医师协助下学习本段落，谢谢合作。 众所周知，声音是在空气中传播的机械波，简称声波；而人类产生听觉的过程，就是「接收声波」、「转化和传递声波信号」、「转化为神经信号」从而最终刺激大脑产生听觉的过程。三个步骤依次进行，其中任何一个步骤出现问题，都会影响听力。通常所说的「听力损失不可逆」是第三个步骤出现的问题。 接收声波的步骤，由通称「外耳」的「耳廓」和「外耳道」承担，它们的形状类似喇叭，从外而内截面逐渐减小，因此起到收集的作用。外耳道内的「耵聍腺」及「皮脂腺」的分泌物，就是我们俗称的「耳屎」，它的分泌量不同人有不同。分泌量大的人，若不经常清理，可能堵塞外耳道，从而干扰声波的接收，影响听力。这种情况的听力下降，是可以恢复的，只需清洁外耳道即可。大多数情况可以自行使用软质的棉签清理，如果阻塞严重，则需要到医院请医生处理。 转化和传递声波信号的步骤，由通称「中耳」的「鼓膜」、「鼓室」内的「听小骨」承担。机械波的本质是振动能量的传递。外耳接受的声波，引起鼓膜的振动，再通过听小骨传递到下一个步骤。如果鼓膜穿孔，则无法承担声波信号转化为振动的工作，导致失聪。鼓膜穿孔通常是由于气压剧变、暴力等引起的外伤和中耳炎等引起，大多数情况能通过手术治疗恢复。听小骨创伤也可能引起听力损失，但大多数情况也能够经治疗恢复。 转化为神经信号的步骤，主要由通称「内耳」中的「耳蜗」承担。耳蜗是由细小空管蜗旋形成的结构，空管内有被称为「毛细胞」的绒毛状结构。这些绒毛随中耳传来的振动而颤动，将振动信号转换为神经冲动，形成神经信号。长时间的大音量刺激，会引起这些绒毛的「倒伏」，从而影响听力。这些绒毛的「倒伏」，人体无法自行修复，医学界目前也没有好的办法。所以这部分引起的听力损伤是「不可逆」的。 额外的话： 内耳中的「半规管」是三个互相垂直的半规管组成的联通空管结构，内有淋巴液。淋巴液收到重力及加速度引起的「惯性力」影响，在半规管内流动。人体通过半规管内的淋巴液的状态，从而确定大脑所处的倾角和加速度的状态，影响人体的平衡感。各省市科技馆内常设的「魔屋」，就是利用半规管产生的平衡感与眼睛所接收的地形信息的不对应，产生「魔」的效果。「陀螺仪」也是通过类似的原理确定加速度状态的，不知是否收到耳朵里半规管结构的启发。 抛砖引玉，希望不要贻笑大方。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Hearing</tag>
        <tag>Damnification</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LaTeX Tips】符合 GBT7714-2005 标准的 BibTeX Style]]></title>
    <url>%2F2014%2F05%2F09%2Fgbt7714-2005-bibtex-style%2F</url>
    <content type="text"><![CDATA[这是一份符合国家标准《GB/T 7714-2005: 文后参考文献著录规则》的BibTeX样式文件，项目托管在 GitHub 上。具体的排版效果请参见测试文档。 特色 严格遵循中国国家标准《GB/T 7714-2005: 文后参考文献著录规则》，适合中文书籍排版和中文论文排版； 代码完全手写生成，每行BAFLL代码都有对应的Java伪代码翻译，方便使用者学习和修改； 有测试文档，经过了详细的测试； 有详细的用户手册。 支持的文献类型 书籍：book 汇编：collection 会议录：proceedings或conference 学位论文：phdthesis、masterthesis或bachelorthesis 科技报告：techreport 技术标准：standard 参考工具：reference 手册：manual 未发表文献：unpublished或manuscript 期刊：periodical 报纸：newspaper 专利：patent 网页：online 计算机程序：program 数据库：database 书籍中的析出文献：inbook 汇编中的析出文献：incollection 会议录中的析出文献（会议论文）：inproceedings 期刊中的析出文献（期刊论文）：article 新闻报道：news 下载 下载tar.gz压缩包，适合Linux/Mac用户 下载zip压缩包，适合Windows用户 安装 下载BST文件 将其复制到$(TEXMFLOCAL)/bibtex/bst/，其中$(TEXMFLOCAL)是你的机器上的本地的texmf目录，您可以通过执行kpsewhich --var-value=TEXMFLOCAL获得该目录路径； 通过执行texhash刷新texmf目录索引，注意执行该命令可能需要系统管理员权限； 如果您使用Linux或Mac OS X操作系统，您也可以通过项目所提供的Makefile脚本进行安装，只需在项目所在目录下运行以下命令：sudo make，注意需要通过sudo切换root权限。 使用您只需在您的LaTeX源码中使用gbt7714-2005参考文献样式即可： 1\bibliographystyle&#123;gbt7714-2005&#125; 更加具体的使用说明可参见用户手册。 TODO 完成BibTeX样式文件 完成测试文档 撰写用户手册 相关项目 南京大学学位论文XeLaTeX模板 中文书刊排版相关标准和规范]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>BibTeX</tag>
        <tag>GBT7714-2005</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LaTeX Tips】带圈数字与带圈数字列表]]></title>
    <url>%2F2014%2F05%2F08%2Flatex-circled-numbers%2F</url>
    <content type="text"><![CDATA[在许多文章中，特别是中文文章中，我们会见到带有圆圈的数字。它们有点是单独出现的，有点作为列表的计数出现。 LaTeX 提供了 \textcircled 命令，但效果并不好。LaTeX studio 曾经提供了一个方法，但缺乏通用性。 这里给出一个利用 TikZ 绘制的方法，能较好地解决这个问题，但仍需完善。 基本的思路是定义一个新命令，接受一个数字参数，用 TikZ 在它周围画圈。同时要考虑基线和对齐的问题。一个尝试如下： 1234567\usepackage&#123;tikz&#125;\usepackage&#123;etoolbox&#125;\newcommand&#123;\circled&#125;[2][]&#123;\tikz[baseline=(char.base)] &#123;\node[shape = circle, draw, inner sep = 1pt] (char) &#123;\phantom&#123;\ifblank&#123;#1&#125;&#123;#2&#125;&#123;#1&#125;&#125;&#125;;% \node at (char.center) &#123;\makebox[0pt][c]&#123;#2&#125;&#125;;&#125;&#125;\robustify&#123;\circled&#125; 这个新定义的命令可以按照 \textcircled 方法在正文中使用，如果需要用在列表中，则因为「脆弱命令」的问题，需要处理一下。这里我们选择使用 etoolbox 宏包提供的 \robustify 来处理一下，同时结合 enumitem 宏包，给出示例用法如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647\documentclass&#123;article&#125;\usepackage&#123;enumitem&#125;\usepackage&#123;tikz&#125;\usepackage&#123;etoolbox&#125;\newcommand&#123;\circled&#125;[2][]&#123;\tikz[baseline=(char.base)] &#123;\node[shape = circle, draw, inner sep = 1pt] (char) &#123;\phantom&#123;\ifblank&#123;#1&#125;&#123;#2&#125;&#123;#1&#125;&#125;&#125;;% \node at (char.center) &#123;\makebox[0pt][c]&#123;#2&#125;&#125;;&#125;&#125;\robustify&#123;\circled&#125;\begin&#123;document&#125;\mbox&#123;&#125;\rlap&#123;\rule&#123;.7\linewidth&#125;&#123;.4pt&#125;&#125;%The original version: \circled&#123;1&#125; and \circled&#123;10&#125;.\mbox&#123;&#125;\rlap&#123;\rule&#123;.7\linewidth&#125;&#123;.4pt&#125;&#125;%The improved version: \circled[10]&#123;1&#125; and \circled[10]&#123;10&#125;.\newcommand&#123;\dcircled&#125;[1]&#123;\circled[00]&#123;#1&#125;&#125;\begin&#123;enumerate&#125;[label=\dcircled&#123;\arabic*&#125;, noitemsep]\item I\item am\item happy\item to\item join\item with\item you\item today\item in\item what\item will\item go\item down\item in\item history\item as\item the\item greatest\item demonstration\item for\item freedom\item in\item the\item history\item of\item our\item nation.\end&#123;enumerate&#125;\end&#123;document&#125;]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>TikZ</tag>
        <tag>Circled</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LaTeX Tips】为所有的浮动体一次性设置浮动选项]]></title>
    <url>%2F2014%2F05%2F08%2Ffloat-setting%2F</url>
    <content type="text"><![CDATA[节选自 elegantlatex. 在我们插图或者插入表格到 LaTeX 文档中，我们会碰到一个概念——浮动体，有时候，我们在文中用到的 table 或者 figure 环境的浮动选项都是相同的，比如 htbp，并且对 table 内、或者 figure 中的内容居中对齐（\centering），本文将介绍如何统一设置浮动体的浮动选项，以及居中设置。本文以 table 环境为例，figure 类似。 可以借助 floatrow 宏包来达到目的。 123456789101112131415\documentclass&#123;article&#125;\usepackage&#123;floatrow&#125; % this automatically centers all floats\floatplacement&#123;table&#125;&#123;hbtp&#125; % all tables are given the [hbtp] option\begin&#123;document&#125;\begin&#123;table&#125;\begin&#123;tabular&#125;&#123;lll&#125;1 &amp; 2 &amp; 3\\a &amp; b &amp; c\\\end&#123;tabular&#125;\end&#123;table&#125;\end&#123;document&#125;]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Float</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LaTeX Tips】利用 TikZ 在 LaTeX 文档中制作水印效果]]></title>
    <url>%2F2014%2F04%2F22%2FLaTeX-watermark%2F</url>
    <content type="text"><![CDATA[本文最早发布于知乎专栏，略有修改. 在未获得本人书面许可的情况下，禁止任何形式的「合理使用」、转载、分享以及将链接发至知乎主站外任何网站或 App （包括知乎日报），外泄斩立决。智商欠奉，中文阅读障碍或微博控患者, 请在监护人及医师协助下学习本段落，谢谢合作。 制作水印基本上需要解决下面几个问题： 水印应该叠放在正文的下面，不得覆盖文字 水印应该放置在合适的位置 水印的颜色应该足够淡，因此不会影响（太多）文章正文的阅读 在 LaTeX 中，可以用 eso-pic 宏包提供的 \AddToShipoutPictureBG 命令，来将内容叠放在正文的下面；使用 TikZ 宏包（这是绘图工具 PGF 的前端）来为水印文字定位；使用 xcolor 宏包设置水印的颜色。 同时，我们会希望： 设定水印文字内容 设定水印文字大小 设定水印文字偏转角度 能够在合适的位置开启水印效果 于是我们有了下面这样的实现： 123456789\newcommand&#123;\watermark&#125;[3]&#123;\AddToShipoutPictureBG&#123;\parbox[b][\paperheight]&#123;\paperwidth&#125;&#123;\vfill%\centering%\tikz[remember picture, overlay]% \node [rotate = #1, scale = #2] at (current page.center)% &#123;\textcolor&#123;gray!80!cyan!30&#125;&#123;#3&#125;&#125;;\vfill&#125;&#125;&#125;\newcommand&#123;\watermarkoff&#125;&#123;\ClearShipoutPictureBG&#125; 一个可供测试的完整例子是： 123456789101112131415161718192021\documentclass&#123;article&#125;\usepackage&#123;tikz&#125;\usepackage&#123;xcolor&#125;\usepackage&#123;eso-pic&#125;\newcommand&#123;\watermark&#125;[3]&#123;\AddToShipoutPictureBG&#123;\parbox[b][\paperheight]&#123;\paperwidth&#125;&#123;\vfill%\centering%\tikz[remember picture, overlay]% \node [rotate = #1, scale = #2] at (current page.center)% &#123;\textcolor&#123;gray!80!cyan!30&#125;&#123;#3&#125;&#125;;\vfill&#125;&#125;&#125;\usepackage&#123;blindtext&#125;\begin&#123;document&#125;\watermark&#123;60&#125;&#123;10&#125;&#123;DRAFT&#125;\blinddocument\clearpage\end&#123;document&#125; 以上。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Watermark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LaTeX】Pro Git 中文版]]></title>
    <url>%2F2014%2F04%2F01%2FLaTeX-Pro-Git-zh%2F</url>
    <content type="text"><![CDATA[Pro Git 是 Git Hub 员工 Scott Chacon 撰写的关于 Git 版本控制系统的书籍，其源码开源，托管在 Git Hub 上。 我将当前（2014-4-2）的仓库克隆到本地，并将其中的 markdown 文件转换成了 LaTeX 文件，编译得到 PDF 档案。 下载： 中文版：//liam.page/attachment/attachment/Git/progit.zh.pdf 日文版：//liam.page/attachment/attachment/Git/progit.ja.pdf 英文版：//liam.page/attachment/attachment/Git/progit.en.pdf]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Pro Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Life on Python】一个简易的通讯录]]></title>
    <url>%2F2014%2F01%2F29%2FPy-Contacts%2F</url>
    <content type="text"><![CDATA[提供了 add, remove, find, view 和 exit 几个命令行接口，意义很明确了，所以 help 选项没空写内容也无所谓了。第一次自己思考结构写的 Python 程序，有点小爽。XD 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import osimport cPickle as pickleclass Persion: '''\ Describe a nature persion, his/her name, sex, and \ age.''' def __init__(self, info): '''Initializes the person's data.''' self.name = info[0] self.sex = info[1] self.age = info[2] print '(Initializing %s)' % self.nameclass Contact(Persion): '''\ Describe a contact that is a nature persion, and \ has his/her Tel., Addr., and Email.''' def __init__(self, info): Persion.__init__(self, info) self.tel = info[3] self.addr = info[4] self.email = info[5] self.info = &#123;self.name : (self.sex, self.age, self.tel, self.addr,\ self.email)&#125; def tell(self): print self.infodef command_line_interface(): prompt = '--&gt; ' workingDict = &#123;&#125; if os.path.exists(r'.\Contact.data'): workingDict = pickle.load(open(r'.\Contact.data', 'r')) else: pass while True: getInput = raw_input(prompt) if getInput == 'exit': pickle.dump(workingDict, open(r'.\Contact.data', 'w')) break elif getInput == 'add': newContact = generate_new_contact(get_info_from_raw_input()) workingDict[newContact.name] = newContact.info[newContact.name] pass elif getInput == 'find': pattern = raw_input('Enter the name:') if pattern in workingDict: print '-' * 45 print 'Name: %s\nSex: %s\nAge: %s\nTel.: %s\nAddr.: %s\nEmail: %s' % (pattern, workingDict[pattern][0], workingDict[pattern][1], workingDict[pattern][2], workingDict[pattern][3], workingDict[pattern][4]) print '-' * 45 else: print 'Sorry, but "%s" is not in your contacts list.' % pattern elif getInput == 'remove': pattern = raw_input('Enter the name:') if pattern in workingDict: workingDict.pop(pattern) print 'Contact "%s" has been removed.' % pattern else: print 'Sorry, but "%s" is not in your contacts list.' % pattern elif getInput == 'view': population = len(workingDict) if population == 1: print 'There is only one contact:' elif population == 0: print 'There is no contact.' continue else: print 'There are %d contacts:' % population for name, info in workingDict.items(): print '-' * 45 print 'Name: %s\nSex: %s\nAge: %s\nTel.: %s\nAddr.: %s\nEmail: %s' % (name, info[0], info[1], info[2], info[3], info[4]) pass elif getInput == 'help': print getInput else: exec(getInput) passdef get_info_from_raw_input(): info = [] info.append(raw_input('Name: ')) info.append(raw_input('Sex: ')) info.append(raw_input('Age: ')) info.append(raw_input('Tel.: ')) info.append(raw_input('Addr.: ')) info.append(raw_input('Email: ')) return infodef generate_new_contact(info): return Contact(info)if __name__ == '__main__': command_line_interface()]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Contact</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Life on Python】批量切割图片]]></title>
    <url>%2F2014%2F01%2F27%2FPy-Incise-Images%2F</url>
    <content type="text"><![CDATA[按照 horizon 和 vertic 两个变量切割当前目录下所有图片（包括子目录）。 代码很简单，就不封装了。 123456789101112131415161718192021222324import Image as imgimport osimgTypes = ['.png','.jpg','.bmp']horizon = 8vertic = 1for root, dirs, files in os.walk('.'): for currentFile in files: crtFile = root + '\\' + currentFile if crtFile[crtFile.rindex('.'):].lower() in imgTypes: crtIm = img.open(crtFile) crtW, crtH = crtIm.size hStep = crtW // horizon vStep = crtH // vertic for i in range(vertic): for j in range(horizon): crtOutFileName = crtFile[:crtFile.rindex('.')] + \ '_' + str(i) + '_' + str(j)\ + crtFile[crtFile.rindex('.'):].lower() box = (j * hStep, i * vStep, (j + 1) * hStep, (i + 1) * vStep) cropped = crtIm.crop(box) cropped.save(crtOutFileName)]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Images</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Life on Python】一个古老闯关游戏]]></title>
    <url>%2F2014%2F01%2F18%2FPy-challenge%2F</url>
    <content type="text"><![CDATA[Python 是一个很实用的脚本语言，学习 Python 无疑需要辅以大量的练习，才能把自己所学运用到实践中去。PythonChallenge 是国外的一款闯关游戏，在挑战关卡的同时学习如何运用 Python 解决问题。 第〇关http://www.pythonchallenge.com/pc/def/0.html 图片提示计算 2 的 38 次幂方的值。在 Python 解释器中输入 12**38 即可得到答案 274877906944L. 这里最后的 L 表示这是一个长整形的数字。将 274877906944 填入页面地址进入下一关。 第一关地址跳转到 http://www.pythonchallenge.com/pc/def/map.html, 继续我们的挑战游戏。 图片提示将 K 对应到 M, O 对应到 Q, E 对应到 G. 这是古典密码学典型的移位密码，位移值为 2. 算法 建立移位映射关系； 读入一个字符； 查找映射表； 根据映射关系输出一个字符； 返回步骤 2, 直至字串末尾。 映射关系可以有多种方法可以建立，可以做一个类似 Python 内建的 dict 类型的 key-value 对应，也可基于 ASCII 码表做数值上的处理。 string 模块有 maketrans 函数，它接收两个等长的字符串，建立从第一个参数到第二个参数逐字符的对应关系，而后用 translate 函数将一个字符串根据这种对应关系转换，返回结果。 string.ascii_lowercase 将返回顺序排放的 26 个小写英文字母。我们可以用切片来得到映射表。 123456789import stringdef Shift_Encrypt(puzzle,Shift): ShiftMap = string.maketrans(string.ascii_lowercase,string.ascii_lowercase[Shift:] + string.ascii_lowercase[:Shift]) return puzzle.translate(ShiftMap)if __name__ == '__main__': puzzle = '''g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.''' print Shift_Encrypt(puzzle,2) 得到结果：i hope you didnt translate it by hand. thats what computers are for. doing it in by hand is inefficient and that’s why this text is so long. using string.maketrans() is recommended. now apply on the url. 内容提示我们，将位移密码作用在当前的 URL 上，即作用在 map 上。得到结果 ocr, 填入地址栏，进入下一关。 第二关http://www.pythonchallenge.com/pc/def/ocr.html 页面提示说，要在网页源代码中寻找答案。打开源代码后发现有 HTML 注释说要寻找下面一堆乱码中罕见的字符。（我把需要测试的文件，保存在了这里。） 算法 建立一个字典，key 是字符，value 是字符出现的次数； 读入一个字符； 如果该字符已存在字典中，则对应的值加一；若不存在，则新建一个字典条目，设定值为一； 返回步骤 2, 直至字串末尾。 计算字符平均出现次数 = 字符总数 / 字典长度； 遍历字典，输出所有值小于字符平均出现次数的字符。 算法如果正确，则所谓的「罕见字符」都将被输出。但是有一个问题，Python 中的字典是无序的，按照算法运行，则输出的字符顺序是不可预知的（因为输入的文本不可预知）。我们需要一个「按照输入顺序排序的字典」。所幸，Python 的 collections 模块为我们提供了 OrderedDict 类型。 123456import collectionspuzzle = ''.join([line.rstrip() for line in open('lv2.txt')])CharCnt = collections.OrderedDict()for Char in puzzle: CharCnt[Char] = CharCnt.get(Char, 0) + 1avgOC = len(puzzle) // len(CharCnt)print ''.join([Char for Char in CharCnt if CharCnt[Char] &lt; avgOC]) 得到结果 equality, 输入地址栏，进入下一关。 第三关http://www.pythonchallenge.com/pc/def/equality.html 网站提示说：One small letter, surrounded by EXACTLY three big bodyguards on each of its sides. 也就是说，需要找出所有 xXXXxXXXx 类型的结构，取中间那个小写的 x 出来。注意问题关键在于「恰好」二字，意味着不多不少都只能是三个字母，因此我们每次对比，都必须考虑前后一共九个字母。另外，实际上，前后的两个字符，不一定是字母，也可以是特殊符号。比如 #ABCdEFG* 也是满足要求的。（我把需要测试的文件，保存在了这里。） 算法 读入一个字符； 如果该字符不是小写字母，返回 1; 如果该字符是小写字母，去到 3； 检查它的前后各四个字符，是否满足条件，若满足，则记录该字母； 检查是否到达字符串尾，若是，则停止；若否，则返回步骤 1. 最简单的方法，是使用 re 模块的正则表达式功能，其中的 findall 函数能够直接完成任务。 12import reprint ''.join(re.findall('[^A-Z][A-Z]&#123;3&#125;([a-z])[A-Z]&#123;3&#125;[^A-Z]', ''.join([line.rstrip() for line in open('lv3.txt')]))) 当然，也可以直接控制。 12345678910111213141516puzzle = ''.join([line.rstrip() for line in open('lv3.txt')])Output = ''for CharIndex in range(len(puzzle) - 8): if not puzzle[CharIndex + 0].isupper() and\ puzzle[CharIndex + 1].isupper() and\ puzzle[CharIndex + 2].isupper() and\ puzzle[CharIndex + 3].isupper() and\ puzzle[CharIndex + 4].islower() and\ puzzle[CharIndex + 5].isupper() and\ puzzle[CharIndex + 6].isupper() and\ puzzle[CharIndex + 7].isupper() and\ not puzzle[CharIndex + 8].isupper(): Output += puzzle[CharIndex + 4]print Output 得到结果为 linkedlist, 输入地址栏则进入下一关。 第四关http://www.pythonchallenge.com/pc/def/linkedlist.html 点进去之后，提示要把后缀改成 php, 改过之后打开一幅图片，点击图片提示说： and the next nothing is 44827 把地址栏改成 44827 之后，有出现类似提示。于是我们知道这样类似的循环估计得要进行几百次了，手工一次次改肯定不现实，上 Python 吧。 手工点几次之后会发现，地址和页面内容是有规律的。页面内容中的 nothing is 后面接的数字，总是跟在地址栏的 nothing= 后面。利用这个规律，代码如下。 12345678910111213import urllib, reurlbase = "http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing="REsearchNUM = re.compile("(\d+)").searchinitNUM = '12345'while True: webContents = urllib.urlopen(urlbase + initNUM).read() match = REsearchNUM(webContents) if match: initNUM = match.group(1) print "We're now going to", initNUM else: print webContents break 执行之后，会有一次停顿，需要你对某个数字除二然后重新开始，代码类似，这里就不想说了。 得到结果 peak.html, 进入下一关。 第五关http://www.pythonchallenge.com/pc/def/peak.html 进去之后发发现一幅图，图上有一座小山；图的下方有一行提示，让我们「读出它」。结合页面标题 peak hell, 知道它和 Python 的一个模块 pickle 音近。pickle 提供了两组函数，每组函数里面有各有两个互逆的操作。其中一组针对文件对象操作，另一组操作的则是 Python 的变量。针对文件对象的两个函数是 dump 和 load, 针对 Python 变量的则是 dumps 和 loads. 其中 dump(s) 将数据以某种方式存入文件（变量），而 load(s) 则将 dump(s) 存入的内容读出。 pickle 模块还有一个用 C 语言实现的版本，称为 cPickle。相对原本的 pickle 版本，cPickle 执行效率更高一些，但是无法被继承。 既然我们知道需要用 pickle 了，就要去找一个对象。按照这个小游戏的风格，右键查看源码，发现 http://www.pythonchallenge.com/pc/def/banner.p 这个文件。我们用 urllib 把它读下来，然后用 pickle 处理。 12345import urllibimport cPicklewebContents = urllib.urlopen('http://www.pythonchallenge.com/pc/def/banner.p').read()pwc = cPickle.loads(webContents)prints pwc 我们会发现，pwc 变量是一个复杂的结构。首先它是一个 list, 这个最外层的 list 里的数据是更小一层的 list; 小一层的 list 里的数据则是一个个 pairs. 如果你用过 *nix 系统，可能会对这种数据结构有些熟悉。仔细观察你会发现，每个小 list 里 pairs 里的数字之和正好都是 95, 而每个 pair 里都有一个长度为 1 的字符串。这意味着，整个大的 list 是一个文本块；每一个小的 list 是一行；每一个 pair 是重复若干次相应的字符。我们来输出它。 1print '\n'.join([''.join([p[0] * p[1] for p in row]) for row in pwc]) 我们会发现如图所示的内容。 其中显示的内容 channel, 正是我们的过关提示。 第六关http://www.pythonchallenge.com/pc/def/channel.html 打开网页后，出现的是一幅牛仔裤拉链的图。拉链的英文是 zip. 和 Python 相关的话，zip 可以是我们熟悉的 .zip 格式，也可以是 Python 内建的函数。考虑没有更多的提示信息，我们试试 chennel.zip. 123import urllib, StringIO, zipfileunzipped = zipfile.ZipFile(StringIO.StringIO(urllib.urlopen('http://www.pythonchallenge.com/pc/def/channel.zip').read()))unzipped.namelist() WOW! 好多…… len 看一下，居然有 910 个文件在里面，太可怕了。 等等！在刚才 namelist 的最后，有一个 readme.txt! 抓住救命稻草了有木有啊！ 1print unzipped.read('readme.txt') 出现提示说，从 90052 开始搞起。难道说又要重复第四关那种情况？ 12345678910111213import urllib, re, StringIO, zipfileunzipped = zipfile.ZipFile(StringIO.StringIO(urllib.urlopen('http://www.pythonchallenge.com/pc/def/channel.zip').read()))REsearchNUM = re.compile("(\d+)").searchinitNUM = '90052'while True: webContents = unzipped.read(initNUM + '.txt') match = REsearchNUM(webContents) if match: initNUM = match.group(1) print "We're now going to", initNUM else: print webContents break 提示说：Collect the comments. 囧，原来遍历一遍还不够啊。再次修改代码，去拿 txt 的注释去。 12345678910111213141516import urllib, re, StringIO, zipfileunzipped = zipfile.ZipFile(StringIO.StringIO(urllib.urlopen('http://www.pythonchallenge.com/pc/def/channel.zip').read()))REsearchNUM = re.compile("(\d+)").searchinitNUM = '90052'StrOutput = ''while True: webContents = unzipped.read(initNUM + '.txt') match = REsearchNUM(webContents) if match: initNUM = match.group(1) StrOutput += unzipped.getinfo(initNUM + '.txt').comment else: print webContents breakprint StrOutput 我们得到： HOCKEY 就是我们的过关代码吗？太天真了！ 进入 http://www.pythonchallenge.com/pc/def/hockey.html 之后得到提示「it’s in the air. look at the letters.」 提示说，空气里有这东西，并且让我们看看刚才那图案。我们发现 HOCKEY 分别由 oxygen 组成。看来 oxygen 才是下一级的入口！ 第七关http://www.pythonchallenge.com/pc/def/oxygen.html 打开来只有一幅图片： 额，这是啥？信息隐藏在中间那个灰度条中嘛？好吧我们来处理图片好了。Python Imaging Library 提供了 Image 模块，可以用来处理图片。 我们需要先下载安装。Image 模块提供了 getpixel 来获得某个像素点上的 RGBA 值（RGB 是颜色，A 是不透明度）。对于灰度图片来说，RGB 三者的值应该相等，我们可以据此提出所需的灰度部分，然后进行判断。 123456789101112131415161718192021222324252627282930import urllib, Image, StringIOdef if_grey_scale(RGBA): if RGBA[0] == RGBA[1] == RGBA[2]: return True else: return Falsedef if_grey_scale_line(linePx): for px in linePx[:10]: if not if_grey_scale(px): return False else: pass return Truedef get_line_px(image, width, heightNum): return [image.getpixel((i, heightNum)) for i in range(width)]imageWeb = Image.open(StringIO.StringIO(urllib.urlopen('http://www.pythonchallenge.com/pc/def/oxygen.png').read()))width, height = imageWeb.sizeif __name__ == '__main__': for i in range(height): if if_grey_scale_line(get_line_px(imageWeb, width, i)): print i print ''.join([chr(imageWeb.getpixel((j, i))[0]) for j in range(0,width)]) else: pass 我们发现最终的输出中，大部分字母都重复了 7 次。这说明图片中一个灰度小块的宽度是 7 个像素。我们可以取其中的一行（比如 47 行），然后将步长设置为 7: 1print ''.join([chr(imageWeb.getpixel((j, 47))[0]) for j in range(0,width,8)]) 这样就能得到最终的结果了：”smart guy, you made it. the next level is [105, 110, 116, 101, 103, 114, 105, 116, 121]”. 再次转换这个结果： 1print ''.join([chr(j) for j in [105, 110, 116, 101, 103, 114, 105, 116, 121]]) 得到：integrity. 这就是我们的通关密码！ 第八关http://www.pythonchallenge.com/pc/def/integrity.html 点开之后发现，有一幅图片，上面画着一只蜜蜂；图片下面是提示「隐藏的链接在哪里」。鼠标点击蜜蜂会进入到下一关的页面——不过没这么简单，要输入密码的。 输入密码提示单词 inflate, 意为膨胀。 至此，线索已经断了，于是回到第八关页面，右键查看网页源代码，发现注释部分有 12un: &apos;BZh91AY&amp;SYA\xaf\x82\r\x00\x00\x01\x01\x80\x02\xc0\x02\x00 \x00!\x9ah3M\x07&lt;]\xc9\x14\xe1BA\x06\xbe\x084&apos;pw: &apos;BZh91AY&amp;SY\x94$|\x0e\x00\x00\x00\x81\x00\x03$ \x00!\x9ah3M\x13&lt;]\xc9\x14\xe1BBP\x91\xf08&apos; BZh9 是 bz2 压缩的著名起始字符。结合 inflate, 不难联想到，我们的任务是通过 un 和 pw 后面的内容，用 bz2 解压得到 username 和 password. 123456un = 'BZh91AY&amp;SYA\xaf\x82\r\x00\x00\x01\x01\x80\x02\xc0\x02\x00 \x00!\x9ah3M\x07&lt;]\xc9\x14\xe1BA\x06\xbe\x084'pw = 'BZh91AY&amp;SY\x94$|\x0e\x00\x00\x00\x81\x00\x03$ \x00!\x9ah3M\x13&lt;]\xc9\x14\xe1BBP\x91\xf08'import bz2print "user name:", bz2.decompress(un)print "password:", bz2.decompress(pw) 得到结果 huge 和 file, 进入下一关，结束战斗。 第九关http://www.pythonchallenge.com/pc/return/good.html 打开网页后见到图片： 网页标题提示我们，连点成线。可是图片中的黑色方块连起来啥也不是。打开网页源码发现里面有提示 first + second = ?, 以及两个很长的 list. 莫非是要我们将这两个 list 当作是坐标来连线？用 PIL 的 ImageDraw 模块可以搞定。 1234567891011import Image, ImageDrawfirst = [ ... ]second = [ ... ]newImage = Image.new('RGB', (640,480))draw = ImageDraw.Draw(newImage)draw.line(first)draw.line(second)del drawnewImage.save('./good.png') 我们得到的结果是： 这是一头公牛——想想 NBA 里的公牛队——答案是 bull！ 第十关http://www.pythonchallenge.com/pc/return/bull.html 图片提示是一头牛，要求计算 len(a[30]). 标题提示说「你看啥呢」，看样子又是故技重施。我们点击图片上的牛，进入 http://www.pythonchallenge.com/pc/return/sequence.txt, 发现了一个不完整的数字序列：a = [1, 11, 21, 1211, 111221,. 所以我们的任务是找这个序列的规律，然后找到它的第 30 项然后返回长度。 乍一看，这是什么情况，小学奥数嘛？把序列放 Google 里搜索，发现这是一个叫做「外观序列」的东西，参见维基百科。意思是，序列的后一项是对前一项的描述。比如 11 表示「一个 1」，也就是前一项的 1；又比如 111221 表示「一个 1, 一个 2, 两个 1」，也就是前一项的 1211. 12345import reinitNum = '1'for each in range(30): initNum = "".join([str(len(i + j)) + i for i, j in re.findall(r"(\d)(\1*)", initNum)])print len(initNum) 这里写了一个用正则表达式处理的代码。其中的 (\d)(\1*) 表示匹配任意数字的连续，也就是匹配 111, 22 这样的序列。这样我们就能得到答案了。返回 5808. 第十一关http://www.pythonchallenge.com/pc/return/5808.html 打开页面后，是一幅图片： 唯一的提示是页面标题的”odd even”（奇偶）。 仔细查看图片，会发现图片的「颗粒化」现象很严重——几乎每一个像素点的旁边，都有黑色的颗粒。再结合「奇偶」这个提示，我们有理由猜想，图片是两张图拼接起来的，像素坐标的奇偶分别对应着一张图。 现在我们可以对图片的横纵坐标，分别取出奇数序列和偶数序列，然后生成四幅图片： x-odd, y-odd x-odd, y-even x-even, y-even x-even, y-odd 代码： 12345678910111213141516171819import Imageimport urllibimport StringIOim = Image.open(StringIO.StringIO(urllib.urlopen('http://huge:file@www.pythonchallenge.com/pc/return/cave.jpg').read()))w, h = im.sizeimgs = [Image.new(im.mode, (w / 2, h / 2)) for dummy in xrange(4)]imgs_load = [i.load() for i in imgs]org = im.load()for i in xrange(w): for j in xrange(h): org_pos = (i, j) new_pos = (i // 2, j // 2) imgs_load[i % 2 + j % 2 * 2 ][new_pos] = org[org_pos][imgs[i].save('%d.png' % i) for i in xrange(4)] 这样我们生成了四幅图片： 可以看到图中的 evil 字样。这就是下一关的钥匙。 第十二关http://www.pythonchallenge.com/pc/return/evil.html 打开网页后发现只有一张图片，看图片那样子似乎又要处理？网页标题提示 dealing evil, 即处理 evil. 打开网页源代码，没啥特别的信息。 等等！ 图片的名字是 http://www.pythonchallenge.com/pc/return/evil1.jpg, 那么有 evil1 的话，会不会还有 evil2, evil3, evil4 … 呢？ 在地址栏中把地址改成 evil2.jpg, 得到一张图片，上面歪歪曲曲地写着 not .jpg .gfx 于是把 evil2.jpg 改成 evil2.gfx, 得到一个十六进制文件。继续改 evil3.jpg, 得到图片说 no more evils… 嗯，提示说没有恶魔（复数）了，那么就是还有一个？继续改 evil4.jpg, 页面提示 Bert is evil! go back! 答案和 bert 有关嘛？进入地址 http://www.pythonchallenge.com/pc/return/bert.html, 页面提示说 Yes! Bert is evil! 看来答案果然和 bert 有关。Google 搜索发现 BERT 是 Bit Error Ratio Test 的缩写（比特误码率测试）。我们先前得到的 gfx 文件是一个十六进制的文件（换言之，可以很简单地转换成二进制文件），这就和所谓的比特误码率很相关了。所以难道信息隐藏在 BERT 里面吗？Google 许久未果，没发现和题目有什么有什么关系。看样子又要卡几天了。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LaTeX Tips】选择加载的图片类型]]></title>
    <url>%2F2013%2F12%2F07%2FLaTeX-Choose-picture-format%2F</url>
    <content type="text"><![CDATA[我们在排版很长的文章或者书籍的时候，编译一次通常需要花费很长时间，并且生成文件的体积也会比较大。而通常我们会希望文档中的图片足够高清，但在写文章的时候又希望能节省时间（同时声称小体积的文件供预览）。因此有一个快速选择图片类型的方法就变得很有必要了。 在 LaTeX 中，相同文件名加载图片的顺序是： 1.png .pdf .jpg .mps .jpeg .jbig2 .jb2 .PNG .PDF .JPG .JPEG .JBIG2 .JB2 而这一顺序存储在宏 \Gin@extensions 之中。因此，若是在相同目录下同时含有 dummy.png 和 dummy.pdf, 编译引擎将会选择前者（假设支持）。你可以用 \DeclareGraphicsExtensions 命令来声明并改变这些扩展名的顺序，比如： 1234\DeclareGraphicsExtensions&#123; .png,.PNG,% .pdf,.PDF,% .jpg,.mps,.jpeg,.jbig2,.jb2,.JPG,.JPEG,.JBIG2,.JB2&#125; 这样就能确保 png 文件在 pdf 文件之前被载入了——在最终输出之时只需要交换两行的顺序即可。 另外 grfext 宏包提供了 \PrependGraphicsExtensions 命令实现同样的效果： 12\usepackage&#123;grfext&#125;\PrependGraphicsExtensions*&#123;.png,.PNG&#125; 选自 egreg 在 TeX.SX 上的回答。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Graphicx</tag>
        <tag>Images</tag>
        <tag>Format</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LaTeX Tips】listings 中高亮定界符内的文本而不高亮定界符本身]]></title>
    <url>%2F2013%2F12%2F05%2FLaTeX-Emphasize-color-contents-between-two-delimiters-in-listings-but-not-the-delimiters-themselves%2F</url>
    <content type="text"><![CDATA[背景图里的代码高亮十分漂亮，用 listings 宏包实现的难点在于如何高亮某种定界符内的内容，而定界符本身保留 basicstyle 设定的样式。 123456789101112131415\documentclass&#123;article&#125;\usepackage&#123;listings&#125;\usepackage&#123;xcolor&#125;\lstset&#123; delim = [s][\ttfamily\color&#123;orange&#125;]&#123;$&#125;&#123;$&#125;&#125;\begin&#123;document&#125;\begin&#123;lstlisting&#125;\documentclass&#123;article&#125;\usepackage&#123;amsmath&#125;\begin&#123;document&#125;$E = mc^2$\end&#123;document&#125;\end&#123;lstlisting&#125;\end&#123;document&#125; 效果： $ 之间的公式随着 $ 本身都变成了橘色。 解决问题的方法，可以参照 David Carlisle 在 TeX.SX 上对这个问题的回答。 我们可以定义这样一个 listings 样式： 1234\def\beginlstdelim#1#2#3&#123; \def\endlstdelim&#123;#2\egroup&#125;% \ttfamily#1\bgroup\color&#123;#3&#125;\aftergroup\endlstdelim%&#125; 它有三个参数，第一个参数是定界符的左边，第二个是定界符的右边，第三个是高亮的颜色。我们可以这样使用： 12345678910111213141516171819202122232425262728\documentclass&#123;article&#125;\usepackage[usenames,dvipsnames]&#123;xcolor&#125;\usepackage&#123;listings&#125;\def\beginlstdelim#1#2#3&#123; \def\endlstdelim&#123;#2\egroup&#125;% \ttfamily#1\bgroup\color&#123;#3&#125;\aftergroup\endlstdelim%&#125;\lstset&#123; moredelim = **[is][\beginlstdelim&#123;\$&#125;&#123;\$&#125;&#123;orange&#125;]&#123;\$&#125;&#123;\$&#125;, moredelim = **[is][\beginlstdelim&#123;\&#123;&#125;&#123;\&#125;&#125;&#123;ForestGreen&#125;]&#123;\&#123;&#125;&#123;\&#125;&#125;, moredelim = **[is][\beginlstdelim&#123;[&#125;&#123;]&#125;&#123;red&#125;]&#123;[&#125;&#123;]&#125;,&#125;\begin&#123;document&#125;\begin&#123;lstlisting&#125;\documentclass&#123;article&#125;\usepackage&#123;amsmath&#125;\begin&#123;document&#125;$E = mc^2$&#123;E = mc^2&#125;[E = mc^2]\end&#123;document&#125;\end&#123;lstlisting&#125;\end&#123;document&#125; 效果是这样的： 输出效果 The code in the background figure is very pretty. In terms of using listings to reproduce this beautiful style, nodus turns out to be how to color contents between two delimiters but not the delimiters themselves (remain basicstyle). If we have the code following: 123456789101112131415\documentclass&#123;article&#125;\usepackage&#123;listings&#125;\usepackage&#123;xcolor&#125;\lstset&#123; delim = [s][\ttfamily\color&#123;orange&#125;]&#123;$&#125;&#123;$&#125;&#125;\begin&#123;document&#125;\begin&#123;lstlisting&#125;\documentclass&#123;article&#125;\usepackage&#123;amsmath&#125;\begin&#123;document&#125;$E = mc^2$\end&#123;document&#125;\end&#123;lstlisting&#125;\end&#123;document&#125; we will get: The equation between $s was colored by orange, so did $s themselves. Inspired by David Carlisle‘s answer to this question, TeX.SX, Jubobs defined a new listings style: 1234\def\beginlstdelim#1#2#3&#123; \def\endlstdelim&#123;#2\egroup&#125;% \ttfamily#1\bgroup\color&#123;#3&#125;\aftergroup\endlstdelim%&#125; It has three arguments: the first one should be the left delimiter, the second one should be the right one, and the third one specifying the color. Let’s take a example: 12345678910111213141516171819202122232425262728\documentclass&#123;article&#125;\usepackage[usenames,dvipsnames]&#123;xcolor&#125;\usepackage&#123;listings&#125;\def\beginlstdelim#1#2#3&#123; \def\endlstdelim&#123;#2\egroup&#125;% \ttfamily#1\bgroup\color&#123;#3&#125;\aftergroup\endlstdelim%&#125;\lstset&#123; moredelim = **[is][\beginlstdelim&#123;\$&#125;&#123;\$&#125;&#123;orange&#125;]&#123;\$&#125;&#123;\$&#125;, moredelim = **[is][\beginlstdelim&#123;\&#123;&#125;&#123;\&#125;&#125;&#123;ForestGreen&#125;]&#123;\&#123;&#125;&#123;\&#125;&#125;, moredelim = **[is][\beginlstdelim&#123;[&#125;&#123;]&#125;&#123;red&#125;]&#123;[&#125;&#123;]&#125;,&#125;\begin&#123;document&#125;\begin&#123;lstlisting&#125;\documentclass&#123;article&#125;\usepackage&#123;amsmath&#125;\begin&#123;document&#125;$E = mc^2$&#123;E = mc^2&#125;[E = mc^2]\end&#123;document&#125;\end&#123;lstlisting&#125;\end&#123;document&#125; It’s output: The Output.]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Highlight</tag>
        <tag>Listings</tag>
        <tag>Delimiter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LaTeX Tips】如何复写定理]]></title>
    <url>%2F2013%2F12%2F04%2FLaTeX-Recalling-a-theorem%2F</url>
    <content type="text"><![CDATA[在书写定理时，我们可能会将定理的结论写在前面，而后展开对它的讨论。定理复杂的证明过程，通常会放在后文的附录中。这时候，我们就需要复写这个定理。 下面这个来自 TeX.SX 的方法由 lockstep 提供。 123456789101112131415161718192021222324252627\documentclass&#123;article&#125;\usepackage&#123;thmtools&#125;\usepackage&#123;thm-restate&#125;\usepackage&#123;hyperref&#125;\usepackage&#123;cleveref&#125;\declaretheorem[name=Theorem,numberwithin=section]&#123;thm&#125;\begin&#123;document&#125;\section&#123;First&#125;\begin&#123;restatable&#125;[Goldbach's conjecture]&#123;thm&#125;&#123;goldbach&#125;\label&#123;thm:goldbach&#125;Every even integer greater than 2 can be expressed as the sum of two primes.\end&#123;restatable&#125;\section&#123;Second&#125;We recall \cref&#123;thm:goldbach&#125;:\goldbach*\end&#123;document&#125; thmtools 包里的 thm-restate 子包提供了 restatable 环境。下面的例子里，借用了 hyperref 宏包（超链接）和 cleveref 宏包（提供了 \cref 宏，可以加载正确的定理样式）。具体可以查看 thmtools 宏包文档的 1.4 节。 效果： 复写定理的效果展示 We sometimes hope that we could show and discuss a theorem, without proof it. However, in appendix, we mey need to recall that theorem and then write down the details of proof. The following context comes from TeX.SX that is provided by lockstep. 123456789101112131415161718192021222324252627\documentclass&#123;article&#125;\usepackage&#123;thmtools&#125;\usepackage&#123;thm-restate&#125;\usepackage&#123;hyperref&#125;\usepackage&#123;cleveref&#125;\declaretheorem[name=Theorem,numberwithin=section]&#123;thm&#125;\begin&#123;document&#125;\section&#123;First&#125;\begin&#123;restatable&#125;[Goldbach's conjecture]&#123;thm&#125;&#123;goldbach&#125;\label&#123;thm:goldbach&#125;Every even integer greater than 2 can be expressed as the sum of two primes.\end&#123;restatable&#125;\section&#123;Second&#125;We recall \cref&#123;thm:goldbach&#125;:\goldbach*\end&#123;document&#125; The thm-restate package which is part of thmtools offers a restatable environment. In the following example, I also use hyperref and cleveref (its \cref macro automatically adds the correct theorem type). See section 1.4 of the thmtools manual for details. 效果： Recalling a theorem.]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Theorem</tag>
        <tag>Tecall</tag>
        <tag>THM-RESTATE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LaTeX Tips】在文本的同一行开始一个列表环境]]></title>
    <url>%2F2013%2F12%2F02%2FLaTeX-How-to-start-itemize-on-same-line-as-text%2F</url>
    <content type="text"><![CDATA[有时我们会希望在文本的同一行开始一个列表环境，而非是使用默认的在下一行开始。同时，我们会希望列表环境的标签仍旧在垂直方向上对齐。 LaTeX 提供的 itemize 环境和 enumerate 环境事实上都是 list 环境的一种，但 itemize 和 enumerate 不允许修改 \labelsep 等距离。因此，要达到我们的目的，我们要么使用原始的 list 环境，要么使用 description 环境——它允许修改这些距离。 代码： 123456789101112131415161718192021\documentclass&#123;article&#125;\usepackage&#123;enumitem&#125;\usepackage&#123;lipsum&#125; % just for the example\newlength&#123;\jeroenlen&#125;\newenvironment&#123;example&#125; &#123;\settowidth&#123;\jeroenlen&#125;&#123;\textbf&#123;Example:&#125;&#125;% \begin&#123;description&#125;[leftmargin=\jeroenlen,labelwidth=0pt,labelsep=0pt] \item[\textbf&#123;Example:&#125;]% \begin&#123;itemize&#125;[leftmargin=1.5em,labelsep=.5em]&#125; &#123;\end&#123;itemize&#125;\end&#123;description&#125;&#125;\begin&#123;document&#125;\lipsum[2]\begin&#123;example&#125;\item Such and such\item So and so\item Enough\end&#123;example&#125;\lipsum[3]\end&#123;document&#125; 效果： Sometimes, we hope that an itemize environment could start at the same line of certain text, rather than start at the next line as the default does. Moreover, the labels should be vertically aligned. The itemize and enumerate environment provided by the standard LaTeX are both descendant of list environment, however, length, such as \labelsep, are prevented from modifying. Thus, we have two choices: using list or using description whose length chould be modified. Code: 123456789101112131415161718192021\documentclass&#123;article&#125;\usepackage&#123;enumitem&#125;\usepackage&#123;lipsum&#125; % just for the example\newlength&#123;\jeroenlen&#125;\newenvironment&#123;example&#125; &#123;\settowidth&#123;\jeroenlen&#125;&#123;\textbf&#123;Example:&#125;&#125;% \begin&#123;description&#125;[leftmargin=\jeroenlen,labelwidth=0pt,labelsep=0pt] \item[\textbf&#123;Example:&#125;]% \begin&#123;itemize&#125;[leftmargin=1.5em,labelsep=.5em]&#125; &#123;\end&#123;itemize&#125;\end&#123;description&#125;&#125;\begin&#123;document&#125;\lipsum[2]\begin&#123;example&#125;\item Such and such\item So and so\item Enough\end&#123;example&#125;\lipsum[3]\end&#123;document&#125; And the output:]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LaTeX Tips】如何确定某个宏定义的位置]]></title>
    <url>%2F2013%2F11%2F20%2FLaTeX-How-to-find-out-where-a-macro-is-defined%2F</url>
    <content type="text"><![CDATA[我们在排错的时候，经常希望知道出错的宏是在哪里定义的，然后通过比对定义和现有情况判断错误原因。 LeoLiu 在 TeX.SX 给出了一个利用 filehook 宏包实现的方法，效果拔群！当然，方法有些讨巧。 代码： 1234567891011121314151617181920\documentclass&#123;article&#125;\usepackage&#123;filehook,currfile&#125;\newwrite\finder\immediate\openout\finder=\jobname.fnd\def\searchmacro#1&#123; \AtBeginOfFiles&#123;\ifdefined#1 \expandafter\def\csname \currfilename:found\endcsname&#123;&#125;% \fi&#125; \AtEndOfFiles&#123;\ifdefined#1 \unless\ifcsname \currfilename:found\endcsname \immediate\write\finder&#123;found in '\currfilename'&#125;% \fi\fi&#125;&#125;\searchmacro\url\usepackage&#123;hyperref&#125;\begin&#123;document&#125;dummy\end&#123;document&#125; 编译后，在 \jobname.fnd 里我们能找到 12found in &apos;url.sty&apos;found in &apos;hyperref.sty&apos; 也就是说，\url 是在 url.sty 里定义的，而 url.sty 被 hyperref.sty 调用。 We would be glad to know where a certain macro is defined, when we are debugging. LeoLiu provided a method by using the package filehook, on the website TeX.SX. It’s really great! The code is somewhat tricky: 1234567891011121314151617181920\documentclass&#123;article&#125;\usepackage&#123;filehook,currfile&#125;\newwrite\finder\immediate\openout\finder=\jobname.fnd\def\searchmacro#1&#123; \AtBeginOfFiles&#123;\ifdefined#1 \expandafter\def\csname \currfilename:found\endcsname&#123;&#125;% \fi&#125; \AtEndOfFiles&#123;\ifdefined#1 \unless\ifcsname \currfilename:found\endcsname \immediate\write\finder&#123;found in '\currfilename'&#125;% \fi\fi&#125;&#125;\searchmacro\url\usepackage&#123;hyperref&#125;\begin&#123;document&#125;dummy\end&#123;document&#125; After compiling, we will get 12found in &apos;url.sty&apos;found in &apos;hyperref.sty&apos; in \jobname.fnd. That is to say, \url is defined in url.sty, which is inputed by hyperref.sty.]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Macro</tag>
        <tag>Package</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笨办法学 Python 中译版]]></title>
    <url>%2F2013%2F11%2F18%2Fpyhardway%2F</url>
    <content type="text"><![CDATA[这是一本优秀的 Python 入门教材，作者为 Zed A. Shaw, 译者为 WangDingwei。原文发布在 这里，译文发布在 这里. 因未能找到译本的 PDF 版，我使用 LaTeX 排版了这本书。 本书 PDF 版未经校对，翻译和排版漏洞在所难免，欢迎留言以便修正。 掀桌！刚排完发现这本书已经有第三版了，我排版的只是第一版……嘛，不过内容不算过时，之后可能会接着排第三版吧…… PDF 文档下载 LaTeX 源码]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PyHardWay</tag>
        <tag>Translation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[极致优雅——Sublime Text 简介/入门/技巧]]></title>
    <url>%2F2013%2F11%2F11%2FSublime-elegant%2F</url>
    <content type="text"><![CDATA[Sublime Text 是一个顶尖的代码、标记语言、随笔编辑器。你会爱上它华丽的界面、超凡的功能和令人惊叹的表现。—http://www.sublimetext.com/ 简介与初步在折腾过无数 IDE 和被无数编辑器折磨过之后，我毅然投入了 Sublime Text (ST for Short)的怀抱。如剑客渴望名剑一样，ST 就是我渴望的誓约胜利之剑，尽管它的售价高达 70 USD^1. 下载与安装你可以在ST 官网找到醒目的下载链接，对于 Windows 系统，当前正式版为 2.02, 最新测试版为 ST 3 build 3047. 对于 ST 3 build 3047, 这里提供一个便携版的本站下载, 这一版本来自官方，这里仅仅是提供另一个下载点。 ST 的安装不必多说，对于可执行文件按照步骤来即可，对于便携版本只需解压到希望的目录下即可。 这里我们讨论在 Windows 系统下的操作，我们假定 ST 根目录为 1C:\ST\ 中文化对于希望将编辑器界面汉化的，可以下载汉化包 for 3047并置于 C:\ST\Data\Installed Packages\ 目录下即可。 选择一个合适的字体在 Windows 系统下，Sublime 默认会使用 Consola 这个字体。作为英文字体来说，它是一个等宽字体，并且设计得十分适合写代码。但很可惜，因为一些原因，尽管英文字体优秀，中文字体默认却使用宋体。尽管这也是一个优秀的字体，但是看久了会很累，并不适合编程使用。 基于这个理由，我将 Consola 和微软雅黑字体合二为一，制作了一个名为 Adina 的字体。可以在这里下载. ^2 安装好字体之后，你可以在 Sublime Text 的窗口中，在菜单栏上找到 Preferences - ‘Settings - User’. 在打开的文件之中增加： 123&quot;font_face&quot;: &quot;Adina&quot;,&quot;line_padding_bottom&quot;: -1,&quot;line_padding_top&quot;: 0, 这样，Sublime Text 就能使用 Adina 字体了。 安装 Package ControlPackage Control 是一个用来管理插件的插件。它能够按照所需启用/停用插件，安装/卸载插件，并支持自动更新插件，十分强大。因此，它几乎是使用 ST 必备的插件。 Package Control 在 ST 控制面板中的示例. 安装方法如下： 点击 Preference/Browse Packages; 跳转到上一级目录，并进入 Installed Packages/; 下载 Control.sublime-package 并置于 Installed Packages/; 重启 ST. 至此，在 Preferences 下就能看到 Package Control 的按钮了，使用 Ctrl + Shift + p (C-S-p for Sort) 调出命令面板，输入 Package Control: 即可看到它的全部功能。这一命令面板在你今后的使用中会不断给你带来惊喜。 一个使用 Package Control 安装插件包的例子在这里. 激活码对于 ST 这样一柄神剑来说，使用盗版并不是一件值得提倡的事情，70 USD 的价格也确实值得上它的价值，何况作者提供了永久试用的功能。所以最好还是买吧！ 当然，朽木博客提供了一份可用的激活码。 入门这一节的大部分内容，来自官网首页和 Nettuts+ 对 Sublime Text 2 的介绍。 记号约定从这里开始，我们将会遇到许多的快捷键。考虑到 ST 是跨平台的，为了统一符号，作如下约定 记号 Windows Mac OS C- Ctrl Command S- Shift Shift A- Alt Option —- C-c Ctrl + c Command + c C-S-p Ctrl + Shift + p Command + Shift + p —- C-kk Ctrl + k, Ctrl + k Command + k, Command + k C-l, v Ctrl + l, v Command + l, v 最具特色的Goto AnythingGoto Anything 使你可以通过敲击少量按键打开任意文件，并跳转至某一符号、行或单词。 按下 C-p, 然后 输入文件名的某一部分以打开文件； 输入 @ 跳转至某一符号，# 搜索文件，: 跳转至行。[^3] 也可以组合使用，比如 tp@tf 会把你带到 text_parser.py 这个文件的 read_file 函数位置。类似，tp:100 会把你带到这一文件的第 100 行。 Multiple Selections你可以通过 Multiple Selections 功能同时更改十个位置，而非是在十个位置分别做十次同样的操作。这允许你交互地对很多行进行更改，比如修改变量名，操作一系列文件。 C-S-l 能将选中的部分分离成行，C-d 会选中下一个重现词。你也可以参考这里，学习如何使用鼠标进行 Multiple Selections. Command PaletteCommand Palette 整合了并不常用的功能，比如排序、改变语法规则、改变缩进设置。只需要简单敲击键盘，你就能找到你想要的功能；在导航栏上寻找功能或是记忆晦涩的快捷键将成为历史。 你可以通过 C-S-p 来打开 Command Palette. Distraction Free Mode当你需要集中精力的时候，Distraction Free Mode 正是你所需的。Distraction Free Mode 将打开全屏模式，除了你的文档之外屏幕上一无所有。你可以根据所需，增加 UI 中的元素。 你可以点击 View - Distraction Free Mode 进入 Distraction Free Mode.[^4] Split Editing尽最大可能利用你的宽屏。你可以将屏幕分成任意多的栏或行，编辑不同的文件或者相同文件的不同部分。 对于具有多显示器的机器，你可以在各个屏幕上分别使用 Split Editing, 或者将每一个屏幕当做是 Split Editing 的一个窗口。 在 View - Layout 菜单中可以找到 Split Editing 的选项。 Instant Project SwitchST 中的 projects 能捕捉工作空间中的所有内容，包括修改且尚未保存的文件。你可以以类似 Goto Anything 的方式瞬间切换 projects. 这种时候不会出现「未保存」的提示——所有的修改，在下一次打开 project 的时候都会被复原。 Plugin APIST 有一个基于 Python 的强大插件 API. 同时，ST 还有一个内建的 Python 控制台，以供随时进行交互测试。 Customize AnythingST 中的任何东西——包括按键绑定、菜单、代码片段、宏、自动补全——都是通过 JSON 文件来控制的。这种机制使得你能够灵活地为每一文件类型和项目来进行不同的配置。 Cross PlatformST 在 OS X, Windows 和 Linux 上都能工作。你可以使用同一许可证在任意系统上使用 ST. 更加详细的介绍参考 Nettuts+ 对 Sublime Text 2 的介绍的译文，由 Lucifr 翻译。 快捷键文件操作/跳转 按键 作用 C-p 跳转 C-g 按行跳转 C-r 按标记跳转[^5] C-; 按搜索关键词跳转 C-S-p 打开命令面板 C-o 打开文件 C-s 保存 C-S-s 另存为 C-w 关闭当前文件 C-S-w 关闭所有打开文件 C-`[^6] 打开/关闭 Python 命令行 界面切换 按键 作用 \&lt;F11> 切换全屏 S-\&lt;F11> 切换免打扰模式 C-kb 开关侧边栏 A-S+\&lt;NUM> 分为 \&lt;NUM> 栏 A-\&lt;NUM> 切换至打开的第 \&lt;NUM> 个文件 C-\&lt;Tab> 切换 Tab C-S-\&lt;Tab> 向前切换 Tab C-i 显示底部面板 文本编辑 按键 作用 C-a 全选 C-c 选中后复制 C-x 选中后剪切 C-v 粘贴 C-z 撤销 C-y 恢复撤销 C-u 软撤销（可以撤销光标移动） C-S-u 恢复软撤销 C-f 查找 C-S-f 在所有打开文件中查找 C-h 替换 C-S-F 查找并替换 \&lt;F3> 查找下一个 S-\&lt;F3> 查找前一个 C-t 光标所在位置的左右字符或单词互换 C-\&lt;Backspace> 删除一个单词 C-ku 改为大写 C-kl 改为小写 C-d 选中光标位单词，继续按键复选下一重复单词 C-l 选中当前行，继续按键继续选定下一行 A-\&lt;F3> 复选所有重复单词 S-\&lt;右键拖拽> 多行光标/多行复选 C-\&lt;左键拖拽> 复选 C-S-\&lt;Space> 选定光标所在范围 C-A-\&lt;↑> 向上多行光标 C-A-\&lt;↓> 向下多行光标 \&lt;Tab> 选中部分缩进 S-\&lt;Tab> 选中部分取消缩进 C-] 选中部分缩进 C-[ 选中部分取消缩进 代码编辑 按键 作用 C-m 光标移动至匹配括号位置 C-S-m 选择括号包含的内容，继续按键选定上一级括号内的内容 C-S-[ 折叠 C-S-] 展开折叠 C-A-] 选中部分代码自动对齐 C-/ 注释/取消注释行 或 注释/取消注释选定部分 C-S-/ 注释/取消注释选定部分 整行编辑 按键 作用 C-kk 从光标位置开始，删除到行尾 C-k\&lt;Backspace> 从光标位置开始，删除到行首 C-S-k 删除整行 C-S-\&lt;Backspace> 删除整行 C-S-\&lt;↑> 光标所在行与上行互换 C-S-\&lt;↓> 光标所在行与下行互换 C-S-d 复制光标所在行，并插入在当前行之前 C-\&lt;Enter> 在光标所在行的后面插入新行，并移动光标 C-S-\&lt;Enter> 在光标所在行的前面插入新行，并移动光标 标记 按键 作用 C-\&lt;F2> 设置/去除标记 \&lt;F2> 跳转至下一个标记位置 S-\&lt;F2> 跳转至上一个标记位置 C-S-\&lt;F2> 清除所有标记 [^3]: 你可以按下 C-r 来跳转到符号，或是按下 C-g 跳转到行。[^4]: 按下 S-F11 可以进入/退出 Distraction Free Mode, 按下 F11 可以进入/退出普通的全屏模式。[^5]: 根据当前设定的语法规则有不同，例如，在 Markdown 模式下，会按照标题跳转；在 Python 等程序语言下，会按照函数名称定义来跳转；在 LaTeX 下，会按照章节标题/标签来跳转。[^6]: 这个键在数字 1 的左边，是英文的「反引号」。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Sublime</tag>
        <tag>Tricks</tag>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LaTeX Tips】指定 include 的路径]]></title>
    <url>%2F2013%2F11%2F05%2FLaTeX-include-path%2F</url>
    <content type="text"><![CDATA[问题的描述在排版很长的文章时，为了便于组织结构，我们通常会将文章的正文部分分章节保存在其它的 .tex 文件中，最后在主控文档中使用 \input 或者 \include 命令来加载这些文档（参见\input 和 \include 的区别）。 如果我们将这些章节源文件保存在指定目录下，比如 ./body/, 那么实际使用时，我们必须在每一次调用 \input 或者 \include 时都输入这一目录。这无疑是麻烦的。我们希望找到一种解决方法，可以免去输入路径。 解决方法参考 qingkuan 的回答, 我们可以在导言区添加如下内容以达到目的： 1234567\makeatletter\providecommand*\input@path&#123;&#125;\newcommand\addinputpath[1]&#123; \expandafter\def\expandafter\input@path \expandafter&#123;\input@path&#123;#1&#125;&#125;&#125;\addinputpath&#123;body/&#125;\makeatother]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Path</tag>
        <tag>Include</tag>
        <tag>Input</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LaTeX Tips】复制代码时避免复制行号的正确方法]]></title>
    <url>%2F2013%2F11%2F04%2FLaTeX-listings-copy%2F</url>
    <content type="text"><![CDATA[问题的描述用 listings 包排版源代码时通常为了便于说明，会显示代码的行号，但是，我们在文档复制的时候却发现，复制代码的时候，同时会把行号也复制出来了，如下： 我们想实现如下的复制，更便于读者提取文档中的源代码进行相关测试。 一次尝试LaTeX studio 提供了一个解决方案。但是该方案是有问题的，因为 \thelstnumber 在很多地方都要用到，所以直接重定义这个宏是很危险的——比如，无法和 hyperref 宏包一起使用。下面的测试代码说明了这个问题： 12345678910111213\documentclass&#123;minimal&#125;\usepackage&#123;hyperref&#125;\usepackage&#123;listings&#125;\usepackage&#123;accsupp&#125;\renewcommand&#123;\thelstnumber&#125;&#123;\protect\BeginAccSupp&#123;ActualText=&#123;&#125;&#125;\arabic&#123;lstnumber&#125;\protect\EndAccSupp&#123;&#125;%&#125;\lstset&#123;numbers = left&#125;\begin&#123;document&#125;\begin&#123;lstlisting&#125;\foo\end&#123;lstlisting&#125;\end&#123;document&#125; 最终的解决更健壮的办法，可以定义一个新的命令，然后用 listings 宏包的 numberstyle 选项来加载这一命令，如下 1234567891011\documentclass&#123;minimal&#125;\usepackage&#123;hyperref&#125;\usepackage&#123;listings&#125;\usepackage&#123;accsupp&#125;\newcommand\emptyaccsupp[1]&#123;\BeginAccSupp&#123;ActualText=&#123;&#125;&#125;#1\EndAccSupp&#123;&#125;&#125;\lstset&#123;numbers = left, numberstyle=\emptyaccsupp&#125;\begin&#123;document&#125;\begin&#123;lstlisting&#125;\foo\end&#123;lstlisting&#125;\end&#123;document&#125;]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Listings</tag>
        <tag>Line number</tag>
        <tag>Copy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 入门中译版]]></title>
    <url>%2F2013%2F11%2F02%2FPython-tutorial-zh_cn%2F</url>
    <content type="text"><![CDATA[这份文档是 Python 官方入门的中文翻译版（主页）。翻译工程属于 O.B.P 计划的一部分，主要翻译者为刘鑫与 DocsPy3zh, 校对为 Zoom.Quiet. 文本的 LaTeX 化输出和版式设计是属于我的成果。 目前二校已经完成，此处发布的为二校稿。我个人因时间安排问题，暂时没有能力进行精校。 PDF 文档下载 The_Python_Tutorial_zh-cn.pdf LaTeX 源码已上传至 bitbucket, 欢迎提出改进意见。]]></content>
      <categories>
        <category>Algorithm and Computer Science</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Translation</tag>
        <tag>Tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道三空题的解释]]></title>
    <url>%2F2013%2F10%2F30%2FGRE-wisest-men%2F</url>
    <content type="text"><![CDATA[题目But they pay little attention to the opposite and more treacherous failing: false certainty, refusing to confess their mistakes and implicitly claiming (i) , thereby embarrassing the nation and undermining the Constitution, which established various mechanisms of self-correction on the premise that even the wisest men are sometimes wrong and need, precisely when they find it most (ii) , the benefit of (iii) process. BLANK i BLANK ii BLANK iii (A) infallibility (D) discomfiting (G) an adaptable —- (B) immunity (E) expedient (H) a remedial —- (C) impartiality (F) imminent (I) an injudicious —- {: rules=”groups”} 解析首先整个句子的结构是这样的，冒号和 which 是两个分割点，冒号表示前后句子句意重复，后面解释前面；which 定从修饰前面的 Constitution （宪法）。 第一空填入一个名词，作为 claiming 的宾语。同时 and 并列 refusing to confess their mistakes 和 implicitly claiming (i), 作为 confess 的宾语。后面的 thereby 一直到 which 是这些 mistakes 的结果。拒绝承认错误 = 声明自己没有错误。所以第一空填入一个不是错误的词。infallibility 无错误的，immunity 免疫力，impartiality 公正的。选 A. 第二空和第三空是 which 从句中的句子。 which established various mechanisms of self-correction on the premise that even the wisest men are sometimes wrong and need, precisely when they find it most (ii), the benefit of (iii) process. that 同位语从句，就是 premise （前提）的内容。 第二空所在的部分是个插入语，去掉插入语部分先看第三空： which established various mechanisms of self-correction on the premise that even the wisest men are sometimes wrong and need the benefit of (iii) process. mechanisms = process self-correction = (iii) 所以第三空填入一个和 self-correction 相对应的词。adaptable 可适应的，remedial 挽救性的，injudicious 不明智的。选 H. 再来看第二空。 precisely when they find it most (ii) they 指代 wisest men, 与句首的 they 和 their mistakes 的 their 指代的人重复。when 前面的 wrong 显然与前面的 mistakes 重复。所以 when 从句的内容就应该体现 thereby 后面的内容。 they = wisest men it = wrong = mistakes (ii) = embarrassing / undermining discomfiting 尴尬的，expedient 权宜的，imminent 迫近的。选 D. 答案 ADH. 翻译：但是他们对相反的且更背信弃义的那种失败却极少关注：即使是错的，他们也拒绝承认错误，并且隐晦地表示自己是没错的。这种行为因此使得国家蒙羞并削弱了宪法，而宪法，基于即使是最聪明的人有时——精确地讲，当他们发现这些错误非常尴尬的时候——也会犯错并且需要挽救性的过程带来的好处这一假设，建立了一些列的自我纠正机制。]]></content>
      <categories>
        <category>GRE</category>
      </categories>
      <tags>
        <tag>Text Completion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LaTeX Tips】2013 清華大學（臺灣） LaTeX 研習投影片——蔡炎龍]]></title>
    <url>%2F2013%2F10%2F18%2FLaTeX-Tsinghua-TW%2F</url>
    <content type="text"><![CDATA[本文原载于 LaTeXstudio. 这是台湾清华大学 2013 年在清大『LaTeX 研習』上使用的投影片，内容非常实用易懂。 投影共分成四个部分： 基础速成 表格和进阶数学式子 基本排版、修饰、自订命令 用 Beamer 做简报 截图：]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>LaTeX speech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LaTeX Tips】LaTeX 相关工具网站]]></title>
    <url>%2F2013%2F10%2F18%2FLaTeX-websites%2F</url>
    <content type="text"><![CDATA[查询符号代码http://detexify.kirelabs.org/classify.html 允许你用鼠标绘制符号的样子，然后为你查询对应的代码和所需的宏包。 手写公式识别为 LaTeX 公式代码MyScript 有多个功能，其中之一就是能将手写的公式识别为 LaTeX 代码。测试表明识别公式效率一般，准确度尚可，对于复杂矩阵几乎无力识别。 在线 LaTeX 编译math.sinica 是台湾中央研究院的支持中文的在线编译，支持中文。 输入 LaTeX 产生数学公式图片http://www.codecogs.com/latex/eqneditor.php 以及 http://www.sciweavers.org/free-online-latex-equation-editor]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Tool</tag>
        <tag>Website</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LaTeX Tips】LaTeX 公式上下花括号的交错]]></title>
    <url>%2F2013%2F10%2F18%2FLaTeX-brace-overlap%2F</url>
    <content type="text"><![CDATA[我们知道，LaTeX 数学模式下，为式子的上下添加花括号可以用 \overbrace 和 underbrace 这两个命令。他们可以互相嵌套，但是不能交错使用。这一特性有时候会给我们带来麻烦。 为了排版如上图所示的效果，我们需要用 \rlap 重叠，同时用 \phantom 占位，见下面的代码。 1234567\documentclass&#123;article&#125;\usepackage&#123;amsmath&#125;\begin&#123;document&#125;\[ \rlap&#123;$\overbrace&#123;\phantom&#123;a \to b&#125;&#125;$&#125; a \to \underbrace&#123;b \to c&#125;\]\end&#123;document&#125;]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Overbrace</tag>
        <tag>Underbrace</tag>
        <tag>Rlap</tag>
        <tag>Phantom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LaTeX Tips】关于行距的研究]]></title>
    <url>%2F2013%2F10%2F17%2FLaTeX-Linespace%2F</url>
    <content type="text"><![CDATA[baseline 是什么TeX 中的每个字符都放在一个 box 里。每个 box 有 base （参考点）、width（宽度）、height（高度）、depth（深度），其中 height + depth = totalheigth （总高）。 若干字符的 box 组成一个词的 box ，同样这个 box 也有这样几个参数。TeX 断行之后，会把这一行的所有盒子的 base 连接起来，以保证改行的内容在一个基准线上，连接成的线段就是 baseline. 如图所示： LaTeX 的行距机制每一行都有一条 baseline, 同一段落中相邻两行之间的 baseline 的间距称为行距 (linespace). 一般来说，最终决定两条 baseline 之间的 linespace 距离的，是 LaTeX 的宏 \baselineskip 之中。也就是说，这个长度值，将会是一般情况下的两条 baseline 之间的距离，也就是我们最终的行距。 显然行距应当随着字号的大小变化；若不然，则对于给定的行距数值，较大字号的内容部分显得拥挤不堪。LaTeX 中的字号存储在内部宏 \f@size 之中，而内部宏 \f@baselineskip 则记录了行距中和字号相关的部分。这个宏当中，它的单位和字号的单位一样，都是 pt ( 1pt = 1/72.27 inch ). LaTeX 的默认情况下，\f@baselineskip 的值是当前 \f@size 的 1.2 倍——例如，当 \f@size 为 10pt 时，\f@baselineskip 的值为 12pt. 为了统一对不同字号的内容进行行距的调整，引入了因子的概念，这是一个数值（而不是长度），储存在 \f@linespread 这个宏里面。这是一个与字号无关的值，在 article 文档类中它默认是 1, 在 ctexart 中默认是 1.3. 通常我们修改行距，都是修改这个因子，而不动前段叙述的基础行距。因此就有必要将因子存储在一个外部宏（没有 @ 的宏）之中，它是 \baselinestretch. 于是我们可以大致地认为，\f@linespread 和 \baselinestretch 是一回事。 因此，根据 \baselineskip = \f@baselineskip * \baselinestretch, 在 article 中默认行距是字号的 1.2 倍，而在 ctexart 中默认行距是字号的 1.56 倍。此外，提一下，Word 中的「单倍行距」/「双倍行距」等名词，指的是因子的数值为 1 或者 2 的时候的行距；相反 setspace 宏包的 「单倍」、「一倍半」、「双倍」则是指行距相对于字号的倍数。 如何修改行距\f@linespread 的值一旦给定，会一直作用到文档末尾或者被新的值覆盖；\f@baselineskip 的情况类似。因为 TeX 排版的过程是对一整段文字进行计算，在每个可能的断行点计算总劣度最小的断行模式，然后进行排版。所以每一段段内的行距，由最后被设置的（覆盖了前面的）\f@baselineskip 和 \f@linespread 决定。 修改行距，也就是修改因子，可以直接修改 \baselinestretch 的值（\renewcommand），或者使用 \linespread{}\selectfont 来修改。然而为了保持与 LaTeX2e 的一致性，推荐使用后一种方法。 \linespread{&lt;因子&gt;}\selectfont setspace 宏包提供的 \setstretch 命令似乎做得更多一些：会同时修改数学公式、浮动体等的间距，使之与正文间距适应。 \setstretch{&lt;因子&gt;} \linespread 和 \fontsize{}{} 这类命令，必须在其后添加 \selectfont 才会生效。\setstretch 大致相当于 \linespread \selectfont, 使用之后直接生效。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Linespace</tag>
        <tag>Baseline</tag>
        <tag>Baselineskip</tag>
        <tag>Baselinestretch</tag>
        <tag>Setspace</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LaTeX Tips】国内期刊 CCT 模板编译经验]]></title>
    <url>%2F2013%2F10%2F15%2FLaTeX-CCT-template%2F</url>
    <content type="text"><![CDATA[国内有不少期刊依旧在使用过时的 CCT 方式来支持中文，这些模板非常相似，似乎系出同源。由于这些模板在现代的 TeX 发行版内无法正确编译，对不少投稿人造成困扰，所以我写下这篇文章，希望对投稿人有一些帮助。 模板特征这些模板的导言区内代码大致如下： 12345678\documentclass[twoside]&#123;cctart&#125;\usepackage&#123;headrule,vatola,amssymb&#125;\usepackage&#123;graphicx,multirow,bm&#125;\usepackage&#123;booktabs,dcolumn&#125;\newcolumntype&#123;z&#125;[1]&#123;D&#123;.&#125;&#123;.&#125;&#123;#1&#125;&#125;\usepackage&#123;tabularx&#125;\usepackage&#123;slashbox&#125;%\usepackage&#123;footmisc,perpage&#125; 提取出以下几条特征： \documentclass 里载入 cctart 文档类； 载入了 vatola 宏包； 载入了 headrule 宏包； 载入了 slashbox 宏包。 如果你手上的模板符合这些特征，那么这篇文章将对你有帮助。 列表这里给出一个列表，记录使用此类模板的期刊。如果你发现你投稿的期刊也使用了这样的模板（符合上述特征），请留言告诉我；我将会及时补充到列表当中，方便后来者。 系统工程理论与实践 - LaTeX 模板 数学的实践与认知 - LaTeX 模板 问题分析这些模板使用的文档类是 cctart，是 CCT 系统的一部分。CCT 系统是早年的一个中文支持方式，现在已经过时。虽然 CTeX 里还保留了 CCT，但是和这些编写模板时的版本已经不同；至于 TeX Live 里，根本就没有 CCT 系统。所以，编译报错也就是自然而然的事情了。 模板使用了 vatola 和 headrule 两个宏包。这两个宏包均是 LaTeX 2.09 时代的陈旧宏包；他们的功能已为其他宏包所替代。因此，现代的发行版（TeX Live、CTeX 2.9.2.164）不再包含这些宏包；于是，编译的时候会提示缺少宏包的错误。 此外，虽然 slashbox 宏包是为当前的 LaTeX 2e 设计的，但是它的许可协议与 TeX Live 的协议有冲突，因此 TeX Live 中并不包含这个宏包。于是，如果你的 TeX 发行版是 TeX Live，那么编译的时候也会提示错误。 解决方案陈旧的模板与现代的 TeX 发行版之间的矛盾不可调和，因此必有一方需要妥协。 如果你坚持不改动模板，那么就只好使用与模板同时代的 TeX 发行版。当然，你必须使用 Windows 操作系统。 你可以到下载 CTeX 2.4.6 并安装。CTeX 2.4.6 里的 WinEdt 有一个 CCTLaTeX 按钮，点击它之后，可以正确编译得到 .dvi 和 .ps 文件，如果需要 .pdf 文件可以用 ps2pdf 工具转换。 如果你坚持使用现代的发行版，那么就需要对模板进行一些微调。这里提供两种方法，两种方法均适用于各个操作系统。 使用 ctexart 将 \documentclass 里载入的文档类，从 cctart 更换为 ctexart； 下载本站提供的 vatola.sty 和 headrule.sty 两个宏包文件（2014-12-17 更新）； 到 CTAN 上下载 slashbox 宏包 并安装； 将上述三个宏包安装至 TEXMFLOCAL，然后执行 texhash 命令；或者直接将它们放在与模板文件相同的文件夹里面； 使用 pdfLaTeX 编译，可以得到与原模板几乎完全一致的结果； 正式投稿时，只需要将 ctexart 换回 cctart 即可。 安装新版 CCT 系统 (2014-12-21 更新） 下载 CCT 的 TDS 安装包； 将 TDS 安装包中的内容，解压合并至 TEXMFLOCAL 的相应目录； 将 \documentclass 里文档类选项，从 twoside 更换为 twoside, CJK； 在 \documentclass 之后加载 ifpdf 宏包：\usepackage{ifpdf}； 下载本站提供的 vatola.sty 和 headrule.sty 两个宏包文件（2014-12-17 更新）； 到 CTAN 上下载 slashbox 宏包 并安装； 将上述三个宏包安装至 TEXMFLOCAL，然后执行 texhash 命令； 分情况讨论： 如果使用 Windows 系统，则在 \begin{document} 之前添加一行命令 \AtBeginDvi{\input{zhwinfonts}}； 如果使用 Mac OS X 或 Linux 系统，则需要安装好 Windows 的中易字体，然后在 \begin{document} 之前添加一行命令 \AtBeginDvi{\input{zhwinfonts}}； 如果使用 Mac OS X 或 Linux 系统，你也可以安装下列字库，然后在 \begin{document} 之前添加一行命令 \AtBeginDvi{\input{zhfzfonts}}； 方正书宋GBK：FZSSK.TTF 方正楷体GBK：FZKTK.TTF 方正黑体GBK：FZHTK.TTF 方正仿宋GBK：FZFSK.TTF 华文隶体：STLITI.ttf 华文琥珀：STHUPO.TTF 使用 pdfLaTeX 编译，可以得到与原模板完全一致的结果； 正式投稿时，只需要将添加的 CJK 选项和 ifpdf 宏包以及 \AtBeginDvi{} 命令删除就可以了。 总结总的来说 CCT 是一个过时的中文支持方式，非常希望系统工程理论与实践的编辑部能与时俱进改用新的方式支持中文，为所有作者提供方便。对于广大的 LaTeX 用户，除非特别需要，不要使用老旧的 TeX 发行，以增强文档的兼容性。 同时也希望各位作者向期刊编辑反映这个问题，尽快淘汰这些模板。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Template</tag>
        <tag>CCT</tag>
        <tag>SYSENGI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LaTeX Tips】使用 LaTeX 排版试卷挖空的问题]]></title>
    <url>%2F2013%2F10%2F14%2FLaTeX-Key-to-questions%2F</url>
    <content type="text"><![CDATA[我们编写试卷的时候，通常会把答案也一并填上，打印的时候却希望按照答案的长度挖空。本文整理了 CTeX 论坛上的一些讨论，尝试解决这个问题。 对于一般的需求，可以用 \iftrue 和 \iffalse 来实现，如下 1234567891011\documentclass&#123;article&#125;\usepackage&#123;ulem&#125;% 显示答案填入 \iftrue, 不显示答案填入 \iffalse\iftrue\newcommand&#123;\myans&#125;[1]&#123;\uline&#123;#1&#125;&#125;\else\newcommand&#123;\myans&#125;[1]&#123;\uline&#123;\phantom&#123;#1&#125;&#125;&#125;\fi\begin&#123;document&#125;\myans&#123;This is the key to the question&#125;.\end&#123;document&#125; 更简练的代码，可以参考一下来自CTeX 论坛提问版的方法。 123456789\documentclass&#123;article&#125;\usepackage&#123;ctex&#125;\usepackage&#123;ulem&#125;\usepackage&#123;tagging&#125;\usetag&#123;ans&#125;% 注释掉该行语句不显示答案\newcommand&#123;\answer&#125;[1]&#123;\iftagged&#123;ans&#125;&#123;\uline&#123;#1&#125;&#125;&#123;\uline&#123;\phantom&#123;#1&#125;&#125;&#125;&#125;\begin&#123;document&#125;这个问题的答案是\answer&#123;This is the key to the question&#125;.\end&#123;document&#125; 但是这种情况下，\phantom 无法自动断行，对于较长的答案来说是不好用的，因此只能考虑放弃 \phantom 将答案的字体颜色调整为白色，如下： 1234567891011\documentclass&#123;ctexart&#125;\usepackage&#123;tagging&#125;\usepackage&#123;xcolor&#125;\usepackage&#123;ulem&#125;%\usetag&#123;ans&#125; % 注释掉该行语句不显示答案\newcommand&#123;\answer&#125;[1]&#123;\iftagged&#123;ans&#125;&#123;\uline&#123;#1&#125;&#125;&#123;\uline&#123;\color&#123;white&#125;&#123;#1&#125;&#125;&#125;&#125;\begin&#123;document&#125;这个问题的答案是\answer&#123;答案This is the key to the question 这是答案这是答案这是答案这是答&#125;.Have a try.\end&#123;document&#125; 注意到这种情况下，只有 \answer 后面的第一个字符被挖空了，后面内容并没有挖空（而且断行失败）。出现这种结果的原因，是因为 ulem 包依赖 \uline 参数中的空格来断开下划线，并且 \uline 里的分组情况还比较特殊。这种情况的工作示例可以参见这里. 因此最终的方案只能绕开 ulem 这个包才行，如下： 12345678910\documentclass[fntef]&#123;ctexart&#125;\usepackage&#123;xcolor&#125;\usepackage&#123;tagging&#125;%\usetag&#123;ans&#125;% 注释掉该行语句不显示答案\renewcommand*\CJKunderlinecolor&#123;\color&#123;black&#125;&#125;\newcommand&#123;\answer&#125;[1]&#123;\iftagged&#123;ans&#125;&#123;\uline&#123;#1&#125;&#125;&#123; &#123;\color&#123;white&#125;\CJKunderline&#123;#1&#125;&#125;&#125;&#125;\begin&#123;document&#125;这个问题的答案是\answer&#123;答案This is the key to the question 这是答案这是答案这是答案这是答&#125;.\end&#123;document&#125; 这一解决方案调用了 ctexart 宏包的 fntef 选项，问题得以解决。在纯英文环境下可以这样做： 123456789101112\documentclass&#123;article&#125;\usepackage&#123;xcolor&#125;\usepackage&#123;tagging&#125;%\usetag&#123;ans&#125;% 注释掉该行语句不显示答案\usepackage&#123;ulem&#125;\newcommand\myuline&#123;\bgroup\markoverwith &#123;\textcolor&#123;black&#125;&#123;\rule[-0.5ex]&#123;2pt&#125;&#123;0.4pt&#125;&#125;&#125;\ULon&#125;\newcommand&#123;\answer&#125;[1]&#123;\iftagged&#123;ans&#125;&#123;\uline&#123;#1&#125;&#125;&#123; &#123;\color&#123;white&#125;\myuline&#123;#1&#125;&#125;&#125;&#125;\begin&#123;document&#125;Your answer is \answer&#123;Hello, \LaTeX&#123;&#125;. Hello, \LaTeX&#123;&#125;. Hello, \LaTeX&#123;&#125;. Hello, \LaTeX&#123;&#125;. Hello, \LaTeX&#123;&#125;.&#125;\end&#123;document&#125; 当然这一方法同样适用于有中文的情况。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Blank</tag>
        <tag>Exam</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LaTeX Tips】在 LaTeX 中实现「子定理」]]></title>
    <url>%2F2013%2F10%2F08%2FLaTeX-def-subnumber%2F</url>
    <content type="text"><![CDATA[问：写了7个definition后，这里第8个definition是分开定义的，即编号为8.1,8.2，8.3 。。。怎么样才能做到？ \newtheorem{myDef}{Definition} 答：1234567891011121314151617181920212223\documentclass&#123;article&#125;\usepackage&#123;amsmath&#125;\newtheorem&#123;myDef&#125;&#123;Definition&#125;\newtheorem&#123;subDef&#125;&#123;Definition&#125;[myDef]\begin&#123;document&#125;\begin&#123;myDef&#125;content...\end&#123;myDef&#125;\stepcounter&#123;myDef&#125;\begin&#123;subDef&#125;content...\end&#123;subDef&#125;\begin&#123;subDef&#125;content...\end&#123;subDef&#125;\begin&#123;myDef&#125;content...\end&#123;myDef&#125;\end&#123;document&#125;]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Subnumber</tag>
        <tag>Definition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【透过例子谈 Argument 思路】Argument 41：安全帽与严重受伤]]></title>
    <url>%2F2013%2F10%2F06%2FGRE-Argument%2F</url>
    <content type="text"><![CDATA[前文（【透过例子谈 Issue 思路】Issue 21: 法律的弹性）通过一篇 Issue 题目，说明了对付 Issue 的一般思路和破题方法。今天和 Layla 随机挑选了一篇 Argument task, 一起总结一下对付 Argument 的一般思路和破题方法。同样，我希望这篇帖子的意义，不仅在于解决了一道 Argument 题目，而且在于提出了一种思考 Argument 的方式（并且它应当会被验证是正确的）。[^1] 先澄清一个长期以来的误会——Issue 是立论而 Argument 是驳论。我不知道是谁先提出这个观点的，但是 ETS 没有这样说。按照 OG 的说法：Argument task 旨在考查考生「在特定指导语的指导下，理解、分析、评估一段陈辞，并清晰地表达出自己对于其评估的结果」；Argument task 要求考生「在指导语的指导下，通过检查逻辑链路，讨论原作者的逻辑完备程度」；并且明确指出「不需要讨论陈辞的真实性、不需要讨论自己的立场（是否同意）、不需要讨论自己对于事件的观点（这是 Issue 考查的东西）」，而是要「评估对方的逻辑推论的完备程度」。 所以 ETS 并没有要求考生「驳倒」原作者的陈辞，而只是需要分析对方推论过程中是否有问题。简而言之 Issue 是需要对一个事情提出一个相对完备的逻辑分析过程，而 Argument 是需要对一个看似完备的陈辞进行逻辑层面的分析。 题目： The following appeared in a health newsletter. “A ten-year nationwide study of the effectiveness of wearing a helmet while bicycling indicates that ten years ago, approximately 35 percent of all bicyclists reported wearing helmets, whereas today that number is nearly 80 percent. Another study, however, suggests that during the same ten-year period, the number of bicycle-related accidents has increased 200 percent. These results demonstrate that bicyclists feel safer because they are wearing helmets, and they take more risks as a result. Thus, to reduce the number of serious injuries from bicycle accidents, the government should concentrate more on educating people about bicycle safety and less on encouraging or requiring bicyclists to wear helmets.” Instruction: Write a response in which you examine the stated and/or unstated assumptions of the argument. Be sure to explain how the argument depends on these assumptions and what the implications are for the argument if the assumptions prove unwarranted. 第一步，审题（了解指导语需要我们做什么，分析 argument 陈辞的逻辑链路）。指导语需要我们检查陈辞所作的前提假设（包括明确陈述的和未陈述的），并且要求解释这些假设是如何在陈辞中起到作用的，以及要求解释若是这些假设不成立会导致何种后果。 不论何种程度的论调，哪怕是谬论，它也应该遵循「论据 - 论点 - 结论」的论证过程。结论可能有很多个，但是在 Argument task 里提供的 argument 通常只有一个。因此抓取逻辑链路的第一步，就是抽取结论；然后再顺藤摸瓜找到论点，以及支持论点的论据。 在这里，很显然，结论是： 政府应专注于对自行车手提供更多安全教育，并减少安全帽的推广，以减少自行车事故中的严重受伤。 而论点只有一个： 自行车手因佩戴安全帽而提升了安全感，并因此承担了更大风险。 支持这个论点的论据是两个研究： 过去十年内佩戴安全帽的自行车手比例从 35% 提升到了 80%；同样时间段内，与自行车相关的事故数量增长了 200%. 能够轻而易举地抓取这些信息，需要一定的对于逻辑关联词的积累。例如 however, thus, therefore, evidently, hence, in conclusion, result in, result from 等等。 第二步，挖掘前提假设（考虑说话人做了何种假设，这些假设是否是 conditional 的）。挖掘假设主要着眼于三个方面： 论据的可靠性； 论据推论到论点的过程/论点推论到结论的过程； 论点以及结论内部的因果关系。 这样清晰地分开好处有二： 清楚地知道，每一个假设是服务于什么的（因此如果该假设不成立，会使得逻辑链路哪里开始中断也很清晰）。 不容易遗漏，因而能充分锻炼到考生对于逻辑链路的分析能力。 第三步，考虑尽可能多的第二选择。所谓第二选择，是对于事情结果的原因的另一种假设。第二选择的出现，削弱了原本原因推导结果的必然性。这应该是显然的，比如说： 小明向老师告状，说小华拿了他的苹果吃。小华辩称说，当时小齐等其他小伙伴们（←_←）也在教室里，可能是他们拿了。 小华的辩解就是提出了针对小明所说的第一选择的另一种解释，无疑削弱了第一选择的必然性，因而达到目的。 对于这篇题目，有如下分析（按照 假设；第二选择 的顺序排列）： 论据的可靠性假设： 研究一（戴安全帽比例上升的研究，下同）调查样本的代表性；调查对象，可能是经过特别选取的。 研究一中，被调查的人说的都是真话；被调查者可能因为麻烦而不愿意佩戴安全帽，却为了响应号召而说谎。 研究二中，事故记录是完善的；十年前可能因为通讯不发达而遗漏了很多和自行车相关的事故。 论据推论点的假设： 佩戴安全帽能够提升自行车手的安全感；如果安全帽不合身，比如小孩戴着成人版的安全帽可能因为遮挡视线而感觉不安全。 事故数量的上升，和佩戴安全帽有直接关系；事实上路况的恶化、骑车人数量的增加都不可避免地导致事故数量上升。 与自行车相关的事故，完全是由自行车手导致的；实际上可能在近十年该市的卡车数量剧增，暴力开车的卡车司机撞死了很多骑自行车的人。 卷入事故的自行车手，都佩戴了安全帽；可能正是因为没有佩戴安全帽的那些车手，酿成的恶果。 论点到结论的假设： 所谓的风险导致的都是严重受伤；事实上受伤的可能都只是轻微的擦伤，算不得严重受伤。 减少安全帽的推广，能够减少安全帽带来的「安全感」；减少推广，只是可能减少佩戴安全帽的车手的比例，而不能减少安全帽带来的安全感。 减少安全帽的推广，能够减少佩戴安全帽的人的比例；可能就有人喜欢唱唱反调，你不让戴我片要带。 论点内部的假设： 车手具有安全感，会降低警惕，从而带来更大风险；车手具有安全感之后，会将精力放在其他更需要注意的地方，减少安全隐患。 结论内部的假设： 对车手提供安全教育能够减少严重受伤；事实上如果严重受伤都由卡车司机导致的话，单单对车手提供教育没有任何意义。 第四步，列提纲（提两个建议）。因为前面分析了 argument 的逻辑链路，所以在文章中进行让步攻击看起来会变得很容易。因为我们分析的每个假设都有对应的点或者过程，我们可以假设对应于逻辑链路前面的某个假设成立，然后论述后面的假设不成立，从而展开文章。比如说：研究一调查的样本可能是没有代表性的（使用了论据的可靠性假设）。就算研究一的调查样本是有代表性的，但是陈辞错误假设了卷入事故的车手都佩戴了安全帽（使用了论据推论点的假设），因此论点是不成立的。 这样一个让步攻击看起来就很合理，然而反过来如果先论证论据推论点的假设的不合理性，再让步讨论论据的可靠性假设，就会显得相当的怪异。毕竟论点推论据，这是没有办法更改方向的。 由此我们就得出了使用上面得到的假设的一个一般性技巧：先从逻辑链路的前端开始分析假设的合理性，再通过让步攻击转到逻辑链路后面的假设。 另外，论据是逻辑链路的「根基」，如果根基不稳，那问题将是很严重的；以及逻辑链路的结论是最终呈献给大家的「直观印象」，而该结论内部就有矛盾，那整个逻辑链路都会给人以一种「荒谬」的感觉。了解到这个事实，对于我们对待 Argument task 是有益的。因为如果我们的习作，对于逻辑链路的这两个方面都进行了分析，那无疑在 GRE 的阅卷者看来，会是相对有力度的。因此此处有一个小的建议：分别针对逻辑链路的首尾进行假设的合理性分析，来讨论逻辑链路的完备性。会有这样的现象也是容易理解的，毕竟在考场压力下，我们不可能将平时习作所能分析到的全部假设都写进文章，必须有所取舍。 以上就是对于列写提纲的过程中，对于错误假设的选择以及顺序的排布，提出的两个建议。 [^1]: 这篇文章最先发表在 ChaseDream: http://forum.chasedream.com/thread-876150-1-1.html.]]></content>
      <categories>
        <category>GRE</category>
      </categories>
      <tags>
        <tag>AW</tag>
        <tag>Argument</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【透过例子谈 Issue 思路】Issue 21：法律的弹性]]></title>
    <url>%2F2013%2F10%2F04%2FGRE-Issue%2F</url>
    <content type="text"><![CDATA[这篇 Issue 的思路归纳是和 Layla 一起讨论的结果，我希望这篇帖子的意义，不仅在于解决了一道 Issue 题目，而且在于提出了一种思考 Issue 的方式（并且它应当会被验证是正确的）。[^1] 题目： Laws should be flexible enough to take account of various circumstances, times, and places. Instruction:Write a response in which you discuss the extent to which you agree or disagree with the statement and explain your reasoning for the position you take. In developing and supporting your position, you should consider ways in which the statement might or might not hold true and explain how these considerations shape your position. 第一步，审题（搞清楚题目要讨论什么，搞清楚文章应当从什么方面考虑）。首先 claim 讨论的主体是 Laws 是否 flexible 的问题, 然后有情态动词 should （区别于 must），以及未定义的抽象词有 circumstances, times, places.然后 instruction 要求考虑同意或者不同意的 extent, 然后要求讨论在一些情况下，statement 会 true 或者 not true, 并且要讨论这些 ways/situations 如何 shape 你的立场的。 这里专门提出情态动词的意义在于，情态动词通常反映着说话人的意愿。比如这里的 should 如果替换成 must, 显而易见考生在行文的过程中会有很大的不同。 专门提出未定义的抽象词的意义在于，这些抽象词可以在我们行文的过程中加以限定，将话题导向我们熟悉的范畴。这是 ETS 允许的。 因此，行文应当围绕 laws’ flexibility 展开，通过限定 circumstances, times and places 来控制行文的方向。在行文的过程中应当选定一个立场（关于在多大程度上同意原文的观点），并且讨论 statement 在哪些情况下成真或者不成真，以及为何得出自己的立场。 第二步，凭感觉选择一个立场（特别要考虑到原文的态度）。你可以凭自己的感觉（实际上是你的生活经验和阅历的综合），来选择一个观点（他们之间无有优劣之分）： 完全同意原文（即，法律在环境、时间、地点这些方面是应该有弹性）； 完全不同意原文（上面取反）； 部分同意/不同意原文（即，在某些情况下有弹性是好的，另一些情况下有弹性是不好的）。 应当指出的是，选择立场之后，就需要有一个清晰的逻辑感官，明白自己要在那些方面进行叙述，才能 shape 自己的立场。例如说： 法律有弹性是好的（列论点）；法律有弹性也有不好的地方（列论点，必须写这一点的原因在于 instruction 的要求，下同）；法律有弹性的好处大于坏处，所以法律应该有弹性。 法律有弹性是不好的（列论点）；法律有弹性也有好的地方（列论点）；法律有弹性的坏处大于好处，所以法律不应该有弹性。 法律有弹性是好的（列论点）；法律有弹性也有不好的地方（列论点）；法律弹性的好处和坏处无法简单地评价，在某些情况下有弹性好，某些情况下有弹性不好，所以我部分同意原文的观点。 不论选择哪一个观点立场，都必须在行文的过程中，体现类似上述的逻辑链。 第三步，挖掘前提假设（考虑说话的人做了何种假设，这些假设的成立是不是 conditional 的）。原文至少做了两个假设： 能够对法律进行「弹性」这个意义上的考虑（即，法律本身有弹性一说）； 有弹性的法律是好的。 关于第一个假设，事实上法律本身是没有弹性的（法律就是写在纸上的东西），有弹性的是法律的审判过程和执行过程。考虑这个假设，有两个好处：体现你的批判性思维；帮助你限定你行文的范围（在有限时间内，这点尤为重要）。如果不考虑这个假设，即不对这个假设的真伪进行讨论，在行文的过程中直接讨论法律的审判和执行也是可以的，原因在于并不是所有考生都对法律有足够清晰的认识（它是否有弹性这一点，事实上可以划归到法律专业的内容里面去）。总之，不管在行文的过程中是否点明这一个假设，对它进行这样的分析是有助于我们的行文的，所以应当是有益的。 关于第二个假设，这显然应该是有条件成立的，因此它成为了破题的关键。我们接下来的讨论，应当围绕这个条件是否成立来进行。 第四步，思考论点以及论据。按照上面的讨论，根据 statement 的陈述我们知道了应当考虑哪些因素，根据 instruction 我们知道了应当从那几个方面考虑，根据前提假设的挖掘我们知道了应当如何设置 conditions （case-by-case 的 case 如何去构建）. 事实上我们行文过程中，会需要一两个正面的论点以及一两个负面的论点。所以在思考文章的时候，我们应当对正负两方面都思考两三个论点，同时每个论点有一两个例子。下面是我个人的思考： 同意的原因： 考虑不同环境：比如说现在的中国和美国，法律就有不同，这就是环境造成的差异。因为美国相对犯罪率更高，因此公民就有自卫的迫切需要，所以允许枪支合法持有是必须的；然而在中国，就不行，比如因为说犯罪率没那么高，允许持枪可能引发更严重的问题，因为人口太多，允许持枪难以管理之类的。 考虑不同地点：美国每个州的法律都不尽相同，因为比如说因为每个州的收入情况不同，因此法定的消费税就不一样，法定的所得税也不一样。如果消费税和所得税全合众国一致，那么欠发达的地方人民生活就会很悲惨。 考虑不同时间（这个最好写了啊，美国有那么多宪法修正案，不就是为了适应不同的时间嘛）：比如黑奴解放了，根据 14 修正案，任何出生在美国并接收管辖的人都是美国公民，不得被取消公民权利，因此过去的针对黑人的歧视性法律就应当废止。 不同意的原因： 同地点同环境，如果时间较短的间隔之间，法律过于 flexible, 可能造成不公平。法律作为一个公约性质的东西，意义就在于大家都遵守所以公平。如果法律弹性太大，那么就容易被人钻空子。（反正 flexible 的程度又没说，你说弹性太大又不算错） 同时间同环境，不同地点的法律之间有差异，弹性过大的话，人们需要适应不同的法律。比如从一个州搬家到另一个州，就需要适应新的法律体系，这是额外的成本和负担，而且可能因为无心之失触犯当地法律造成损失。 补述：由此观之，事实上我第一反应想出来的例子，都是很「接地气」的例子，并没有很高端大气上档次的东西。能做到这一点，在于我通过控制不同的因素变化（来自第一步），在各个方面（来自第一步），从特定的角度（来自第三步）去思考问题，这样就容易想出符合要求的例子。事实上，我认为，中国考生并非是腹中无物，而是没有「控制变量（因素）」，在一个相对较大的范围内把自己的脑子搞的一团浆糊，所以想不出合适的例子。 第五步，思考 refutation 以及你的 defence.在考场上，如果觉得时间不够，这一步可以省略。事实上进行到第四步，就已经能够写出一篇足够好的 Issue 文章了。会进行第五步的原因在于两点：通过论点中的局部让步，体现更成熟的思变；通过进行 refutation &amp; defence 的训练来增强批判性思维的能力。 你可以想象一下脑海里有一只小人，在「叽里呱啦」说你的论点哪里有问题，然后你在脑海中为自己的论点做辩护——我想这种事情大家都干过。你需要做的，就是选取一个会在行文中使用的论点（经过第三第四步的思考，这个问题应当是清晰的，尽管行文的细节可能还不明了），然后针对其中的一个例子进行辩驳（如同你在 Argument 中做的那样），然后再为你原来的观点进行辩护。 在此之后，你就可以在论点的陈述过程中使用局部让步了，比如有下面的句式：「可能有人说 … （反例）所以 … （讨论中心）应当会 …（与你论点相反的论点）, 但是我认为，在更 … （选择第一步以外的 element）的意义上，…（会怎么样）, 因此还是 … （我的观点）更好。」 举一个例子如下： （不同意）. 同地点同环境，如果时间较短的间隔之间，法律过于 flexible, 可能造成不公平。法律作为一个公约性质的东西，意义就在于大家都遵守所以公平。如果法律弹性太大，那么就容易被人钻空子。（反正 flexible 的程度又没说，你说弹性太大又不算错） 可能有人会说，只要法院的判决公正并且执行机构给力，那样就不会有人能够钻空子了，所以还是不要 flexible 比较好。但是我认为，法院的判决受到各种因素的影响，包括陪审团的情绪/他们自身的经历/被告人的家世，不可能特别公正，并且执法部门在执法的过程中，可能遇到各类问题，心有余而力不足。因此空子总是有可能被发现并利用的，也就是说实际上判决公正和执行给力本身就是不可能的事情，因此这种论调是不靠谱的。 第六步，整理素材，根据逻辑链形成提纲。这应该不需要我详述，实际上就是根据第二步的「纲」穿起第四步和第五步形成的素材，列出的过程就是所谓「提」了。 [^1]: 这篇文章最先发表在 ChaseDream: http://forum.chasedream.com/thread-875967-1-1.html.]]></content>
      <categories>
        <category>GRE</category>
      </categories>
      <tags>
        <tag>AW</tag>
        <tag>Issue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LaTeX Tips】How to highlight text.]]></title>
    <url>%2F2013%2F09%2F26%2FLaTeX-highlight-text%2F</url>
    <content type="text"><![CDATA[If anyone wanna highlight text in LaTeX file using the package soul, they may counter some problems, such as lineberak, since package soul is very fragile. 在使用宏包 soul 进行高亮操作的时候，可能因其代码的脆弱性，导致许多问题，例如无法正确换行。 Using more robust ulem package to define a new \hl command is a good way.^1 使用更加健壮的 ulem 宏包去定义一个新的 \hl 命令是个不错的选择。 123456789\documentclass&#123;article&#125;\usepackage&#123;xcolor&#125;\usepackage[normalem]&#123;ulem&#125; % use normalem to protect \emph\newcommand\hl&#123;\bgroup\markoverwith &#123;\textcolor&#123;yellow&#125;&#123;\rule[-.5ex]&#123;2pt&#125;&#123;2.5ex&#125;&#125;&#125;\ULon&#125;\begin&#123;document&#125;This is a test \hl&#123;for highlighting&#125; text.\end&#123;document&#125;]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Highlight</tag>
        <tag>Ulem</tag>
        <tag>Robust</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LaTeX Tips】输出罗马数字]]></title>
    <url>%2F2013%2F09%2F10%2FLaTeX-RomanNumber%2F</url>
    <content type="text"><![CDATA[1234567%罗马数字演示\documentclass&#123;ctexart&#125;\newcommand*&#123;\rmn&#125;[1]&#123;\romannumeral#1&#125;\newcommand*&#123;\RMN&#125;[1]&#123;\uppercase\expandafter&#123;\romannumeral#1&#125;&#125;\begin&#123;document&#125;\RMN&#123;2013&#125;年\RMN&#123;9&#125;月\rmn&#123;10&#125;日\end&#123;document&#125; 如此即可。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Roman</tag>
        <tag>Number</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LaTeX Tips】在 Chapter/Section 等标题中插入脚注]]></title>
    <url>%2F2013%2F08%2F26%2FLaTeX-Footnote-In-Section-Title%2F</url>
    <content type="text"><![CDATA[12345\documentclass&#123;article&#125;\begin&#123;document&#125;\tableofcontents\section[Section Title]&#123;Section Title\footnote&#123;This is footnote.&#125;&#125;\end&#123;document&#125; 如此即可。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Footnote</tag>
        <tag>Section</tag>
        <tag>Chapter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全国大学生数学竞赛论文模板]]></title>
    <url>%2F2013%2F08%2F25%2FLaTeX-xcumcmart%2F</url>
    <content type="text"><![CDATA[本模板根据「2013高教社杯全国大学生数学建模竞赛论文格式规范」中的相关规定制作。供参加全国大学生数学建模竞赛的同学们使用。Liam Huang 制作该模板的目的在于推进竞赛论文格式规范化，推广 LaTeX。 下载：这里 本模板将整篇论文视作「文章」（article），而不是「书」（book）。实现时，以 ctexart 为基类。与 ctexart.cls 的使用基本相同，但必须保存为 UTF8 编码并使用 XeLaTeX 或 pdfLaTeX 编译。具体请参考本文源文件。 为了实现比较好的兼容性，模板仅达到了 2013 高教社杯全国大学生数学建模竞赛论文格式规范 中对竞赛论文的基本要求，而不包括额外的功能，也没有引入其他的宏包，请使用时根据需要自行添加。 模板发行包包括如下文件： declaration.tex —— 承诺书及编号页（必须。如有变动，请修改该文件） readme.pdf —— 本文件 readme.tex —— 本文件源文件 xcumcmart.cls —— 模板文件 模板的最新版本可以在 http://liam0205.me/2013/08/25/LaTeX-xcumcmart/ 下载。有关于模板的任何问题，比如 Bug 提交、功能建议、赞助、宣传推广等，均可与 Liam Huang 联系。 感谢 http://www.shumo.com/ 早先以 CCT 方式制作的竞赛论文模板。 任何个人或团体可以无限制的自由使用本模板。 本模板目前尚未得到全国大学生数学建模竞赛组委会的认可，模板作者对使用该模板所引起的后果不负任何责任。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>XCUMCMART</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LaTeX Tips】画一条自动延伸到行尾的线]]></title>
    <url>%2F2013%2F08%2F25%2FLaTeX-RuleTillEnd%2F</url>
    <content type="text"><![CDATA[LaTeX 向来是不擅长处理动态问题的，而我们的需求显然需要定义一个动态的长度。为了解决这个矛盾，我们可以退而求其次，选择用很短的一小节 rule 拼接在一起填充满整一行，而不是定义一个动态的长度。 示例代码在这里. 理解思路之后，读者还可以定义出许多其他的「动态」，愿诸君都能勤思考。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Rule</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LaTeX Tips】LaTeX 中公式编号括号样式及章节关联的方法]]></title>
    <url>%2F2013%2F08%2F23%2FLaTeX-Formula-Number%2F</url>
    <content type="text"><![CDATA[章节关联使用 amsmath 宏包的时候，我们可以利用 amsmath 宏包提供的 \numberwithin{&lt;sub-counter&gt;}{&lt;counter&gt;} 命令来实现公式与章节关联。效果形如 1.1 123456789\documentclass&#123;article&#125;\usepackage&#123;amsmath&#125;\numberwithin&#123;equation&#125;&#123;section&#125;\begin&#123;document&#125;\section&#123;Test&#125;\begin&#123;equation&#125;E = mc^2\end&#123;equation&#125;\end&#123;document&#125; 当我们不使用 amsmath 宏包的时候，或者需要别的样式的时候，就必须修改 \theequation 的输出样式了。如下代码可以生成形如 1-1 的效果 1234567891011\documentclass&#123;article&#125;\makeatletter\@addtoreset&#123;equation&#125;&#123;section&#125;\makeatother\renewcommand\theequation&#123;\arabic&#123;section&#125;-\arabic&#123;equation&#125;&#125;\begin&#123;document&#125;\section&#123;Test&#125;\begin&#123;equation&#125;E = mc^2\end&#123;equation&#125;\end&#123;document&#125; 修改括号的样式使用 amsmath 宏包的时候，可以借助 mathtools 宏包提供的命令来修改公式编号的括号样式。可以去掉 LaTeX 公式编号的括号，或者变成别的样式——比如方括号/特别的文字。 mathtools 宏包提供了两个命令，用于定义和应用公式编号的括号的样式。 12\newtagform&#123;form-name&#125;[Number-Style]&#123;left&#125;&#123;right&#125;\usetagform&#123;form-name&#125; 用 \newtagform 来定义样式，用 \usetagform 来应用。 12345678910111213141516\documentclass&#123;article&#125;\usepackage&#123;amsmath&#125;\usepackage&#123;mathtools&#125;\newtagform&#123;test&#125;[\textbf]&#123;\textbf&#123;\small Equation~&#125;&#125;&#123;&#125;\usetagform&#123;test&#125;\begin&#123;document&#125;\section&#123;Test&#125;\begin&#123;equation&#125;E = mc^2\end&#123;equation&#125;\end&#123;document&#125; 这段代码可以产生形如 Equation 1.1 的公式编号效果。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Equation number</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LaTeX Tips】各种表格的绘制]]></title>
    <url>%2F2013%2F08%2F04%2FLaTeX-table%2F</url>
    <content type="text"><![CDATA[听说 LaTeX 中有一只表格君欠调教，于是有了以下调教指南【雾。。】 且看表格君是如何在我的手里变得面目狰狞丧心病狂无法直视的【弥天大雾。。】 最初的表格君初生的娃娃 12345678% 我是代码 01 号\documentclass[UTF8]&#123;ctexart&#125;\begin&#123;document&#125;\begin&#123;tabular&#125;&#123;cc&#125;我是&amp; 一只\\表格君&amp; 咿呀咿呀哟\end&#123;tabular&#125;\end&#123;document&#125; 编译结果在这里。 给娃娃摆个造型你可以通过调整 tabular 环境的选项，来掰掰这个小婴儿的手脚，然后咔嚓拍一张照片。比如我希望表格的第一列居左，而希望表格的第二列居右，可以这样 12345678% 我是代码 02 号\documentclass[UTF8]&#123;ctexart&#125;\begin&#123;document&#125;\begin&#123;tabular&#125;&#123;lr&#125;我是&amp; 一只\\表格君&amp; 咿呀咿呀哟\end&#123;tabular&#125;\end&#123;document&#125; 编译结果在这里。 你会发现文字呈现一个弧形，就好像娃娃咧嘴笑的样子【好吧我想多了禁止吐槽！！！；我一定很萌对吧！快回答我很萌不然我不继续写了！！】 给娃娃穿件衣服看到这么可爱的娃娃，你们一定不会希望他赤♂身果♀体（请想歪）到处乱跑。通常我们会希望给表格画一些线来分割各个 cell. LaTeX 提供的最基本方法，是用 \hline 命令画横线，在表格选项处加 | 以添加竖线。 1234567891011% 我是代码 03 号\documentclass[UTF8]&#123;ctexart&#125;\begin&#123;document&#125;\begin&#123;tabular&#125;&#123;|l|r|&#125;\hline我是&amp; 一只\\\hline表格君&amp; 咿呀咿呀哟\\\hline\end&#123;tabular&#125;\end&#123;document&#125; 编译结果在这里。 需要注意的是，\hline 命令必须接在换行符 \\ 的后面，或者在表头。 三线表最基本的三线表科技论文写作中，更常见的可能是三线表，比如这样 123456789101112% 我是代码 04 号\documentclass[UTF8]&#123;ctexart&#125;\begin&#123;document&#125;\begin&#123;tabular&#125;&#123;ccc&#125;\hline姓名&amp; 学号&amp; 性别\\\hlineCh'en Meng&amp; 001&amp; Male\\Sarah Brightman&amp; 002&amp; Female\\\hline\end&#123;tabular&#125;\end&#123;document&#125; 编译结果在这里。 让它变得更漂亮通常来说，我们会希望表格的第一根线和最后一根线比表格中的横线更粗一些。booktabs 宏包为我们提供了这个功能，加载 booktabs 宏包之后我们可以使用 \toprule 和 \bottomrule 命令分别画出表格头和表格底的粗横线，而用 \midrule 画出表格中的横线。比如这样 12345678910111213% 我是代码 05 号\documentclass[UTF8]&#123;ctexart&#125;\usepackage&#123;booktabs&#125;\begin&#123;document&#125;\begin&#123;tabular&#125;&#123;ccc&#125;\toprule姓名&amp; 学号&amp; 性别\\\midruleCh'en Meng&amp; 001&amp; Male\\Sarah Brightman&amp; 002&amp; Female\\\bottomrule\end&#123;tabular&#125;\end&#123;document&#125; 编译结果在这里. table 环境LaTeX 的排版的一个特点就是编号和位置浮动的自动化。为了让表格能够自动编号并尽可能美观的浮动，LaTeX 提供了 table 环境。基本用法如下 1234567891011121314151617% 我是代码 06 号\documentclass[UTF8]&#123;ctexart&#125;\usepackage&#123;booktabs&#125;\begin&#123;document&#125;\begin&#123;table&#125;[!htbp]\centering\caption&#123;这是一张奇怪的表格&#125;\label&#123;tab:aStrangeTable&#125;\begin&#123;tabular&#125;&#123;ccc&#125;\toprule姓名&amp; 学号&amp; 性别\\\midruleCh'en Meng&amp; 001&amp; Male\\Sarah Brightman&amp; 002&amp; Female\\\bottomrule\end&#123;tabular&#125;\end&#123;table&#125;\end&#123;document&#125; 编译结果在这里. 注意到 table 环境后面跟了一些由方括号包括起来的可选参数 [!htbp]. 其中 h 代表 here, 意思是将表格排在当前文字的位置； t 表示将表格放在下一页的 top (页首)； b 表示将表格放在当前页的 bottom (底部)；p 表示表格单独放在一个浮动页中；最前面的 ! 表示忽略美观因素，尽可能按照参数指定的方式来处理表格浮动位置。因此这五个参数放在一起就表示「尽可能将表格放在这里，不行就放在下一页的页首，再不行就放在这一页的底部，如果实在不行就单独成页吧」。 应当说明的是，浮动环境会根据行文的状况来调整表格的位置。几乎每个 LaTeX user 都会遇到表格位置不符合自己心中所想的情况。最佳的处理办法，是「随它去」，因为本来就应该这样去处理。如果一定要表格固定在所需位置，可以不用 table 环境，取消浮动。 \centering 命令的意义是将 tabular 环境绘制的表格居中放置。你可以去掉这个命令编译看看效果，进行对比。 \caption 命令输出表格的标题，并按照预定义的样式为表格编号。 \label 命令的作用，是在此处做一个「标记」，可以与 \ref 命令共同使用实现「交叉引用」的效果。注意为了得到正确的交叉引用结果，\label 命令必须放在 \caption 命令之后。该命令并不影响表格本身的样式，但是设置不当会使得交叉引用失效。交叉引用的具体细节不在本文的讨论范围之内，请自行阅读相关文献。 跨行和跨列的表格有时我们需要进行类似 MS Office Excel 中的「合并单元格」的操作。 横向合并在 tabular 中，可以用 \multicolumn{cols}{pos}{text} 来使得 text 占据 cols 个 cells, 并遵照 pos 中指示的位置。其中 pos 中支持竖线 | 的使用，以在合并后的 cells 两侧绘制竖线。 123456789101112131415161718% 我是代码 07 号\documentclass[UTF8]&#123;ctexart&#125;\begin&#123;document&#125;\begin&#123;table&#125;[!htbp]\centering\caption&#123;这是一张奇怪的表格&#125;\label&#123;tab:aStrangeTable&#125;\begin&#123;tabular&#125;&#123;|c|c|c|&#125;\hline\multicolumn&#123;3&#125;&#123;|c|&#125;&#123;学生信息&#125;\\\hline姓名&amp; 学号&amp; 性别\\\hlineCh'en Meng&amp; 001&amp; Male\\Sarah Brightman&amp; 002&amp; Female\\\hline\end&#123;tabular&#125;\end&#123;table&#125;\end&#123;document&#125; 编译结果在这里. 注意如果横向合并 cells 之后，改行的列数会相应增加。亦即在上述例子中，第一行的 cell 占据了 3 列的空间，如果在其后添加 &amp; 符号（表示希望将接下来的内容添加在下一列），则会提示列数过多。 纵向合并纵向合并 cells 需要 multirow 宏包的支持。该宏包提供的 \multirow{rows}{width}{text} 命令能够实现我们的需求。其中若 width 参数中填入 *, 则占据的宽度会根据需要自动增减。 12345678910111213141516171819% 我是代码 08 号\documentclass[UTF8]&#123;ctexart&#125;\usepackage&#123;multirow&#125;\begin&#123;document&#125;\begin&#123;table&#125;[!htbp]\centering\caption&#123;这是一张奇怪的表格&#125;\label&#123;tab:aStrangeTable&#125;\begin&#123;tabular&#125;&#123;|c|c|c|c|&#125;\hline\multicolumn&#123;4&#125;&#123;|c|&#125;&#123;学生信息&#125;\\\hline班级&amp; 姓名&amp; 学号&amp; 性别\\\hline\multirow&#123;2&#125;*&#123;1 班&#125;&amp; Ch'en Meng&amp; 001&amp; Male\\&amp; Sarah Brightman&amp; 002&amp; Female\\\hline\end&#123;tabular&#125;\end&#123;table&#125;\end&#123;document&#125; 编译结果在这里. 注意该命令仅仅是将目标位置的 text 扩展到了包括目标位置所在的 rows 行。因此，在其下的若干行，必须用 &amp; 符号空出相应的位置，不然就会导致文字重叠。例如编译下面的代码 12345678910111213141516171819% 我是一个错误演示\documentclass[UTF8]&#123;ctexart&#125;\usepackage&#123;multirow&#125;\begin&#123;document&#125;\begin&#123;table&#125;[!htbp]\centering\caption&#123;这是一张奇怪的表格&#125;\label&#123;tab:aStrangeTable&#125;\begin&#123;tabular&#125;&#123;|c|c|c|c|&#125;\hline\multicolumn&#123;4&#125;&#123;|c|&#125;&#123;学生信息&#125;\\\hline班级&amp; 姓名&amp; 学号&amp; 性别\\\hline\multirow&#123;2&#125;*&#123;1 班&#125;&amp; Ch'en Meng&amp; 001&amp; Male\\Sarah Brightman&amp; 002&amp; Female\\\hline\end&#123;tabular&#125;\end&#123;table&#125;\end&#123;document&#125; 既跨行又跨列显见，实现这样的需求需要将上述两个命令结合起来使用。但是只能用 \multicolumn{cols}{pos}{\multirow{rows}{width}{text}} 这样的形式，而不能反过来嵌套。具体原因不明。 以下是一个示例代码 123456789101112131415161718% 我是代码 09 号\documentclass&#123;standalone&#125;\usepackage&#123;multirow&#125;\begin&#123;document&#125;\begin&#123;tabular&#125;&#123;|*&#123;10&#125;&#123;r|&#125;&#125;\hline\multicolumn&#123;2&#125;&#123;|c|&#125;&#123;\multirow&#123;2&#125;*&#123;Blank&#125;&#125;&amp; \multicolumn&#123;2&#125;&#123;|c|&#125;&#123;CG&#125; &amp; \multicolumn&#123;2&#125;&#123;|c|&#125;&#123;IS&#125;&amp; \multicolumn&#123;2&#125;&#123;|c|&#125;&#123;MG&#125; &amp; \multicolumn&#123;2&#125;&#123;|c|&#125;&#123;LU&#125;\\\cline&#123;3-10&#125;\multicolumn&#123;2&#125;&#123;|c|&#125;&#123;&#125; &amp; 2 &amp; 4 &amp; 2 &amp; 4 &amp; 2 &amp; 4 &amp; 2 &amp; 4\\\hline\multirow&#123;2&#125;*&#123;Run Time(s)&#125;&amp; IA32 &amp; 24.37 &amp; 16.18 &amp; 19.62 &amp; 8.98 &amp; 31.98 &amp; 18.71 &amp; 622.76 &amp; 266.16\\&amp; IA64 &amp; 54.41 &amp; 30.29 &amp; 25.54 &amp; 15.72 &amp; 164.16 &amp; 84.73 &amp; 3226.60 &amp; 1723.11\\\hline\multirow&#123;2&#125;*&#123;Sync Time(ms)&#125;&amp; IA32 &amp; 7.156 &amp; 25.607 &amp; 189.793 &amp; 70.336 &amp; 286.354 &amp; 86.888 &amp; 6.446 &amp; 18.434\\&amp; IA64 &amp; 5.960 &amp; 7.043 &amp; 21.980 &amp; 10.078 &amp; 2.780 &amp; 13.793&amp; 2.922 &amp; 5.385\\\hline\end&#123;tabular&#125;\end&#123;document&#125; 编译结果在这里. 体型「不正常」的表格「肥胖」表格你可能已经注意到，在代码 09 中，我使用了 standalone 文档类，而不是之前一直在使用的 ctexart 文档类。standalone 这个文档类，会根据需要，设定恰好的纸张大小，特别适合生成 pdf 格式的图档。事实上，在代码 09 中的表格，就是一个「肥胖」的表格。如果你把上面这段代码放在普通的 article 文档类中，或是像之前一样放在 ctexart 中，因为表格过于宽，会超过页面跑到异次元去。比如你可以编译下面的代码试试看 123456789101112131415161718% 我是一个错误演示\documentclass&#123;article&#125;\usepackage&#123;multirow&#125;\begin&#123;document&#125;\begin&#123;tabular&#125;&#123;|*&#123;10&#125;&#123;r|&#125;&#125;\hline\multicolumn&#123;2&#125;&#123;|c|&#125;&#123;\multirow&#123;2&#125;*&#123;Blank&#125;&#125;&amp; \multicolumn&#123;2&#125;&#123;|c|&#125;&#123;CG&#125; &amp; \multicolumn&#123;2&#125;&#123;|c|&#125;&#123;IS&#125;&amp; \multicolumn&#123;2&#125;&#123;|c|&#125;&#123;MG&#125; &amp; \multicolumn&#123;2&#125;&#123;|c|&#125;&#123;LU&#125;\\\cline&#123;3-10&#125;\multicolumn&#123;2&#125;&#123;|c|&#125;&#123;&#125; &amp; 2 &amp; 4 &amp; 2 &amp; 4 &amp; 2 &amp; 4 &amp; 2 &amp; 4\\\hline\multirow&#123;2&#125;*&#123;Run Time(s)&#125;&amp; IA32 &amp; 24.37 &amp; 16.18 &amp; 19.62 &amp; 8.98 &amp; 31.98 &amp; 18.71 &amp; 622.76 &amp; 266.16\\&amp; IA64 &amp; 54.41 &amp; 30.29 &amp; 25.54 &amp; 15.72 &amp; 164.16 &amp; 84.73 &amp; 3226.60 &amp; 1723.11\\\hline\multirow&#123;2&#125;*&#123;Sync Time(ms)&#125;&amp; IA32 &amp; 7.156 &amp; 25.607 &amp; 189.793 &amp; 70.336 &amp; 286.354 &amp; 86.888 &amp; 6.446 &amp; 18.434\\&amp; IA64 &amp; 5.960 &amp; 7.043 &amp; 21.980 &amp; 10.078 &amp; 2.780 &amp; 13.793&amp; 2.922 &amp; 5.385\\\hline\end&#123;tabular&#125;\end&#123;document&#125; 为了解决这个问题，同时尽可能让示例简单明了，我们将会在下面这个表格的基础上进行修改 12345678910111213% 我是一个肥胖儿童\documentclass[UTF8]&#123;ctexart&#125;\begin&#123;document&#125;\begin&#123;table&#125;[!htbp]\begin&#123;tabular&#125;&#123;|*&#123;5&#125;&#123;c|&#125;&#125;\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列&amp; 第四列第四列&amp; 第五列第五列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列&amp; 第四列第四列&amp; 第五列第五列\\\hline\end&#123;tabular&#125;\end&#123;table&#125;\end&#123;document&#125; 它的编译结果在这里. 压缩一个显然的想法，是横纵各压缩相同的比例，使得表格足够「苗条」。 graphicx 宏包提供的 \resizebox{h-length}{v-length}{text} 命令可以满足要求。这个命令可以将 text 中的内容拉伸至 h-length 和 v-length 指定的长度。同时如果将 ! 填入 v-length 的话，将会按照 h-length 的比例拉伸 text 中的内容。 参考以下代码 12345678910111213141516% 我是代码 10 号\documentclass[UTF8]&#123;ctexart&#125;\usepackage&#123;graphicx&#125;\begin&#123;document&#125;\begin&#123;table&#125;[!htbp]\resizebox&#123;\textwidth&#125;&#123;!&#125;&#123;\begin&#123;tabular&#125;&#123;|*&#123;5&#125;&#123;c|&#125;&#125;\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列&amp; 第四列第四列&amp; 第五列第五列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列&amp; 第四列第四列&amp; 第五列第五列\\\hline\end&#123;tabular&#125;&#125;\end&#123;table&#125;\end&#123;document&#125; 编译结果在这里. 这种方法在「微胖」的时候特别有用，但是如果表格超出页面太多，这样强制压缩会使得表格内的文字太小，「有碍观瞻」。因此我们需要考虑另外的方法。 限制列宽如果我们用 p{} 选项限制列宽，则能够间接控制整个表格的宽度，从而达到目的。但是 p{} 选项不能同时和 lrc 等位置选项并存，也就是说使用 p{} 选项的时候，我们就无法控制列内的文字位置，这是不科学的。 考虑到这个情况，我们需要对 LaTeX 本身的命令做一些补充，才能够达到我们的目的。array 宏包为我们提供了这样做的可能。下面的代码，定义了 L{} R{} C{} 三个表格列选项，集合了原本的 lrc 的功能以及 p{} 选项限制列宽的功能 1234567891011121314151617181920% 我是代码 11 号\documentclass[UTF8]&#123;ctexart&#125;\usepackage&#123;array&#125;\newcolumntype&#123;L&#125;[1]&#123;&gt;&#123;\vspace&#123;0.5em&#125;\begin&#123;minipage&#125;&#123;#1&#125;\raggedright\let\newline\\\arraybackslash\hspace&#123;0pt&#125;&#125;m&#123;#1&#125;&lt;&#123;\end&#123;minipage&#125;\vspace&#123;0.5em&#125;&#125;&#125;\newcolumntype&#123;R&#125;[1]&#123;&gt;&#123;\vspace&#123;0.5em&#125;\begin&#123;minipage&#125;&#123;#1&#125;\raggedleft\let\newline\\\arraybackslash\hspace&#123;0pt&#125;&#125;m&#123;#1&#125;&lt;&#123;\end&#123;minipage&#125;\vspace&#123;0.5em&#125;&#125;&#125;\newcolumntype&#123;C&#125;[1]&#123;&gt;&#123;\vspace&#123;0.5em&#125;\begin&#123;minipage&#125;&#123;#1&#125;\centering\let\newline\\\arraybackslash\hspace&#123;0pt&#125;&#125;m&#123;#1&#125;&lt;&#123;\end&#123;minipage&#125;\vspace&#123;0.5em&#125;&#125;&#125;\begin&#123;document&#125;\begin&#123;table&#125;[!htbp]\begin&#123;tabular&#125;&#123;|*&#123;5&#125;&#123;C&#123;.15\textwidth&#125;|&#125;&#125;\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列&amp; 第四列第四列&amp; 第五列第五列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列&amp; 第四列第四列&amp; 第五列第五列\\\hline\end&#123;tabular&#125;\end&#123;table&#125;\end&#123;document&#125; 编译结果在这里. 实际应用中，还可以将这两个方法结合起来，效果拔群。 「姚明」表格LaTeX 将 tabular 环境当做一个 box 来处理，因此用 tabular 环境输出的表格不能跨页。当然你可以使用 \resizebox 命令来缩放表格，不过显然，会有更好的办法。 longtable 宏包提供了 longtable 环境，来生成可以跨页的表格。下面是一个示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293% 我是代码 12 号\documentclass[UTF8]&#123;ctexart&#125;\usepackage&#123;longtable&#125;\begin&#123;document&#125;\begin&#123;longtable&#125;&#123;|c|c|c|&#125;\caption&#123;这是一个很长的表格&#125;\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline第一列第一列&amp; 第二列第二列&amp; 第三列第三列\\\hline\end&#123;longtable&#125;\end&#123;document&#125; 编译结果在这里. 斜线表头diagbox 宏包可以制作斜线表头。参照下列示例 12345678910111213% 我是代码 13 号\documentclass&#123;article&#125;\usepackage&#123;diagbox&#125;\begin&#123;document&#125;\begin&#123;tabular&#125;&#123;|l|ccc|&#125;\hline\diagbox&#123;Time&#125;&#123;Room&#125;&#123;Day&#125; &amp; Mon &amp; Tue &amp; Wed \\\hlineMorning &amp; used &amp; used &amp;\\Afternoon &amp; &amp; used &amp; used \\\hline\end&#123;tabular&#125;\end&#123;document&#125; 编译结果见这里.]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LaTeX Tips】LaTeX 模板收集]]></title>
    <url>%2F2013%2F05%2F18%2FLaTeX-templates%2F</url>
    <content type="text"><![CDATA[国外大学学位论文模板 北卡罗来纳州立大学：http://www.latexstudio.net/latex-thesis-class-conforming-to-nc-state-etd/ 德国达姆斯塔特工业大学: http://www.latexstudio.net/tu-darmstadt-latex-thesis-template/ 牛津大学: http://www.latexstudio.net/oxford-thesis-latex-template/ 哈维姆德学院数学系: http://www.latexstudio.net/harvey-mudd-college-latex-collection-for-student/ 丹麦技术大学: http://www.latexstudio.net/danmarks-tekniske-universite-latex-template-collection/ 麻省理工学院博士: http://www.latexstudio.net/mit-phd-thesis-latex-template/ 哈佛大学博士: http://www.latexstudio.net/latex-template-for-harvard-dissertation/ 联邦伯南布哥州大学: http://www.latexstudio.net/new-version-of-rise-latex-template/ 亚琛工业大学: http://www.latexstudio.net/rwth-aachen-latex-thesis-template/ 美国国家科学院院刊: http://www.latexstudio.net/united-states-national-academy-pnas-latex-template-sharing/ 密歇根州立大学博士硕士: http://www.latexstudio.net/michigan-state-university-masters-thesis-latex-template-sharing/ 新里斯本大学: http://www.latexstudio.net/new-university-of-lisbon-article-template-sharing/ 国外大学学位论文答辩幻灯片模板 北卡罗来纳州立大学：http://www.latexstudio.net/latex-thesis-class-conforming-to-nc-state-etd/ 阿拉斯加大学费尔班克斯分校：http://www.latexstudio.net/uaf-beamer-poster-and-letter-templates/ 不伦瑞克大学: http://www.latexstudio.net/technische-universitaet-braunschweig-beamer-theme-template/ 内梅亨大学: http://www.latexstudio.net/the-radboud-university-latex-presentation-templates/ 曼彻斯特大学: http://www.latexstudio.net/unofficial-university-of-manchester-beamer/ 卡尔斯鲁厄理工学院: http://www.latexstudio.net/kit-beamer-theme-share/ 安特卫普大学: http://www.latexstudio.net/ap-university-of-antwerp-latex-beamer-template/ 麦吉尔大学: http://www.latexstudio.net/beamer-theme-of-mcgill-university-to-share/ 印度甘露大学: http://www.latexstudio.net/india-dew-university-share-beamer-theme/ 剑桥大学: http://www.latexstudio.net/university-of-cambridge-beamer-theme/ 荷兰埃因霍温科技大学: http://www.latexstudio.net/netherlands-eindhoven-university-of-technology-beamer-theme/ 莱斯大学: http://www.latexstudio.net/united-states-rice-university-beamer-theme-and-poster-topics-sharing/ 拉脱维亚大学: http://www.latexstudio.net/beamer-template-for-university-of-latvia/ 阿拉斯加大学费尔班克斯分校: http://www.latexstudio.net/university-of-alaska-fairbanks-beamer-theme/ 贝尔福-蒙贝利亚技术大学: http://www.latexstudio.net/a-beamer-theme-for-utbm/ 国内大学学位论文模板 中国科学技术大学本科: http://www.latexstudio.net/ustc-thesis-bachelor-latex-template/ 中央大學碩博士: http://www.latexstudio.net/ncu-thesis-latex-template/ 中国地质大学(武汉): http://www.latexstudio.net/latex-template-of-china-university-of-geosciences/ 南京大学: http://www.latexstudio.net/nju-thesis-latex-template-without-bachelor/ 南开大学: http://www.latexstudio.net/nankai-university-thesis-latex-template-update/; http://www.latexstudio.net/nankai-university-degree-thesis-latex-template/ 中国科学院大学硕博: http://www.latexstudio.net/latex-template-of-graduate-thesis-university-of-chinese-academy-of-sciences/ 东北大学博士: http://www.latexstudio.net/northeastern-university-doctoral-thesis-latex-template/ 中山大学博士: http://www.latexstudio.net/sun-yat-sen-university-doctoral-thesis-latex-template/ 大连海事大学硕博: http://www.latexstudio.net/bo-dalian-maritime-university-masters-thesis-latex-template/ 东南大学: http://www.latexstudio.net/southeast-university-degree-thesis-latex-template/ 上海交通大学: http://www.latexstudio.net/shanghai-jiao-tong-university-degree-thesis-latex-template/ 华东师范大学: http://www.latexstudio.net/east-china-normal-university-latex-template-sharing/ 武汉大学: http://www.latexstudio.net/whu-latex-template-update/ 北京师范大学: http://www.latexstudio.net/beijing-normal-university-degree-thesis-latex-template/ 大连理工大学博士: http://www.latexstudio.net/dalian-university-of-technology-phd-thesis-latex-template/ 电子科技大学: http://www.latexstudio.net/university-degree-thesis-latex-template/ 北京大学: http://www.latexstudio.net/peking-university-thesis-latex-document-template/ 北京师范大学: http://www.latexstudio.net/beijing-normal-university-latex-thesis-template/ 四川大学本科: http://www.latexstudio.net/sichuan-university-graduation-thesis-latex-template/ 华南理工大学硕士博士: http://www.latexstudio.net/south-china-university-of-technology-masters-doctoral-dissertation-lyx-and-latex-templates/ 华中科技大学: http://www.latexstudio.net/huazhong-university-of-science-and-the-unofficial-thesis-latex-template/ 同济大学: http://www.latexstudio.net/tongji-university-degree-thesis-latex-template/ 哈尔滨工业大学: http://www.latexstudio.net/harbin-institute-of-technology-thesis-latex-template/ 首都师范大学: http://www.latexstudio.net/latex-thesis-template-for-capital-normal-university/ 华南师范大学硕士/博士: http://www.latexstudio.net/south-china-normal-university-masters-doctorate-thesis-latex-template/ 厦门大学: http://www.latexstudio.net/xmuthesis-latex-template/ 北京航空航天大学: http://www.latexstudio.net/beijing-university-of-aeronautics-and-astronautics-thesis-latex-template/ 清华大学: http://www.latexstudio.net/tsinghua-university-degree-thesis-latex-template/ 西安电子科技大学: http://www.latexstudio.net/xidian-university-graduation-thesis-latex-template/ 西北工业大学: http://www.latexstudio.net/northwestern-polytechnical-university-bachelors-degree-thesis-latex-template/ 臺灣大學碩博: http://www.latexstudio.net/wikiproject-taiwan-university-dr-%e7%a2%a9-lun-xelatex-template/ 山东大学: /LaTeX-SDUtemplate/ 国内幻灯片模板 毕业答辩幻灯片beamer分享[ChinaTeX]: http://www.latexstudio.net/graduation-reply-share-slide-beamer-chinatex/ 一个漂亮, 简洁的Latex 幻灯片模板: http://www.latexstudio.net/a-beautiful-simple-latex-slide-templates/ 黑板主题的beamer主题分享: http://www.latexstudio.net/beamer-theme-themes-the-blackboard-share/ 香港理工大学: http://www.latexstudio.net/polyu-beamer-theme/ 带进度条的beamer主题分享: http://www.latexstudio.net/beamer-theme-with-a-progress-bar-to-share/ 简历 定制性很好的 LaTeX 简历模板（林莲枝）: http://www.latexstudio.net/easy-modified-latex-resume-template/ LaTeX简历模板分享: http://www.latexstudio.net/latex-resume-template-simple-sharing/ 一个质感的简历LaTeX模板分享: http://www.latexstudio.net/a-latex-texture-resume-template-sharing/ 一个由表格制作的简历模板分享: http://www.latexstudio.net/a-from-table-to-make-a-resume-template-sharing/ 一个精心制作的简历模板分享: http://www.latexstudio.net/a-carefully-crafted-resume-template-sharing-2/ 数学建模 全国大学生数学建模竞赛论文模板 其他 课堂笔记: http://www.latexstudio.net/latex-cources-note-template/]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Templates</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LaTeX Tips】如何正确定义中文段落缩进]]></title>
    <url>%2F2013%2F05%2F15%2FLaTeX-Chinese-parindent%2F</url>
    <content type="text"><![CDATA[段落缩进的中文习惯引中文行文有在每个自然段段首缩进两个字符的习惯。但是 LaTeX 是美国人做的，CJK 宏包是德国人做的，在段落缩进这方面设计得并不符合中国人的使用习惯。 为了解决这个问题，通常的解决方案是将 \parindent 这个宏设置为某一个特殊的值。比如在 12pt 的模式下，设置 \setlength\parindent{2.45em}，看起来中文正好缩进了两个字符。但实际上这种方式治标不治本——比如你将模式改为 10pt，就会发现缩进过头了。 讨论中文缩进和英文缩进有不同，为了解决问题，我们首先应当搞清楚，究竟应该缩进多少，而非是在一次次地尝试中「大概」完成任务。 缩进两个字符，准确地说，应该是段首的第一 个文字的左沿 和该段第二 行第三个文字的左沿 切齐。 于是缩进长度 = 两个字符的宽度 ？ 错！！ 一个字符在排版中所占的宽度并不等于它本身的宽度，因为字符和字符之间还有一定的空隙——不可能每个字符毫无间隙地黏在一起。所以若是缩进两个字符的宽度，那么看起来缩进将会有些「不够」。亦即段首第一个文字的左沿看起来在第二行第三个文字左沿的左边。 因此我们定义 字宽 = 字符宽度 + 字符间距 = 相邻两字符中心的间距。 因此，缩进长度 = 2 * 字宽。 解决步骤 获取当前字符宽度； 获取当前字符间距大小； 定义字宽（上述二者相加）； 定义缩进长度（两倍字宽）。 LaTeX 实现获取当前字符宽度1234%----CJK字符宽度%\f@size = 当前字符大小数值（pt/pt）%\p@ = 1pt\def\elegant@CJKChar@size&#123;\hskip \f@size \p@&#125; 这里的\f@size和\p@均是 LaTeX 内部定义的宏，前者存储了当前字符大小（以 pt 为单位的数值；不带单位；注意这是个数字 ），后者代表 1pt. 因此 \elegant@CJKChar@size 被定义为了带单位（pt）的字符宽度，这正是我们需要的。 获取当前字符间距大小在 LaTeX 的中文支持中（CJK 和 xeCJK是如此；CCT 及天元系统不了解，不过也不会有人用了吧），字符间距被定义为CJKglue，我们可以直接使用这个宏。 定义字宽123%字宽 = 字符宽度 + 字符间距 = 相邻字符中心的间距\newdimen\elegant@CJKChar@size@dimen\settowidth\elegant@CJKChar@size@dimen&#123;\elegant@CJKChar@size\CJKglue&#125; 第一行，定义了一个 dimen 类型的长度宏，名字是 \elegant@CJKChar@size@dimen。第二行，将它设置为字符宽度与字符间距之和。这正是我们需要的。 定义缩进长度LaTeX 的缩进长度被存储在 \parindent 这个宏之中，用 \parindent2\elegant@CJKChar@size@dimen 将之设置为字宽的二倍。 至此，基本的代码已经构建完成，原理也已经讲述清楚。下面是添加用户接口的代码。 完整代码1234567891011121314151617181920212223242526272829\ProvidesPackage&#123;cjkindent&#125;%-----字宽/缩进-----%----CJK字符宽度%\f@size = 当前字符大小数值（pt/pt）%\p@ = 1pt\def\elegant@CJKChar@size&#123;\hskip \f@size \p@&#125;%----定义字宽%字宽 = 字符宽度 + 字符间距 = 相邻字符中心的间距\newdimen\elegant@CJKChar@size@dimen\settowidth\elegant@CJKChar@size@dimen&#123;\elegant@CJKChar@size\CJKglue&#125;%----用户接口%负责刷新字宽和段落缩进\newcommand&#123;\CJKsetfontspace&#125;&#123;%刷新字宽\settowidth\elegant@CJKChar@size@dimen&#123;\elegant@CJKChar@size\CJKglue&#125;%%刷新段落缩进%判断段落缩进是否被设置为0（如果是表示要求不缩进）\ifdim\parindent=0pt%\relax%\else%\parindent2\elegant@CJKChar@size@dimen%\fi%&#125;\newcommand&#123;\Eindent&#125;&#123;\CJKsetfontspace\parindent2\elegant@CJKChar@size@dimen&#125;\newcommand&#123;\Enoindent&#125;&#123;\parident\z@&#125;%----自动执行\RequirePackage&#123;indentfirst&#125;\AtBeginDocument&#123;\Eindent&#125;%-----字宽/缩进----- 用法 将该段代码另存为 cjkindent.sty，保存在当前目录； 在导言区使用命令 \usepackage{cjkindent}； 正文部分立即能按照中文习惯缩进。 使用 \Eindent 命令，可以使得该段缩进； 使用 \Enoindent 命令，可以使得该段不缩进。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Chinese</tag>
        <tag>Parindent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LaTeX Tips】定义新环境时，花括号意外匹配的解决]]></title>
    <url>%2F2013%2F05%2F14%2FLaTeX-environ%2F</url>
    <content type="text"><![CDATA[问题环境XP sp3, TeX Live 2012, TeX studio. 测试代码12345678910111213141516171819202122232425262728293031\documentclass&#123;book&#125;\usepackage&#123;tikz&#125;\usetikzlibrary&#123;shapes,snakes&#125;\usepackage&#123;amsmath,amssymb&#125;\usepackage&#123;xcolor&#125;\definecolor&#123;main&#125;&#123;HTML&#125;&#123;66CCFF&#125;\tikzstyle&#123;newthemsty&#125; = [draw=main, fill=yellow!20,very thick, rectangle, rounded corners, inner sep=10pt, inner ysep=20pt]\tikzstyle&#123;newthemstytitle&#125; = [rounded corners, fill=main, text=white]\newenvironment&#123;tikzthm&#125;[1]&#123;\begin&#123;tikzpicture&#125;\node [newthemsty] (box)&#123;&#125;&#123;&#125;;\node[newthemstytitle, right=10pt] at (box.north west) &#123;\textbf&#123;#1&#125;&#125;;\end&#123;tikzpicture&#125;&#125;\begin&#123;document&#125;\begin&#123;tikzpicture&#125;\node [newthemsty] (box)&#123;blah blah.&#125;;\node[newthemstytitle, right=10pt] at (box.north west) &#123;\textbf&#123;thmtitle&#125;&#125;;\end&#123;tikzpicture&#125;\begin&#123;tikzthm&#125;&#123;thmtitle&#125;blah blah.\end&#123;tikzthm&#125;\end&#123;document&#125; pdfLaTeX 编译效果如图 描述尝试定义环境 tikzthm, 实现编译效果中上边的样式，但实际定义出来效果是下边的样子。 初步分析，定义环境的时候，花括号意外地被匹配了。 12345678\newenvironment&#123;tikzthm&#125;[1]&#123;\begin&#123;tikzpicture&#125;\node [newthemsty] (box)&#123;&#125;&#123;&#125;;\node[newthemstytitle, right=10pt] at (box.north west) &#123;\textbf&#123;#1&#125;&#125;;\end&#123;tikzpicture&#125;&#125; 这里的第四行中的 }{ 应当是 \newenvironment{nam}[args]{begdef}{enddef} 中 begdef 和 enddef 之间的两个花括号。但事实上，因为 TikZ 中 \node 的作用，这里的前一个右花括号和 \node 的左花括号配对了，后一个左花括号和本来应该是 \node 的右花括号配对了。实际效果应该是下面这个样子： 1234567\newenvironment&#123;tikzthm&#125;[1]&#123;\begin&#123;tikzpicture&#125;\node [newthemsty] (box)&#123;&#125;&#123;&#125;;\node[newthemstytitle, right=10pt] at (box.north west) &#123;\textbf&#123;#1&#125;&#125;;\end&#123;tikzpicture&#125;&#125; 这就使得 \node 无法接收到内容，而且 \newenvironment 少了一个参数（如果后面接着什么东西的话，会出现奇怪的错误的。。）。 解决已经解决，方案来自 stackexchange. 如果期待 \formatcommand{ foo } 形式的代码作用于环境的 body, 则因为花括号匹配的问题会出错: 12345\newenvironment&#123;testenv&#125;&#123; \formatcommand&#123;&#125;&#123; &#125;&#125; 解决方案可以用 environ 包提供的新命令 \NewEnviron 定义环境。举例如下： 123456789101112131415161718192021222324\documentclass&#123;book&#125;\usepackage&#123;environ&#125;\usepackage&#123;tikz&#125;\usetikzlibrary&#123;shapes,snakes&#125;\usepackage&#123;amsmath,amssymb&#125;\usepackage&#123;xcolor&#125;\definecolor&#123;main&#125;&#123;HTML&#125;&#123;66CCFF&#125;\tikzstyle&#123;newthemsty&#125; = [draw=main, fill=yellow!20,very thick, rectangle, rounded corners, inner sep=10pt, inner ysep=20pt]\tikzstyle&#123;newthemstytitle&#125; = [rounded corners, fill=main, text=white]\NewEnviron&#123;tikzthm&#125;[1]&#123;\begin&#123;tikzpicture&#125;\node [newthemsty] (box)&#123;\BODY&#125;;\node[newthemstytitle, right=10pt] at (box.north west) &#123;\textbf&#123;#1&#125;&#125;;\end&#123;tikzpicture&#125;&#125;\begin&#123;document&#125;\begin&#123;tikzthm&#125;&#123;thmtitle&#125;blah blah.\end&#123;tikzthm&#125;\end&#123;document&#125; 与 LaTeX 提供的 \newenvironment 不同，\NewEnviron 要求用 \BODY 显示地标明环境的 body 出现的位置。这样就避免了花括号错误匹配的问题。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Environ</tag>
        <tag>Newenvironment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LaTeX Tips】LaTeX 山东大学学位论文模板]]></title>
    <url>%2F2013%2F05%2F12%2FLaTeX-SDUtemplate%2F</url>
    <content type="text"><![CDATA[扉页预览 重要的说明安装字体模板实现了中英文混排，中文字体使用的是 Adobe 家的字体，你可以在这里下载到。对于 Windows 系统，安装字体很简单，只需要把下载得到的字体文件解压到C:\\windows\Fonts\下即可（系统会自动安装）；对于 *nix 系统，安装相对麻烦，不过相信使用这些系统的你一定知道怎么办。另外还有微软雅黑字体，这在 Windows Vista 及以后的 Windows 系列系统中是默认字体，如果需要，请到这里下载。 英文字体使用如下字体 TeX Gyre Pagella作为 Roman 字体，这在大多数的 TeX 发行中都已经自带了； Verdana作为粗体，这是Windows系统的自带字体，如果你的系统里没有这个字体，请到这里下载； Arial作为 Sans 字体，它的情况同Verdana一样，如有需要请到这里下载； Inconsolata作为打字机字体，这是一款优秀的打字机字体，请到这里下载。 这些字体仅仅是个人喜好，当然也是推荐的字体。如果你希望能够正常使用这个模板，则必须安装好这些字体；或者，如果你会的话，可以在文档类中修改使用的字体。事实上做这个修改是很容易的，因为我将系统字体映射为了逻辑字体，这样使得你只需要修改映射部分的代码，而无需在文档类中依次寻找并修改设置。 123456789\newcommand\fontnameroman&#123;TeX Gyre Pagella&#125;\newcommand\fontnameblack&#123;Verdana&#125;\newcommand\fontnamesans&#123;Arial&#125;\newcommand\fontnamemono&#123;Inconsolata&#125;\newcommand\fontnamehei&#123;Adobe Heiti Std&#125;\newcommand\fontnamesong&#123;Adobe Song Std&#125;\newcommand\fontnamefsong&#123;Adobe Fangsong Std&#125;\newcommand\fontnamekai&#123;Adobe Kaiti Std&#125;\newcommand\fontnameyahei&#123;Yahei Mono&#125; 怎样编译文档使用 XeLaTeX 进行编译。这要求所有参与编译的文档必须使用 UTF8 编码格式，因此你新建的任何参与编译的.tex文件都必须使用 UTF8 编码。 不选择 pdfLaTeX 或者 LaTeX 的原因很简单，使用它们结合 CJK 宏包支持中文的方法已经过时了，因为他们对于换行和字体选择的处理不好。此外 XeTeX 引擎原生支持 Unicode 编码，很好很强大。 打印的问题对于需要打印的文档，请在载入文档类的时候添加 print 选项。这将会调整页面设置以适应双页打印，并调整 \chapter{title} 命令的效果。 1\documentclass[print]&#123;sduthesis&#125; 如果不是彩色打印机，在打印的时候请选择黑白打印。文中有些使用彩色标注的部分在黑白打印中效果不好，如果不正确选择打印机模式的话。 获取与更新获取请到项目的 GitHub 页获取。 https://github.com/ChenMeng0518/sduthesis/ 更新记录1.1.4增加定义了中英文的摘要环境和关键词控制序列。可以使用 cnabstract 和 enabstract 生成中英文的摘要，以及使用 \cnkeywords{} 和 \enkeywords{} 生成中英文的关键词。 1.1.0修正了目录中章节显示的问题，提供了新的选项 [roman] 以调用 Times New Roman 字体。修正了 Readme 中的一些小问题。]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>SDU</tag>
        <tag>Template</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LaTeX Tips】绘制平行四边形符号]]></title>
    <url>%2F2013%2F04%2F13%2FLaTeX-parallelogram%2F</url>
    <content type="text"><![CDATA[平行四边形符号不是国际标准符号，而是我国「自造」的一个符号，所以在LaTeX本身以及常用符号宏包中都是未定义的。最方便的方法就是「自造」一个符号，利用 TikZ 之类的绘图工具。以下是代码： 12345678910\documentclass&#123;article&#125;\usepackage&#123;amsmath&#125;\usepackage&#123;tikz&#125;\newcommand\parallelogram&#123;% \mathord&#123;\text&#123;% \tikz[baseline] \draw (0,.1ex) -- (.8em,.1ex) -- (1em,1.6ex) -- (.2em,1.6ex) -- cycle;&#125;&#125;&#125;\begin&#123;document&#125;\[ \parallelogram ABCD \]\[ E_&#123;\parallelogram ABCD&#125; \]\end&#123;document&#125; 以下是效果：]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>Parallelogram</tag>
      </tags>
  </entry>
</search>

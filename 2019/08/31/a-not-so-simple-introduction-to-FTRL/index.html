<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png">
  <link rel="mask-icon" href="/images/favicon/safari-pinned-tab.svg" color="#222">
  <link rel="manifest" href="/images/favicon/site.webmanifest">
  <meta name="msapplication-config" content="/images/favicon/browserconfig.xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="google-site-verification" content="TYuJQFuiVqfbFfJAkHfXigSDRIMibztxXxgl_iAaQhA">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liam.page","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="FTRL 是 Follow The Regularized Leader 的缩写，它是 Google 在 2010 -- 2013 年三年时间内，从理论研究到实际工程化实现的在线优化算法框架。FTRL 在处理带 $L_1$ 正则化的逻辑回归类模型时，效果非常出色：能够得到性能较好的稀疏解。 中文网络上，已有一些关于 FTRL 的介绍。比较详细和出名的是新浪微博的冯扬撰写的「在线最优化求解」。但在我">
<meta property="og:type" content="article">
<meta property="og:title" content="FTRL 不太简短之介绍">
<meta property="og:url" content="https://liam.page/2019/08/31/a-not-so-simple-introduction-to-FTRL/index.html">
<meta property="og:site_name" content="始终">
<meta property="og:description" content="FTRL 是 Follow The Regularized Leader 的缩写，它是 Google 在 2010 -- 2013 年三年时间内，从理论研究到实际工程化实现的在线优化算法框架。FTRL 在处理带 $L_1$ 正则化的逻辑回归类模型时，效果非常出色：能够得到性能较好的稀疏解。 中文网络上，已有一些关于 FTRL 的介绍。比较详细和出名的是新浪微博的冯扬撰写的「在线最优化求解」。但在我">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-08-31T12:01:23.000Z">
<meta property="article:modified_time" content="2021-04-21T13:48:50.290Z">
<meta property="article:author" content="Liam Huang">
<meta property="article:tag" content="Logistic Regression">
<meta property="article:tag" content="FTRL">
<meta property="article:tag" content="Online Optimization">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://liam.page/2019/08/31/a-not-so-simple-introduction-to-FTRL/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><style>
#needsharebutton-postbottom {
  cursor: pointer;
  height: 26px;
  margin-top: 10px;
  position: relative;
}
#needsharebutton-postbottom .btn {
  border: 1px solid $btn-default-border-color;
  border-radius: 3px;
  display: initial;
  padding: 1px 4px;
}
</style>
  <title>FTRL 不太简短之介绍 | 始终</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-44836433-1"></script>
    <script data-pjax>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-44836433-1');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">始终</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">不忘初心</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">404</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">15</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">773</span></a>

  </li>
        <li class="menu-item menu-item-系列">

    <a href="/series/" rel="section"><i class="fa fa-fw fa-book"></i>系列</a>

  </li>
        <li class="menu-item menu-item-札记-&-留言板">

    <a href="/notes/" rel="section"><i class="fa fa-fw fa-sticky-note"></i>札记 & 留言板</a>

  </li>
        <li class="menu-item menu-item-英文">

    <a href="/en/" rel="section"><i class="fa fa-fw fa-link"></i>英文</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liam.page/2019/08/31/a-not-so-simple-introduction-to-FTRL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar/avatar-3.jpg">
      <meta itemprop="name" content="Liam Huang">
      <meta itemprop="description" content="虚室生白，吉祥止止">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="始终">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          FTRL 不太简短之介绍
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019 年 08 月 31 日 20:01:23" itemprop="dateCreated datePublished" datetime="2019-08-31T20:01:23+08:00">2019 年 08 月 31 日</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021 年 04 月 21 日 21:48:50" itemprop="dateModified" datetime="2021-04-21T21:48:50+08:00">2021 年 04 月 21 日</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Big-Data-and-Machine-Learning/" itemprop="url" rel="index"><span itemprop="name">Big Data and Machine Learning</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>27k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>49 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>FTRL 是 Follow The Regularized Leader 的缩写，它是 Google 在 2010 -- 2013 年三年时间内，从理论研究到实际工程化实现的在线优化算法框架。FTRL 在处理带 <code>$L_1$</code> 正则化的<a href="/2018/10/10/logistic-regression/">逻辑回归</a>类模型时，效果非常出色：能够得到性能较好的稀疏解。</p>
<p>中文网络上，已有一些关于 FTRL 的介绍。比较详细和出名的是新浪微博的冯扬撰写的「在线最优化求解」。但在我看来，已有的关于 FTRL 的介绍，都或多或少有些值得调整和改进的地方。这促成了这篇文章。</p>
<p>这篇文章讲 FTRL 的理论部分，大致会按照这样的路径来阐述：</p>
<ul>
<li>我们想要解决什么问题？</li>
<li>FTRL 的前辈们是怎么尝试解决问题的？</li>
<li>前辈们之间是什么关系？又留下了哪些尚未解决的问题？FTRL 是如何解决这些遗留问题的？</li>
</ul>
<p>而后，在下一篇工程部分的文章中，我们会讨论一下 FTRL 的工程实现有哪些值得谈一谈的问题。</p>
<span id="more"></span>

<h2 id="我们面临的问题"><a href="#我们面临的问题" class="headerlink" title="我们面临的问题"></a>我们面临的问题</h2><p>传统的运用机器学习解决实际问题的步骤如下：</p>
<ul>
<li>数据融合，获取数据样本的标签。</li>
<li>特征工程及其 ETL，获取每个样本的特征。</li>
<li>样本处理，处理正负样本比例、无效或作弊样本等问题，输出用于训练、验证、测试的样本集。</li>
<li>构建模型，根据业务特点和数据特点，选取恰当的模型；比如 LR、FM、GBDT、DNN 等。</li>
<li>训练模型，在训练集上训练模型，在验证集上调参。</li>
<li>模型评估，在测试机上评估模型。</li>
<li>在线预测，将有效模型上线，进行在线预测。</li>
</ul>
<p>这样的流程能够解决很多问题，但存在至少两方面的瓶颈：</p>
<ol>
<li>整套流程在样本维度是「批量」的，在特征高维数据大量的情况下，这导致模型更新周期较长。在工程能力强的团队手上，模型的更新周期最好能做到小时级别；在工程能力差的团队手上，这个周期可能是天级甚至是周级别的。</li>
<li>模型的复杂度和线上预测性能之间难以权衡：模型复杂度低，线上预测效果差；模型复杂度高，线上预测效果好，但需要的存储、时间资源也随之升高，无法保证 RT 和 QPS。</li>
</ol>
<p>为了解决这里的问题 (1)，在线学习（Online Learning）逐渐兴起；为了解决问题 (2)，人们从各种正则、剪枝开始，尝试用各种手段，在保证模型精度的前提下，尽可能获得稀疏的模型。</p>
<h3 id="在线学习的兴起"><a href="#在线学习的兴起" class="headerlink" title="在线学习的兴起"></a>在线学习的兴起</h3><p>我曾经在多个场合谈到，机器学习模型的三要素是：</p>
<ul>
<li>模型结构；</li>
<li>优化目标；</li>
<li>求解方法。</li>
</ul>
<p>在这里，模型结构通常会需要根据实际问题的特点进行调整。例如，对于具有稠密特征样本的分类问题，GBDT 类的树模型往往效果良好。又例如，对于具有高维稀疏特征的大规模样本，<a href="/2018/10/10/logistic-regression/">逻辑回归</a>和<a href="https://liam.page/2019/03/25/Factorization-Machine/">因子分解机</a>（及其<a href="https://liam.page/2019/06/28/variants-of-FM/">变体</a>）就会是不错的选择。</p>
<p>优化目标往往会以目标函数这一数学形式来表达。目标函数中的损失函数，则是用来描述「模型对经验数据拟合程度好坏」的方法。目标函数（或损失函数）的选择，通常也是和实际问题的特点相关的。例如对于回归问题和分类问题，通常就会选择不同的损失函数。</p>
<blockquote>
<p>对于样本集合 <code>$\mathcal&#123;D&#125;$</code> 中编号为 <code>$i$</code> 的样本 <code>$\&#123;\vec x_i, y_i\&#125;$</code> 来说，在确定好模型结构 <code>$h(\cdot; \vec\omega)$</code> 的基础上，损失函数记为<br><code>$$\ell\bigl(h(\vec x_i; \vec\omega), y_i\bigr).$$</code></p>
</blockquote>
<p>求解方法则是解决如何在有限的时间内，求得一个既简单（模型复杂度低，不易过拟合）性能又好（对经验数据拟合程度较高）的模型。在模型结构确定的基础上，机器学习模型的学习，往往会化归为带参数目标函数的最优化求解问题。如何解决这些最优化问题，或者说，采用何种求解方法，往往要根据问题特点、模型结构、目标函数等等各种因素的不同，综合考虑。</p>
<h4 id="批量"><a href="#批量" class="headerlink" title="批量"></a>批量</h4><p>在机器学习兴起的早期，由于数据规模较小，计算性能较低与求解复杂度较高的矛盾尚不明显，人们很自然地选择与直觉相符合的批量求解方式来优化模型。具体来说，人们通常会随机给定模型参数 <code>$\vec\omega$</code> 的初值 <code>$\vec\omega_0$</code>，通过迭代，不断更新来调整 <code>$\vec\omega$</code> 的取值，使得目标函数在样本集合 <code>$\mathcal&#123;D&#125;$</code> 上的加和取得或接近最小值：</p>
<p><code>$$ \begin&#123;aligned&#125;   L(\vec\omega\mid \mathcal&#123;D&#125;) &amp;&#123;&#125; = \sum_&#123;\&#123;\vec x_i, y_i\&#125; \in \mathcal&#123;D&#125;&#125;\ell\bigl(h(\vec x_i; \vec\omega), y_i\bigr) \\   \vec\omega^&#123;*&#125; &amp;&#123;&#125; = \mathop&#123;\arg\,\min&#125;_&#123;\vec\omega&#125; L(\vec\omega\mid \mathcal&#123;D&#125;) \end&#123;aligned&#125; $$</code></p>
<p>对于这种解法，典型的方式是梯度下降（Gradient Descend）和牛顿法、拟牛顿法等。以梯度下降法为例，其 <code>$t$</code> 轮迭代的更新如下所示：</p>
<p><code>$$ \vec\omega^&#123;(t + 1)&#125; \gets \vec\omega^&#123;(t)&#125; - \eta^&#123;(t)&#125;\cdot\nabla_&#123;\vec\omega^&#123;(t)&#125;&#125;L(\vec\omega^&#123;(t)&#125;\mid \mathcal&#123;D&#125;). $$</code></p>
<p>在这种做法当中，每一次迭代，都需要扫描整个样本集合 <code>$\mathcal&#123;D&#125;$</code> 以计算全局损失 <code>$L$</code>，而后才能更新参数 <code>$\vec\omega$</code>。对于数据规模较小的情况，这样做的好处是能够准确计算每一次迭代时的梯度，避免「跑偏」。但对于随着数据规模的增大，每一次计算全局梯度的代价变得过高，完成训练的时间就会变得很长。为了解决这个问题，人们引入了随机（小批量）的解法。</p>
<h4 id="随机小批量"><a href="#随机小批量" class="headerlink" title="随机小批量"></a>随机小批量</h4><p>我在<a href="/2019/06/18/OCD-needs-stochastic-gradient-descent/">强迫症患者也需要随机梯度下降</a>一文中介绍了随机（小批量）梯度下降（Stochastic Gradient Descend）的方法和它的好处。按照本文的记号约定，随机梯度下降第 <code>$t$</code> 轮迭代的更新如下所示：</p>
<p><code>$$ \vec\omega^&#123;(t + 1)&#125; \gets \vec\omega^&#123;(t)&#125; - \eta^&#123;(t)&#125;\cdot\nabla_&#123;\vec\omega^&#123;(t)&#125;&#125;L(\vec\omega^&#123;(t)&#125;\mid \mathcal&#123;D&#125;^&#123;(t)&#125;). $$</code></p>
<p>这里描述的是随机小批量梯度下降。其中 <code>$\mathcal&#123;D&#125;^&#123;(t)&#125;$</code> 是当前轮次的迭代从全部样本集 <code>$\mathcal&#123;D&#125;$</code> 中随机选取的子集。当子集 <code>$\mathcal&#123;D&#125;^&#123;(t)&#125;$</code> 当中只有 1 个元素时，算法退化为纯粹的随机梯度下降。</p>
<p>在这种做法当中，每一次迭代，无需扫描整个样本集合 <code>$\mathcal&#123;D&#125;$</code> 以计算全局损失 <code>$L$</code>。取而代之的是，计算一个随机选取的小集合 <code>$\mathcal&#123;D&#125;^&#123;(t)&#125;$</code> 中的局部损失，即可更新参数 <code>$\vec\omega$</code>。对于数据规模较大的情况，这样的做法节省了每次迭代的计算量，虽然代价是需要迭代更多轮次，但是总体来说极大地降低了整体的训练时间；与此同时，如<a href="/2019/06/18/OCD-needs-stochastic-gradient-descent/">强迫症患者也需要随机梯度下降</a>一文中介绍的那样，随机梯度下降还能带来其它一些好处。</p>
<h4 id="在线学习"><a href="#在线学习" class="headerlink" title="在线学习"></a>在线学习</h4><p>随机（小批量）的优化方法解决了一部分问题，但做到极限，模型的更新周期也只能缩短到小时级。因此，在线学习逐渐走上了舞台。</p>
<p>和前辈们相比，在线学习最大的特点（或者说需求）有两个：</p>
<ul>
<li>每次只处理少数几个样本，甚至每次只处理一个样本；</li>
<li>处理过的样本对于优化过程来说会被「丢弃」，再也看不到了，因此在线学习需要一种「不吃后悔药」的优化方法。</li>
</ul>
<p>回过头来看随机（小批量）梯度下降，我们发现它恰好能满足在线学习的这两方面需求。对于第一个需求来说，这是显然的。对于第二个需求来说，在线接收的样本某种意义上就可以理解为是一种随机，只要这些随机送到优化器的样本的梯度在统计期望上与总体样本是一致的（而这是在线学习的基本假设），那就适用随机（小批量）梯度下降。</p>
<p>事情看起来很美妙，只需要把随机（小批量）梯度下降整合进在线学习的工程框架当中就可以了。但是事情没有那么美妙，因为这依然无法解决我们面临的第二个问题——对模型稀疏性的追求。</p>
<h3 id="对模型稀疏性的追求"><a href="#对模型稀疏性的追求" class="headerlink" title="对模型稀疏性的追求"></a>对模型稀疏性的追求</h3><h4 id="模型稀疏的好处"><a href="#模型稀疏的好处" class="headerlink" title="模型稀疏的好处"></a>模型稀疏的好处</h4><p>模型稀疏的好处有几个方面。</p>
<p>一是能解决之前提到的「模型复杂度低，线上预测效果差；模型复杂度高，线上预测效果好，但需要的存储、时间资源也随之升高，无法保证 RT 和 QPS」之问题。这是比较显然的。稀疏的模型会大大减少预测时的内存和复杂度。以 LR 为例，若已知输入向量的维度是 <code>$d$</code> 而 LR 中不为 0 的参数的数量是 <code>$w$</code>，若 <code>$d \gg w$</code>，那么绝大多数特征甚至不需要去采集。这样一来，从特征采集到预测运算整个步骤都能省下很多内存和计算复杂度。</p>
<p>二是模型的稀疏与 <code>$L_1$</code> 正则化不谋而合（见<a href="/2017/03/30/L1-and-L2-regularizer/">谈谈 L1 与 L2-正则项</a>一文），这意味着运用 <code>$L_1$</code> 正则化一方面可以使得模型变得稀疏，另一方面还能够降低模型过拟合的风险。</p>
<p>三是稀疏性较好的模型，相对来说可解释性更好。这对于我们来说，特别是在实际应用当中，是很有好处的。以那个经典的例子来解释，假设你现在需要训练一个模型，解释人的某些特征和罹患某种疾病之间的关系。如果模型稀疏，那么意味着，罹患某种疾病只与少数一些特征有关。这种模型，对于医生来说，是很友好的。因为当医生拿到一个人的指标数据（特征），他就能根据模型，很容易地告诉来访的就医者说：「你的 XX 指标比较高，而 YY 指标比较低，这是罹患 ZZ 疾病的高危因素。因此你需要在日常生活中注意某些方面，同时定期进行身体检查。」</p>
<h4 id="在批量梯度下降中，追求模型稀疏性"><a href="#在批量梯度下降中，追求模型稀疏性" class="headerlink" title="在批量梯度下降中，追求模型稀疏性"></a>在批量梯度下降中，追求模型稀疏性</h4><p>我们从最基本的批量梯度下降开始，逐步探寻如何解得一个稀疏的模型。</p>
<p>如<a href="/2017/03/30/L1-and-L2-regularizer/">谈谈 L1 与 L2-正则项</a>一文所说的那样，我们只需将 <code>$L_1$</code> 范数引入模型求解过程中的目标函数，即可获得相对稀疏的模型。注意，由于我们的终极目标是「稀疏」，这意味着要有尽可能多的权重项为 0。这样看起来，使用 <code>$L_0$</code> 范数可能更好（向量 <code>$\vec x$</code> 的 <code>$L_0$</code> 范数 <code>$\lVert \vec x\rVert_0$</code> 是向量 <code>$\vec x$</code> 各维度中不为 0 的维度的数量）。但由于 <code>$L_0$</code> 范数是非凸的，在求解优化上比较困难，故而采用 <code>$L_0$</code> 范数的最紧凸放松，即 <code>$L_1$</code> 范数作为替代。</p>
<p>这样一来，模型优化时需要最小化的目标函数变更为如下形式：</p>
<p><code>$$ \text&#123;Obj&#125;(\vec\omega\mid \mathcal&#123;D&#125;) = L(\vec\omega\mid \mathcal&#123;D&#125;) + \lambda_1\frac&#123;\lVert \vec\omega\rVert_1&#125;&#123;n&#125;, \quad\lambda_1 &gt; 0. $$</code></p>
<p>这里，等式右边的第一项表示模型在训练集 <code>$\mathcal&#123;D&#125;$</code> 上经验损失，第二项则表示模型的 <code>$L_1$</code> 正则项。其中 <code>$\lVert \vec\omega\rVert_1$</code> 表示向量 <code>$\vec\omega$</code> 的 <code>$L_1$</code> 范数，<code>$n$</code> 表示向量 <code>$\vec\omega$</code> 的维度。</p>
<p>那么为什么加入 <code>$L_1$</code> 正则项，有助于产出稀疏解呢？</p>
<p>我们假设对于某个 <code>$i \in \&#123;1, 2, \ldots, n\&#125;$</code> 来说，<code>$\omega_i = 0$</code>。然后，在接下来的迭代中，<code>$\omega_i$</code> 被更新为 <code>$\omega_i \gets 0 - \eta\frac&#123;\partial \text&#123;Obj&#125;&#125;&#123;\partial \omega_i&#125;$</code> 而其它参数保持不变。这意味着，对于 <code>$L_1$</code> 正则项来说，在这一轮迭代中增加了 <code>$\Delta\Omega = \eta\frac&#123;\lambda_1&#125;&#123;n&#125;\Bigl\lvert \frac&#123;\partial \text&#123;Obj&#125;&#125;&#123;\partial \omega_i&#125;\Bigr\rvert$</code>；对于损失函数来说，在这一轮迭代中大约下降了 <code>$\Delta L = \eta\Bigl\lvert \frac&#123;\partial \text&#123;Obj&#125;&#125;&#123;\partial \omega_i&#125;\Bigr\rvert\Bigl\lvert \frac&#123;\partial L&#125;&#123;\partial \omega_i&#125;\Bigr\rvert$</code>。而如果 <code>$\Delta L &lt; \Delta\Omega$</code>，即 <code>$\Bigl\lvert \frac&#123;\partial L&#125;&#123;\partial \omega_i&#125;\Bigr\rvert &lt; \frac&#123;\lambda_1&#125;&#123;n&#125;$</code>，那么目标函数整体是变大了（而不是变小了）。因此，对于这种情况，优化器会拒绝更新 <code>$\omega_i$</code>，也就是拒绝将 <code>$\omega_i$</code> 更新为非 0 值。由此就得到了相对稀疏的模型。</p>
<h4 id="L-1-正则在-SGD-中"><a href="#L-1-正则在-SGD-中" class="headerlink" title="$L_1$ 正则在 SGD 中"></a><code>$L_1$</code> 正则在 SGD 中</h4><p>注意，在批量梯度下降中，<code>$L_1$</code> 正则项能有效的原因在于下式的成立：</p>
<p><code>$$\biggl\lvert \frac&#123;\partial L&#125;&#123;\partial \omega_i&#125;\biggr\rvert &lt; \frac&#123;\lambda_1&#125;&#123;n&#125;.$$</code></p>
<p>但是，SGD 的假设（随机梯度的期望等于全局梯度）并不能保证在全局梯度满足上式的情况下，随机梯度总能使上式成立。这意味着，在 SGD 的场景中，使用 <code>$L_1$</code> 正则化有助于提升模型的稀疏性，但并不能很好地保证有在批量梯度下降中的那种稀疏化效果。</p>
<p>那么问题就来了：按之前的说法，在线学习中，我们必然要依赖类似 SGD 的算法；但 <code>$L_1$</code> 正则化并不能在 SGD 中确保模型是足够稀疏的。于是，<strong>我们迫切需要找到一种能够满足在线学习的需要，同时又能保证模型稀疏性的优化方法</strong>。</p>
<h2 id="FTRL-的前辈们"><a href="#FTRL-的前辈们" class="headerlink" title="FTRL 的前辈们"></a>FTRL 的前辈们</h2><p>前面提到，加入 <code>$L_1$</code> 正则项，是获得稀疏模型的主要手段；但由于 SGD 的原因，<code>$L_1$</code> 正则项又很难发挥作用。因此，我们需要新的手段——或者在 <code>$L_1$</code> 正则化的基础上改进，或者有全新的手段——来解决模型稀疏化的问题。完全创新总是比较困难的。事实上，目前也没有发现完全独立于 <code>$L_1$</code> 范数同时又十分有效的稀疏化方法。因此，人们的目光还是更多地会聚焦在，如何基于 <code>$L_1$</code> 正则项进行改进之上。</p>
<p>一个粗暴有简单的想法是：基于 <code>$L_1$</code> 正则项，对模型参数进行截断。具体是这样做的，以 <code>$k$</code> 轮迭代为一组：</p>
<ul>
<li>按带 <code>$L_1$</code> 正则项的 SGD 的方法训练 <code>$k - 1$</code> 轮</li>
<li>在第 <code>$k$</code> 轮迭代中，先按通常的 SGD 进行更新，得到 <code>$\vec\omega^&#123;(k&#39;)&#125;$</code>，然后对所有参数进行考察，以超参数 <code>$\theta$</code> 进行截断置零：</li>
</ul>
<p><code>$$\omega_i^&#123;(k)&#125; \gets \begin&#123;cases&#125; 0 &amp; \text&#123;if $\Bigl\lvert\omega_&#123;i&#125;^&#123;(k&#39;)&#125;\Bigr\rvert &lt; \theta$,&#125; \\ \omega_&#123;i&#125;^&#123;(k&#39;)&#125; &amp; \text&#123;otherwise.&#125; \end&#123;cases&#125;$$</code></p>
<p>显然，这种做法太过粗暴，存在很多问题；但它是所有类似方法的祖师爷，反映的是「不等式约束下的凸优化」的思路。在这种思路下，求到的梯度 <code>$g^&#123;(t)&#125; = \frac&#123;\partial \text&#123;Obj&#125;&#125;&#123;\partial \omega_i&#125;$</code> 被视作是次梯度（subgradient）。根据次梯度更新的结果，可能落在不等式约束的范围之外。此时，就要取该梯度在不等式约束范围内的投影作为真正的迭代结果。</p>
<p>简单截断法采取的投影方式，是直接截断。接下来，我们看看 FTRL 的其他前辈们是怎么做的。</p>
<h3 id="Truncated-Gradient"><a href="#Truncated-Gradient" class="headerlink" title="Truncated Gradient"></a>Truncated Gradient</h3><p>既然简单地截断过于粗暴，那么我们就让截断温和一点。这就是 09 年提出的截断梯度法。</p>
<ul>
<li>按带 <code>$L_1$</code> 正则项的 SGD 的方法训练 <code>$k - 1$</code> 轮</li>
<li>在第 <code>$k$</code> 轮迭代中，先按通常的 SGD 进行更新，得到 <code>$\vec\omega^&#123;(k&#39;)&#125;$</code>，然后对所有参数进行考察，以超参数 <code>$\theta$</code> 和 <code>$\alpha$</code> 进行截断：</li>
</ul>
<p><code>$$\omega_i^&#123;(k)&#125; \gets \begin&#123;cases&#125; 0&amp; \text&#123;if $\Bigl\lvert\omega_&#123;i&#125;^&#123;(k&#39;)&#125;\Bigr\rvert \leqslant \alpha$,&#125; \\ \omega_&#123;i&#125;^&#123;(k&#39;)&#125; - \alpha\,\text&#123;sgn&#125;\Bigl(\omega_&#123;i&#125;^&#123;(k&#39;)&#125;\Bigr) &amp; \text&#123;if $\alpha &lt; \Bigl\lvert\omega_&#123;i&#125;^&#123;(k&#39;)&#125;\Bigr\rvert \leqslant \theta$,&#125; \\ \omega_&#123;i&#125;^&#123;(k&#39;)&#125; &amp; \text&#123;otherwise.&#125; \end&#123;cases&#125;$$</code></p>
<p>这里 <code>$\alpha$</code> 通常取学习率 <code>$\eta^&#123;(k)&#125;$</code> 的倍数，例如 <code>$\alpha^&#123;(k)&#125; = \eta^&#123;(k)&#125;\lambda$</code>。截断梯度法采用的投影方式，是以分段函数的方式，对参数进行截断。</p>
<p>显然，<code>$\alpha$</code> 或 <code>$\theta$</code> 越大，模型越容易求得稀疏解。当 <code>$\alpha = \theta$</code>，TG 退化为简单截断法；当 <code>$\theta = \infty$</code> 且 <code>$k = 1$</code>，在截断区域之外，TG 继续退化为 SGD-<code>$L_1$</code>，此时 <code>$\omega_i$</code> 的更新是：</p>
<p><code>$$\omega_&#123;i&#125;^&#123;(t + 1)&#125; \gets \omega_&#123;i&#125;^&#123;(t)&#125; - \eta^&#123;(t)&#125;g_&#123;i&#125;^&#123;(t)&#125; - \eta^&#123;(t)&#125;\lambda\,\text&#123;sgn&#125;\Bigl(\omega_&#123;i&#125;^&#123;(t)&#125;\Bigr).$$</code></p>
<h3 id="FOBOS-Forward-Backward-Splitting"><a href="#FOBOS-Forward-Backward-Splitting" class="headerlink" title="FOBOS (Forward-Backward Splitting)"></a>FOBOS (Forward-Backward Splitting)</h3><p>FOBOS 最开始的名字叫做 Forward Looking Subgradients，简写叫做 FOLOS；后来改名叫做 Forward-Backward Splitting，按说应该简写成 FOBAS。但作者为了减少可能的困扰，就只修改了一个字母，变成了 FOBOS。</p>
<blockquote>
<p>吐槽：但实际上，变得更加困惑了好不好……</p>
</blockquote>
<p>FOBOS 可以看做是 TG 的改进。</p>
<p>首先，FOBOS 将 <code>$k$</code> 设置为 1。如此一来，每一轮迭代都一样了：先根据次梯度做梯度下降，再做一步投影操作。</p>
<p>其次，FOBOS 将投影操作改进如下：</p>
<p><code>$$\vec\omega^&#123;(t + 1)&#125; \gets \mathop&#123;\arg\,\min&#125;_&#123;\vec\omega&#125;\biggl\&#123;\frac&#123;1&#125;&#123;2&#125;\Bigl\lVert\vec\omega - \vec\omega^&#123;t&#39;&#125;\Bigr\rVert^&#123;2&#125; + \eta^&#123;(t&#39;)&#125;\Omega(\vec\omega)\biggr\&#125;.$$</code></p>
<p>这里，优化符号中的第一项保证了投影之后的结果距离梯度下降的结果不太远，第二项是正则项，用于产生稀疏性。我们将它转换为无约束优化的形式：</p>
<p><code>$$ \begin&#123;aligned&#125; \vec\omega^&#123;(t + 1)&#125; \gets&#123;&#125;&amp; \mathop&#123;\arg\,\min&#125;_&#123;\vec\omega&#125;\biggl\&#123;\frac&#123;1&#125;&#123;2&#125;\Bigl\lVert\vec\omega - \vec\omega^&#123;(t)&#125; + \eta^&#123;(t)&#125;\nabla\text&#123;Obj&#125;(\vec\omega^&#123;(t)&#125;)\Bigr\rVert^&#123;2&#125; + \eta^&#123;(t&#39;)&#125;\Omega(\vec\omega)\biggr\&#125;,  \\ =&#123;&#125;&amp; \vec\omega^&#123;(t)&#125; - \eta^&#123;(t)&#125;\nabla\text&#123;Obj&#125;(\vec\omega^&#123;(t)&#125;) - \eta^&#123;(t&#39;)&#125;\nabla\Omega(\vec\omega^&#123;(t + 1)&#125;). \end&#123;aligned&#125; $$</code></p>
<p>可见，更新结果不仅与上一轮迭代的结果有关（梯度下降），还与迭代之后的状态有关（正则约束），这就是所谓的 Forward-Backword Splitting。</p>
<p>当 <code>$\Omega(\cdot) = \eta^&#123;(t&#39;)&#125;\lambda\lVert\cdot\rVert_1 = \tilde\lambda\lVert\cdot\rVert_1$</code> 时，我们将向量形式再化简到具体某一维度的更新：</p>
<p><code>$$ \begin&#123;aligned&#125; \omega_&#123;i&#125;^&#123;(t + 1)&#125; \gets&#123;&#125;&amp; \text&#123;sgn&#125;\bigl(\omega_&#123;i&#125;^&#123;(t)&#125; - \eta^&#123;(t)&#125;g_&#123;i&#125;^&#123;(t)&#125;\bigr)\cdot\max\Bigl\&#123;0, \bigl\lvert \omega_&#123;i&#125;^&#123;(t)&#125; - \eta^&#123;(t)&#125;g_&#123;i&#125;^&#123;(t)&#125; \bigr\rvert - \tilde\lambda\Bigr\&#125;, \\ =&#123;&#125;&amp; \begin&#123;cases&#125; 0 &amp; \text&#123;if $\lvert\omega_&#123;i&#125;^&#123;(t&#39;)&#125;\rvert &lt; \tilde\lambda$,&#125; \\ \omega_&#123;i&#125;^&#123;(t)&#125; - \eta^&#123;(t)&#125;g_&#123;i&#125;^&#123;(t)&#125; - \tilde\lambda\,\text&#123;sgn&#125;\Bigl(\omega_&#123;i&#125;^&#123;(t)&#125; - \eta^&#123;(t)&#125;g_&#123;i&#125;^&#123;(t)&#125;\Bigr) &amp; \text&#123;otherwise.&#125; \end&#123;cases&#125; \end&#123;aligned&#125; $$</code></p>
<p>不难发现，它与 TG 的形式非常接近。当 TG 中的 <code>$\theta = \infty$</code>, <code>$\alpha = \tilde\lambda$</code>, <code>$k = 1$</code> 时，TG 与 FOBOS 的唯一差别就在于惩罚项上。TG 是惩罚在迭代前的项上，FOBOS 是惩罚在经过次梯度迭代后的项上。</p>
<h3 id="RDA-Regularized-Dual-Averaging"><a href="#RDA-Regularized-Dual-Averaging" class="headerlink" title="RDA (Regularized Dual Averaging)"></a>RDA (Regularized Dual Averaging)</h3><p>RDA 是微软 10 年发表的研究成果，其权重更新策略如下：</p>
<p><code>$$\vec\omega^&#123;(t + 1)&#125; \gets \mathop&#123;\arg\,\min&#125;_&#123;\vec\omega&#125;\biggl\&#123;\frac&#123;1&#125;&#123;t&#125;\sum_&#123;r = 1&#125;^&#123;t&#125;\Bigl\langle \nabla\text&#123;Obj&#125;\bigl(\vec\omega^&#123;(r)&#125;\bigr), \vec\omega\Bigr\rangle + \Omega(\vec\omega) + \frac&#123;\beta^&#123;(t)&#125;&#125;&#123;t&#125;h(\vec\omega)\biggr\&#125;.$$</code></p>
<p>这里，</p>
<ul>
<li><code>$\Bigl\langle \nabla\text&#123;Obj&#125;\bigl(\vec\omega^&#123;(r)&#125;\bigr), \vec\omega\Bigr\rangle$</code> 表示梯度 <code>$\nabla\text&#123;Obj&#125;\bigl(\vec\omega^&#123;(r)&#125;\bigr)$</code> 对参数 <code>$\vec\omega$</code> 的积分中值，即：第 <code>$r$</code> 轮迭代中的梯度对参数 <code>$\vec\omega$</code> 产生的变动在所有样本上产生的平均影响。</li>
<li><code>$\frac&#123;1&#125;&#123;t&#125;\sum_&#123;r = 1&#125;^&#123;t&#125;\Bigl\langle \nabla\text&#123;Obj&#125;\bigl(\vec\omega^&#123;(r)&#125;\bigr), \vec\omega\Bigr\rangle$</code> 则是前 <code>$r$</code> 轮迭代上述平均影响的平均值（Dual Average）。</li>
<li><code>$\Omega(\vec\omega)$</code> 是正则项。</li>
<li><code>$\frac&#123;\beta^&#123;(t)&#125;&#125;&#123;t&#125;h(\vec\omega)$</code> 是额外的正则项。<ul>
<li><code>$\bigl\&#123;\beta^&#123;(t)&#125;\mid t \geqslant 1\bigr\&#125;$</code> 是一个非负的非降序列。</li>
<li><code>$h(\vec\omega)$</code> 是一个严格的凸函数。</li>
</ul>
</li>
</ul>
<p>除开正则项的变化，和 FOBOS 及之前的截断方法比较，RDA 最大的差别在于丢弃了梯度下降的那一项，换成了梯度的二次平均值。接下来，我们取</p>
<ul>
<li><code>$\Omega(\vec\omega) = \lambda\lVert\vec\omega\rVert_1$</code>，其中 <code>$\lambda &gt; 0$</code>；</li>
<li><code>$h(\vec\omega) = \frac&#123;1&#125;&#123;2&#125;\lVert\vec\omega\rVert_2^2$</code>；</li>
<li><code>$\beta^&#123;(t)&#125; = \gamma\sqrt&#123;t&#125;$</code>，其中 <code>$\gamma &gt; 0$</code>。</li>
</ul>
<p>记 <code>$g_i^&#123;(1:t)&#125; = \frac&#123;1&#125;&#123;t&#125;\sum_&#123;r = 1&#125;^&#123;t&#125; g_i^&#123;(r)&#125;$</code>，于是得到第 <code>$i$</code> 维权重的更新：</p>
<p><code>$$ \omega_&#123;i&#125;^&#123;(t + 1)&#125; \gets \begin&#123;cases&#125; 0&amp; \text&#123;if $\bigl\lvert g_i^&#123;(1:t)&#125;\bigr\rvert &lt; \lambda$,&#125; \\ -\frac&#123;\sqrt&#123;t&#125;&#125;&#123;\gamma&#125;\Bigl(g_i^&#123;(1:t)&#125; - \lambda\,\text&#123;sgn&#125;\bigl(g_i^&#123;(1:t)&#125;\bigr)\Bigr) &amp; \text&#123;otherwise.&#125; \end&#123;cases&#125; $$</code></p>
<p>可见，当某一维度参数的二次平均梯度小于阈值 <code>$\lambda$</code> 时，这一维度被截断，产生稀疏性。</p>
<h2 id="FTRL-Follow-The-Regularized-Leader"><a href="#FTRL-Follow-The-Regularized-Leader" class="headerlink" title="FTRL (Follow The Regularized Leader)"></a>FTRL (Follow The Regularized Leader)</h2><p>接下来介绍 FTRL。</p>
<h3 id="FOBOS-和-RDA-的区别"><a href="#FOBOS-和-RDA-的区别" class="headerlink" title="FOBOS 和 RDA 的区别"></a>FOBOS 和 RDA 的区别</h3><p>为便于比较，这里把 FOBOS 和 RDA 在单一维度上的更新策略再次抄录如下。</p>
<p><code>\begin&#123;equation&#125; \omega_&#123;i&#125;^&#123;(t + 1)&#125; \gets \begin&#123;cases&#125; 0 &amp; \text&#123;if $\lvert\omega_&#123;i&#125;^&#123;(t&#39;)&#125;\rvert &lt; \tilde\lambda$,&#125; \\ \omega_&#123;i&#125;^&#123;(t)&#125; - \eta^&#123;(t)&#125;g_&#123;i&#125;^&#123;(t)&#125; - \tilde\lambda\,\text&#123;sgn&#125;\Bigl(\omega_&#123;i&#125;^&#123;(t)&#125; - \eta^&#123;(t)&#125;g_&#123;i&#125;^&#123;(t)&#125;\Bigr) &amp; \text&#123;otherwise.&#125; \end&#123;cases&#125; \tag&#123;FOBOS&#125;\label&#123;eq:FOBOS&#125; \end&#123;equation&#125;</code></p>
<p><code>\begin&#123;equation&#125; \omega_&#123;i&#125;^&#123;(t + 1)&#125; \gets \begin&#123;cases&#125; 0&amp; \text&#123;if $\bigl\lvert g_i^&#123;(1:t)&#125;\bigr\rvert &lt; \lambda$,&#125; \\ -\frac&#123;\sqrt&#123;t&#125;&#125;&#123;\gamma&#125;\Bigl(g_i^&#123;(1:t)&#125; - \lambda\,\text&#123;sgn&#125;\bigl(g_i^&#123;(1:t)&#125;\bigr)\Bigr) &amp; \text&#123;otherwise.&#125; \end&#123;cases&#125; \tag&#123;RDA&#125;\label&#123;eq:RDA&#125; \end&#123;equation&#125;</code></p>
<p>首先我们看 FOBOS 和 RDA 的截断部分的差异。</p>
<p>FOBOS 的截断判断取的是单次梯度下降的结果，而 RDA 的截断判断取的是往期所有梯度的二次平均。考虑到我们面临的是「在线学习」，样本在局部抖动的几率比较大。因此 FOBOS 的做法容易因为某些异常、离群样本的出现而错误地截断；RDA 的做法则稳妥许多，参考了过去所有样本的梯度结果。</p>
<p>FOBOS 的截断阈值是 <code>$\tilde\lambda = \eta^&#123;(t&#39;)&#125;\lambda$</code>。考虑到学习率 <code>$\eta^&#123;(t&#39;)&#125;$</code> 往往会随着 <code>$t$</code> 的增加而减小。故而 FOBOS 的截断阈值是不断减小的；与之相对，RDA 的截断阈值是固定的 <code>$\lambda$</code>。这说明，随着训练的进程，FOBOS 对截断的要求越放越松，因而 RDA 相对更容易得到稀疏解。</p>
<p>接下来我们看 FOBOS 和 RDA 截断之外部分的差异。</p>
<p>FOBOS 的取值主体是 <code>$\omega_&#123;i&#125;^&#123;(t)&#125; - \eta^&#123;(t)&#125;g_&#123;i&#125;^&#123;(t)&#125;$</code>，即梯度下降的结果，在此基础上做微调——向 0 的方向微调 <code>$\tilde\lambda$</code> 步长。按「下山」的比喻，FOBOS 的取值，是在梯度反方向上下山，每次做一定的微调。RDA 的取值，主体是往期所有梯度的二次平均的缩放（<code>$-\frac&#123;\sqrt&#123;t&#125;&#125;&#123;\gamma&#125;$</code>），在此基础上做微调——向 0 的方向微调 <code>$\lambda$</code>。按同样的比喻，RDA 的取值，是在山顶上试探很多步，平均之后只走出一小步。从感性的认知来说，FOBOS 的准确度显然会更高一些。</p>
<p>这也就是说，FOBOS 的精度较高，但解的稀疏性相对较差；RDA 的解的稀疏性好，但精度较差。于是，很自然地，我们会问：<strong>是否有办法，将二者的优点合在一起呢</strong>？</p>
<h3 id="统一-FOBOS-和-RDA-的形式"><a href="#统一-FOBOS-和-RDA-的形式" class="headerlink" title="统一 FOBOS 和 RDA 的形式"></a>统一 FOBOS 和 RDA 的形式</h3><p>想要取长补短，就要想办法将 FOBOS 和 RDA 的形式统一起来。这样才方便拆墙补墙。</p>
<p>首先看 FOBOS 的无约束优化形式：</p>
<p><code>$$ \vec\omega^&#123;(t + 1)&#125; \gets \mathop&#123;\arg\,\min&#125;_&#123;\vec\omega&#125;\biggl\&#123;\frac&#123;1&#125;&#123;2&#125;\Bigl\lVert\vec\omega - \vec\omega^&#123;(t)&#125; + \eta^&#123;(t)&#125;\vec g^&#123;(t)&#125;\Bigr\rVert^&#123;2&#125; + \eta^&#123;(t)&#125;\lambda\lVert\vec\omega\rVert_1\biggr\&#125;. $$</code></p>
<p>注意，这里 <code>$\vec g^&#123;(t)&#125; = \nabla\text&#123;Obj&#125;(\vec\omega^&#123;(t)&#125;)$</code>，并且令 <code>$\eta^&#123;(t&#39;)&#125; = \eta^&#123;(t)&#125; = \frac&#123;\gamma&#125;&#123;\sqrt&#123;t&#125;&#125;$</code>。我们将之按维度拆开：</p>
<p><code>$$ \begin&#123;aligned&#125; &amp; \min_&#123;\omega_i\in\mathbb&#123;R&#125;&#125;\biggl\&#123;\frac&#123;1&#125;&#123;2&#125;\Bigl\lVert\omega_i - \omega_i^&#123;(t)&#125; + \eta^&#123;(t)&#125;g_i^&#123;(t)&#125;\Bigr\rVert^&#123;2&#125; + \eta^&#123;(t)&#125;\lambda\lvert\omega_i\rvert\biggr\&#125; \\ =&#123;&#125;&amp; \min_&#123;\omega_i\in\mathbb&#123;R&#125;&#125;\biggl\&#123;\omega_ig_i^&#123;(t)&#125; + \lambda\lvert\omega_i\rvert + \frac&#123;1&#125;&#123;2\eta^&#123;(t)&#125;&#125;\bigl(\omega_i - \omega_i^&#123;(t)&#125;\bigr)_2^2 + \biggl[ \frac&#123;\eta^&#123;(t)&#125;&#125;&#123;2&#125;\bigl(g_i^&#123;(t)&#125;\bigr)_2^2 + \omega_i^&#123;(t)&#125;g_i^&#123;(t)&#125; \biggr]\biggr\&#125; \\ =&#123;&#125;&amp; \min_&#123;\omega_i\in\mathbb&#123;R&#125;&#125;\biggl\&#123;\omega_ig_i^&#123;(t)&#125; + \lambda\lvert\omega_i\rvert + \frac&#123;1&#125;&#123;2\eta^&#123;(t)&#125;&#125;\bigl(\omega_i - \omega_i^&#123;(t)&#125;\bigr)_2^2\biggr\&#125;. \end&#123;aligned&#125; $$</code></p>
<p>再合并起来有，</p>
<p><code>$$ \begin&#123;aligned&#125; \vec\omega^&#123;(t + 1)&#125; \gets&amp;&#123;&#125; \mathop&#123;\arg\,\min&#125;_&#123;\vec\omega&#125;\biggl\&#123;\vec g^&#123;(t)&#125;\cdot\vec\omega + \lambda\lVert\vec\omega\rVert_1 + \frac&#123;1&#125;&#123;2\eta^&#123;(t)&#125;&#125;\bigl\lVert\vec\omega - \vec\omega^&#123;(t)&#125;\bigr\rVert_2^2\biggr\&#125; \\ =&amp;&#123;&#125; \mathop&#123;\arg\,\min&#125;_&#123;\vec\omega&#125;\biggl\&#123;\vec g^&#123;(t)&#125;\cdot\vec\omega + \lambda\lVert\vec\omega\rVert_1 + \frac&#123;1&#125;&#123;2&#125;\sigma^&#123;(1:t)&#125;\bigl\lVert\vec\omega - \vec\omega^&#123;(t)&#125;\bigr\rVert_2^2\biggr\&#125;. \end&#123;aligned&#125; $$</code></p>
<p>其中 <code>$\sigma^&#123;(t)&#125; = \frac&#123;1&#125;&#123;\eta^&#123;(t)&#125;&#125; - \frac&#123;1&#125;&#123;\eta^&#123;(t - 1)&#125;&#125;$</code>，以及 <code>$\sigma^&#123;(1:t)&#125; = \sum_&#123;r = 1&#125;^&#123;t&#125;\sigma^&#123;(r)&#125; = \frac&#123;1&#125;&#123;\eta^&#123;(t)&#125;&#125;$</code>（注意与 <code>$\vec g^&#123;(1:t)&#125;$</code> 不同，<code>$\sigma^&#123;(1:t)&#125;$</code> 在求和符号外没有 <code>$\frac&#123;1&#125;&#123;t&#125;$</code>）。类似地，对于 RDA 有：</p>
<p><code>$$ \vec\omega^&#123;(t + 1)&#125; \gets \mathop&#123;\arg\,\min&#125;_&#123;\vec\omega&#125;\biggl\&#123;\vec G^&#123;(1:t)&#125;\cdot\vec\omega + t\lambda\lVert\vec\omega\rVert_1 + \frac&#123;1&#125;&#123;2&#125;\sigma^&#123;(1:t)&#125;\bigl\lVert\vec\omega - \vec 0\bigr\rVert_2^2\biggr\&#125;. $$</code></p>
<p>这里 <code>$\vec G^&#123;(t)&#125; = \vec g^&#123;(t)&#125;$</code>，而 <code>$\vec G^&#123;(1:t)&#125; = \sum_&#123;r = 1&#125;^&#123;t&#125;\vec G^&#123;(t)&#125; = t\cdot\vec g^&#123;(1:t)&#125;$</code>。</p>
<h3 id="拆墙补墙得到-FTRL"><a href="#拆墙补墙得到-FTRL" class="headerlink" title="拆墙补墙得到 FTRL"></a>拆墙补墙得到 FTRL</h3><p>统一了 FOBOS 和 RDA 的形式之后，我们就可以将它们各自的优点拿出来了。</p>
<p>对于 FOBOS，它的优点体现在 <code>$ \frac&#123;1&#125;&#123;2&#125;\sigma^&#123;(1:t)&#125;\bigl\lVert\vec\omega - \vec\omega^&#123;(t)&#125;\bigr\rVert_2^2$</code> 这一项上；对于 RDA，它的优点体现在 <code>$\vec G^&#123;(1:t)&#125;\cdot\vec\omega$</code> 这一项上。于是，我们将这两项组合起来，得到的就是标准的 FTRL 了（11 年的论文中的原始版本）：</p>
<p><code>$$ \vec\omega^&#123;(t + 1)&#125; \gets \mathop&#123;\arg\,\min&#125;_&#123;\vec\omega&#125;\biggl\&#123;\vec G^&#123;(1:t)&#125;\cdot\vec\omega + \lambda\lVert\vec\omega\rVert_1 + \frac&#123;1&#125;&#123;2&#125;\sum_&#123;r = 1&#125;^&#123;t&#125;\sigma^&#123;(r)&#125;\bigl\lVert\vec\omega - \vec\omega^&#123;(r)&#125;\bigr\rVert_2^2\biggr\&#125;. $$</code></p>
<p>注意这里式中第 3 项与 FOBOS 的第三项稍有区别。我们还可以为它加上 <code>$L_2$</code> 正则项，变成：</p>
<p><code>\begin&#123;equation&#125; \vec\omega^&#123;(t + 1)&#125; \gets \mathop&#123;\arg\,\min&#125;_&#123;\vec\omega&#125;\biggl\&#123;\vec G^&#123;(1:t)&#125;\cdot\vec\omega + \lambda_1\lVert\vec\omega\rVert_1 + \frac&#123;1&#125;&#123;2&#125;\lambda_2\lVert\vec\omega\rVert_2^2 + \frac&#123;1&#125;&#123;2&#125;\sum_&#123;r = 1&#125;^&#123;t&#125;\sigma^&#123;(r)&#125;\bigl\lVert\vec\omega - \vec\omega^&#123;(r)&#125;\bigr\rVert_2^2\biggr\&#125;. \tag&#123;FTRL&#125;\label&#123;eq:FTRL&#125; \end&#123;equation&#125;</code></p>
<h3 id="FTRL-更新公式的推导"><a href="#FTRL-更新公式的推导" class="headerlink" title="FTRL 更新公式的推导"></a>FTRL 更新公式的推导</h3><p>我们将 \ref{eq:FTRL} 展开，得到</p>
<p><code>$$ \begin&#123;aligned&#125; \vec\omega^&#123;(t + 1)&#125; \gets&#123;&#125;&amp; \mathop&#123;\arg\,\min&#125;_&#123;\vec\omega&#125;\biggl\&#123;\vec G^&#123;(1:t)&#125;\cdot\vec\omega + \lambda_1\lVert\vec\omega\rVert_1 + \frac&#123;1&#125;&#123;2&#125;\lambda_2\lVert\vec\omega\rVert_2^2 + \frac&#123;1&#125;&#123;2&#125;\sum_&#123;r = 1&#125;^&#123;t&#125;\sigma^&#123;(r)&#125;\bigl\lVert\vec\omega - \vec\omega^&#123;(r)&#125;\bigr\rVert_2^2\biggr\&#125; \\ =&#123;&#125;&amp; \mathop&#123;\arg\,\min&#125;_&#123;\vec\omega&#125;\biggl\&#123;\vec z^&#123;(1:t)&#125;\vec\omega + \lambda_1\lVert\vec\omega\rVert_1 + \frac&#123;1&#125;&#123;2&#125;\Bigl(\lambda_2 + \sum_&#123;r = 1&#125;^&#123;t&#125;\sigma^&#123;(r)&#125;\Bigr)\lVert\vec\omega\rVert_2^2 + \frac&#123;1&#125;&#123;2&#125;\sum_&#123;r = 1&#125;^&#123;t&#125;\sigma^&#123;(r)&#125;\lVert\vec\omega^&#123;(r)&#125;\rVert_2^2\biggr\&#125; \\ =&#123;&#125;&amp; \mathop&#123;\arg\,\min&#125;_&#123;\vec\omega&#125;\biggl\&#123;\vec z^&#123;(1:t)&#125;\vec\omega + \lambda_1\lVert\vec\omega\rVert_1 + \frac&#123;1&#125;&#123;2&#125;\Bigl(\lambda_2 + \sum_&#123;r = 1&#125;^&#123;t&#125;\sigma^&#123;(r)&#125;\Bigr)\lVert\vec\omega\rVert_2^2\biggr\&#125;. \end&#123;aligned&#125; $$</code></p>
<p>其中 <code>$\vec z^&#123;(t)&#125; = \vec g^&#123;(t)&#125; - \sigma^&#123;(t)&#125;\cdot\vec\omega^&#123;(t)&#125;$</code>，而 <code>$\vec z^&#123;(1:t)&#125; = \sum_&#123;r = 1&#125;^&#123;t&#125;\vec z^&#123;(r)&#125;$</code>。我们将之按维度拆开，有</p>
<p><code>\begin&#123;equation&#125; \min_&#123;\omega_&#123;i&#125;\in\mathbb&#123;R&#125;&#125;\biggl\&#123;z_i^&#123;(t)&#125;\omega_&#123;i&#125; + \lambda_1\lvert\omega_i\rvert + \frac&#123;1&#125;&#123;2&#125;\Bigl(\lambda_2 + \sigma^&#123;(1:t)&#125;\Bigr)\omega_&#123;i&#125;^&#123;2&#125;\biggr\&#125;. \label&#123;eq:ftrl-one-dim&#125; \end&#123;equation&#125;</code></p>
<p>式 \ref{eq:ftrl-one-dim} 是一个无约束的非平滑参数优化问题，其中第二项 <code>$\lambda_1\lvert\omega_i\rvert$</code> 在 <code>$\omega_i = 0$</code> 处不可导。假设 <code>$\omega_i^*$</code> 是使式 \ref{eq:ftrl-one-dim} 得到最优解的 <code>$\omega_i$</code> 的取值；定义 <code>$\xi\in\partial\lvert\omega_i^*\rvert$</code> 是 <code>$\lvert\omega_i\rvert$</code> 在 <code>$\omega_i^*$</code> 处的次导数，于是有</p>
<p><code>\begin&#123;equation&#125; \partial\lvert\omega_i^*\rvert = \begin&#123;cases&#125; 1  &amp; \text&#123;if $\omega_i^* &gt; 0$&#125;, \\ &#123;-1 &lt; \xi &lt; 1&#125; &amp; \text&#123;if $\omega_i^* = 0$&#125;, \\ -1 &amp; \text&#123;if $\omega_i^* &lt; 0$&#125;. \end&#123;cases&#125; \label&#123;eq:ftrl-subgradient&#125; \end&#123;equation&#125;</code></p>
<p>根据式 \ref{eq:ftrl-subgradient} 定义的次导数，对式 \ref{eq:ftrl-one-dim} 待优化的部分求导，令其为零，得到方程：</p>
<p><code>\begin&#123;equation&#125; z_i^&#123;(t)&#125; + \lambda_1\cdot\xi + \bigl(\lambda_2 + \sigma^&#123;(1:t)&#125;\bigr)\omega_&#123;i&#125;^* = 0. \label&#123;eq:ftrl-equation&#125; \end&#123;equation&#125;</code></p>
<p>式 \ref{eq:ftrl-equation} 中，<code>$\lambda_1 &gt; 0$</code> 且 <code>$\bigl(\lambda_2 + \sigma^&#123;(1:t)&#125;\bigr) &gt; 0$</code>。对 <code>$z_i^&#123;(t)&#125;$</code> 的取值进行分类讨论：</p>
<ul>
<li>当 <code>$\bigl\lvert z_i^&#123;(t)&#125;\bigr\rvert &lt; \lambda_1$</code> 时，有 <code>$\omega_i^&#123;*&#125; = 0$</code>。因为若不然：<ul>
<li>当 <code>$\omega_i^&#123;*&#125; &lt; 0$</code>，有 <code>$\xi = -1$</code>。式 \ref{eq:ftrl-equation} 左边有 <code>$z_i^&#123;(t)&#125; - \lambda_1 + \bigl(\lambda_2 + \sigma^&#123;(1:t)&#125;\bigr)\omega_&#123;i&#125;^* &lt; z_i^&#123;(t)&#125; - \lambda_1 &lt; 0$</code>，与式 \ref{eq:ftrl-equation} 矛盾。</li>
<li>当 <code>$\omega_i^&#123;*&#125; &gt; 0$</code>，有 <code>$\xi = 1$</code>。式 \ref{eq:ftrl-equation} 左边有 <code>$z_i^&#123;(t)&#125; + \lambda_1 + \bigl(\lambda_2 + \sigma^&#123;(1:t)&#125;\bigr)\omega_&#123;i&#125;^* &gt; z_i^&#123;(t)&#125; + \lambda_1 &gt; 0$</code>，与式 \ref{eq:ftrl-equation} 矛盾。</li>
</ul>
</li>
<li>当 <code>$z_i^&#123;(t)&#125; &gt; \lambda_1$</code> 时，有 <code>$\omega_i^&#123;*&#125; = -\frac&#123;1&#125;&#123;\lambda_2 + \sigma^&#123;(1:t)&#125;&#125;\bigl(z_i^&#123;(t)&#125; - \lambda_1\bigr) &lt; 0$</code>。因为若不然：<ul>
<li>当 <code>$\omega_i^&#123;*&#125; = 0$</code>，由式 \ref{eq:ftrl-equation} 知 <code>$\xi = -\frac&#123;z_i^&#123;(t)&#125;&#125;&#123;\lambda_1&#125; &lt; -1$</code>，与式 \ref{eq:ftrl-subgradient} 矛盾。</li>
<li>当 <code>$\omega_i^&#123;*&#125; &gt; 0$</code>，与 <code>$\bigl\lvert z_i^&#123;(t)&#125;\bigr\rvert &lt; \lambda_1$</code> 的情况类似，与式 \ref{eq:ftrl-equation} 矛盾。</li>
</ul>
</li>
<li>当 <code>$z_i^&#123;(t)&#125; &lt; -\lambda_1$</code>，类似分析，有 <code>$\omega_i^&#123;*&#125; = -\frac&#123;1&#125;&#123;\lambda_2 + \sigma^&#123;(1:t)&#125;&#125;\bigl(z_i^&#123;(t)&#125; + \lambda_1\bigr) &gt; 0$</code>。</li>
</ul>
<p>如此一来，我们得到 FTRL 的更新公式：</p>
<p><code>\begin&#123;equation&#125; \omega_i^&#123;(t + 1)&#125; = \begin&#123;cases&#125; 0 &amp; \text&#123;if $\lvert z_i^&#123;(t)&#125;\rvert &lt; \lambda_1$&#125;, \\ -\frac&#123;1&#125;&#123;\lambda_2 + \sigma^&#123;(1:t)&#125;&#125;\bigl(z_i^&#123;(t)&#125; - \text&#123;sgn&#125;(z_i^&#123;(t)&#125;)\lambda_1\bigr) &amp; \text&#123;otherwise&#125;. \end&#123;cases&#125; \label&#123;eq:ftrl-updates&#125; \end&#123;equation&#125;</code></p>
<p>从式 \ref{eq:ftrl-updates} 来看，加入 <code>$L_2$</code> 正则，没有影响模型的稀疏性，而只是使得参数的取值趋向零。</p>
<h3 id="FTRL-为什么是有效的"><a href="#FTRL-为什么是有效的" class="headerlink" title="FTRL 为什么是有效的"></a>FTRL 为什么是有效的</h3><p>我们引出 FTRL 是按「稀疏性」的路径，从 FOBOS 和 RDA 拆借出来的。从上面的推导，我们能看出 FTRL 能够较好地获得稀疏解。但是，我们仍未能说明，FTRL 能够获得较好的稀疏解。（大家来找茬，笑）这一小节里，我们来说明 FTRL 是有效的。</p>
<p>首先回顾一下 SGD 的更新公式：</p>
<p><code>\begin&#123;equation&#125; \vec\omega_i^&#123;(t + 1)&#125; \gets \vec\omega_i^&#123;(t)&#125; - \eta^&#123;(t)&#125;\vec g^&#123;(t)&#125;. \label&#123;eq:sgd&#125; \end&#123;equation&#125;</code></p>
<p>我们丢掉式 \ref{eq:FTRL} 中有关 <code>$L_1$</code> 和 <code>$L_2$</code> 正则相关的部分，有</p>
<p><code>\begin&#123;equation&#125; \vec\omega^&#123;(t + 1)&#125; \gets \mathop&#123;\arg\,\min&#125;_&#123;\vec\omega&#125;\biggl\&#123;\vec G^&#123;(1:t)&#125;\cdot\vec\omega + \frac&#123;1&#125;&#123;2&#125;\sum_&#123;r = 1&#125;^&#123;t&#125;\sigma^&#123;(r)&#125;\bigl\lVert\vec\omega - \vec\omega^&#123;(r)&#125;\bigr\rVert_2^2\biggr\&#125;. \label&#123;eq:ftrl-pure&#125; \end&#123;equation&#125;</code></p>
<p>记式 \ref{eq:ftrl-pure} 中待优化的部分为 <code>$f(\vec\omega)$</code>。对其求导，有：</p>
<p><code>\begin&#123;equation&#125; \frac&#123;\partial f(\vec\omega)&#125;&#123;\partial\vec\omega&#125; = \vec G^&#123;(1:t)&#125; + \sum_&#123;r = 1&#125;^&#123;t&#125;\sigma^&#123;(r)&#125;\bigl(\vec\omega - \vec\omega^&#123;(r)&#125;\bigr). \label&#123;eq:ftrl-pure-gradient&#125; \end&#123;equation&#125;</code></p>
<p>当式 \ref{eq:ftrl-pure-gradient} 为 0 时的 <code>$\vec\omega$</code>，式 \ref{eq:ftrl-pure} 取得极值。此即有</p>
<p><code>\begin&#123;equation&#125; \begin&#123;aligned&#125; \vec G^&#123;(1:t)&#125; + \sum_&#123;r = 1&#125;^&#123;t&#125;\sigma^&#123;(r)&#125;\bigl(\vec\omega^&#123;(t + 1)&#125; - \vec\omega^&#123;(r)&#125;\bigr) =&#123;&#125;&amp; 0 \\ \sigma^&#123;(1:t)&#125; \vec\omega^&#123;(t + 1)&#125; =&#123;&#125;&amp; \sum_&#123;r = 1&#125;^&#123;t&#125;\sigma^&#123;(r)&#125; \vec\omega^&#123;(r)&#125; - \vec G^&#123;(1:t)&#125; \end&#123;aligned&#125; \label&#123;eq:ftrl-pure-gradient-equation&#125; \end&#123;equation&#125;</code></p>
<p>在式 \ref{eq:ftrl-pure-gradient-equation} 中，以 <code>$t - 1$</code> 替换 <code>$t$</code>，得到</p>
<p><code>\begin&#123;equation&#125; \sigma^&#123;(1:t - 1)&#125; \vec\omega^&#123;(t)&#125; = \sum_&#123;r = 1&#125;^&#123;t - 1&#125;\sigma^&#123;(r)&#125; \vec\omega^&#123;(r)&#125; - \vec G^&#123;(1:t - 1)&#125; \label&#123;eq:ftrl-pure-gradient-equation-minus&#125; \end&#123;equation&#125;</code></p>
<p>用式 \ref{eq:ftrl-pure-gradient-equation} 减去式 \ref{eq:ftrl-pure-gradient-equation-minus} 得到</p>
<p><code>\begin&#123;equation&#125; \begin&#123;aligned&#125; \sigma^&#123;(1:t)&#125; \vec\omega^&#123;(t + 1)&#125; - \sigma^&#123;(1:t - 1)&#125; \vec\omega^&#123;(t)&#125; =&#123;&#125;&amp; \sigma^&#123;(t)&#125;\vec\omega^&#123;(t)&#125; - \vec g^&#123;(t)&#125; \\ \sigma^&#123;(1:t)&#125; \vec\omega^&#123;(t + 1)&#125; =&#123;&#125;&amp; \sigma^&#123;(1:t)&#125; \vec\omega^&#123;(t)&#125; - \vec g^&#123;(t)&#125; \end&#123;aligned&#125; \label&#123;eq:ftrl-sgd-equiv&#125; \end&#123;equation&#125;</code></p>
<p>考虑 <code>$\sigma^&#123;(1:t)&#125; = \frac&#123;1&#125;&#123;\eta^&#123;(t)&#125;&#125;$</code>，化简式 \ref{eq:ftrl-sgd-equiv} 即得到式 \ref{eq:sgd}。这也就是说，FTRL 去掉 <code>$L_1$</code> 和 <code>$L_2$</code> 部分后，和 SGD 是等价的。这说明 FTRL 能够较好地获得稀疏解并且能够获得较好的稀疏解。</p>

    </div>

    
    
    <div class="post-widgets">
      <div id="needsharebutton-postbottom">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    </div>
        <div class="reward-container">
  <div>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/reward/wechatpay-cropped.png" alt="Liam Huang 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/reward/alipay-cropped.png" alt="Liam Huang 支付宝">
        <p>支付宝</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/reward/paypal.jpeg" alt="Liam Huang 贝宝">
        <p>贝宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Liam Huang
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://liam.page/2019/08/31/a-not-so-simple-introduction-to-FTRL/" title="FTRL 不太简短之介绍">https://liam.page/2019/08/31/a-not-so-simple-introduction-to-FTRL/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Logistic-Regression/" rel="tag"># Logistic Regression</a>
              <a href="/tags/FTRL/" rel="tag"># FTRL</a>
              <a href="/tags/Online-Optimization/" rel="tag"># Online Optimization</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/08/29/rebuild-a-binary-search-tree-from-its-preorder-traversal-result/" rel="prev" title="从前序遍历结果中重建二叉搜索树">
      <i class="fa fa-chevron-left"></i> 从前序遍历结果中重建二叉搜索树
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/09/16/safe-clean-all-data-on-disks-in-Windows/" rel="next" title="在 Windows 中抹除磁盘上所有已删除文件的痕迹">
      在 Windows 中抹除磁盘上所有已删除文件的痕迹 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E4%BB%AC%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">我们面临的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%85%B4%E8%B5%B7"><span class="nav-number">1.1.</span> <span class="nav-text">在线学习的兴起</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%B9%E9%87%8F"><span class="nav-number">1.1.1.</span> <span class="nav-text">批量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E5%B0%8F%E6%89%B9%E9%87%8F"><span class="nav-number">1.1.2.</span> <span class="nav-text">随机小批量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E7%BA%BF%E5%AD%A6%E4%B9%A0"><span class="nav-number">1.1.3.</span> <span class="nav-text">在线学习</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E6%A8%A1%E5%9E%8B%E7%A8%80%E7%96%8F%E6%80%A7%E7%9A%84%E8%BF%BD%E6%B1%82"><span class="nav-number">1.2.</span> <span class="nav-text">对模型稀疏性的追求</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E7%A8%80%E7%96%8F%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">1.2.1.</span> <span class="nav-text">模型稀疏的好处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E6%89%B9%E9%87%8F%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E4%B8%AD%EF%BC%8C%E8%BF%BD%E6%B1%82%E6%A8%A1%E5%9E%8B%E7%A8%80%E7%96%8F%E6%80%A7"><span class="nav-number">1.2.2.</span> <span class="nav-text">在批量梯度下降中，追求模型稀疏性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#L-1-%E6%AD%A3%E5%88%99%E5%9C%A8-SGD-%E4%B8%AD"><span class="nav-number">1.2.3.</span> <span class="nav-text">$L_1$ 正则在 SGD 中</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FTRL-%E7%9A%84%E5%89%8D%E8%BE%88%E4%BB%AC"><span class="nav-number">2.</span> <span class="nav-text">FTRL 的前辈们</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Truncated-Gradient"><span class="nav-number">2.1.</span> <span class="nav-text">Truncated Gradient</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FOBOS-Forward-Backward-Splitting"><span class="nav-number">2.2.</span> <span class="nav-text">FOBOS (Forward-Backward Splitting)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDA-Regularized-Dual-Averaging"><span class="nav-number">2.3.</span> <span class="nav-text">RDA (Regularized Dual Averaging)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FTRL-Follow-The-Regularized-Leader"><span class="nav-number">3.</span> <span class="nav-text">FTRL (Follow The Regularized Leader)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FOBOS-%E5%92%8C-RDA-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.1.</span> <span class="nav-text">FOBOS 和 RDA 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%9F%E4%B8%80-FOBOS-%E5%92%8C-RDA-%E7%9A%84%E5%BD%A2%E5%BC%8F"><span class="nav-number">3.2.</span> <span class="nav-text">统一 FOBOS 和 RDA 的形式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%86%E5%A2%99%E8%A1%A5%E5%A2%99%E5%BE%97%E5%88%B0-FTRL"><span class="nav-number">3.3.</span> <span class="nav-text">拆墙补墙得到 FTRL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FTRL-%E6%9B%B4%E6%96%B0%E5%85%AC%E5%BC%8F%E7%9A%84%E6%8E%A8%E5%AF%BC"><span class="nav-number">3.4.</span> <span class="nav-text">FTRL 更新公式的推导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FTRL-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%89%E6%95%88%E7%9A%84"><span class="nav-number">3.5.</span> <span class="nav-text">FTRL 为什么是有效的</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Liam Huang"
      src="/images/avatar/avatar-3.jpg">
  <p class="site-author-name" itemprop="name">Liam Huang</p>
  <div class="site-description" itemprop="description">虚室生白，吉祥止止</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">404</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">773</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://dennybritz.com/" title="https:&#x2F;&#x2F;dennybritz.com&#x2F;" rel="noopener" target="_blank">Denny</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://chattymoney.com/" title="http:&#x2F;&#x2F;chattymoney.com&#x2F;" rel="noopener" target="_blank">ChattyMoney</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://qixinbo.info/" title="http:&#x2F;&#x2F;qixinbo.info&#x2F;" rel="noopener" target="_blank">XinboQi</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://ionizing.page/" title="https:&#x2F;&#x2F;ionizing.page&#x2F;" rel="noopener" target="_blank">ChenLinjie</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://yihui.name/" title="https:&#x2F;&#x2F;yihui.name&#x2F;" rel="noopener" target="_blank">Yihui</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.felixc.at/" title="https:&#x2F;&#x2F;blog.felixc.at&#x2F;" rel="noopener" target="_blank">Felix</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://wyydsb.xin/" title="https:&#x2F;&#x2F;wyydsb.xin&#x2F;" rel="noopener" target="_blank">Gunjianpan</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://joselynzhao.top/" title="https:&#x2F;&#x2F;joselynzhao.top&#x2F;" rel="noopener" target="_blank">JoselynZhao</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.dang.fan/" title="https:&#x2F;&#x2F;blog.dang.fan&#x2F;" rel="noopener" target="_blank">DangFan</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://harrychen.xyz/" title="https:&#x2F;&#x2F;harrychen.xyz" rel="noopener" target="_blank">HarryChen</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.echen.me/" title="https:&#x2F;&#x2F;blog.echen.me&#x2F;" rel="noopener" target="_blank">EdwinChen</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://fengweiustc.github.io/" title="https:&#x2F;&#x2F;fengweiustc.github.io&#x2F;" rel="noopener" target="_blank">WayneFung</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cyningsun.com/" title="https:&#x2F;&#x2F;www.cyningsun.com&#x2F;" rel="noopener" target="_blank">CyningSun</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://0o0blog.com/" title="https:&#x2F;&#x2F;0o0blog.com&#x2F;" rel="noopener" target="_blank">Francis</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2013 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liam Huang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">1.5m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">45:11</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>


<script>
  window.addEventListener('DOMContentLoaded', function() {
    
    
    var intervalTotalViews = setInterval(fixTotalViews, 100);
    var offsetTotalViews   = parseInt(100000);
    function fixTotalViews() {
      if (document.getElementById('busuanzi_container_site_pv').style.display != "none") {
        clearInterval(intervalTotalViews);
        var el = document.getElementById("busuanzi_value_site_pv");
        var value = parseInt(el.innerHTML) + offsetTotalViews;
        el.innerHTML = '' + value;
      }
    }
    
  });
</script>










      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>














<script type="text/javascript">
var crashSwitched = false;
var originalTitle = document.title;
var titleTime;
document.addEventListener('visibilitychange', function () {
  if (document.hidden) {
    if (Math.random() < parseFloat(0.25)) {
      crashSwitched = true;
      document.title = '╭(°A°`)╮ 页面崩溃啦~' + originalTitle;
      clearTimeout(titleTime);
    }
  } else {
    if (crashSwitched == true) {
      crashSwitched = false;
      document.title = '(ฅ>ω<*ฅ) 咦，又好了~' + originalTitle;
      titleTime = setTimeout(function () {
        document.title = originalTitle;
      }, 2000);
    }
  }
});
</script>



    <div id="pjax">
  

  
      

<script>
    document.querySelectorAll('code').forEach(code => {
      const text = code.innerHTML;
      // is_inline_math  = /^\$(.*)\$$/.exec(text) || /^\\\((.*)\\\)$/.exec(text);
      // is_display_math = /^\$\$(.*)\$\$$/ms.exec(text) || /^\\begin\{.+\}(.*)\\end\{.+\}/ms.exec(text);
      if (/^\$\$(.*)\$\$$/ms.exec(text) || /^\\begin\{.+\}(.*)\\end\{.+\}/ms.exec(text)) {
        code.outerHTML = "<span class='theme_next_mathjax_display has-jax'>" + text + "</span>";
      } else if (/^\$(.*)\$$/.exec(text) || /^\\\((.*)\\\)$/.exec(text)) {
        code.outerHTML = "<span class='theme_next_mathjax_inline has-jax'>"  + text + "</span>";
      }
    });
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/ams'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['ams']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://liam.page/2019/08/31/a-not-so-simple-introduction-to-FTRL/',]
      });
      });
  </script>

  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script>
  <script>
      pbOptions = {};
        pbOptions.iconStyle = "default";
        pbOptions.boxForm = "horizontal";
        pbOptions.position = "topCenter";
        pbOptions.networks = "Wechat,Weibo,renren,Twitter,Facebook,Douban,QQZone,Evernote,Mailto";
      new needShareButton('#needsharebutton-postbottom', pbOptions);
  </script>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'a3d846b3392f468b5746',
      clientSecret: '61bc947cad0ec7078e800e05b1e3c78b763b2c55',
      repo        : 'liam0205.github.io',
      owner       : 'Liam0205',
      admin       : ['Liam0205'],
      id          : 'f2ed74f05d9fe27f830801cacf409aa1',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
</body>
</html>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>始终</title>
  
  <subtitle>不忘初心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liam.page/"/>
  <updated>2025-12-07T15:42:01.541Z</updated>
  <id>https://liam.page/</id>
  
  <author>
    <name>Liam Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>光与影的魔术①：闪光灯的基础知识；以及三个速度之间的深刻联系</title>
    <link href="https://liam.page/2025/12/07/The-Magic-of-Light-and-Shadow-Fundamentals-of-Flash-Photography-and-the-Intrinsic-Connection-Between-Three-Speeds/"/>
    <id>https://liam.page/2025/12/07/The-Magic-of-Light-and-Shadow-Fundamentals-of-Flash-Photography-and-the-Intrinsic-Connection-Between-Three-Speeds/</id>
    <published>2025-12-07T14:20:59.000Z</published>
    <updated>2025-12-07T15:42:01.541Z</updated>
    
    <content type="html"><![CDATA[<p>接触摄影已有相当长的时间。考虑自己资质愚笨，在自觉摸清楚曝光三要素之前，对闪光灯一直望而生畏。今日得闲，做了一些初步的了解。略有所得，记录成文。</p><span id="more"></span><h2 id="初识闪光灯"><a href="#初识闪光灯" class="headerlink" title="初识闪光灯"></a>初识闪光灯</h2><h3 id="闪光灯的作用：画龙点睛之笔"><a href="#闪光灯的作用：画龙点睛之笔" class="headerlink" title="闪光灯的作用：画龙点睛之笔"></a>闪光灯的作用：画龙点睛之笔</h3><p>摄影是用光影作画。闪光灯的主要作用是在光线不足时提供瞬间的强光源，或在光线充足时对主体进行补光，以平衡光线、突出主体、调整色彩和凝固瞬间。</p><ul><li>补充环境光：在暗光环境下提供足够亮度。</li><li>消除阴影：在逆光或侧光时，照亮主体正面阴影。</li><li>控制色彩：闪光灯色温接近日光（约 5500K），有助于在复杂光源下获得准确的白平衡。</li><li>凝固动作：极短的闪光时间能瞬间定格高速移动的物体。</li></ul><h3 id="对「三要素」的影响"><a href="#对「三要素」的影响" class="headerlink" title="对「三要素」的影响"></a>对「三要素」的影响</h3><p>当有闪光灯参与时，曝光三要素相较不使用闪光灯时会有一些变化。</p><table><thead><tr><th>三要素</th><th>影响范围</th><th>说明</th></tr></thead><tbody><tr><td>光圈 (Aperture)</td><td>同时影响环境光和闪光灯对主体的曝光量</td><td>光圈越大（数值小），进光量越多，照片越亮</td></tr><tr><td>感光度 (ISO)</td><td>同时影响环境光和闪光灯对主体的曝光量</td><td>ISO 越高，感光元件越敏感，照片也越亮</td></tr><tr><td>快门速度(Shutter Speed)</td><td>主要影响环境光</td><td>较慢的快门速度可以捕捉更多环境光，使背景更亮；而快门速度一般无法高于相机的「闪光同步速度」（通常在 1&#x2F;160s 到 1&#x2F;250s 之间），否则画面会出现黑色阴影（幕帘遮挡）。</td></tr></tbody></table><p>可见，加入闪光灯之后，光圈和感光度相比以前变化不大；唯快门速度较为复杂。</p><h3 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h3><h4 id="闪光指数-Guide-Number-GN"><a href="#闪光指数-Guide-Number-GN" class="headerlink" title="闪光指数 (Guide Number, GN)"></a>闪光指数 (Guide Number, GN)</h4><p>闪光指数是衡量闪光灯最大输出功率的指标，通常以 GN (米) 为单位表示。</p><p>GN 值越大，闪光灯越强劲，有效照明距离越远。例如在大型宴会厅、户外或拍摄大场景时使用，往往需要一个高 GN 值的灯。</p><p>计算公式：GN &#x3D; 光圈值 × 距离 (米)。例如，一个 GN 为 60 的闪光灯，在光圈设定为 f&#x2F;8 时，可以照亮 7.5 米远的主体 (60 ÷ 8 &#x3D; 7.5)。即是说，使得 7.5 米远的被摄物体得到恰到好处的曝光。</p><h4 id="闪光覆盖范围-Zoom-Range"><a href="#闪光覆盖范围-Zoom-Range" class="headerlink" title="闪光覆盖范围 (Zoom Range)"></a>闪光覆盖范围 (Zoom Range)</h4><p>闪光覆盖范围是闪光灯头可以调节的焦距范围，通常从 20mm 左右到 200mm 左右。它能匹配您镜头的视角。</p><p>当闪光灯焦距与使用的镜头焦距匹配时，光线覆盖会更均匀，避免画面边缘出现亮度衰减（黑角）。具体来说，在广角端（如 24mm），光线分散，覆盖面积大；在长焦端（如 105mm），光线集中，射程更远，光束更窄。</p><h4 id="闪光模式-Flash-Modes"><a href="#闪光模式-Flash-Modes" class="headerlink" title="闪光模式 (Flash Modes)"></a>闪光模式 (Flash Modes)</h4><p>主流的外置闪光灯通常提供以下几种模式：</p><ul><li>TTL 模式 (Through The Lens)：镜后测光，相当于闪光灯的「自动挡」。相机通过镜头实时测量反射回来的光线，自动计算并输出合适的闪光量，非常适合快速变化的场景和新手使用。</li><li>M 模式 (Manual)：手动模式。需要手动设置闪光输出功率（例如 1&#x2F;1 全功率到 1&#x2F;128 微弱功率）。可以完全掌控光线，在布景固定（如影棚）时非常精准可控。</li><li>频闪模式 (Multi)：在一次曝光中进行多次闪光，可以捕捉物体移动的轨迹和多个瞬间的影像。例如，在相对较长的曝光时间里，多次频闪，顶格高尔夫球运动员的挥杆轨迹。</li></ul><h4 id="回电时间-Recycle-Time"><a href="#回电时间-Recycle-Time" class="headerlink" title="回电时间 (Recycle Time)"></a>回电时间 (Recycle Time)</h4><p>两次全功率闪光之间所需的充电时间（通常以秒为单位）。</p><p>回电时间越短（例如 0.1s - 2s），您连续拍摄的速度就越快。在拍摄婚礼、体育赛事等需要快速连拍的场景中至关重要。回电慢会错过精彩瞬间。</p><h4 id="高速同步-High-Speed-Sync-HSS"><a href="#高速同步-High-Speed-Sync-HSS" class="headerlink" title="高速同步 (High-Speed Sync, HSS)"></a>高速同步 (High-Speed Sync, HSS)</h4><p>相机往往有所谓闪光同步速度（之后讲解）。所谓高速同步，即是允许闪光灯在高于闪光同步速度的快门下，通过连续频闪来模拟连续光源而的技术。</p><p>在白天户外强光下，若想使用大光圈（如 f&#x2F;1.8）拍摄人像以虚化背景，快门速度必须很高。HSS 功能可以在高速快门下使用闪光灯补光，压暗背景，突出主体。</p><h4 id="闪光灯头可旋转角度-Head-Rotation-x2F-Bounce"><a href="#闪光灯头可旋转角度-Head-Rotation-x2F-Bounce" class="headerlink" title="闪光灯头可旋转角度 (Head Rotation&#x2F;Bounce)"></a>闪光灯头可旋转角度 (Head Rotation&#x2F;Bounce)</h4><p>闪光灯头可以水平（左右）和垂直（上下）转动的角度范围。</p><p>这个参数直接决定了您能否方便地进行「跳闪」（Bounce Flash）。一个灵活可旋转的灯头（例如垂直 90 度，水平 180 度）是实现柔和光线效果的关键。无法旋转的灯头只能直射，光线生硬。</p><h3 id="玩转光线"><a href="#玩转光线" class="headerlink" title="玩转光线"></a>玩转光线</h3><p>仅仅将闪光灯直射主体往往会产生生硬的光线和难看的阴影。有一些技巧能让光线更柔和自然：</p><ul><li>跳闪 (Bounce Flash)：将闪光灯头对准天花板或侧面的墙壁，利用大面积的反射面作为光源，从而创造出非常柔和、均匀的光线，效果类似大型柔光箱。这是最常用的技巧之一。</li><li>离机闪光 (Off-Camera Flash)：将闪光灯从相机热靴上取下，放置在不同的位置和角度（通常需要引闪器或连接线），可以创造更有立体感的光影效果。</li><li>使用配件（柔光罩、柔光伞、雷达罩等）：这些附件旨在增大光源面积或改变光线方向，使光线更加柔和，阴影过度更自然。</li></ul><h2 id="凝固瞬间"><a href="#凝固瞬间" class="headerlink" title="凝固瞬间"></a>凝固瞬间</h2><p>闪光灯的持续时间极短，通常只有几千分之一秒甚至几万分之一秒。在曝光过程中，虽然相机的快门可能打开了较长时间（比如 1&#x2F;60 秒），但真正记录影像的瞬间，是闪光灯亮起的那一刹那。由于这个「闪光持续时间」非常短暂，任何高速移动的物体都没来得及在画面中产生位移，因此它们的动作就被清晰、锐利地定格下来，消除了一般慢速快门下常见的动态模糊（Motion Blur）。这即是所谓的「凝固瞬间」。</p><h3 id="水花飞溅或液滴皇冠"><a href="#水花飞溅或液滴皇冠" class="headerlink" title="水花飞溅或液滴皇冠"></a>水花飞溅或液滴皇冠</h3><ul><li>场景：拍摄一颗水滴落入水面激起完美水花「皇冠」的瞬间。</li><li>难点：水花的运动速度非常快，使用常规快门（如 1&#x2F;250s）很难拍清晰，画面容易模糊。</li><li>闪光灯的作用：将相机设置在暗房中，使用较慢的快门速度，并在水滴触水的瞬间触发闪光灯。闪光持续时间可能只有 1&#x2F;10000 秒。这个极其短暂的光照时间瞬间冻结了水花的形态。这让我们能够获得一张锐利无比、细节清晰的凝固画面。</li></ul><h3 id="创意频闪摄影（Multi模式）"><a href="#创意频闪摄影（Multi模式）" class="headerlink" title="创意频闪摄影（Multi模式）"></a>创意频闪摄影（Multi模式）</h3><ul><li>场景：拍摄一个人挥动荧光棒或高尔夫球杆的完整运动轨迹。</li><li>难点：既要显示运动的路径，又要保证每个瞬间的主体清晰。</li><li>闪光灯的作用：利用闪光灯的频闪（Multi）模式。在一次长时间曝光中，闪光灯会连续、快速地闪烁多次。每一次闪光都凝固了一个瞬间，最终在同一张照片上形成一系列清晰的、按时间顺序排列的影像，展示出完整的运动过程。</li></ul><h2 id="闪光灯与电子快门"><a href="#闪光灯与电子快门" class="headerlink" title="闪光灯与电子快门"></a>闪光灯与电子快门</h2><h3 id="触发时机与后帘同步"><a href="#触发时机与后帘同步" class="headerlink" title="触发时机与后帘同步"></a>触发时机与后帘同步</h3><p>首先简单解释机械快门的原理。在大多数数码单反或无反相机中，快门系统由两片帘幕（机械快门）组成，它们在感光元件（传感器）前方运动以控制曝光时间：</p><ul><li>前帘 (First Curtain)：按下快门时，前帘打开，曝光开始。</li><li>后帘 (Rear Curtain &#x2F; Second Curtain)：曝光结束时，后帘关闭，曝光停止。</li></ul><p>光线从前帘打开到后帘关闭的这段时间内进入传感器。</p><p>默认情况下，按下快门时，前帘完全打开的瞬间，闪光灯就立即闪光，然后快门保持打开状态直到曝光结束。而后帘同步是一种闪光模式，它改变了闪光灯触发的时机：按下快门时，前帘先打开，快门保持打开状态（根据快门速度，可能是几分之一秒甚至几秒），在快门即将关闭（后帘开始关闭）的前一刻，闪光灯才触发闪光。</p><p>后帘同步的精髓在于结合了环境光的拖影和闪光灯的凝固效果，从而在画面中制造出具有方向感的动态模糊（拖影）效果。具体来说：</p><ul><li>前帘同步的效果：因为闪光灯在曝光开始时就凝固了主体，如果主体在曝光结束前移动，拖影会出现在主体前方（即运动方向的前方）。这看起来很不自然，仿佛主体要「逃离」它的运动轨迹。</li><li>后帘同步的效果：曝光前期只记录环境光和主体的移动轨迹（拖影），在曝光结束前，闪光灯将主体凝固在最终位置。拖影自然地跟在主体后方，明确指出了运动的方向和速度，视觉上更符合我们对运动的认知。</li></ul><h3 id="既没有前帘也没有后帘的电子快门"><a href="#既没有前帘也没有后帘的电子快门" class="headerlink" title="既没有前帘也没有后帘的电子快门"></a>既没有前帘也没有后帘的电子快门</h3><p>电子快门没有物理上的前帘和后帘，这需要新的技术来管理闪光时机。即是说，闪光灯和电子快门之间完全可以协作，但协作方式与机械快门时代有很大不同。</p><p>机械快门时代，闪光灯的同步是物理性的：当前帘完全打开或后帘即将关闭时触发闪光。电子快门（特别是 CMOS 传感器上的卷帘快门，Rolling Shutter）的工作方式是逐行扫描传感器。它不是一次性曝光整个画面，而是从上到下一行一行地读取数据。这就引入了一个困难：</p><blockquote><p>如果在扫描过程中闪光，画面顶部的行可能曝光正常，而底部的行可能根本没接收到闪光，导致画面亮度不均甚至只有半幅曝光（类似机械快门速度太高时的黑边）。</p></blockquote><p>为了解决这个问题，我们需要……</p><ul><li>模拟「机械同步速度」：相机系统会计算出一个「安全」的电子快门速度，在这个速度下（比如 1&#x2F;100秒或 1&#x2F;200秒），虽然还是逐行扫描，但在闪光持续期间，基本能够覆盖大部分画面，从而避免明显的亮度不均。但这通常限制了电子快门的最高闪光同步速度。</li><li>高频闪光&#x2F;HSS模式的沿用：在高速同步（HSS）模式下，闪光灯会模仿一个连续光源，进行高速、高频的脉冲闪光，而不是单次强闪。这使得电子快门可以在逐行扫描的同时「捕捉」到足够的光线，从而实现高速快门下的闪光补光。虽然效率较低，但解决了技术上的同步难题。</li></ul><h2 id="三大速度的关系"><a href="#三大速度的关系" class="headerlink" title="三大速度的关系"></a>三大速度的关系</h2><p>摄影中的曝光受光圈、快门、ISO 影响。加入闪光灯后，引入了三个关键时间维度：</p><ul><li>快门速度 $t_s$：设定的曝光总时长（主要控制环境光）。</li><li>CMOS 读出速度（或机械快门扫描速度）$t_r$：传感器「扫描」完整个画面的总耗时（如 a1m2 的 3.8ms）。</li><li>闪光灯闪光时间 $t_f$：实际光照的持续时间（如 1&#x2F;5000s）。</li></ul><h3 id="闪光同步速度（Flash-sync-Speed）"><a href="#闪光同步速度（Flash-sync-Speed）" class="headerlink" title="闪光同步速度（Flash-sync Speed）"></a>闪光同步速度（Flash-sync Speed）</h3><p>在不引入不考虑高速同步的情况下，我们思考一个问题：如何让整个画幅的感光单元，都能接收到闪光灯的瞬时闪光？</p><p>无论是机械快门，还是电子快门；它们都是「卷帘式」的。我们考虑，对第 $i$ 行的感光单元来说，其在 $A_i$ 时刻开始感光；在 $B_i$ 时刻结束感光。其中 $B_i - A_i$ 即是设定的快门速度 $t_s$。</p><p>现在我们从 $A_i$ 时刻出发会发现：</p><ul><li>经过 $t_s$ 之后，第一行结束曝光；</li><li>经过 $t_r$ 之后，最后一行开始曝光。</li></ul><p>如果 $t_s &lt; t_r$ 则在最后一行开始曝光之前，第一行已经结束曝光。于是，无论如何我们都无法让整个画幅的所有感光元件同时接收到闪光灯的光照。因此我们势必要求 $t_s &gt; t_r + t_f$。由此得到的即是闪光同步速度。</p><p>以 a1m2 为例。</p><ul><li>其 CMOS 的读出速度约为 3.8ms；即大约 1&#x2F;260s。因此其电子快门下的闪光同步速度不可能短于 1&#x2F;260s。索尼官方为其设定的电子快门闪光同步速度是 1&#x2F;200s。</li><li>索尼官方为其设定的机械快门闪光同步速度是 1&#x2F;320s。由此可知，其机械快门结构扫过整个 CMOS 的时间不会长于 3.125ms。</li></ul><p>此外，考虑快门速度设置为 1&#x2F;200s 的情况。此处 $t_s &#x3D; 5ms$ 而 $t_r &#x3D; 3.8ms$。于是，留给闪光灯的时间 $t_f &lt; t_s - t_r &#x3D; 1.2ms \approx 1&#x2F;833s$。因此，若一款闪光灯全功率闪烁的耗时高于 1&#x2F;833s；则在这种情况下，必须要降低闪光灯功率（从而降低 $t_f$），以保证所有像素接到的闪光灯光强均匀。</p><h2 id="未来：全域快门"><a href="#未来：全域快门" class="headerlink" title="未来：全域快门"></a>未来：全域快门</h2><p>全域快门是终极解决方案。它能让所有像素同时开始、同时结束曝光，消除了时间差和「曝光缝隙」。全域快门意味着：完美消除果冻效应和几乎无限的闪光同步速度（可达 1&#x2F;32000s）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接触摄影已有相当长的时间。考虑自己资质愚笨，在自觉摸清楚曝光三要素之前，对闪光灯一直望而生畏。今日得闲，做了一些初步的了解。略有所得，记录成文。&lt;/p&gt;
    
    </summary>
    
      <category term="Magic of Light and Shadow" scheme="https://liam.page/categories/Magic-of-Light-and-Shadow/"/>
    
    
      <category term="Flash" scheme="https://liam.page/tags/Flash/"/>
    
  </entry>
  
  <entry>
    <title>FDWM: 一个实现「不可见」水印的 Python 库</title>
    <link href="https://liam.page/2025/06/28/fdwm/"/>
    <id>https://liam.page/2025/06/28/fdwm/</id>
    <published>2025-06-28T05:07:27.000Z</published>
    <updated>2025-06-28T05:15:14.508Z</updated>
    
    <content type="html"><![CDATA[<p>还在念书时，就听说过频域水印。它可以通过将水印内容隐藏在宿主图像的高频区域，从而让人肉眼不可见地打上水印。为了详细了解相关技术，结合 LLM，我开发了一个 Python 库：<strong>FDWM（Frequency Domain Watermarking）</strong>。</p><span id="more"></span><h2 id="技术原理：为什么选择频域？"><a href="#技术原理：为什么选择频域？" class="headerlink" title="技术原理：为什么选择频域？"></a>技术原理：为什么选择频域？</h2><h3 id="1-频域水印的基本原理"><a href="#1-频域水印的基本原理" class="headerlink" title="1. 频域水印的基本原理"></a>1. 频域水印的基本原理</h3><p>数字水印技术主要分为空域和频域两大类。FDWM 选择频域技术，其优势在于：</p><ul><li><strong>不可见性更好</strong>：在高频区域嵌入水印，人眼很难察觉</li><li><strong>鲁棒性更强</strong>：对压缩、裁剪等攻击有更好的抵抗能力</li><li><strong>容量适中</strong>：在不可见性和容量之间取得了很好的平衡</li></ul><h3 id="2-核心算法实现"><a href="#2-核心算法实现" class="headerlink" title="2. 核心算法实现"></a>2. 核心算法实现</h3><p>FDWM 的核心实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 图像预处理</span></span><br><span class="line">host = _read_image(host_path, gray=<span class="literal">True</span>)  <span class="comment"># 读取宿主图像</span></span><br><span class="line">watermark_norm = watermark.astype(np.float32) / <span class="number">255.0</span>  <span class="comment"># 归一化水印</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 频域变换</span></span><br><span class="line">host_dft = np.fft.fft2(host)  <span class="comment"># 2D FFT</span></span><br><span class="line">host_dft_shift = np.fft.fftshift(host_dft)  <span class="comment"># 频谱中心化</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 水印嵌入（高频区域）</span></span><br><span class="line">host_dft_shift[r_start:r_end, c_start:c_end] += strength * watermark_norm</span><br><span class="line">host_dft_shift[r_start_sym:r_end_sym, c_start_sym:c_end_sym] += (</span><br><span class="line">    strength * np.flipud(np.fliplr(watermark_norm))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 逆变换</span></span><br><span class="line">host_idft_shift = np.fft.ifftshift(host_dft_shift)</span><br><span class="line">img_back = np.fft.ifft2(host_idft_shift)</span><br><span class="line">img_back = np.real(img_back)</span><br></pre></td></tr></table></figure><h3 id="3-关键技术细节"><a href="#3-关键技术细节" class="headerlink" title="3. 关键技术细节"></a>3. 关键技术细节</h3><h4 id="对称嵌入策略"><a href="#对称嵌入策略" class="headerlink" title="对称嵌入策略"></a>对称嵌入策略</h4><p>FDWM 采用对称嵌入策略，在频谱的四个角落同时嵌入水印。</p><ul><li>提高水印的鲁棒性</li><li>减少视觉影响</li><li>增强检测可靠性</li></ul><h4 id="自适应文本渲染"><a href="#自适应文本渲染" class="headerlink" title="自适应文本渲染"></a>自适应文本渲染</h4><p>对于文本水印，FDWM 实现了智能的字体大小调整：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_text_to_image</span>(<span class="params">text: <span class="built_in">str</span>, target_size: <span class="type">Tuple</span>[<span class="built_in">int</span>, <span class="built_in">int</span>], ...</span>) -&gt; np.ndarray:</span><br><span class="line">    <span class="comment"># 自适应字体大小计算</span></span><br><span class="line">    <span class="keyword">while</span> font_size &gt; <span class="number">10</span>:</span><br><span class="line">        <span class="comment"># 计算文本边界框</span></span><br><span class="line">        text_bbox = draw.multiline_textbbox((<span class="number">0</span>, <span class="number">0</span>), wrapped, font=font, spacing=<span class="number">4</span>)</span><br><span class="line">        text_w = text_bbox[<span class="number">2</span>] - text_bbox[<span class="number">0</span>]</span><br><span class="line">        text_h = text_bbox[<span class="number">3</span>] - text_bbox[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> text_w &lt;= cols <span class="keyword">and</span> text_h &lt;= rows:</span><br><span class="line">            <span class="comment"># 文本适合，居中绘制</span></span><br><span class="line">            x = (cols - text_w) // <span class="number">2</span></span><br><span class="line">            y = (rows - text_h) // <span class="number">2</span></span><br><span class="line">            draw.multiline_text((x, y), wrapped, fill=<span class="number">255</span>, font=font, spacing=<span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span> np.array(img)</span><br><span class="line"></span><br><span class="line">        font_size -= <span class="number">2</span>  <span class="comment"># 减小字体重试</span></span><br></pre></td></tr></table></figure><h2 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h2><h3 id="1-模块结构"><a href="#1-模块结构" class="headerlink" title="1. 模块结构"></a>1. 模块结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fdwm/</span><br><span class="line">├── __init__.py          # 包入口，导出主要函数</span><br><span class="line">├── watermark.py         # 核心水印算法实现</span><br><span class="line">├── cli.py              # 命令行界面</span><br><span class="line">└── __main__.py         # 模块执行入口</span><br></pre></td></tr></table></figure><h3 id="2-设计模式"><a href="#2-设计模式" class="headerlink" title="2. 设计模式"></a>2. 设计模式</h3><p>FDWM 采用了清晰的分层架构：</p><ul><li><strong>算法层</strong>：<code>watermark.py</code> 包含所有核心算法</li><li><strong>接口层</strong>：<code>__init__.py</code> 提供简洁的 API</li><li><strong>用户层</strong>：<code>cli.py</code> 提供命令行工具</li></ul><h3 id="3-配置管理"><a href="#3-配置管理" class="headerlink" title="3. 配置管理"></a>3. 配置管理</h3><p>项目使用现代化的 Python 包配置：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pyproject.toml</span></span><br><span class="line"><span class="section">[project]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;fdwm&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">description</span> = <span class="string">&quot;Frequency-domain watermarking library and CLI&quot;</span></span><br><span class="line"><span class="attr">dependencies</span> = [</span><br><span class="line">    <span class="string">&quot;numpy&gt;=1.20&quot;</span>,</span><br><span class="line">    <span class="string">&quot;opencv-python&gt;=4.5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Pillow&gt;=10.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pytesseract&gt;=0.3.10&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="section">[project.scripts]</span></span><br><span class="line"><span class="attr">fdwm</span> = <span class="string">&quot;fdwm.cli:main&quot;</span></span><br></pre></td></tr></table></figure><h2 id="使用体验：简单到让人惊喜"><a href="#使用体验：简单到让人惊喜" class="headerlink" title="使用体验：简单到让人惊喜"></a>使用体验：简单到让人惊喜</h2><h3 id="1-安装简单"><a href="#1-安装简单" class="headerlink" title="1. 安装简单"></a>1. 安装简单</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install fdwm</span><br></pre></td></tr></table></figure><h3 id="2-API-简洁"><a href="#2-API-简洁" class="headerlink" title="2. API 简洁"></a>2. API 简洁</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> fdwm <span class="keyword">import</span> embed, extract, extract_text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图像水印</span></span><br><span class="line">watermarked_img = embed(host_img, watermark_img, strength=<span class="number">0.1</span>)</span><br><span class="line">extracted_watermark = extract(watermarked_img, watermark_img.shape[:<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文本水印</span></span><br><span class="line">watermarked_img = embed(host_img, <span class="string">&quot;Hello World&quot;</span>, strength=<span class="number">0.1</span>, is_text=<span class="literal">True</span>)</span><br><span class="line">extracted_text = extract_text(watermarked_img)</span><br></pre></td></tr></table></figure><h3 id="3-命令行友好"><a href="#3-命令行友好" class="headerlink" title="3. 命令行友好"></a>3. 命令行友好</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 嵌入图像水印</span></span><br><span class="line">fdwm embed host.jpg watermark.png -o watermarked.jpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 嵌入文本水印</span></span><br><span class="line">fdwm embed host.jpg <span class="string">&quot;Hello World&quot;</span> -o watermarked.jpg --text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取水印</span></span><br><span class="line">fdwm extract watermarked.jpg watermark.png -o extracted.png</span><br></pre></td></tr></table></figure><h2 id="性能与质量保证：做得相当到位"><a href="#性能与质量保证：做得相当到位" class="headerlink" title="性能与质量保证：做得相当到位"></a>性能与质量保证：做得相当到位</h2><h3 id="1-测试覆盖"><a href="#1-测试覆盖" class="headerlink" title="1. 测试覆盖"></a>1. 测试覆盖</h3><p>项目包含完整的测试套件，这个测试写得很有意思：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_embed_extract</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;完整工作流测试：嵌入 -&gt; 提取 -&gt; 计算相关系数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 生成测试图像</span></span><br><span class="line">    generate_host_image(<span class="built_in">str</span>(host_path))</span><br><span class="line">    generate_watermark(<span class="built_in">str</span>(wm_path))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 嵌入水印</span></span><br><span class="line">    fdwm.embed(host_path, watermark_path, output_path, strength=<span class="number">5000.0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提取水印</span></span><br><span class="line">    extracted = fdwm.extract(watermarked_path, strength=<span class="number">5000.0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算相关系数</span></span><br><span class="line">    corr = np.corrcoef(wm_resized.flatten(), extracted.flatten())[<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">assert</span> corr &gt; <span class="number">0.5</span>, <span class="string">&quot;水印提取相关系数过低&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2-质量指标"><a href="#2-质量指标" class="headerlink" title="2. 质量指标"></a>2. 质量指标</h3><ul><li><strong>相关系数</strong>：原始水印与提取水印的相关系数 &gt; 0.5</li><li><strong>不可见性</strong>：水印嵌入后图像质量无明显下降</li><li><strong>鲁棒性</strong>：对常见图像处理操作有良好抵抗能力</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>FDWM 是一个使用简单、功能完善的数字水印库。它成功地将复杂的频域水印技术封装成易用的 Python 包，为图像版权保护和信息隐藏提供了解决方案。</p><p>特别值得一提的事，包括撰写这篇博客本身，整个过程中，我几乎没有手写代码。95% 以上的工作由 LLM 自动完成。</p><hr><p><strong>项目地址</strong>：<a href="https://github.com/Liam0205/fdwm">https://github.com/Liam0205/fdwm</a><br><strong>PyPI 包名</strong>：<a href="https://pypi.org/project/fdwm/">fdwm</a><br><strong>许可证</strong>：MIT<br><strong>作者</strong>：Liam Huang</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;还在念书时，就听说过频域水印。它可以通过将水印内容隐藏在宿主图像的高频区域，从而让人肉眼不可见地打上水印。为了详细了解相关技术，结合 LLM，我开发了一个 Python 库：&lt;strong&gt;FDWM（Frequency Domain Watermarking）&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Watermark" scheme="https://liam.page/tags/Watermark/"/>
    
      <category term="Steganography" scheme="https://liam.page/tags/Steganography/"/>
    
      <category term="Image processing" scheme="https://liam.page/tags/Image-processing/"/>
    
      <category term="Frequency domain" scheme="https://liam.page/tags/Frequency-domain/"/>
    
      <category term="FFT" scheme="https://liam.page/tags/FFT/"/>
    
  </entry>
  
  <entry>
    <title>运动生理学读书笔记：微观视角下的运动生理学与运动训练</title>
    <link href="https://liam.page/2024/10/04/notes-on-Exercise-Physiology-chap-02-Exercise-physiology-and-sports-training-from-a-microscopic-perspective/"/>
    <id>https://liam.page/2024/10/04/notes-on-Exercise-Physiology-chap-02-Exercise-physiology-and-sports-training-from-a-microscopic-perspective/</id>
    <published>2024-10-04T07:00:24.000Z</published>
    <updated>2024-10-04T13:40:54.502Z</updated>
    
    <content type="html"><![CDATA[<p>续接<a href="/2024/10/04/notes-on-Exercise-Physiology-chap-01-Aerobic-and-anaerobic-exercise/">前文</a>，这篇依旧是读书笔记，讨论微观视角下的运动生理学和运动训练。</p><span id="more"></span><h2 id="运动与能量平衡"><a href="#运动与能量平衡" class="headerlink" title="运动与能量平衡"></a>运动与能量平衡</h2><h3 id="运动的能量来源"><a href="#运动的能量来源" class="headerlink" title="运动的能量来源"></a>运动的能量来源</h3><p>运动中最直接和迅速的能量来源是 ATP，即磷酸原系统中的三磷酸腺苷。任何其他来源的能量若要被肌肉组织利用，首先要转化为 ATP 才行。在肌肉组织中的 ATP 储量很小；即便加上可以在磷酸激酶作用下转换为 ATP 的磷酸肌酸（PCr），能够维持的最大强度肌肉收缩的时间也不过 10s 左右。</p><p>运动中 ATP 消耗后需要不断再合成，以维持运动的需要。ATP 的再合成依赖其他供能物质的在细胞内的氧化还原反应释放的能量。这其中，糖（包括有氧氧化和无氧酵解）和脂肪（有氧氧化）提供运动中 ATP 在合成所需的绝大部分能量；蛋白质、酮体和乙酸仅在某些情况下提供少量能量。糖和脂肪的供能比例取决于运动强度和运动时长。此外，在身体的不同系统中，糖和脂肪的供能比例也不相同。下表描述各个功能系统在不同运动状态下的功能情况。</p><table><thead><tr><th>供能系统</th><th>运动类型和情况</th><th>举例说明</th></tr></thead><tbody><tr><td>三磷酸腺苷</td><td>所有运动，在力量爆发性运动中起主导作用</td><td>各种投掷、跳、百米跑等短时高强度爆发性运动</td></tr><tr><td>磷酸肌酸</td><td>运动刚开始时，极限强度运动及其后的短间歇</td><td>同上，以及高强度有间隙的运动训练</td></tr><tr><td>糖无氧酵解</td><td>高强度运动，尤其是 30s -- 2min 的运动</td><td>200m 计时跑</td></tr><tr><td>糖有氧氧化</td><td>运动持续 2min -- 5h。强度越大利用越多</td><td>篮球、排球、游泳、慢跑等运动</td></tr><tr><td>脂肪有氧氧化</td><td>持续时间长的低强度运动</td><td>长距离跑步、游泳和骑车</td></tr><tr><td>蛋白质有氧氧化</td><td>所有低强度运动以及糖缺乏时的中等强度耐力运动</td><td>耐力性跑步等</td></tr></tbody></table><h3 id="影响运动是能量代谢的因素"><a href="#影响运动是能量代谢的因素" class="headerlink" title="影响运动是能量代谢的因素"></a>影响运动是能量代谢的因素</h3><p>由于人的体力和耐力是有限的，所以通常强度大的运动持续时间短，相反持续时间长的运动通常强度低。强度大、时间段的运动，通常以无氧代谢供能为主。强度小、时间长的运动，通常以有氧代谢供能为主。除去力量爆发性运动（例如投掷标枪、百米跑）的能量绝大部分由磷酸原系统提供，多数运动的能量供应都是多系统混合的。</p><p>下表以运动持续时间区分，考察各类运动的主要功能系统。</p><table><thead><tr><th>运动持续时间</th><th>主要供能系统</th></tr></thead><tbody><tr><td>&lt; 30s</td><td>磷酸原</td></tr><tr><td>30s -- 1.5min</td><td>磷酸原和糖无氧酵解</td></tr><tr><td>1.5min -- 3min</td><td>糖无氧酵解和糖有氧氧化</td></tr><tr><td>&gt; 3min</td><td>糖有氧氧化和脂肪有氧氧化</td></tr></tbody></table><h2 id="水与运动"><a href="#水与运动" class="headerlink" title="水与运动"></a>水与运动</h2><p>水是生命之源。在人体内，水承担了非常多的生理功能。</p><p>运动者的水代谢远高于不运动者。运动中肌体大量产热，需要依靠排汗蒸发的方式来散发热量。此外，运动者从安静状态进入运动状态时，体内的物质代谢加强；若身体得不到水分补充，会脱水从而导致各种生理功能紊乱，造成运动循环衰竭。因此，必须要以合适的方式及时补充水。</p><h3 id="运动员水代谢的特点"><a href="#运动员水代谢的特点" class="headerlink" title="运动员水代谢的特点"></a>运动员水代谢的特点</h3><ul><li><strong>大量出汗</strong> 出汗程度与运动强度成正比，且受到持续时间、环境温度及湿度、热辐射强度等因素相关。</li><li><strong>排尿减少</strong> 高强度大运动量的运动导致大量水分经由汗液排出体外，加上运动时肾血流量降低以及肾小球过滤效率降低，常导致少尿或者无尿。</li><li><strong>呼吸蒸腾</strong> 运动时呼吸深度和频率提升，致使水分从呼吸渠道丢失的量可达平时的 10 -- 20 倍。</li><li><strong>代谢水增加</strong> 为了提供足够能量满足运动需要，代谢水量增多。</li></ul><p>若不及时补水，则可能导致脱水症状。</p><table><thead><tr><th>脱水程度</th><th>脱水部位</th><th>脱水量&#x2F;体重 (%)</th><th>症状</th><th>体力下降程度 (%)</th></tr></thead><tbody><tr><td>轻度脱水</td><td>细胞外液为主</td><td>2</td><td>血液渗透压升高，血容量减少，血液浓缩，心脏负担增加，口渴，尿量减少。</td><td>10 -- 15</td></tr><tr><td>中度脱水</td><td>细胞内外相等</td><td>4</td><td>严重口渴，心率加快，体温升高，感觉疲劳加重，血压降低</td><td>10 -- 30</td></tr><tr><td>重度脱水</td><td>细胞内失水增多</td><td>6 -- 10</td><td>血容量减少，心率加快，呼吸加快，恶心，食欲丧失，容易激动，精神活动减弱，严重时产生幻觉，全身乏力，无尿</td><td>严重威胁健康，意识丧失，昏迷，甚至死亡</td></tr></tbody></table><h3 id="运动中的合理补水"><a href="#运动中的合理补水" class="headerlink" title="运动中的合理补水"></a>运动中的合理补水</h3><p>首先，总的原则是要积极补水。</p><ul><li><strong>运动前</strong> 运动前 2h 最好摄入 400 -- 500 毫升水；在炎热的天气还应额外补充 250 -- 500 毫升水。运动前 15 分钟应该少量多次饮水。</li><li><strong>运动中</strong> 运动中每隔 15 -- 20 分钟应当补充 200 -- 300 毫升水；最好采用含糖和矿物质的运动饮料来补充水分及矿物质。</li><li><strong>运动后</strong> 根据体重丢失情况而定，分多次少量补水；应采用含糖和矿物质的运动饮料来补充水分及矿物质，不可只引用白开水。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;续接&lt;a href=&quot;/2024/10/04/notes-on-Exercise-Physiology-chap-01-Aerobic-and-anaerobic-exercise/&quot;&gt;前文&lt;/a&gt;，这篇依旧是读书笔记，讨论微观视角下的运动生理学和运动训练。&lt;/p&gt;
    
    </summary>
    
      <category term="Sports" scheme="https://liam.page/categories/Sports/"/>
    
    
      <category term="Exercise" scheme="https://liam.page/tags/Exercise/"/>
    
      <category term="Physilogy" scheme="https://liam.page/tags/Physilogy/"/>
    
  </entry>
  
  <entry>
    <title>运动生理学读书笔记：有氧与无氧运动</title>
    <link href="https://liam.page/2024/10/04/notes-on-Exercise-Physiology-chap-01-Aerobic-and-anaerobic-exercise/"/>
    <id>https://liam.page/2024/10/04/notes-on-Exercise-Physiology-chap-01-Aerobic-and-anaerobic-exercise/</id>
    <published>2024-10-04T02:57:04.000Z</published>
    <updated>2024-10-04T07:03:54.592Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="/2024/04/21/VO2-Max/">前一篇文章</a>中，我们讨论了最大摄氧量的概念。但显然，我对这个概念以及相关领域并不了解。为了解除「半桶水晃荡」的状态，我决定对这个领域进行更进一步的了解；于是前往国家图书馆借阅了运动生理学相关的专著书籍来阅读。这一系列是读书笔记。</p><span id="more"></span><h2 id="人体的生存和各种活动都需要氧的支持"><a href="#人体的生存和各种活动都需要氧的支持" class="headerlink" title="人体的生存和各种活动都需要氧的支持"></a>人体的生存和各种活动都需要氧的支持</h2><p>氧的摄取和利用是人体生存和活动的必要条件之一。可以说：</p><ul><li>人活着，就需要氧；</li><li>人活动，就需要更多的氧；</li><li>人活动的强度越大，就越需要氧；</li><li>人活动的时间越长，就越需要氧。</li></ul><p>在需求端，人体在单位时间内的需氧量是两个因素的和：</p><ul><li>维持基本生理活动的需氧量；</li><li>支持当前活动强度的需氧量。</li></ul><p>上述和与活动时长的乘积，就是这段时间内总的需氧量。</p><p>在供给端，人体的摄氧量则是单位时间内（通常是 1min）人从肺泡的气体交换中获取的氧气体积（绝对值）或者全身所有组织从毛细血管中获取的氧气的体积（绝对值）。</p><p>这里蕴含了一对矛盾。</p><ul><li>开始运动时，人体从静息状态立即切换到活动状态。根据上述说明，需氧量会陡然增加。但是呼吸系统和循环系统响应需求需要一定时间。在这个时间范围内，供氧能力小于需氧量，因此身体处在「亏氧」状态。</li><li>停止运动时，人体从活动状态立即切换到静息状态。根据上述说明，需氧量会陡然下降。但是呼吸系统和循环系统仍会在一段时间内处在「高功率」的工作状态中。在这个时间范围内，供氧能力大于需氧量，于是身体处在「过氧」状态。这个状态被称为运动后的过量氧耗。</li></ul><h2 id="有氧运动的生理基础及其能量供应特点"><a href="#有氧运动的生理基础及其能量供应特点" class="headerlink" title="有氧运动的生理基础及其能量供应特点"></a>有氧运动的生理基础及其能量供应特点</h2><h3 id="有氧运动的生理基础"><a href="#有氧运动的生理基础" class="headerlink" title="有氧运动的生理基础"></a>有氧运动的生理基础</h3><p>有氧运动据其字面可以简单拆分为两个部分：有氧、运动。因此其生理学基础可以分为三个部分讨论：</p><ul><li>氧气的摄入、运输和利用的生理学基础；</li><li>人体得以运动的生理学基础；</li><li>上述二者的结合以利用氧气。</li></ul><p>呼吸系统负责摄入氧气，循环系统负责运输氧气。因此，呼吸系统和循环系统的功能水平和储备能力是有氧运动的重要生理学基础。</p><p>人的运动基本上都由肌肉支持。而讨论通常意义上的运动时，最为重要的是骨骼肌。骨骼肌中有所谓慢肌纤维（ST）和快肌纤维的区别。慢肌纤维含量高的人，有氧运动能力相对好。</p><p>神经系统会对身体各个器官和系统进行调节、调整和整合，实现移缓救急。比如血液的重新分配、皮肤血管的适时扩张、保持体温稳态、抑制肠胃活动等。在有氧运动中，神经系统的参与，可以将呼吸和循环系统与支持运动的骨骼肌整合起来。特别地，长期训练可以改善神经系统的调节能力，从而节省能量消耗，维持更长时间的肌肉活动。</p><h3 id="有氧运动的供能特点"><a href="#有氧运动的供能特点" class="headerlink" title="有氧运动的供能特点"></a>有氧运动的供能特点</h3><p>耐力性项目运动强度小而持续时间长，主要以有氧功能为主。在人体能量供给的体系中，糖和脂肪在有氧条件下可以保持长时间的供能；于是他们也会是有氧运动表现的重要影响因素。在运动中提高自由脂肪酸（FFA）的氧化功能能力将有助于节约肌糖原的消耗，从而增强有氧运动表现。</p><p>此外，增加肌糖原的储量对有氧运动能力有重大提升。Gollnick 的研究发现，20 周每周 4 天的有氧训练可以使得肌糖原储量增加 2.5 倍（到 3.5 倍）。</p><h3 id="最大摄氧量"><a href="#最大摄氧量" class="headerlink" title="最大摄氧量"></a>最大摄氧量</h3><h4 id="定义与解析"><a href="#定义与解析" class="headerlink" title="定义与解析"></a>定义与解析</h4><p>最大摄氧量是指人体在进行全身大肌肉群参与的递增负荷运动中，当人体的氧运输系统的供氧能力和肌肉的用氧能力达到本人的极限水平时，单位时间内（通常以分钟为单位）所吸收的氧的量。最大摄氧量亦称为最大吸氧量或最大耗氧量或有氧适能水平。</p><p>这一定义是最大摄氧量的绝对值定义。由于最大摄氧量和身高、体重相关，以绝对值进行横向比较通常难以公平。于是又可以引进相对值定义；即按照每分钟每千克体重来计算最大摄氧量，其单位是毫升&#x2F;(千克·分钟)。一般来说，我国男大学生的最大摄氧量是 50 -- 55 毫升&#x2F;(千克·分钟)，而女大学生的最大摄氧量是 40 -- 45 毫升&#x2F;(千克·分钟)。</p><p>最大摄氧量是评价有氧耐力的重要指标，是心肺功能、肌肉耐力的综合反应。</p><h4 id="测定方法"><a href="#测定方法" class="headerlink" title="测定方法"></a>测定方法</h4><p>简单粗暴地，可以依照定义在实验室条件下对运动员进行最大摄氧量的测定。例如说，逐步增加跑台（跑步机）的坡度，从而使受试者的运动符合逐渐增加；同时通过特质的呼吸面罩，记录受试者的通气量以及呼吸中氧气和二氧化碳分量的变化情况，从而计算出受试者的最大摄氧量。</p><p>直接测定的方法数据可靠、重复性好、准确性高，但这需要专门的实验室条件和仪器以及严格的操作来保证。对普通人来说，直接测定的方法显得过于麻烦。于是有许多学者致力于用简单方法来间接推算最大摄氧量。市面上各类运动手表，都是使用间接法对最大摄氧量做的估算。</p><p>间接法总的原理是，在一定范围内，摄氧量与心率呈现线性关系。于是，只需要测定受试者一次最大运动时的心率，或者达到一定心率的做工量就可以推算出最大摄氧量。这种推算和实验室直接测定的结果通常差距较大，但因其便捷性仍被广泛使用。</p><h4 id="决定因素"><a href="#决定因素" class="headerlink" title="决定因素"></a>决定因素</h4><p>最大摄氧量一方面和心肺功能相关（决定了摄取和运输氧的效率），另一方面和肌肉能力相关（决定了利用氧的效率）。心肺功能是最大摄氧量的中央机制，肌肉能力是最大摄氧量的外周机制。</p><p>虽然将心肺功能看做一个整体作为影响最大摄氧量的中央机制，但实际上只要不患有严重的肺部疾病，肺的通气功能储备通常远高于心脏的泵血功能储备。因此，在心肺功能中，实际对最大摄氧量产生显著影响的是心脏的泵血能力。这里又包括了左心室的最大心输出量，以及体循环中血管输氧的各环节的能力。考虑到，心脏的最大泵血量是心率和最大每搏输出量的乘积，而在心率于一定范围内最大每搏输出量是几乎不变的，这是上述「线性关系」的生理学基础。（心率过高时，最大每搏输出量会下降）</p><p>肌肉利用氧的能力取决于两个因素；一是肌肉的摄氧能力，二是供给肌肉的血量。慢肌纤维有丰富的蛮细血管分布；慢肌纤维内的肌肉细胞线粒体数目多、体积大，氧化酶的活性高，肌红蛋白的比例高。因此慢肌纤维的比例越高，肌肉的摄氧能力越高。肌肉的供血量一方面和心脏的泵血能力相关，另一方面还与血液的重新分配相关。Rowell 于 1974 年的研究表明，即便不考虑心输出量的变化，仅仅从腹腔内脏和肾血管的收缩，每分钟就可以腾出额外的 2.2L 血液容量分配到活动肌肉中。这可以是摄氧量每分钟增加 500 毫升左右。</p><h4 id="影响因素"><a href="#影响因素" class="headerlink" title="影响因素"></a>影响因素</h4><p>遗传是影响最大摄氧量的最大因素。多数学者认为最大摄氧量的遗传度在 80% 以上。</p><p>遗传之外，影响最大摄氧量的最大因素是性别与年龄。</p><p>在青春期之前，男女最大摄氧量的差异不明显。但在青春期之后，差异逐渐显著。成年男性的最大摄氧量要高于同龄女性 20% -- 30%。</p><p>在年龄角度，从出生开始，人体的最大摄氧量会逐渐提升，直到在 15 -- 20 岁达至巅峰。这一巅峰基本维持到 30 岁，而后开始逐年下降。男子基本以每年 2% 的速度逐渐下降；女子下降的速度则约为 2.5%。老年后下降率降低至不足 1%，而在 60 岁时可降至最大值的 70%。</p><p>从事不同项目的运动员，最大摄氧量有明显差异。从事越野滑雪、长跑的运动员，其最大摄氧量明显高于短跑、举重等非耐力项目的运动员。</p><h3 id="无氧阈"><a href="#无氧阈" class="headerlink" title="无氧阈"></a>无氧阈</h3><p>随着运动负荷的递增，人体的需氧量逐渐上升。但人体的呼吸循环系统的能力和效率是有限的。在供氧不足时，糖的无氧酵解产物是丙酮酸，丙酮酸在氧气不足时还原为乳酸。随着运动负荷递增，乳酸的积累速度加快。随着乳酸积累的速度逐渐超过乳酸清除速度，血液中积累的乳酸开始显著消耗血液中的碱储备（碳酸氢根）生成碳酸。碳酸解离出氢离子刺激呼吸中枢，促使肺通气量急剧上升。</p><p>这一过程中，乳酸累计速度超过乳酸清除速度的阈值，称之为乳酸阈；肺通气量急剧上升的拐点，称之为呼吸阈。二者都说明运动中，人体的供能开始由有氧呼吸为主导切换到无氧呼吸为主导，因此也称为无氧阈。</p><p>随着运动负荷的递增，心率亦逐渐增加。在强度较小时，心率与运动负荷基本呈现线性关系。但当运动强度超过某一阈值时，心率增加呈现非线性变化。这一转折点被称作心率阈。研究表明，心率阈与乳酸阈高度相关，相关系数高达 0.98。因此，通过测定和观察心率，可以一定程度上判别无氧阈。</p><p>一般来说，健康青年人的无氧阈是 50% -- 60% 的最大摄氧量；优秀的耐力运动员的无氧阈之可达 70% -- 80% 的最大摄氧量。</p><h2 id="有氧运动能力的训练方法"><a href="#有氧运动能力的训练方法" class="headerlink" title="有氧运动能力的训练方法"></a>有氧运动能力的训练方法</h2><p><strong>持续训练</strong> 在（略高于）无氧阈强度下，或在最大心率 70% 强度下进行持续训练，是提高最大摄氧量与无氧阈的有效方式。</p><p><strong>间歇训练</strong> 在一次练习之后，按照严格规定的捡些时间用积极休息的方法进行休息，在肌体未完全恢复的情况下进行下一次练习的方法称为间歇训练。高强度间歇训练（HIIT）可以提高耐力水平。</p><p><strong>力量训练</strong> 一个好的建议是在短暂的热身后先进行力量练习（理想重量下每组重复 6 -- 12 次），然后做有氧训练（达到最大心率的 70% 以上）。</p><h2 id="无氧运动能力"><a href="#无氧运动能力" class="headerlink" title="无氧运动能力"></a>无氧运动能力</h2><p>无氧运动基本上可以分为两种：力量爆发性运动和无氧耐力运动。前者依靠磷酸原系统（ATP-PCr）供能，后者依靠糖无氧酵解系统供能。虽然都是无氧运动，但二者生理基础有显著差异。</p><h3 id="力量爆发性运动"><a href="#力量爆发性运动" class="headerlink" title="力量爆发性运动"></a>力量爆发性运动</h3><p>力量爆发性运动通常需要运动员在数秒时间内发挥最大的能量输出。如短跑、投掷、跳跃、举重等运动项目。</p><p>ATP（三磷酸腺苷）是人体内最直接的能量来源。但它在肌肉内的存量极其稀少，大约为 20 -- 30 mmol&#x2F;Kg。PCr（磷酸肌酸）可在 CK（肌酸激酶）的作用下水解，使 ADP（二磷酸腺苷）再合成 APT。PCr 的存量大约是 APT 的 3 -- 5 倍。APT 和 PCr 的储量大约可以支持人体高强度、高爆发运动 10 秒时间。</p><h3 id="无氧耐力运动"><a href="#无氧耐力运动" class="headerlink" title="无氧耐力运动"></a>无氧耐力运动</h3><p>无氧耐力运动依靠糖无氧酵解系统功能。因此，乳酸脱氢酶的活性和肌糖原的储量是无氧耐力运动的重要生理基础。</p><p>此外，无氧酵解的代谢产物乳酸进入血液后，因为缓冲液的作用，血液 pH 值只会在微小范围内波动。而后者对于维持人体稳态具有重要意义。因此，缓冲液的缓冲能力对延长肌肉无氧运动的时间有重要意义；前者取决于碳酸氢钠的含量及碳酸酐酶的火星。</p><p>再者，尽管有缓冲液的存在，但是大量乳酸入血依然会导致血液的平衡向酸性方向移动。这会影响脑细胞的工作能力。因此，脑细胞对这些不利因素的耐受能力也会显著影响无氧耐力运动的能力。</p><h3 id="训练方法"><a href="#训练方法" class="headerlink" title="训练方法"></a>训练方法</h3><p>间歇训练不仅可以用于改善有氧运动表现，也有助于改善力量爆发性运动和无氧耐力运动的表现。但其强度和间歇比例会有所不同。</p><table><thead><tr><th>间歇</th><th>训练目标</th><th>重复次数</th><th>时间 (s)</th><th>工作:休息</th><th>最大心率 (%)</th></tr></thead><tbody><tr><td>长</td><td>有氧运动</td><td>4 -- 6</td><td>120 -- 300</td><td>1:1</td><td>85 -- 90</td></tr><tr><td>中</td><td>无氧耐力</td><td>8 -- 12</td><td>60 -- 90</td><td>1:2</td><td>95</td></tr><tr><td>短</td><td>力量爆发</td><td>15 -- 20</td><td>30 -- 60</td><td>1:3</td><td>100</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;/2024/04/21/VO2-Max/&quot;&gt;前一篇文章&lt;/a&gt;中，我们讨论了最大摄氧量的概念。但显然，我对这个概念以及相关领域并不了解。为了解除「半桶水晃荡」的状态，我决定对这个领域进行更进一步的了解；于是前往国家图书馆借阅了运动生理学相关的专著书籍来阅读。这一系列是读书笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="Sports" scheme="https://liam.page/categories/Sports/"/>
    
    
      <category term="Exercise" scheme="https://liam.page/tags/Exercise/"/>
    
      <category term="Physilogy" scheme="https://liam.page/tags/Physilogy/"/>
    
      <category term="Aerobic" scheme="https://liam.page/tags/Aerobic/"/>
    
      <category term="Anaerobic" scheme="https://liam.page/tags/Anaerobic/"/>
    
  </entry>
  
  <entry>
    <title>最大摄氧量是什么？</title>
    <link href="https://liam.page/2024/04/21/VO2-Max/"/>
    <id>https://liam.page/2024/04/21/VO2-Max/</id>
    <published>2024-04-21T14:33:16.000Z</published>
    <updated>2024-08-06T14:00:02.454Z</updated>
    
    <content type="html"><![CDATA[<p>用了 8 年的 Apple Watch，一直就知道其中有「最大摄氧量」（Apple 翻译做有氧适能水平）这一身体指标。由于最近自身身体上出现的一些问题，开始更加关注它。</p><p>由于 Apple 健康中给出的最大摄氧量相关的解释不甚清晰，所以检索资料后，对最大摄氧量做一些简单的记录。</p><span id="more"></span><p>最大摄氧量是评估身体摄取（与肺脏关系最大）、运输（和心脏关系较大）、利用（和肌肉组织关系较大）能力的指标。其公式可以表述为</p><p><code>$\text&#123;$\text&#123;VO&#125;_2$ MAX&#125; = \text&#123;MHR&#125;\times\text&#123;SV MAX&#125;\times\text&#123;A-V $\text&#123;O&#125;_2$ diff&#125;.$</code></p><p>这里</p><ul><li>MHR 是最大心率。这是一个估算值。对于身体健康的成人来说，它与年龄（周岁）负相关。具体计算方法为 <code>$220 - \text&#123;年龄&#125;$</code>。对于有特别的病史的人（比如有过心肺手术术后病史的人），MHR 的计算方法不能就此预估，应当咨询医生。</li><li>SV MAX 是心脏每一次搏动射血量（每搏输出量）的最大值，是评估心脏能力的重要指标。</li><li>A-V O2 diff 则是动静脉中含氧量的差异，是评估机体利用氧气能力的重要指标。</li></ul><p>可见，在 SV Max 和 A-V O2 diff 不变的情况下，随着年龄的增长，VO2 Max 的指标确实会逐渐降低。但若保持运动，可使指标降低的速率变慢。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用了 8 年的 Apple Watch，一直就知道其中有「最大摄氧量」（Apple 翻译做有氧适能水平）这一身体指标。由于最近自身身体上出现的一些问题，开始更加关注它。&lt;/p&gt;
&lt;p&gt;由于 Apple 健康中给出的最大摄氧量相关的解释不甚清晰，所以检索资料后，对最大摄氧量做一些简单的记录。&lt;/p&gt;
    
    </summary>
    
      <category term="Sports" scheme="https://liam.page/categories/Sports/"/>
    
    
      <category term="Apple Watch" scheme="https://liam.page/tags/Apple-Watch/"/>
    
      <category term="最大摄氧量" scheme="https://liam.page/tags/%E6%9C%80%E5%A4%A7%E6%91%84%E6%B0%A7%E9%87%8F/"/>
    
      <category term="有氧适能水平" scheme="https://liam.page/tags/%E6%9C%89%E6%B0%A7%E9%80%82%E8%83%BD%E6%B0%B4%E5%B9%B3/"/>
    
  </entry>
  
  <entry>
    <title>这书有点甜——《数理化通俗演义》读后感</title>
    <link href="https://liam.page/2024/04/21/book-review-a-general-narration-of-math-physics-and-chemistry/"/>
    <id>https://liam.page/2024/04/21/book-review-a-general-narration-of-math-physics-and-chemistry/</id>
    <published>2024-04-21T13:17:44.000Z</published>
    <updated>2024-08-06T14:00:02.455Z</updated>
    
    <content type="html"><![CDATA[<p>《数理化通俗演义》是梁衡的作品。本书初版于 1984 年，距今已有 40 年的历史。</p><p>初次知道这本书，大约是 2019 年时候在知乎上浏览时看到网友推荐。至今的 5 年时间里，我也不知读了它多少遍。萦绕在我脑海里的一个问题就是，这么好的一本科普书，为什么在我年少时没有读到过？——实际上，少时的我，读类似的书并不少。</p><span id="more"></span><p>《数理化通俗演义》以小说的形式，让我们仿佛穿越回那些科学大发现的时代。看着书里一个个栩栩如生的科学家形象和他们的故事，不仅能让读者学到了很多科学知识，更能让读者感受到科学探索的那份激情和艰辛。</p><p>想想看，那些年我们在学校里学习的时候，数理化总是让很多同学觉得头大。尤其那些偏爱文科的同学，大约对那些公式和定理更是又爱又恨。但是，如果当年我们能有机会读到《数理化通俗演义》，可能会完全改观。这本书用它那富有感染力的叙述方式，简直是为数理化课本的生硬知识点披上了一层浓厚的糖衣。</p><p>书中不仅仅是把科学知识简化了，更重要的是，它让我们看到了科学家们的人性光辉。他们不是高高在上的圣人，而是有血有肉、有情有义的普通人。他们在科学的道路上也会跌跌撞撞，甚至犯错。这样的描写，让我深刻体会到，科学不仅是理智的积累，更是情感与智慧的结合。</p><p>特别是在介绍生物链和细菌病毒的章节，我不由得联想到几年前的新冠疫情。如果不是有那么多科学家前赴后继的研究和牺牲，我们现在可能还在与病毒斗争的更加艰难的境地。这本书中关于科学发展的历史回顾，不只是让我们了解过去，更是让我们对未来充满了希望。</p><p>所以，是的。在我眼里，这是一本好书，一本值得推荐的书。我特别推荐这本书给那些对数理化感到害怕或者不感兴趣的人。你们会发现，从探索者的角度出发，科学其实并不是那么的难懂，它充满了探险和发现的乐趣。书中的科学家们用他们的智慧和毅力，为我们展示了一个又一个令人兴奋的科学世界。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《数理化通俗演义》是梁衡的作品。本书初版于 1984 年，距今已有 40 年的历史。&lt;/p&gt;
&lt;p&gt;初次知道这本书，大约是 2019 年时候在知乎上浏览时看到网友推荐。至今的 5 年时间里，我也不知读了它多少遍。萦绕在我脑海里的一个问题就是，这么好的一本科普书，为什么在我年少时没有读到过？——实际上，少时的我，读类似的书并不少。&lt;/p&gt;
    
    </summary>
    
      <category term="Literature and Social Sciences" scheme="https://liam.page/categories/Literature-and-Social-Sciences/"/>
    
    
      <category term="Book review" scheme="https://liam.page/tags/Book-review/"/>
    
      <category term="数理化通俗演义" scheme="https://liam.page/tags/%E6%95%B0%E7%90%86%E5%8C%96%E9%80%9A%E4%BF%97%E6%BC%94%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>《谈人生》读后感</title>
    <link href="https://liam.page/2024/03/17/book-review-tanrensheng/"/>
    <id>https://liam.page/2024/03/17/book-review-tanrensheng/</id>
    <published>2024-03-17T05:32:33.000Z</published>
    <updated>2024-03-17T10:14:17.243Z</updated>
    
    <content type="html"><![CDATA[<p>最近读完了季羡林先生的《谈人生》。此处要感谢 Millie 赠书。</p><p>这是季先生万年在医院疗养期间亲自编选的作品集。文集收录了季先生在人生各个阶段的代表作品。从文体上说，涵盖散文、随笔、邮寄、回忆录、日记、讲演报告等。</p><p>在读书的过程中，遇到一些自觉有趣的文字，就随手摘录，并作感想。这里同季先生选编文集一样，将这些摘录和感想选编在一起，形成此文。</p><span id="more"></span><blockquote><p>时光流逝，一转眼，自己已经到了望九之年，活得远远超过了我的预算。有人认为长寿是福，我看也不尽然。人活得大久了，对人生的种种相、众生的种种相，看得透透彻彻，反而鼓舞时少，叹息时多，远不如早一点离开人世这个是非之地，落一个耳根清净。</p><p>……</p><p>话说到这里，我想把上面说的意思简短扼要地归纳一下：如果人生真有意义与价值的话，其意义与价值就在于对人类发展的承上启下、承前启后的责任感。</p><p>——《人生的意义与价值》 季羡林</p></blockquote><p>季先生的文字还是有趣的。</p><p>「活得超过了预算」初看到真的会笑死，然后反思自己好像没有做这样的预算，又继而想是否有必要做这样的预算？乐而又乐。</p><p>「被困于名缰，被缚于利索」这一句容易理解，但应该惊叹大师练字的本领。名缰利索算是一般常见的词。单独用，大体上也就感觉是有那么个东西。拆开使用平添不少意味，「作茧自缚」的感觉被加强，终知名缰利索是自困、自缚，而不是他困、他缚。</p><p>文末的总结很有中华文人的古典气质：追求传世，追求大同。</p><p>若说印度之类的国家修来世（做好事是为了来生转世得好缘法），沙漠三教修今世（做好事是为了今生赎罪得上天堂），那中华文化圈就是修传世。即是说，人总要留下或是血脉传承或是文脉传承的东西，为民族、人类的发展留下自己的印记。而若再进步一点者，可以推动人类向前，那便可以在生命最后一刻坦然地说「我已尽到责任」了。</p><hr><blockquote><p>现在杨女士却对我垂青，要我作“哲学思考”，侈谈“禅趣”，我焉得不诚惶诚恐呢？这就是我把来信搁置不答的真正原因。我的如意算盘是，我稍搁置，杨女士担当编辑重任，时间一久，就会把此事忘掉，我就可以逍遥自在了。</p><p>然而事实却大出我意料，她不但没有忘掉，而且打来长途电话，直捣黄龙，令我无所逃于天地之间。我有点惭愧，又有点惶恐。但是，心里想的却是：按既定方针办。我连忙解释，说我写惯了考据文章。关于“禅”，我只写过一篇东西，而且是被赶上了架才写的，当然属于“野狐”一类。我对她说了许多话，实际上却是“居心不良”，想推掉了事，还我一个逍遥自在身。</p><p>可是我万万没有想到，正当我颇为得意的时候，杨女士的长途电话又来了，而且还是两次。昔者刘先主三顾茅庐，躬请卧龙先生出山，共图霸业。藐予小子，焉敢望卧龙先生项背！三请而仍拒，岂不是太不识相了吗？我痛自谴责，要下决心认真对待此事了。我拟了一个初步选目。过后自己一看，觉得好笑，选的仍然多是考据的东西。我大概已经病入膏肓，脑袋瓜变成了花岗岩，已经快到不可救药的程度了。于是决心改弦更张，又得我多年的助手李铮先生之助，终于选成了现在这个样子。这里面不能说没有涉及禅趣，也不能说没有涉及人生。但是，把这些文章综合起来看，我自己的印象是一碗京海杂烩。可这种东西为什么竟然敢拿出来给人看呢？自己“藏拙”不是更好吗？我的回答是：我在任何文章中讲的都是真话，我不讲半句谎话。而且我已经到了耄耋之年，一生并不是老走阳光大道，独木小桥我也走过不少。因此，酸、甜、苦、辣，悲、欢、离、合，我都尝了个够。发为文章，也许对读者，特别是青年读者，不无帮助。这就是我斗胆拿出来的原因。倘若读者—不管是老中青年—真正能从我在长达八十多年对生活的感悟中学到一点有益的东西，那我就十分满意了。至于杨女士来信中提到的那一些想法或者要求，我能否满足或者满足到什么程度，那就只好请杨女士自己来下判断了。</p><p>——《禅趣人生》 季羡林</p></blockquote><p>如先前所说，季先生的文字属实有趣。今日始知这份有趣来自「不作伪」。</p><p>大师也有七情六欲，遇事也会有退缩逃避，然后打起如意算盘。<br>大师在如意算盘被瞧破之后，也会有惶恐（也许心虚脸红？）。<br>大师也会有思维定式，然后感叹自己的脑袋瓜变成了花岗岩。</p><p>真诚而不作伪是打动读者的「大杀器」，写文十年深以为然。然则想要真诚而不作伪，需得首先与自己握手言和，内照己心而圆融无碍。若不然，为了所谓的「面子」或者时下流行的「人设」，则难免带上偏见，从而在自知或者不自知的情况下作伪。</p><hr><blockquote><p>敌兵压境，应当振作起来，鼓励士兵，同仇敌忾，可是苻坚自己却先泄了气。这样的人不称为孱头，又称之为什么呢？结果留下了两句著名的话：“风声鹤唳，草木皆兵。”至今还流传在人民的口中，也可以说是流什么千古了。</p><p>——《论恐惧》季羡林</p></blockquote><p>我快要被「流什么千古」笑死了。</p><p>文人笔墨，果然有趣。放着有「遗臭万年」不用，偏生要去用「流什么千古」（显然这里的什么代指臭）。用这种小朋友也能懂的小手法表达「遗臭万年」的含义，有多出俏皮和趣味。</p><hr><blockquote><p>对此我有自己的哲学基础：吃饭是为了自己，而穿衣则是为了别人。道理自明，不用辩证。哪有一个人穿着华丽，珠光宝气，天天坐在菱花镜前，顾影自怜？如果真正有的话，他或她距入疯人院的日期也不会远了。</p><p>——《衣着的款式》季羡林</p></blockquote><blockquote><p>至于衣着，更不在我考虑之列。在这方面，我是一个“利己主义者”。衣足以蔽体而已，何必追求豪华。一个人穿衣服，是给别人看的。如果一个人穿上十分豪华的衣服，打扮得珠光宝气，天天坐在穿衣镜前，自我欣赏，他（她）不是一个疯子，就是一个傻子。如果只是给别人去看，则观看者的审美能力和审美标准，千差万别，你满足了这一帮人，必然开罪于另一帮人，绝不能使人人都高兴，皆大欢喜。反不如我行我素，我就是这一身打扮，你爱看不看，反正我不能让你指挥我，我是个完全自由自主的人。</p><p>——《漫谈消费》季羡林</p></blockquote><p>看到前一篇文章部分时候，我还在诧异什么叫做「穿衣是为了别人」。这与我心中所想相差颇大，也与认知中的季老影响相去甚远。</p><p>继续读到后一篇文章才明白季老想表达的意思。这个「给别人看的」其实是说，别人看看就好，至于看过之后意见如何则不必在意。</p><p>穿衣服嘛，蔽体、得体即可。</p><hr><blockquote><p>不管你意识到还是没有意识到，大自然还是把虚无缥缈的时间用具体的东西暗示给了人们。比如用日出日落标志出一天，用月亮的圆缺标志出一月，用四季（在印度是六季或者两季）标志出一年。</p><p>——《时间》季羡林</p></blockquote><p>印度居然有六季的说法。原来蟪蛄不知春秋不只是说说。若在印度，我岂不就是阿成不知雨风吗？</p><p>查阅得印度一年分为六个季节，这六个季节分别是春季、夏季、雨季、秋季、风季、冬季。<br>春季（3月20——5月19）  金星主宰<br>夏季（5月20——7月19）  太阳与火星主宰<br>雨季（7月20——9月19）  月亮主宰<br>秋季（9月20——11月19） 水星主宰<br>风季（11月20——1月19）  木星主宰<br>冬季（1月20——3月19）  土星主宰</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近读完了季羡林先生的《谈人生》。此处要感谢 Millie 赠书。&lt;/p&gt;
&lt;p&gt;这是季先生万年在医院疗养期间亲自编选的作品集。文集收录了季先生在人生各个阶段的代表作品。从文体上说，涵盖散文、随笔、邮寄、回忆录、日记、讲演报告等。&lt;/p&gt;
&lt;p&gt;在读书的过程中，遇到一些自觉有趣的文字，就随手摘录，并作感想。这里同季先生选编文集一样，将这些摘录和感想选编在一起，形成此文。&lt;/p&gt;
    
    </summary>
    
      <category term="Literature and Social Sciences" scheme="https://liam.page/categories/Literature-and-Social-Sciences/"/>
    
    
      <category term="Book review" scheme="https://liam.page/tags/Book-review/"/>
    
      <category term="季羡林" scheme="https://liam.page/tags/%E5%AD%A3%E7%BE%A1%E6%9E%97/"/>
    
      <category term="谈人生" scheme="https://liam.page/tags/%E8%B0%88%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>百度大搜的一些历史经验</title>
    <link href="https://liam.page/2024/01/04/legacy-experience-of-Baidu-search/"/>
    <id>https://liam.page/2024/01/04/legacy-experience-of-Baidu-search/</id>
    <published>2024-01-04T01:10:24.000Z</published>
    <updated>2024-03-17T05:08:22.502Z</updated>
    
    <content type="html"><![CDATA[<p>这是 2016 年 6 月和百度的技术专家交流的一些经验总结。近期翻出来，记录在这里。</p><span id="more"></span><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul><li>AC：高级搜索（AS 拆出来的），类似于 tuner 上移后的 merger</li><li>DX：存储正排相关的内容，最简单的是存储每个 url 的所有文字内容，然后可以存储各种离线 parse 出来的内容（包括各种段落、命名实体等信息）</li><li>GBRank：可以认为是 GBDT 的同义词</li><li>BS：基于倒排索引的分布式索引的基础检索，类似于 qsrchd 或者 leaf</li></ul><h2 id="百度的在线-ranking-相关架构"><a href="#百度的在线-ranking-相关架构" class="headerlink" title="百度的在线 ranking 相关架构"></a>百度的在线 ranking 相关架构</h2><p>基本如图。这个应该是表意的，不是完全和实际情况对应的。</p><p><img data-src="/uploads/images/algorithms/baidu-ranking-arch-2016.jpg"></p><p>重点说明：</p><p>DX - 正排库，对前 300 条结果进行精细正排计算，会重新计算 proximity。这个模块我们当前（2016）是缺失的，我们只有前 100 条结果的title。对方描述里这个模块是非常重要的，是百度 12 年相关性提升最大的项目。</p><p>百度的基本流程应该是 BS（qsrchd&#x2F;leaf）返回结果，merge 后对前 300 条在 DX 重新排序，返回给 AC，AC 继续重新排序，然后返回。</p><p>DX 和 AC 各有一个 GBRank 模型来负责排序。</p><h2 id="百度-LTR-的发展历程"><a href="#百度-LTR-的发展历程" class="headerlink" title="百度 LTR 的发展历程"></a>百度 LTR 的发展历程</h2><h3 id="第一阶段：线性模型"><a href="#第一阶段：线性模型" class="headerlink" title="第一阶段：线性模型"></a>第一阶段：线性模型</h3><p>特征的线性拟合：$Y &#x3D; \sum_{i}\omega_if_i$。</p><p>效果：和手写规则基本打平。</p><p>好处：基本验证机器学习是可行的，同时，可以得到每个特征有多大作用，即每个特征的 weight，这个 weight 的概念对于理解机器学习有非常大的作用，在后面用非线性模型时，他们依然找到一种计算特征weight的方法，这个方法在debug中也起到很大的作用。</p><h3 id="第二阶段：GBRank"><a href="#第二阶段：GBRank" class="headerlink" title="第二阶段：GBRank"></a>第二阶段：GBRank</h3><p>这个和我们用的lambdaMart基本类似。</p><ol><li>标注量：DX 的 GBRank 当标注 query 上升到 7--8w 量级时，有明显提升，对比目前我们的标注量是不到 4w。</li><li>特征数量：100 左右，比我们少。他们每个特征都做的很细，都有可解释的物理意义，大部分特征会有相应的评测。相反我们有 180 个特征，但是大部分都是围绕点击来做的，同时特征可解释性差，没有单独评测。</li><li>debug 平台：强大的 debug 平台，可以计算每个特征的 weight，在树模型里，对方描述的计算 weight 的方法是在给定的数据集上，固定其他的特征，观察目标特征的变化导致的预测值的变化，用这个变化来计算 weight 的权重。对于具体的 badcase，如果是由于这个 case 在某些特征上不合理，预期 debug 平台是能够发现，所以通过 badcase + debug 平台，能够逐步地改进特征。</li><li>控制diff，当新加特征时，diff率太大的问题。对方的描述中也提到尝试过 continue train。但是他们最后使用的是bagging的方法来提升模型的稳定性，这个思路我们之前没有想到过，可以借鉴。</li></ol><h3 id="第三阶段：深度学习"><a href="#第三阶段：深度学习" class="headerlink" title="第三阶段：深度学习"></a>第三阶段：深度学习</h3><p>基本思路和我们目前做的是一样的，但是各种细节还是不一样</p><ol><li>使用长尾 query 的点击与未点击的数据作为训练数据，他们并没有观察过数据的准确率，但估计还行。相反地，我们用各种方法得到的数据准确率偏低，这个可以在多尝试一些方法。</li><li>大数据量，100 亿规模，与之对比的是我们只有 1 亿的规模。</li><li>模型简单，基本上只有一个隐层。</li><li>多机并行版本，百度 IDL 提供的平台。</li><li>将深度学习得到的语义相似度作为模型加入到 BRank 里。</li></ol><h2 id="问答环节"><a href="#问答环节" class="headerlink" title="问答环节"></a>问答环节</h2><p>Q： 百度如何评测</p><p>A： 测试集 ndcg + 人工 side by side + 线上小流量实验</p><hr><p>Q：DX 的作用</p><p>A：DX 提供的正排对于计算 proximity，term 紧密度非常重要，是必不可少的一个模块，并且为后续的一些质量改进可能也提供了基础，对长尾 query 的提升非常大</p><hr><p>Q：DX 具体存了什么</p><p>A：url 的正排，同时包括 entity&#x2F;anchor 等，提到分域存储（这个回答貌似不是很全面）</p><hr><p>Q：GBRank 如何控制 diff</p><p>A：用 bagging 来提升模型稳定性，可以是几个 bagging 的 GBRank，也可以是 GBRank 里面每棵树用 bagging 的方法来生成多个树。Bagging 的 GBDT 已经有人做过了，但是效果和非 bagging 的差不多，但是之前没有人从模型稳定性来看这个问题，从稳定性的角度来看，bagging 就比较重要了。</p><hr><p>Q：ltr 的标注规模</p><p>A：DX 上升到 7--8w 时效果提升比较大，百度的整体标注规模在几十万 query 级别。每个 query 标注了 20 条。</p><hr><p>Q：ltr 标注 query 是怎么选取的</p><p>A： 随机，偏向长尾，40%是长尾的。还说看长尾是怎样定义，貌似听见一个搜索次数小于 10 次。</p><hr><p>Q：是否采用 active learning 来选取标注集</p><p>A： 没有，但是后来在 spam 的机器学习上有采用，因为 spam 的样本少。</p><hr><p>Q：百度的标注人力是怎样的</p><p>A：全公司的标注是外包的，只需要在平台提交标注任务就可以了</p><hr><p>Q：新特征的开发过程是怎样的，是否需要先经过评测，还是直接放到 GBRank 里，通过 debug 来发现特征是否符合预期</p><p>A： 新特征一般来讲还是要先经过评测，确保和 label 有一定的相关性</p><hr><p>Q：一些需要组合的特征，是否直接加入模型</p><p>A：从理论上来讲，直接加入，期望模型学习出来各种组合是可以的，但百度不是这样干的，如果你觉得一些特征需要组合，最好手动组合，把组合后的特征加入到模型</p><hr><p>Q：特征的 weight 是如何计算的</p><p>A：类似于算导数的方法，上面已经大概说过了。</p><hr><p>Q：LTR 的工作方向，模型为主还是特征为主</p><p>A：经历不同时期，一开始模型为主，后面加入 DNN 后，特征变的很大，很难做，当然这些特征也是 LTR 团队做。LTR 团队一开始 4 个人，后面发展到接近 20 人。</p><hr><p>Q：新特征的上线方式</p><p>A：如果另外一个团队升级了一个特征，一般来讲不重新训练，直接上线。如果是新加了特征，ltr 团队会负责重新训练。如果同时加了多个特征，也是 ltr 团队负责重新训练上线</p><hr><p>Q：GBRank 上面是否还有 ranksvm</p><p>A： 没有</p><hr><p>Q：DNN 的并行化方式</p><p>A：用的 IDL 的平台，100 多台机器？100 亿的数据规模， 一开始模型比较简单，经过 4--5 个月做出来后，效果非常好。后面也逐渐尝试 cnn，rnn 等</p><hr><p>Q：目前我们 1 亿的数据，有啥建议</p><p>A：先把数据加到 10 亿，看看效果。他们在 1 亿的时候效果也不明显。可以把 1kw&#x2F;5kw 数据时的结果拿来观察</p><hr><p>Q：ltr 标注量多少比较合适</p><p>A：DX在标注到 7--8w 时有比较大的突破。 这个数据提到好几次，可能他们的实际情况确实是数据量提升到 7--8w 时产生了一个质变。</p><hr><p>Q：DX 也是 GBRank</p><p>A：是，DX 也是用 GBRank 来排序</p><hr><p>Q：AC 还有多少基于规则的排序</p><p>A：基本没有了，都被替换了，但是 AC 的上游 US 还有一些规则，例如合并 onebox 等</p><hr><p>Q：百度结果里经常靠百度知道顶着，大搜索是否对百度知道有特殊处理，例如单字检索等</p><p>A：没有对百度知道特殊处理。但是百度知道是一个垂搜， US会请求。同时百度知道有很多站内的权重数据，可能做的比较好</p><hr><p>Q：DNN 出来的值是作为特征加入到 GBRank 里的吗？</p><p>A：是的</p><hr><p>Q：LTR 技术的发展过程</p><p>A：先是把 rank 的 LTR 做好，站住脚，然会向外输出技术，例如泛时效性 query 的识别，省略与 termweight、spam 等。</p><hr><p>Q：DNN 的关键</p><p>A：数据量，必须上大数据量。与 msra 的 gaojianhong 交流是，对于 msra 只用了 1 亿的数据量很鄙视</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>LTR 使用的特征非常谨慎：对特征做了很多特征工程，尽量让每个特征有意义。</li><li>DX 起到关键作用，DX 在长尾 query 的基础相关性上起到决定性作用，提供了很多特征。</li><li>GBRank 的 debug 平台非常重要，必不可少。</li><li>DNN 必须上大数据量。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 2016 年 6 月和百度的技术专家交流的一些经验总结。近期翻出来，记录在这里。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm and Computer Science" scheme="https://liam.page/categories/Algorithm-and-Computer-Science/"/>
    
    
      <category term="Search" scheme="https://liam.page/tags/Search/"/>
    
      <category term="Baidu" scheme="https://liam.page/tags/Baidu/"/>
    
  </entry>
  
  <entry>
    <title>教程：如何在越狱设备上映射目录？</title>
    <link href="https://liam.page/2023/04/21/Toturial-how-to-bind-and-mount-folders-on-a-jailbroken-device/"/>
    <id>https://liam.page/2023/04/21/Toturial-how-to-bind-and-mount-folders-on-a-jailbroken-device/</id>
    <published>2023-04-21T06:57:12.000Z</published>
    <updated>2023-05-10T15:04:19.712Z</updated>
    
    <content type="html"><![CDATA[<p>字体替换、生效替换、动画效果资源替换……这些都是越狱圈经久不衰的美化需求。</p><p>在 iOS 15 以前，因为没有 SSV，所以用户可以在越狱后的设备上直接替换系统目录下的文件达成效果。实际上，当年的很多「字体插件」就是干的这么个事情。但从 iOS 15 开始，事情发生了变化。Apple 向 iOS 引入了在 macOS 上已经成熟的技术：SSV。用普通人能理解的话说，SSV 是一个在系统启动阶段的密码学校验机制。它会校验整个系统目录是否完整无修改，而如果校验失败则会拒绝启动（表现为反复白苹果）。因此，我们需要新的方案。</p><span id="more"></span><h2 id="目录映射是什么？"><a href="#目录映射是什么？" class="headerlink" title="目录映射是什么？"></a>目录映射是什么？</h2><p>对于普通用户，目录映射理解为是一种可以达到「指鹿为马」效果的机制。即是说，当系统或者某个软件想要访问某个路径 A 时，通过建立 A 与 B 的映射关系，让系统或者软件实际访问到的是 B 而不自知。</p><p>以字体为例。iOS 系统所用的字体存放于 <code>/System/Library/Fonts</code> 这个目录下。显然，我们无法修改其中的内容，否则 SSV 校验失败，机器就变砖了。但是，我们可以做目录映射，比如将其映射到 <code>/var/jb/System/Library/Fonts</code> 这个目录下。其中 &#x2F;var&#x2F;jb 是越狱后我们有权限修改而无需担心破坏 SSV 的路径。这样一来，我们只需要修改 <code>/var/jb/System/Library/Fonts</code> 下的文件内容，就能让系统和软件读取到替换后的字体了。</p><p>但要注意，<code>/var/jb/System/Library/Fonts</code> 这个路径下原本是没有内容的。因此，建立这种映射关系的前提是要将原始目录（source）当中的内容拷贝一份到目标目录（target）中去，然后再建立这一映射关系。这是有代价的。尽管 iOS 使用的文件系统 APFS 有 Copy-on-Write 的能力，但它对跨 Volumn 的拷贝并不生效（而 <code>/System</code> 和 <code>/var/jb</code> 就是在不同 Volumn 中的）。因此，这种拷贝会占用系统的存储空间，尽管可用，但不是没有代价。</p><h2 id="Fugu15-Max-怎样开启目录映射？"><a href="#Fugu15-Max-怎样开启目录映射？" class="headerlink" title="Fugu15 Max 怎样开启目录映射？"></a>Fugu15 Max 怎样开启目录映射？</h2><p>很遗憾，Fugu15 Max 的官方版本并不支持用户自定义的目录映射，而且大概率在将来也不会添加这一功能。因此，想要自定义目录映射的用户只能选择第三方修改的越狱包。这其中也存着风险——你并不知道第三方有没有往里面「加料」。</p><p>目前，已知支持用户自定义目录映射功能的有</p><ul><li><a href="https://github.com/Liam0205/Dopamine/releases/tag/auto_1681979446">我维护的 Fugu15 Max（可以与官方版本共存）</a>，以及</li><li>真皮维护的 Fugu15 Max。</li></ul><p>普通用户只需安装上述越狱包即可开启自定义的目录映射。默认已开启映射的目录有：</p><ul><li><code>/System/Library/Fonts</code></li><li><code>/System/Library/PrivateFrameworks/CoverSheet.framework/zh_CN.lproj</code></li><li><code>/System/Library/PrivateFrameworks/SpringBoardUIServices.framework/zh_CN.lproj</code></li><li><code>/System/Library/PrivateFrameworks/UserNotificationsUIKit.framework/zh_CN.lproj</code></li></ul><p>这两个版本都已开源。并且，真皮的开源修改版我已完整检查过代码，确认没有加料。我自己的改版当然也是开源不加料的。这里要特别感谢真皮：我维护的版本里目录映射的功能代码最初就是来自真皮的开源改版。（俗称：抄代码）</p><h2 id="怎样进行替换？"><a href="#怎样进行替换？" class="headerlink" title="怎样进行替换？"></a>怎样进行替换？</h2><p>以 <code>AppleSymbols.ttf</code> 这个字体为例。它是 Apple 官方提供的字体，包含了各种特殊符号；其默认路径位于 <code>/System/Library/Fonts/Core/AppleSymbols.ttf</code>。</p><p>假使我们获得了一个改版的 <code>AppleSymbols.ttf</code> 文件（例如，网上广泛流传的所谓盲文修改版），就可以利用 Filza（可通过 TrollStore 安装）将它复制并粘贴到 <code>/var/jb/System/Library/Fonts/Core/AppleSymbols.ttf</code>，然后注销（Restart SpringBoard）即可使其生效。</p><p>有时，你也可能获得一组字体。此时，若你想要替换，则需要逐个目录地对字体文件进行替换（可以多选文件，但是不要替换目录本身）。</p><h2 id="想要映射更多目录怎么办？"><a href="#想要映射更多目录怎么办？" class="headerlink" title="想要映射更多目录怎么办？"></a>想要映射更多目录怎么办？</h2><p>我的修改版和真皮的修改版都支持用户自己添加更多映射目录。但这需要用户通过 Filza 自己修改相应的 plist 配置文件。</p><ul><li>我的版本，配置文件位于 <code>/var/mobile/prefixers.plist</code>，在 <code>Root/source</code> 下添加你想要映射的目录，然后重启再越狱即可。</li><li>真皮的版本，配置文件位于 <code>/var/mobile/newFakePath.plist</code>，在 <code>Root/path</code> 下添加你想要映射的目录，然后重启再越狱即可。</li></ul><p>进阶用户（需要会使用命令行）也可以做到无需重启越狱即可实现新增映射目录。</p><ul><li>我的版本，复制配置文件至 <code>/var/mobile/update.prefixers.plist</code>，在 <code>Root/source</code> 下添加你想要映射的目录，然后在命令行执行 <code>/var/jb/basebin/jbctl update_bindmount</code> 即可。</li><li>我的版本，复制配置文件至 <code>/var/mobile/otaFakePath.plist</code>，删除 <code>Root/pat</code>h 下的已有目录，再添加你想要映射的目录，然后在命令行执行 <code>/var/jb/basebin/jbctl OTAFake</code> 即可。</li></ul><h2 id="迁移到-Dopamine-之后呢？"><a href="#迁移到-Dopamine-之后呢？" class="headerlink" title="迁移到 Dopamine 之后呢？"></a>迁移到 Dopamine 之后呢？</h2><p>我也将修改并维护中文版的 Dopamine（多巴胺）。迁移到多巴胺后，用户需要在设置中打开「启用目录映射」再进行越狱。</p><p>若想要增加自定义的目录映射，则可按照同样的方法修改 <code>/var/mobile/Library/Preferences/page.liam.prefixers.plist</code>（再次越狱生效），或是在越狱状态下修改 <code>/var/mobile/Library/Preferences/update.page.liam.prefixers.plist</code> 后执行命令 <code>/var/jb/basebin/jbctl update_bindmount</code> 以立即生效。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;字体替换、生效替换、动画效果资源替换……这些都是越狱圈经久不衰的美化需求。&lt;/p&gt;
&lt;p&gt;在 iOS 15 以前，因为没有 SSV，所以用户可以在越狱后的设备上直接替换系统目录下的文件达成效果。实际上，当年的很多「字体插件」就是干的这么个事情。但从 iOS 15 开始，事情发生了变化。Apple 向 iOS 引入了在 macOS 上已经成熟的技术：SSV。用普通人能理解的话说，SSV 是一个在系统启动阶段的密码学校验机制。它会校验整个系统目录是否完整无修改，而如果校验失败则会拒绝启动（表现为反复白苹果）。因此，我们需要新的方案。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="iPhone" scheme="https://liam.page/tags/iPhone/"/>
    
      <category term="Jailbreak" scheme="https://liam.page/tags/Jailbreak/"/>
    
      <category term="iOS" scheme="https://liam.page/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>通过 Apple Configurator 安装 TrollStore</title>
    <link href="https://liam.page/2023/04/04/Install-TrollStore-by-Apple-Configurator/"/>
    <id>https://liam.page/2023/04/04/Install-TrollStore-by-Apple-Configurator/</id>
    <published>2023-04-04T03:39:46.000Z</published>
    <updated>2023-04-07T15:03:36.438Z</updated>
    
    <content type="html"><![CDATA[<p>近日有朋友问到，当无法通过<a href="https://github.com/opa334/TrollStore">标准的网页安装</a>的方式安装 TrollStore 时，应当怎么办。</p><p>这里提供一个利用 Apple Configurator 安装的办法。</p><span id="more"></span><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ul><li>一台 Mac（此处测试的是 macOS 12.6.1）</li><li>一台可安装 TrollStore 的 iDevice（此处测试的是 iPhone Xʀ, iOS 15.1）</li><li>一根可以连接 Mac 和 TrollStore 的线缆</li></ul><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><ol><li>打开 Mac，并打开 App Store.app</li><li>搜索并安装：Apple Configurator</li><li>打开 Apple Configurator，将手机和 Mac 连接</li><li>在 Apple Configurator 中，选中你的手机，然后在上方点 + 号，选择 App</li><li>左下角，选择「从我的 Mac 选取」，找到 GTA Car Tracker.ipa，等待安装</li><li>等待手机上安装好 GTA Car Tracker 后，打开它，选择 Install TrollStore</li><li>打开 TrollStore，install ldid</li><li>在 TrollStore 的设置页选择 Install Presistence Helper，选一个你不会用到的系统 App（我选的是 Home&#x2F;家庭）</li><li>如常使用</li></ol><p>这种方法因为 GTA Car Tracker 的权限不够，所以不能被选为 Presistence Helper，只能选择一个平常不用的系统 App。之后，如果 TrollStore 及其安装的 App 闪退&#x2F;无法打开，则可以打开 Home&#x2F;家庭 App，刷新 App。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近日有朋友问到，当无法通过&lt;a href=&quot;https://github.com/opa334/TrollStore&quot;&gt;标准的网页安装&lt;/a&gt;的方式安装 TrollStore 时，应当怎么办。&lt;/p&gt;
&lt;p&gt;这里提供一个利用 Apple Configurator 安装的办法。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Apple" scheme="https://liam.page/tags/Apple/"/>
    
      <category term="TrollStore" scheme="https://liam.page/tags/TrollStore/"/>
    
      <category term="Configurator" scheme="https://liam.page/tags/Configurator/"/>
    
  </entry>
  
  <entry>
    <title>越狱后 iDevice 的重启、重启用户空间、软重启、注销、重建图标之间的关系</title>
    <link href="https://liam.page/2023/03/17/difference-between-reboot-reboot-userspace-ldrestart-respring-and-unicache/"/>
    <id>https://liam.page/2023/03/17/difference-between-reboot-reboot-userspace-ldrestart-respring-and-unicache/</id>
    <published>2023-03-17T03:39:50.000Z</published>
    <updated>2023-04-07T15:03:36.437Z</updated>
    
    <content type="html"><![CDATA[<p>越狱用户在将 iDevice 越狱后往往会接触到重启、重启用户空间、软重启、注销、重建图标这些概念。但中文互联网圈子内似乎还没有对它们做完整解释的帖子，故有此篇。</p><span id="more"></span><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="内核空间与用户空间"><a href="#内核空间与用户空间" class="headerlink" title="内核空间与用户空间"></a>内核空间与用户空间</h3><p>内存对于程序的运行是必不可少的。程序需要将自身的可执行代码以及运行过程中处理的数据结构存放在内存当中。操作系统内核也是一种程序，因此也和普通的用户应用程序一样需要内存。</p><p>为了安全起见，防止普通的用户应用程序不小心地（当然，也防止恶意地）访问并修改内核保存在内存中的内容，现代计算机的操作系统（iDevice 等手持设备也属于广义的计算机）会将整个内存寻址空间（这里的内存指得是虚拟内存）切出一块来单独给内核使用。这块空间就是所谓的内核空间。普通用户程序的权限较低，无权访问内核空间的内容，只能通过系统调用（System Call）来与内核进行交互。</p><p>与此相对应地，内核之外的所有其他用户应用程序都运行在内核空间之外的部分，即用户空间。</p><h3 id="launchd"><a href="#launchd" class="headerlink" title="launchd"></a><code>launchd</code></h3><p>在 macOS 和 iOS (包括衍生的 iPad OS 和 TVOS) 中，进程 ID（PID）为 1 的进程即是 <code>launchd</code>。这是操作系统内核启动后启动的第一个程序。它负责按需启动守护进程（不运行在前台的进程）和应用程序，并负责监控守护进程。操作系统启动后，所有后续启动的进程都是它的子子孙孙（直接或间接 <code>fork</code> 自 <code>launchd</code>）。</p><p><code>launchd</code> 还有一个配套的命令行应用程序 <code>launchctl</code>。它可以与 <code>launchd</code> 通讯，以便管理系统的各个守护进程。</p><h3 id="SpringBoard"><a href="#SpringBoard" class="headerlink" title="SpringBoard"></a>SpringBoard</h3><p>SpringBoard 是 iDevice 上管理主屏幕界面的标准应用程序。它也负责启动 WindowServer、启动 App 等工作。因此它也成为越狱后众多 Tweak 的注入目标。</p><h2 id="辨析"><a href="#辨析" class="headerlink" title="辨析"></a>辨析</h2><p>有了这些前置知识，我们就能对这些概念进行辨析了。</p><ul><li>重启（Reboot）：和普通意义上的「重启计算机」是同样的含义。它几乎相当于给设备断电，然后从零开始启动系统和其他应用程序。因此，如果你的 iDevice 运行的越狱不是完美越狱（Untethered Jailbreak），那么重启后将会丢掉越狱状态。在 iDevice 命令行中运行 <code>reboot</code> 可使设备重启。</li><li>重启用户空间（Reboot Userspace）：保持内核持续运行，但杀死所有运行在用户空间的进程，包括 <code>launchd</code>，然后重启。这种情况下，因为内核未受影响，所以重启用户空间后仍处于越狱状态。在 iDevice 命令行中运行 <code>launchctl reboot userspace</code> 可使设备重启用户空间。</li><li>软重启（<code>ldrestart</code>）：这是 Apple 官方提供的能力。和重启用户空间类似，但 <code>launchd</code> 本身并不会杀死然后重启。同样，为内核未受影响，所以重启用户空间后仍处于越狱状态。在 iDevice 命令行中运行 <code>ldrestart</code> 可使设备软重启。</li><li>注销（Respring）：杀死 SpringBoard，然后重启它。我们通常会在一些影响到 SpringBoard 的设置之后执行注销指令。显然，注销不会掉出越狱状态。在 iDevice 命令行中运行 <code>killall -9 backboardd</code> 可使设备注销。</li><li>重建图标（UICache）：SpringBoard 存有一份 App 图标、状态栏、Dock 等的缓存（UICache）。若你修改了这些内容，那么可能需要重建这一缓存来使你的变更生效。显然，重建图标不会掉出越狱状态。在 iDevice 命令行中运行 <code>uicache</code> 可使设备重建图标。</li></ul><p>注意，在重启用户空间和软重启的过程中，你可能有一定概率遇见内核错误（Kernel Panic），从而导致 iDevice 从重启用户空间&#x2F;软重启 fallback 到直接重启。这种情况，是会丢掉越狱状态的。</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>Netskao 开发的 PowerSelector 插件可在控制中心（Control Center）中添加一个插件。点按该插件的图标后会弹出一个窗口。在窗口中可以按需选择关机、重启、重启用户空间、软重启、注销、重建图标等操作。可谓十分方便，在此推荐。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;越狱用户在将 iDevice 越狱后往往会接触到重启、重启用户空间、软重启、注销、重建图标这些概念。但中文互联网圈子内似乎还没有对它们做完整解释的帖子，故有此篇。&lt;/p&gt;
    
    </summary>
    
      <category term="Jailbreak and Reverse Engineering" scheme="https://liam.page/categories/Jailbreak-and-Reverse-Engineering/"/>
    
    
      <category term="Reboot" scheme="https://liam.page/tags/Reboot/"/>
    
      <category term="Userspace" scheme="https://liam.page/tags/Userspace/"/>
    
      <category term="LDRestart" scheme="https://liam.page/tags/LDRestart/"/>
    
      <category term="Respring" scheme="https://liam.page/tags/Respring/"/>
    
      <category term="UICache" scheme="https://liam.page/tags/UICache/"/>
    
  </entry>
  
  <entry>
    <title>在 iOS 14.5.1/unc0ver 8.0.2 上解决电池用量信息无法载入的问题</title>
    <link href="https://liam.page/2023/02/12/fix-battery-usage-graph-on-iOS-14-5-1-unc0ver-8-0-2/"/>
    <id>https://liam.page/2023/02/12/fix-battery-usage-graph-on-iOS-14-5-1-unc0ver-8-0-2/</id>
    <published>2023-02-12T11:01:30.000Z</published>
    <updated>2023-02-16T15:08:24.106Z</updated>
    
    <content type="html"><![CDATA[<p>手头的 iOS 14.5.1 自使用 unc0ver 8.0.2 越狱起就一直困扰于无法正确载入电池用量信息。今日终于无法忍受这一问题，遂解决它。</p><span id="more"></span><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>经过一番检索，在 <a href="https://github.com/SongXiaoXi">@SongXiaoXi</a> 的<a href="https://github.com/LinusHenze/Fugu14/pull/242#issue-1242075829">这篇帖子</a>中找到了问题的原因。具体来说，Fugu14 在越狱过程中，将用户名 <code>_analyticsd</code> 改为了 <code>_nanalyticsd</code>，但其 ID 和 <code>$HOME</code> 则保持不变。但随后其他的某个守护进程将 <code>/private/var/db/analyticsd</code> 及其子目录的所有者改为了 <code>_analyticsd</code>（ID 变更为 <code>264</code>）。这造成 <code>_analyticsd.back</code> 以 <code>263</code> 启动时无法读取 <code>/private/var/db/analyticsd</code> 下的数据库信息，导致电池用量信息无法渲染。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>解决起来也很简单。我写了一个插件来完成所有需要的工作。你需要添加以下两个源，然后搜索安装 <code>FixBetteryUsageFugu14</code>：</p><ul><li><code>https://liam.page/apt/</code></li><li><code>https://liam.page/apt-beta/</code></li></ul><p>插件会在每次 SpringBoard 启动时执行一些 Shell 命令。</p><blockquote><p>你也可以手工执行这些命令观察其效果。但请确认你知道每一步在做什么之后再操作。</p><p>首先，你需要在 Cydia&#x2F;Zebra 等包管理器中安装 <code>file-cmds</code> 这一软件包。它提供了 <code>chflags</code> 命令。（或者，对于高级用户，也可以考虑安装 <a href="http://newosxbook.com/tools/iOSBinaries.html"><code>binpack64</code></a>）。</p><p>而后，你需要在 iOS 命令行（或者 SSH 过去）中执行下列命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /var/mobile/Containers/Data/Fugu14Untether/Library/Caches/com.apple.dyld/</span><br><span class="line"><span class="built_in">ls</span> -l</span><br><span class="line">sudo chflags -v noschg,nouchg *.closure</span><br><span class="line">sudo <span class="built_in">chown</span> 263:263 *.closure</span><br><span class="line">sudo chflags -v schg,uchg *.closure</span><br><span class="line"><span class="built_in">ls</span> -l</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /var/mobile/Containers/Data/Fugu14Untether</span><br><span class="line"><span class="built_in">ls</span> -l</span><br><span class="line">sudo <span class="built_in">chown</span> -h 263:263 /var/mobile/Containers/Data/Fugu14Untether/Library <span class="comment"># 只修改 Library 这一 symlink 的所有者</span></span><br><span class="line"><span class="built_in">ls</span> -l</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /var/db</span><br><span class="line"><span class="built_in">ls</span> -l</span><br><span class="line">sudo <span class="built_in">chown</span> -R 263:263 /var/db/analyticsd/</span><br><span class="line"><span class="built_in">ls</span> -l</span><br><span class="line"></span><br><span class="line">sudo launchctl stop com.apple.analyticsd</span><br><span class="line"><span class="built_in">sleep</span> 3</span><br><span class="line">sudo launchctl start com.apple.analyticsd</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手头的 iOS 14.5.1 自使用 unc0ver 8.0.2 越狱起就一直困扰于无法正确载入电池用量信息。今日终于无法忍受这一问题，遂解决它。&lt;/p&gt;
    
    </summary>
    
      <category term="Jailbreak and Reverse Engineering" scheme="https://liam.page/categories/Jailbreak-and-Reverse-Engineering/"/>
    
    
      <category term="Fixing" scheme="https://liam.page/tags/Fixing/"/>
    
  </entry>
  
  <entry>
    <title>TrollStore 及常用 IPA 官方下载</title>
    <link href="https://liam.page/2023/02/08/TrollStore-and-useful-IPA-files/"/>
    <id>https://liam.page/2023/02/08/TrollStore-and-useful-IPA-files/</id>
    <published>2023-02-08T09:39:04.000Z</published>
    <updated>2023-04-07T15:03:36.437Z</updated>
    
    <content type="html"><![CDATA[<p>TrollStore 是一个永久签名的非越狱 App。通过它，我们可以安装任意未签名的 IPA 文件。它基于一个存在于 iOS 14.0 -- iOS 15.4.1 当中的 AMFI&#x2F;CoreTrust 漏洞：iOS 不验证用于签署二进制文件的根证书是否合法。因此，如果你的 i-设备的系统版本在这个范围内，则可以安装 TrollStore，而不论是否越狱。</p><span id="more"></span><h2 id="TrollStore"><a href="#TrollStore" class="headerlink" title="TrollStore"></a>TrollStore</h2><p>TrollStore 由社区著名开发者 opa334 开发，安装方法及完整的支持列表可见其<a href="https://github.com/opa334/TrollStore#installation-guides">官方 GitHub 页面</a>。</p><h2 id="常用-IPA-官方下载"><a href="#常用-IPA-官方下载" class="headerlink" title="常用 IPA 官方下载"></a>常用 IPA 官方下载</h2><ul><li><a href="https://github.com/powenn/ModMyIPA/releases/">ModMyIPA</a>：它可以修改 IPA 文件的 Package 名字等信息。于是你可以利用它做 App 多开。</li><li><a href="https://github.com/sourcelocation/DebToIPA">DebToIPA</a>：它可以将 <code>.deb</code> 格式的 App 转成 <code>.ipa</code> 格式。</li><li><a href="https://www.tigisoftware.com/default/?p=439">Filza</a>：iOS 平台上著名的文件管理器。特别地，它可以访问系统根目录下的文件。（当然，最好不要在不熟悉的情况下对其中文件进行修改）</li><li><a href="https://github.com/D0m0/CocoaTop/releases/">CocoaTop</a>：iOS 平台上著名的进程管理器。</li><li><a href="https://github.com/CokePokes/AppStorePlus-TrollStore">AppStore++</a>：允许你自由降级从 AppStore 安装的 App。</li><li><a href="https://github.com/SmileZXLee/IpaDownloadTool">IPA 提取器</a>：允许你捕获网页安装的 IPA。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TrollStore 是一个永久签名的非越狱 App。通过它，我们可以安装任意未签名的 IPA 文件。它基于一个存在于 iOS 14.0 -- iOS 15.4.1 当中的 AMFI&amp;#x2F;CoreTrust 漏洞：iOS 不验证用于签署二进制文件的根证书是否合法。因此，如果你的 i-设备的系统版本在这个范围内，则可以安装 TrollStore，而不论是否越狱。&lt;/p&gt;
    
    </summary>
    
      <category term="Jailbreak and Reverse Engineering" scheme="https://liam.page/categories/Jailbreak-and-Reverse-Engineering/"/>
    
    
      <category term="TrollStore" scheme="https://liam.page/tags/TrollStore/"/>
    
  </entry>
  
  <entry>
    <title>编写 iOS 越狱插件：给 App 砸壳</title>
    <link href="https://liam.page/2023/01/21/Build-an-iOS-Jailbreak-Tweak-dumpdecrypted-IPA/"/>
    <id>https://liam.page/2023/01/21/Build-an-iOS-Jailbreak-Tweak-dumpdecrypted-IPA/</id>
    <published>2023-01-21T14:47:07.000Z</published>
    <updated>2023-02-16T13:55:02.968Z</updated>
    
    <content type="html"><![CDATA[<p>在真正开始编写插件之前，我们还必须要分析我们的目标对象。只有进行了妥善的分析之后，我们才能确定要在何处进行注入、修改。</p><p>现代软件通常会加上一层加密的壳，必须经过脱壳才能分析。脱壳也常被戏称为砸壳。此篇我们介绍可用于 iOS 平台的脱壳工具。</p><span id="more"></span><h2 id="iOS-端：安装-frida-server"><a href="#iOS-端：安装-frida-server" class="headerlink" title="iOS 端：安装 frida-server"></a>iOS 端：安装 frida-server</h2><p>Frida 是跨平台的脱壳工具。首先我们需要在 iOS 上安装其服务端。</p><ul><li>源：<code>https://build.frida.re/</code></li><li>搜索 Frida 安装即可。</li></ul><blockquote><p>目前最新版本的 Frida (16.0.8) 存在 bug 会导致无法安装。蜗牛源（<code>https://repo.snailovet.com/</code>）提供了其早先版本（15.2.2）。经测试可用。</p></blockquote><h2 id="macOS-端：安装-frida-tools"><a href="#macOS-端：安装-frida-tools" class="headerlink" title="macOS 端：安装 frida-tools"></a>macOS 端：安装 frida-tools</h2><p>Terminal 中执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install frida-tools</span><br></pre></td></tr></table></figure><blockquote><p>为与 15.2.2 版本的 frida-server 匹配，你可能需要安装指定版本的 frida-tools。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install frida-tools==11.0.0</span><br></pre></td></tr></table></figure></blockquote><p>而后，我们可以下载 dump 脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/AloneMonkey/frida-ios-dump</span><br></pre></td></tr></table></figure><h2 id="Dumpdecrypting"><a href="#Dumpdecrypting" class="headerlink" title="Dumpdecrypting"></a>Dumpdecrypting</h2><p>使用 USB 线缆，连接手机和电脑。以不加载任何插件的方式启动你要砸壳的 App。（你可能需要 Choicy 这一插件来实现）</p><p>在 macOS 的 Terminal 中执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/frida-ios-dump</span><br><span class="line">python3 dump.py -H 192.168.1.3 -p 22 -u root -P <span class="string">&#x27;alpine&#x27;</span> <span class="string">&quot;健康&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>其中 <code>-H</code> 指定你手机的 IP 地址，<code>-p</code> 指定 ssh 的端口，<code>-P</code> 指定 <code>root</code> 账户的密码（默认是 <code>alpine</code>）。<br>最后的程序名字，可以是显示在你手机上的名字，也可以是它的 Package ID。所有可用的 name&#x2F;ID 可以通过下列命令查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 dump.py -H 192.168.1.3 -p 22 -u root -P <span class="string">&#x27;alpine&#x27;</span> -l</span><br></pre></td></tr></table></figure></blockquote><p>如此，即可在当前目录下生成 <code>健康.ipa</code> 可供后续分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在真正开始编写插件之前，我们还必须要分析我们的目标对象。只有进行了妥善的分析之后，我们才能确定要在何处进行注入、修改。&lt;/p&gt;
&lt;p&gt;现代软件通常会加上一层加密的壳，必须经过脱壳才能分析。脱壳也常被戏称为砸壳。此篇我们介绍可用于 iOS 平台的脱壳工具。&lt;/p&gt;
    
    </summary>
    
      <category term="Jailbreak and Reverse Engineering" scheme="https://liam.page/categories/Jailbreak-and-Reverse-Engineering/"/>
    
    
      <category term="Jailbreak" scheme="https://liam.page/tags/Jailbreak/"/>
    
      <category term="Development" scheme="https://liam.page/tags/Development/"/>
    
      <category term="Dumpdecrypting" scheme="https://liam.page/tags/Dumpdecrypting/"/>
    
  </entry>
  
  <entry>
    <title>解决 cisco.anyconnect.macos.acsockext 大量消耗 CPU 资源的问题</title>
    <link href="https://liam.page/2023/01/21/fix-the-CPU-hogging-of-cisco-anyconnect-macos-acsockext/"/>
    <id>https://liam.page/2023/01/21/fix-the-CPU-hogging-of-cisco-anyconnect-macos-acsockext/</id>
    <published>2023-01-21T09:47:04.000Z</published>
    <updated>2023-02-16T13:55:02.968Z</updated>
    
    <content type="html"><![CDATA[<p>最近将 Cisco AnyConnect 升级到了公司提供的 4.10.00093 版本。接下来就发现 cisco.anyconnect.macos.acsockext 长期大量占用 CPU 资源，以及导致风扇转动不停。这显然是个问题。</p><span id="more"></span><p><img data-src="/uploads/images/computer-skills/acsockext-cpu-usage.jpg"></p><p>检查发现，这是因为在 4.10 版本开始，思科的 VPN 加入了 Socket 过滤功能。从现象来看，它几乎无时无刻不在 buzy loop（哪怕把所有网络连接都断掉），这应当是个 bug。从功能来看，这种全方位的过滤功能，实在令人担忧其安全性。因此决定干掉他。以下是步骤：</p><ul><li>打开系统设置 -&gt; 网络</li><li>应能观察到三个以 <code>Cisco...</code> 开头的网络配置</li><li>选中它们，然后点下方的 <code>-</code>，删除他们</li><li>右下角，应用</li><li>应能观察到 CPU 利用率立刻下降</li><li>删除 <code>/Applications/Cisco/Cisco AnyConnect Socket Filter.app</code> 以免将来之虞</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近将 Cisco AnyConnect 升级到了公司提供的 4.10.00093 版本。接下来就发现 cisco.anyconnect.macos.acsockext 长期大量占用 CPU 资源，以及导致风扇转动不停。这显然是个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="CPU" scheme="https://liam.page/tags/CPU/"/>
    
      <category term="Cisco" scheme="https://liam.page/tags/Cisco/"/>
    
      <category term="VPN" scheme="https://liam.page/tags/VPN/"/>
    
  </entry>
  
  <entry>
    <title>编写 iOS 越狱插件：速览 Objective-C</title>
    <link href="https://liam.page/2023/01/21/Build-an-iOS-Jailbreak-Tweak-Objective-C-the-quick-start/"/>
    <id>https://liam.page/2023/01/21/Build-an-iOS-Jailbreak-Tweak-Objective-C-the-quick-start/</id>
    <published>2023-01-21T01:32:37.000Z</published>
    <updated>2023-02-16T13:55:02.968Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C 在很长时间内都是 iOS 上的主流编程语言。2014 年 Apple 发布 Swift 之后，这一情况才逐渐改变。但是，在开发 Tweak 时，用得更多的依旧是 Objective-C。因此有必要对 Objective-C 有一个快速的了解。</p><p>这里假定你对 C-like 语言有一个较为全面的了解。若你是 C&#x2F;C++ 的熟练使用者则更好。</p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Objective-C 是 C 语言的严格超集。即是说，在 C 编译器下能够编译的代码，应当可以不加修改地使用 Objective-C 的编译器来编译。（尽管可能行为不完全相同）另一方面，在 Objective-C 当中，可以混合使用 C 风格的代码。</p><h2 id="文件扩展名"><a href="#文件扩展名" class="headerlink" title="文件扩展名"></a>文件扩展名</h2><table><thead><tr><th></th><th>头文件</th><th>实现文件</th></tr></thead><tbody><tr><td>C</td><td><code>.h</code></td><td><code>.c</code></td></tr><tr><td>C++</td><td><code>.h</code>&#x2F;<code>.hpp</code></td><td><code>.cc</code>&#x2F;<code>.cpp</code>&#x2F;<code>.cxx</code></td></tr><tr><td>Objective-C</td><td><code>.h</code></td><td><code>.m</code></td></tr><tr><td>Objective-C++</td><td><code>.h</code></td><td><code>.mm</code></td></tr></tbody></table><p>为了兼容 C，我们依然可以使用预处理器指令 <code>#include</code> 来包含头文件。但是 Objective-C 提供了另一选项 <code>#import</code>。它与 <code>#include</code> 的作用几乎完全相同，但可以保证在一个编译单元中每个头文件都只被引入一次。即是说，它起到了传统 C&#x2F;C++ 变成中 <code>#pragma once</code> 或是 Guard Macro 的作用。</p><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>Objective-C&#x2F;C++ 中的基本类型和 C&#x2F;C++ 中的差不多。几种基本类型在 Objective-C&#x2F;C++ 中的长度分别是：</p><ul><li><code>char</code>: 1B</li><li><code>int</code>: 4B</li><li><code>float</code>: 4B</li><li><code>double</code>: 8B</li></ul><p>此外，Objective-C&#x2F;C++ 中也有 <code>short</code>&#x2F;<code>long</code>&#x2F;<code>long long</code>&#x2F;<code>signed</code>&#x2F;<code>unsigned</code> 之类的修饰。含义也和 C&#x2F;C++ 中的相同。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Objective-C 支持 C-style 字符串，并且也遵循 C 语言当中对引号使用的约定。亦即，使用单引号表示字符（例 <code>&#39;c&#39;</code>），使用双引号表示字符串（null termination）。但在 Objective-C 中也有实现 <code>NSString</code> 类（类似 C++ 中的 <code>std::string</code> 但更强大）。它更常用。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;c&#x27;</span>;  <span class="comment">// 字符类型字面量</span></span><br><span class="line"><span class="string">&quot;hello world&quot;</span>;  <span class="comment">// C-style string</span></span><br><span class="line"><span class="string">@&quot;hello world&quot;</span>;  <span class="comment">// Objective-C NSString</span></span><br></pre></td></tr></table></figure><p>此外，<code>NSString</code> 也支持 <code>printf</code> 风格的字符串构造方法，以及支持从 C-style 字符串中构造。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// construct a NSString object from literal</span></span><br><span class="line"><span class="built_in">NSString</span>* myString = <span class="string">@&quot;My String\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// construct a NSString object from printf formatter</span></span><br><span class="line"><span class="built_in">NSString</span>* anotherString = [<span class="built_in">NSString</span> stringWithFormat: <span class="string">@&quot;%d %s&quot;</span>, <span class="number">1</span>, <span class="string">@&quot;String&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// construct a NSString object from C-style string</span></span><br><span class="line"><span class="built_in">NSString</span>*  fromCString = [<span class="built_in">NSString</span> stringWithCString: <span class="string">&quot;A C string&quot;</span> encoding: <span class="built_in">NSASCIIStringEncoding</span>];</span><br></pre></td></tr></table></figure><h2 id="逻辑控制"><a href="#逻辑控制" class="headerlink" title="逻辑控制"></a>逻辑控制</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a><code>if</code></h3><p>Objective-C 中的 <code>if</code> 语句和 C&#x2F;C++ 中的基本一致。唯独，在 Objective-C 中以 <code>0</code> 表示 <code>false</code>，而以其他值表示 <code>true</code>。例如说，其他任何数值，或是任何字符串，在 <code>Objective-C</code> 中都会被认为是 <code>true</code>。</p><h3 id="for-x2F-while"><a href="#for-x2F-while" class="headerlink" title="for&#x2F;while"></a><code>for</code>&#x2F;<code>while</code></h3><p>Objective-C 中的 <code>for</code>&#x2F;<code>while</code> 和 C 中的完全一致。</p><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><table><thead><tr><th></th><th>名称</th><th>代码风格</th></tr></thead><tbody><tr><td>C&#x2F;C++</td><td>对象成员函数调用</td><td><code>obj.method(args)</code></td></tr><tr><td>Objective-C&#x2F;C++</td><td>向对象传递消息</td><td><code>[obj method: args]</code></td></tr></tbody></table><p>在 C++&#x2F;Java 中，类中定义有成员函数&#x2F;成员方法。我们可以通过类似 <code>obj.method(args)</code> 的方式调用 <code>obj</code> 对象的 <code>method</code> 成员函数。如果 <code>method</code> 在 <code>obj</code> 所属的类中没有定义，则在编译期就会报错。</p><p>Objective-C 则继承了 Smalltalk 的消息传递模型。在这一模型中，调用成员函数被视作是向对象发送一个消息。例如，<code>obj.method(args)</code> 式的调用会被写作是 <code>[obj method: args]</code>。这种写法的意思是，向 <code>obj</code> 这个对象发送名为 <code>method</code> 的消息，<code>args</code> 则是消息附带的参数。与 C++&#x2F;Java 风格的调用不同，<code>obj</code> 所属的类即便没有定义名为 <code>method</code> 的成员函数，我们在代码中依旧可以向 <code>obj</code> 发送这一消息。Objective-C 的编译器不会为此报错，但在程序执行时则会抛出一个异常。</p><p>对比下来，消息传递模型中类和成员函数的关系较为松散，这种调用方式总是在运行期动态绑定。于是，它不需要 C++ 当中的 <code>virtual</code>&#x2F;<code>override</code> 关键字。当然，这种做法也存在一定额外开销。（显然）</p><blockquote><p>空对象（<code>nil</code>）接受消息后默认不做任何事情。因此向 <code>nil</code> 传递消息是安全的。</p></blockquote><h2 id="类的声明与数据成员"><a href="#类的声明与数据成员" class="headerlink" title="类的声明与数据成员"></a>类的声明与数据成员</h2><p>在 C++ 中，我们称之为「声明一个类」。在 Objective-C&#x2F;C++ 中，我们说「定义类的接口（interface）」。</p><hr><p>在 C++ 中，定义一个空的类形如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p>注意，它不需要继承自一个作为占位符的父类。在 Objective-C&#x2F;C++ 中，定义一个空类形如</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>注意，和 Python 中所有类都继承自 <code>object</code> 类似，Objective-C 中所有类都继承自 <code>NSObject</code>。</p><hr><p>在 C++ 中，定义一个包含有数据成员的类形如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> : <span class="keyword">public</span> Bar &#123;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> private_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类比在 Objective-C&#x2F;C++ 中则是</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span> : <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> private_data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>Objective-C 的类分为接口（interface）和实现（implementation）。接口部分通常包含了类声明以及其中数据成员的定义，以及相关成员函数的声明。实现部分通常包含了成员函数的实现代码。</p><p>注意，C++ 中，<code>class</code> 中的数据成员默认是 <code>private</code> 的；在 Objective-C&#x2F;C++ 中，<code>@interface</code> 段定义的数据成员默认是 <code>protected</code> 的，<code>@implementation</code> 段定义的数据成员默认是 <code>private</code> 的。为了保持访问控制一致，额外在 C++ 代码中加上了 <code>protected</code> 关键字来指定 <code>data</code> 的访问控制类型。</p><h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><p>在 C++ 中，成员函数的声明形如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> : <span class="keyword">public</span> Bar &#123;</span><br><span class="line"> <span class="keyword">public</span>:  <span class="comment">// 1.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">class_method</span><span class="params">()</span></span>;  <span class="comment">// 2.</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">instance_method1</span><span class="params">()</span></span>;  <span class="comment">// 3.a</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">instance_method2</span><span class="params">(<span class="type">int</span> p1)</span></span>;  <span class="comment">// 3.b</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">instance_method3</span><span class="params">(<span class="type">int</span> p1, <span class="type">int</span> p2)</span></span>;  <span class="comment">// 4.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类比在 Objective-C 中，则是如下形式</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span>: <span class="title">Bar</span></span></span><br><span class="line"><span class="comment">// 1.</span></span><br><span class="line">+(<span class="type">void</span>) class_method;  <span class="comment">// 2.</span></span><br><span class="line"></span><br><span class="line">-(<span class="type">void</span>) instance_method1;  <span class="comment">// 3.a</span></span><br><span class="line">-(<span class="type">void</span>) instance_method2: (<span class="type">int</span>) p1;  <span class="comment">// 3.b</span></span><br><span class="line">-(<span class="type">void</span>) instance_method3: (<span class="type">int</span>) p1 and: (<span class="type">int</span>) p2;  <span class="comment">// 4.</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>首先关注 (1)。在 C++ 中，<code>class</code> 内的访问控制默认是 <code>private</code>。因此，要使声明的成员函数可用，我们需要显式地指明 <code>public</code>。在 Objective-C 中，<code>@interface</code> 段的方法默认是 <code>@public</code> 的。</p><p>接下来关注 (2)。在 C++ 中有所谓的 <code>static</code>-成员函数。此类成员函数是属于整个类的，不能修改类的对象内部的数据成员。Objective-C 中也有类似设定，即所谓的类方法（class method）。具体形式是在方法前加上一个 <code>+</code> 记号。</p><p>现在关注 (3)。这是典型的成员函数的声明方式。这样的成员函数是与具体的类的对象绑定的，必须要有一个构造好的对象才能执行这些成员函数。在 Objective-C 中，这是所谓的对象方法（instance method），也称为一般方法。</p><p>(4) 处也声明了一般意义上的成员函数，但在 Objective-C 这里稍有不同。对 Objective-C 的版本，它的函数全名（签名）是 <code>instance_method3:and:</code>。即是说，在声明时，函数的名称和参数列表交织在一起；每个冒号后面都带有一次参数传递。调用它的时候则类似：<code>[obj instance_method3: 0 and: 1]</code>。这是 Objective-C&#x2F;C++ 特有的。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>尽管我们也可以在 Objective-C 中定义数据成员，但实际上更好的方式是使用属性。例如</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span>: <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>它等价于</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span>: <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="type">int</span> age;  <span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="keyword">@synthesize</span> age = _age;  <span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这里，(1) 声明了类 <code>Foo</code> 的一个属性。它的类型是 <code>int</code>，名字是 <code>age</code>。如果没有显式地如 (2) 这样将属性和变量关联起来，则编译器会自动产生一个变量，并做这样的关联。注意，属性的声明应当位于 <code>@interface</code> 段，属性与变量的关联则应放在 <code>@implementation</code> 段。</p><p>你也可以使用别的变量与属性进行关联。例如 <code>@synthesize age = internal_age;</code>。这样会将 <code>age</code> 这个属性与 <code>internal_age</code> 这个数据成员进行关联。</p><p>声明属性，则编译器会为我们自动生成相应的 setter&#x2F;getter 方法。例如说，上面的代码，大致相当于会生成这样的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Foo</span></span></span><br><span class="line">-(<span class="type">void</span>) setAge: (<span class="type">int</span>) n &#123;</span><br><span class="line">  <span class="keyword">self</span>-&gt;_age = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="type">int</span>) age &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>-&gt;_age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>也就是说，通过属性，我们将类的数据成员封装了起来。外部不能直接操作类的数据成员，而要通过 setter&#x2F;getter 来操作。此外，Objective-C 还为此提供了类似 C++ 中成员访问运算符（<code>.</code>）的语法糖。我们可以写出类似下面的代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.age = <span class="number">10</span>;  <span class="comment">// 1.a</span></span><br><span class="line">[p setAge: <span class="number">10</span>];  <span class="comment">// 1.b</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;age is: %d&quot;</span>, p.age);  <span class="comment">// 2.a</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;age is: %d&quot;</span>, [p age]);  <span class="comment">// 2.b</span></span><br></pre></td></tr></table></figure><p>其中 (1.a) 和 (1.b) 的含义相同，(2.a) 和 (2.b) 的含义也相同。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Objective-C 在很长时间内都是 iOS 上的主流编程语言。2014 年 Apple 发布 Swift 之后，这一情况才逐渐改变。但是，在开发 Tweak 时，用得更多的依旧是 Objective-C。因此有必要对 Objective-C 有一个快速的了解。&lt;/p&gt;
&lt;p&gt;这里假定你对 C-like 语言有一个较为全面的了解。若你是 C&amp;#x2F;C++ 的熟练使用者则更好。&lt;/p&gt;
    
    </summary>
    
      <category term="Jailbreak and Reverse Engineering" scheme="https://liam.page/categories/Jailbreak-and-Reverse-Engineering/"/>
    
    
      <category term="Language" scheme="https://liam.page/tags/Language/"/>
    
      <category term="Objective-C" scheme="https://liam.page/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>解决 macOS 上 VSCode 当中终端环境变量重复问题</title>
    <link href="https://liam.page/2023/01/20/different-PATH-env-in-VSCode-macOS/"/>
    <id>https://liam.page/2023/01/20/different-PATH-env-in-VSCode-macOS/</id>
    <published>2023-01-20T14:02:11.000Z</published>
    <updated>2023-02-16T13:55:02.967Z</updated>
    
    <content type="html"><![CDATA[<p>最近在 VSCode 当中调试代码时，意外发现 VSCode 嵌入的终端内，<code>PATH</code> 变量很长。仔细一看，发现其中有重复部分。但同期在系统 Terminal 当中，<code>PATH</code> 变量则是正常的。</p><span id="more"></span><p>举例来说，VSCode 里的终端有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">/usr/local/opt/node@12/bin:/Users/Liam/local/opt/bin:/Users/Liam/local/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/TeX/texbin:/opt/X11/bin:/Library/Apple/usr/bin:/usr/local/opt/node@12/bin:/Users/Liam/local/opt/bin:/Users/Liam/local/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/TeX/texbin:/opt/X11/bin:/Library/Apple/usr/bin</span><br></pre></td></tr></table></figure><p>同期 Terminal 里的终端有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">/usr/local/opt/node@12/bin:/Users/Liam/local/opt/bin:/Users/Liam/local/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/TeX/texbin:/opt/X11/bin:/Library/Apple/usr/bin</span><br></pre></td></tr></table></figure><p>检查各种 <code>profile</code>&#x2F;<code>bashrc</code> 文件，均未发现异常。后查明是在 VSCode 当中启动嵌入的终端时，默认会继承 VSCode 启动时的环境变量。这导致后续在使用 <code>PATH = &quot;/path/to/foo/bar:$PATH&quot;</code> 这样的语法时，会将 <code>PATH</code> 复制一份。只需将 VSCode 中的下列设置改为 <code>false</code> 即可。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;terminal.integrated.inheritEnv&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在 VSCode 当中调试代码时，意外发现 VSCode 嵌入的终端内，&lt;code&gt;PATH&lt;/code&gt; 变量很长。仔细一看，发现其中有重复部分。但同期在系统 Terminal 当中，&lt;code&gt;PATH&lt;/code&gt; 变量则是正常的。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="Shell" scheme="https://liam.page/tags/Shell/"/>
    
      <category term="VSCode" scheme="https://liam.page/tags/VSCode/"/>
    
      <category term="Terminal" scheme="https://liam.page/tags/Terminal/"/>
    
  </entry>
  
  <entry>
    <title>编写 iOS 越狱插件：从 NIC 中创建项目</title>
    <link href="https://liam.page/2023/01/20/Build-an-iOS-Jailbreak-Tweak-init-project-from-NIC/"/>
    <id>https://liam.page/2023/01/20/Build-an-iOS-Jailbreak-Tweak-init-project-from-NIC/</id>
    <published>2023-01-19T16:21:45.000Z</published>
    <updated>2023-02-16T13:55:02.967Z</updated>
    
    <content type="html"><![CDATA[<p>安装好 Theos 之后，我们便可以开始编写插件了。第一步，我们可以利用 Theos 提供的 New Instance Creator（NIC）来创建一个项目模板。这样一来，很多基本信息的文件，我们就不用手工编辑了。</p><span id="more"></span><h2 id="执行-NIC"><a href="#执行-NIC" class="headerlink" title="执行 NIC"></a>执行 NIC</h2><p>在安装好 Theos 的基础上，可以执行下列命令启动 NIC 程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$THEOS</span>/bin/nic.pl</span><br></pre></td></tr></table></figure><p>之后，NIC 会在终端上打印出一个列表，询问你想要创建何种类型的项目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="variable">$THEOS</span>/bin/nic.pl</span><br><span class="line">NIC 2.0 - New Instance Creator</span><br><span class="line">------------------------------</span><br><span class="line">  [1.] iphone/activator_event</span><br><span class="line">  [2.] iphone/activator_listener</span><br><span class="line">  [3.] iphone/application</span><br><span class="line">  [4.] iphone/application_swift</span><br><span class="line">  [5.] iphone/control_center_module-11up</span><br><span class="line">  [6.] iphone/cydget</span><br><span class="line">  [7.] iphone/flipswitch_switch</span><br><span class="line">  [8.] iphone/framework</span><br><span class="line">  [9.] iphone/library</span><br><span class="line">  [10.] iphone/notification_center_widget</span><br><span class="line">  [11.] iphone/notification_center_widget-7up</span><br><span class="line">  [12.] iphone/preference_bundle</span><br><span class="line">  [13.] iphone/preference_bundle_swift</span><br><span class="line">  [14.] iphone/theme</span><br><span class="line">  [15.] iphone/tool</span><br><span class="line">  [16.] iphone/tool_swift</span><br><span class="line">  [17.] iphone/tweak</span><br><span class="line">  [18.] iphone/tweak_with_simple_preferences</span><br><span class="line">  [19.] iphone/xpc_service</span><br><span class="line">  [20.] iphone/xpc_service_modern</span><br><span class="line">Choose a Template (required):</span><br></pre></td></tr></table></figure><p>我们主要关注的是其中的 <code>iphone/tweak</code> 和 <code>iphone/tweak_with_simple_preferences</code>。后者会构造一个 <code>Preferences.plist</code> 文件，以便我们能在 iOS 的系统设置中配置该插件的行为。</p><p>这里我们选择 18。接下来，NIC 会交互式地要求我们键入一些插件的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Choose a Template (required): 18</span><br><span class="line">Project Name (required): PhantomSteps</span><br><span class="line">Package Name [com.yourcompany.phantomsteps]: page.liam.phantom_steps</span><br><span class="line">Author/Maintainer Name [Liam Huang]:</span><br><span class="line">[iphone/tweak_with_simple_preferences] MobileSubstrate Bundle filter [com.apple.springboard]: com.apple.Health</span><br><span class="line">[iphone/tweak_with_simple_preferences] List of applications to terminate upon installation (space-separated, <span class="string">&#x27;-&#x27;</span> <span class="keyword">for</span> none) [SpringBoard]: com.apple.Health</span><br><span class="line">Instantiating iphone/tweak_with_simple_preferences <span class="keyword">in</span> phantomsteps/...</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure><p>这里，我们给项目起名为 <code>PhantomSteps</code>，其包名称为 <code>page.liam.phantom_steps</code>。你可以按需修改。MobileSubstrate Bundle filter 这一项是说，你可能影响的 App 的名字。List of applications to terminate upon installation 这一项则是说，在安装你的插件时，需要杀死的程序的名字。</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>创建成功后，目录结构应该类似</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ tree .</span><br><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── PhantomSteps.plist</span><br><span class="line">├── Tweak.x</span><br><span class="line">├── control</span><br><span class="line">└── layout</span><br><span class="line">    └── Library</span><br><span class="line">        └── PreferenceLoader</span><br><span class="line">            └── Preferences</span><br><span class="line">                └── PhantomSteps</span><br><span class="line">                    └── Preferences.plist</span><br><span class="line"></span><br><span class="line">5 directories, 5 files</span><br></pre></td></tr></table></figure><p>这里</p><ul><li><code>PhantomSteps.plist</code> 记录了需要杀死的包的名称。</li><li><code>control</code> 包含了先前在 NIC 交互式环境中填写的信息。</li><li><code>Makefile</code> 是对应 GNU make 的文件。</li><li><code>Tweak.x</code> 是插件自身的代码。Theos 会从模板中创建一个带有各种注释的文件供参考。</li></ul><blockquote><p>通过 NIC 模板创建的项目可见：<a href="https://github.com/Liam0205/PhantomSteps/tree/c48a76ae16ea761b24bfa94524331a1b7523d0b0">GitHub</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安装好 Theos 之后，我们便可以开始编写插件了。第一步，我们可以利用 Theos 提供的 New Instance Creator（NIC）来创建一个项目模板。这样一来，很多基本信息的文件，我们就不用手工编辑了。&lt;/p&gt;
    
    </summary>
    
      <category term="Jailbreak and Reverse Engineering" scheme="https://liam.page/categories/Jailbreak-and-Reverse-Engineering/"/>
    
    
      <category term="Jailbreak" scheme="https://liam.page/tags/Jailbreak/"/>
    
      <category term="Development" scheme="https://liam.page/tags/Development/"/>
    
      <category term="Tweak" scheme="https://liam.page/tags/Tweak/"/>
    
      <category term="Theos" scheme="https://liam.page/tags/Theos/"/>
    
  </entry>
  
  <entry>
    <title>编写 iOS 越狱插件：安装 Theos</title>
    <link href="https://liam.page/2023/01/19/Build-an-iOS-Jailbreak-Tweak-Install-Theos/"/>
    <id>https://liam.page/2023/01/19/Build-an-iOS-Jailbreak-Tweak-Install-Theos/</id>
    <published>2023-01-19T15:16:51.000Z</published>
    <updated>2023-02-16T13:55:02.966Z</updated>
    
    <content type="html"><![CDATA[<p>Theos 是一个使用 Perl 开发的跨平台构建系统。由于它最开始就是为了 iOS 越狱插件而开发的，所以非常适合用来做越狱插件的开发。我们也不标新利益，从 Theos 开始。</p><blockquote><p>你也可以直接参考官方英文文档：<a href="https://theos.dev/docs/installation-macos">https://theos.dev/docs/installation-macos</a></p></blockquote><span id="more"></span><h2 id="前置依赖"><a href="#前置依赖" class="headerlink" title="前置依赖"></a>前置依赖</h2><h3 id="安装-XCode"><a href="#安装-XCode" class="headerlink" title="安装 XCode"></a>安装 XCode</h3><p>打开 MAS，搜索 XCode，安装&#x2F;更新到最新。</p><h3 id="安装-Homebrew"><a href="#安装-Homebrew" class="headerlink" title="安装 Homebrew"></a>安装 Homebrew</h3><p>打开 Terminal，执行下列命令（来自<a href="https://brew.sh/">Homebrew 官网</a>）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="通过-brew-安装依赖库"><a href="#通过-brew-安装依赖库" class="headerlink" title="通过 brew 安装依赖库"></a>通过 brew 安装依赖库</h3><p>在 Terminal 中执行下列命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install ldid xz</span><br></pre></td></tr></table></figure><h2 id="下载和安装-Theos"><a href="#下载和安装-Theos" class="headerlink" title="下载和安装 Theos"></a>下载和安装 Theos</h2><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export THEOS=~/theos&quot;</span> &gt;&gt; ~/.zprofile</span><br><span class="line"><span class="comment"># 早期的系统应该加至 ~/.profile</span></span><br></pre></td></tr></table></figure><h3 id="下载-Theos"><a href="#下载-Theos" class="headerlink" title="下载 Theos"></a>下载 Theos</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recursive https://github.com/theos/theos.git <span class="variable">$THEOS</span></span><br></pre></td></tr></table></figure><blockquote><p>当然，你也可以将 <code>$THEOS/bin/</code> 加到环境变量 <code>$PATH</code> 中去。</p></blockquote><h2 id="安装-SDK"><a href="#安装-SDK" class="headerlink" title="安装 SDK"></a>安装 SDK</h2><p>新版的 XCode 不提供插件可能使用到的私有框架，因此我们需要安装 Theos 维护的补丁版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -LO https://github.com/theos/sdks/archive/master.zip</span><br><span class="line">TTT=$(<span class="built_in">mktemp</span> -d)</span><br><span class="line">unzip master.zip -d <span class="variable">$TTT</span></span><br><span class="line"><span class="built_in">mv</span> <span class="variable">$TTT</span>/sdks-master/*.sdk <span class="variable">$THEOS</span>/sdks</span><br><span class="line"><span class="built_in">rm</span> -r master.zip <span class="variable">$TTT</span></span><br><span class="line"><span class="built_in">unset</span> <span class="variable">$TTT</span></span><br></pre></td></tr></table></figure><h2 id="更新-Theos"><a href="#更新-Theos" class="headerlink" title="更新 Theos"></a>更新 Theos</h2><p>将来需要更新 Theos 时，可以这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$THEOS</span>/bin/update-theos</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Theos 是一个使用 Perl 开发的跨平台构建系统。由于它最开始就是为了 iOS 越狱插件而开发的，所以非常适合用来做越狱插件的开发。我们也不标新利益，从 Theos 开始。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你也可以直接参考官方英文文档：&lt;a href=&quot;https://theos.dev/docs/installation-macos&quot;&gt;https://theos.dev/docs/installation-macos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Jailbreak and Reverse Engineering" scheme="https://liam.page/categories/Jailbreak-and-Reverse-Engineering/"/>
    
    
      <category term="Jailbreak" scheme="https://liam.page/tags/Jailbreak/"/>
    
      <category term="Development" scheme="https://liam.page/tags/Development/"/>
    
      <category term="Tweak" scheme="https://liam.page/tags/Tweak/"/>
    
      <category term="Theos" scheme="https://liam.page/tags/Theos/"/>
    
  </entry>
  
  <entry>
    <title>iOS 越狱后插件推荐</title>
    <link href="https://liam.page/2023/01/19/Tweaks-that-I-ve-installed-on-my-iPhone/"/>
    <id>https://liam.page/2023/01/19/Tweaks-that-I-ve-installed-on-my-iPhone/</id>
    <published>2023-01-19T02:53:10.000Z</published>
    <updated>2024-03-17T05:08:22.501Z</updated>
    
    <content type="html"><![CDATA[<p>手头上的 iPhone Xʀ 越狱已经有一年多了。经过一年的不断调整、去芜存菁，是时候整理一下当前安装的插件了。这也可以算作是做一次插件推荐。</p><span id="more"></span><h2 id="设备信息"><a href="#设备信息" class="headerlink" title="设备信息"></a>设备信息</h2><ul><li>iPhone Xʀ</li><li>iOS 14.5.1</li><li>unc0ver 8.0.2</li></ul><h2 id="软件源"><a href="#软件源" class="headerlink" title="软件源"></a>软件源</h2><p>首先是介绍一下我订阅的软件源。</p><ul><li>Zebra：<code>https://getzbra.com/repo/</code></li><li>BigBoss：<code>http://apt.thebigboss.org/repofiles/cydia/</code></li><li>Bingner&#x2F;Elucubratus：<code>https://apt.bingner.com/</code></li><li>Limneos Repo：<code>https://limneos.net/repo/</code></li><li>MERONA Repo：<code>https://repo.co.kr/</code></li><li>Chariz：<code>https://repo.chariz.io/</code></li><li>Havoc：<code>https://havoc.app/</code></li><li>jjolano：<code>https://ios.jjolano.me/</code></li><li>opa334&#39;s Repo：<code>https://opa334.github.io/</code></li><li>ichitaso repository：<code>http://cydia.ichitaso.com/</code></li><li>蜗牛源：<code>https://repo.snailovet.com/</code></li><li>AutoTouch：<code>https://repo.autotouch.net/</code></li><li>Packix：<code>https://repo.packix.com/</code></li><li>Ginsu Tweaks：<code>https://repo.ginsu.dev/</code></li><li>Liam-apt：<code>https://liam.page/apt/</code>&#x2F;<code>https://liam.page/apt-beta/</code></li><li>Liam - oldabi：<code>https://liam.page/oldabi</code></li><li>Ivano Bilenchi：<code>https://ib-soft.net/repo/</code></li><li>subdiox&#39;s Repo：<code>https://subdiox.com/cydia/</code></li><li>Cydiakk：<code>https://apt.cydiakk.com/</code></li><li>CokePokes：<code>https://www.ios-repo-updates.com/repository/cokepokes/</code></li><li>Fouadraheb：<code>https://apt.fouadraheb.com/</code></li><li>电话助手作者源：<code>https://apt.htv123.com/</code></li><li>老牌猫源：<code>https://apt.25mao.com/</code></li><li>Netskao：<code>https://repo.initnil.com/</code></li><li>Procursus：<code>https://apt.procursus.us/</code></li><li>Acreson：<code>https://repo.acreson.cn/</code></li><li>Lenglengyu：<code>https://lenglengyu.com/</code></li><li>SOPPPra：<code>https://sopppra.mooo.com/</code></li><li>PoomSmart：<code>https://poomsmart.github.io/repo/</code></li><li>alias20：<code>https://alias20.gitlab.io/apt/</code></li><li>c1d3r：<code>https://c1d3r.com/repo/</code></li></ul><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>这里按照大致的安装时间顺序介绍我目前还在使用的插件。其中，插件名字后面带有星号标记的表示已适配 Fugu15 Rootless 越狱。</p><ul><li>CCPower⭐️（Netskao）：控制中心插件。点按后会弹出菜单。菜单上部显示电池状况、运行时间、闪存、运存等情况。下部允许进行重启、重新载入 SpringBoard 等动作。来源：BigBoss。</li><li>CCBadgeClear⭐️（Netskao）：控制中心插件。点按后可以清除 App 图标右上角的角标数字。来源：BigBoss。</li><li>CCVPN⭐️（Acreson）：控制中心插件。点按后可以切换 VPN 的状态。来源：BigBoss。</li><li>CCSwitchData⭐️（Netskao）：控制中心插件，可以切换用来访问移动网络的 Sim 卡。来源：BigBoss。</li><li>CCCellularRate⭐️（Netskao）：控制中心插件，可以用来控制蜂窝网络的速率。来源：Netskao。</li><li>CCNC⭐️（Liam - oldabi）：控制中心插件，点按后可以切换 AirPods Pro 的降噪状态。来源：BigBoss。</li><li>iPonCC⭐️：控制中心插件。在控制中心显示 IP 地址。来源：BigBoss。</li><li>Filza File Manager⭐️（TrollStore）：著名的文件管理器。来源：BigBoss。</li><li>FLEXList⭐️（Netskao）：开发者工具。著名的开发者动态调试工具 FLEX 的包装。它允许你在任意 App 运行时动态加载 FLEX 库以调试其界面元素。来源：BigBoss。</li><li>Vi Improved⭐️（Procursus）：著名的命令行编辑器。来源：Bingner&#x2F;Elucubratus。</li><li>AppStore++⭐️（TrollStore）：允许你对来自 AppStore 的 App 进行指定版本的升降级操作，还能设置屏蔽某些 App 的升级。来源：CokePokes。</li><li>zfbbs⭐️（Liam-apt，改名 zfbstep）：随机生成支付宝步数，蚂蚁森林好帮手。来源：Cydiakk。</li><li>ShowTouch⭐️（Acreson）：显示触碰手势，在录屏时很有用。来源：Cydiakk。</li><li>SettingsRevamp⭐️：重新组织设置 App 中的项目，将系统 App、Tweak、用户 App 分别收至单独的二级目录中。来源：SOPPPra。</li><li>NFCWriter XS⭐️：著名的 NFC 模拟&#x2F;写入 App。它可以读取外部的 NFC tag，然后模拟出来。例如，可以用来模拟小区门禁卡。来源：Limneos Repo。</li><li>BioProtect XS⭐️：著名的生物信安保护插件。它可以按照 App、Folder 等维度，设置是否需要验证生物信安（Face ID&#x2F;Touch ID）。来源：Limneos Repo。</li><li>AudioRecoder XS⭐️：著名的通话录音插件。它能自动录制呼入呼出的电话并保存在手机本地，还支持自动上传到云（Google Drive&#x2F;Dropbox）。来源：Limneos Repo。</li><li>VoiceChanger XS⭐️：著名的变声器插件。来源：Limneos Repo。</li><li>PhantomSteps⭐️（Liam-apt）：自研的生成虚拟步数的插件。来源：Liam-apt。</li><li>Choicy⭐️（opa334）：注入管理插件。它可以按照 App 维度，以白名单&#x2F;黑名单的方式禁用插件。来源：opa334&#39;s Repo。</li><li>Zebra⭐️：替代 Cydia 的包管理器。其运行效率和操作流畅度远胜 Cydia。来源：Zebra。</li><li>Shadow⭐️：越狱检测屏蔽插件。是已安装四个同类插件中整体效果最好者。来源：jjolano。</li><li>位置自动允许一次 &#x2F;&#x2F; AllowLocationOnce⭐️：在 App 请求系统位置服务时，自动点选「允许一次」。来源：蜗牛源。</li><li>AppData⭐️（Netskao）：允许你在主屏幕状态下，通过单指向上扫 App icon 来打开菜单。允许你修改 App 在主屏幕上展示的名字，也允许你做一些清理工作。来源：Fouadraheb。</li><li>StoreSwitcher 2⭐️（Lenglengyu）：允许在 AppStore 中快速切换账号。在需要跨区下载 App 时非常实用。来源：subdiox&#39;s Repo。</li><li>电话助手⭐️：一个集成式的强大插件。它的功能涵盖系统电话增强、系统短信增强、通话录音、状态栏美化等等，是优秀的国产插件。来源：电话助手作者源。</li><li>魔术师⭐️：电话助手作者退出的越狱屏蔽插件。来源：电话助手作者源。</li><li>微信净化⭐️：还原微信聊天本质。来源：Netskao。</li><li>微信助手⭐️：给微信添加强大的功能。来源：老牌猫源。</li><li>斗图助手⭐️：给微信添加斗图功能。来源：老牌猫源。</li><li>左滑返回⭐️：允许从屏幕右侧向中间单指滑动执行返回操作（类似于系统默认提供的从屏幕左侧向中间单指滑动的操作）。对于大屏幕的机器，单手操作十分友好。来源：老牌猫源。</li><li>SmallBanners⭐️：将系统通知横幅改为只能容纳一行文字的横向滚动消息。来源：Netskao。</li><li>New Term 3 Beta⭐️：基于 zsh 的终端模拟器。来源：Chariz。</li><li>Ersatz⭐️：全局替换字符串的插件。比如将「向上滑动解锁」替换成任意你想要的字符串。来源：lenglengyu</li><li>iCleaner Pro⭐️：可以清理 iPhone 上的闪存空间的插件。它还可以对启动项进行调整。来源：Ivano Bilenchi。</li><li>Crane⭐️：允许你创建 App 的分身，且每次运行前可以选择运行哪个分身。来源：Havoc。</li><li>Aemulo⭐️：可能是最好的 NFC 模拟&#x2F;写入 App。它的功能和 NFCWriter XS 类似，但还额外提供了将 NFC tag 保存入 Apple Wallet 的功能。这使得我们可以在锁屏界面调出 NFC tag，解开小区门禁。来源：Chariz。</li><li>Snapper 3⭐️：允许在 iOS 设备上自由截图。来源：Havoc</li><li>ColorBadge⭐️（Liam - oldabi）：让右上角的数字角标染上颜色。来源：BigBoss。</li><li>DumpDecrypter⭐️（替代品：DumpApps）：砸壳工具。来源：Cydiakk。</li><li>Pullover Pro⭐️（Netskao）：侧边分屏，超好用，比 o2 Pro 好用。来源：c1d3r。</li><li>OneHandWizard 2⭐️（Liam - oldabi）：通过自上向下扫过 iPhone 全面屏底部的 Gesture Bar 触发真·单手操作模式。来源：Havoc。</li><li>Hammer It⭐️：文字大爆炸插件。与 Snapper 3 继承良好，可以轻松地控制你选定的文字&#x2F;OCR 从图片中提取的文字，然后进行分词，在自由组合、操控他们。来源：Havoc。</li><li>CopyLog⭐️：设计良好的剪贴板插件。可以管理剪贴历史，并带有收藏功能。来源：Havoc。</li><li>Tanslomatic⭐️：著名的翻译类插件。来源：Havoc。</li><li>ShutupShortcuts⭐️：禁用 Apple 自带的捷径的恼人的提示消息。来源：Liam - rehosts。</li><li>LastLook⭐️：熄屏显示插件。来源：Chariz。<!-- * InApp Purchase 内购破解：可以破解大部分软件的内购，从而可以获得免费试用的机会。来源：Cydiakk。 --></li><li>kai：可以在锁屏界面和通知中心界面显示各个关联设备（耳机、Apple Watch 等）的电量状态。来源：Chariz。<!-- 依赖 Cephei, 破解 --></li><li>Appaze 2：在 Haptic Touch 菜单中添加 Appaze 选项，支持对 App 做个性化的设置。来源：Chariz。<!-- 依赖 Cephei, flipswitch, rocketbootstrap --></li><li>SmartVPN：它可以按照 App 维度进行设置，在 App 运行时自动启动 VPN，在所有白名单 App 关闭时自动关闭 VPN。来源：BigBoss。<!-- 依赖 Cephei, applist, rocketbootstrap --></li><li>IAmLazy：备份和恢复插件的插件。来源：Chariz。</li><li>AltDeamon：一个 AltServer 的守护进程。安装后可以不借助电脑实用 AltStore 对应用进行自签 Side load。来源：Chariz。</li><li>Frida：开发者工具。著名的 Frida 的服务端。来源：蜗牛源。</li><li>Activator：著名的手势操作插件。来源：BigBoss。</li><li>FixBatteryUsageFugu14：解决 Fugu14 越狱导致无法查看电池用量信息的问题。来源：Liam-apt。</li><li>LocationService (CCSupport)：控制中心插件。点按后可以切换系统定位服务的状态。来源：ichitaso repository。</li><li>OpenSSH CC Toggle：控制中心插件，点按后可以切换手机中 sshd 的运行状态。来源：BigBoss。</li><li>EnableBatteryPercent：在屏幕顶栏电量标志中显示具体的电量剩余百分比。来源：Ginsu Tweaks。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手头上的 iPhone Xʀ 越狱已经有一年多了。经过一年的不断调整、去芜存菁，是时候整理一下当前安装的插件了。这也可以算作是做一次插件推荐。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer Skills" scheme="https://liam.page/categories/Computer-Skills/"/>
    
    
      <category term="iPhone" scheme="https://liam.page/tags/iPhone/"/>
    
      <category term="Jailbreak" scheme="https://liam.page/tags/Jailbreak/"/>
    
      <category term="iOS" scheme="https://liam.page/tags/iOS/"/>
    
      <category term="Tweaks" scheme="https://liam.page/tags/Tweaks/"/>
    
  </entry>
  
</feed>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png">
  <link rel="mask-icon" href="/images/favicon/safari-pinned-tab.svg" color="#222">
  <link rel="manifest" href="/images/favicon/site.webmanifest">
  <meta name="msapplication-config" content="/images/favicon/browserconfig.xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="google-site-verification" content="TYuJQFuiVqfbFfJAkHfXigSDRIMibztxXxgl_iAaQhA">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liam.page","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="在前三篇文章中，我们捡着重要的部分翻译和扩展了 cppreference 网站上关于内存模型和内存顺序（上、中）的文章。坦率地说，因为涉及内容相对底层，所以通篇相对晦涩。所以它们虽然阐述了相关内容，但不易读。 此篇讨论的内容在前三篇文章中都有讨论，但将从一系列例子出发，从实践的角度去讨论内存模型和内存顺序。">
<meta property="og:type" content="article">
<meta property="og:title" content="程序员的自我修养（⑬）：C++ 的内存顺序·下">
<meta property="og:url" content="https://liam.page/2021/12/14/memory-order-cpp-03/index.html">
<meta property="og:site_name" content="始终">
<meta property="og:description" content="在前三篇文章中，我们捡着重要的部分翻译和扩展了 cppreference 网站上关于内存模型和内存顺序（上、中）的文章。坦率地说，因为涉及内容相对底层，所以通篇相对晦涩。所以它们虽然阐述了相关内容，但不易读。 此篇讨论的内容在前三篇文章中都有讨论，但将从一系列例子出发，从实践的角度去讨论内存模型和内存顺序。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-12-13T16:14:42.000Z">
<meta property="article:modified_time" content="2021-12-18T11:52:24.022Z">
<meta property="article:author" content="Liam Huang">
<meta property="article:tag" content="Atomics">
<meta property="article:tag" content="Memory Model">
<meta property="article:tag" content="Memory Order">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://liam.page/2021/12/14/memory-order-cpp-03/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><style>
#needsharebutton-postbottom {
  cursor: pointer;
  height: 26px;
  margin-top: 10px;
  position: relative;
}
#needsharebutton-postbottom .btn {
  border: 1px solid $btn-default-border-color;
  border-radius: 3px;
  display: initial;
  padding: 1px 4px;
}
</style>
  <title>程序员的自我修养（⑬）：C++ 的内存顺序·下 | 始终</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-44836433-1"></script>
    <script data-pjax>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-44836433-1');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">始终</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">不忘初心</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">404</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">15</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">773</span></a>

  </li>
        <li class="menu-item menu-item-系列">

    <a href="/series/" rel="section"><i class="fa fa-fw fa-book"></i>系列</a>

  </li>
        <li class="menu-item menu-item-札记-&-留言板">

    <a href="/notes/" rel="section"><i class="fa fa-fw fa-sticky-note"></i>札记 & 留言板</a>

  </li>
        <li class="menu-item menu-item-英文">

    <a href="/en/" rel="section"><i class="fa fa-fw fa-link"></i>英文</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liam.page/2021/12/14/memory-order-cpp-03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar/avatar-3.jpg">
      <meta itemprop="name" content="Liam Huang">
      <meta itemprop="description" content="虚室生白，吉祥止止">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="始终">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          程序员的自我修养（⑬）：C++ 的内存顺序·下
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021 年 12 月 14 日 00:14:42" itemprop="dateCreated datePublished" datetime="2021-12-14T00:14:42+08:00">2021 年 12 月 14 日</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021 年 12 月 18 日 19:52:24" itemprop="dateModified" datetime="2021-12-18T19:52:24+08:00">2021 年 12 月 18 日</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm-and-Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Algorithm and Computer Science</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>23 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>在前三篇文章中，我们捡着重要的部分翻译和扩展了 cppreference 网站上关于<a href="/2021/06/05/memory-model-cpp/">内存模型</a>和内存顺序（<a href="/2021/06/06/memory-order-cpp-01/">上</a>、<a href="/2021/12/11/memory-order-cpp-02/">中</a>）的文章。坦率地说，因为涉及内容相对底层，所以通篇相对晦涩。所以它们虽然阐述了相关内容，但不易读。</p>
<p>此篇讨论的内容在前三篇文章中都有讨论，但将从一系列例子出发，从实践的角度去讨论内存模型和内存顺序。</p>
<span id="more"></span>

<h2 id="最简单的例子"><a href="#最简单的例子" class="headerlink" title="最简单的例子"></a>最简单的例子</h2><p>让我们从一个最简单的生产者&#x2F;消费者的例子出发。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iosteram&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; data;  <span class="comment">// 1.a.</span></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; ready&#123;<span class="literal">false</span>&#125;;  <span class="comment">// 1.b.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  data.<span class="built_in">push_back</span>(<span class="number">1024</span>);  <span class="comment">// 2.</span></span><br><span class="line">  ready.<span class="built_in">store</span>(<span class="literal">true</span>);  <span class="comment">// 3.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!ready.<span class="built_in">load</span>()) &#123;  <span class="comment">// 4.</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep</span>(std::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; data[<span class="number">0</span>] &lt;&lt; std::endl;  <span class="comment">// 5.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::thread a&#123;producer&#125;, b&#123;consumer&#125;;</span><br><span class="line">  a.<span class="built_in">join</span>(); b.<span class="built_in">join</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处，(1) 初始化了全局共享的数据 <code>data</code> 和原子标记 <code>ready</code>。生产者线程中，(2) 对全局共享的数据进行修改，并在 (3) 处将标记设置为 <code>true</code>。消费者线程中，(4) 循环等待原子标记（当然，它效率极低；作为示例我们暂时忽略这个问题），而后在 (5) 处读取共享数据。</p>
<p>我们知道，在多个线程中，并发读写同一个内存位置（此处的 <code>&amp;data[0]</code>）可能造成数据竞争，必须有相应的同步机制。此处同步机制由原子标记 <code>ready</code> 协助建立。</p>
<ul>
<li>(2) <ins>先于（happens-before）</ins> (3)；</li>
<li><strong>当 (4) 读到 <code>ready.load()</code> 为真</strong>，则 (3) 与 (4) 建立<ins>同步（synchronizes-with）</ins>关系，因而有 (3) <ins>先于（happens-before）</ins> (4)；</li>
<li>(4) <ins>先于（happens-before）</ins> (5)。</li>
</ul>
<p>在原子标记 <code>ready</code> 的协助下，我们建立了对 <code>data</code> 的写<ins>先于（happens-before）</ins>读的顺序关系，数据竞争的风险就此解除。</p>
<p>整体看下来，这一过程非常符合直觉。而我们知道，原子变量除了保证其上原子操作的原子性之外，各个操作还有内存顺序标记。不同的顺序标记会影响编译器优化和 CPU 执行时的行为；更准确地，影响原子操作附近访问内存的顺序。默认的顺序标记是 <code>std::memory_order_seq_cst</code>。之所以将它作为默认标记，是因为它能带来这一符合直觉的结果。</p>
<p>接下来，我们顺势讨论<ins>先于（happens-before）</ins>关系和<ins>同步（synchronizes-with）</ins>关系。</p>
<h2 id="两种关系"><a href="#两种关系" class="headerlink" title="两种关系"></a>两种关系</h2><h3 id="同步（synchronizes-with）关系"><a href="#同步（synchronizes-with）关系" class="headerlink" title="同步（synchronizes-with）关系"></a><ins>同步（synchronizes-with）</ins>关系</h3><p><ins>同步（synchronizes-with）</ins>关系，追根究底只能由原子操作提供。我们能见到的所有产生同步关系的办法，其底层都包含了某些原子操作。同步关系是这样建立的，</p>
<ul>
<li>首先有在线程 A 中对原子变量 <code>x</code> 打上恰当标记的写入操作 <code>W</code>；</li>
<li>而后有在线程 B 中对原子变量 <code>x</code> 打上恰当标记的读取操作 <code>R</code>。</li>
</ul>
<p>若 <code>R</code> 读到的值，来自以下任意一种情况，则说 <code>W</code> 与 <code>R</code> <ins>同步（synchronizes-with）</ins>。</p>
<ul>
<li><code>W</code> 的写入；或者</li>
<li>线程 A（<code>W</code> 所在线程）中，<code>W</code> 之后的某次写入；或者</li>
<li>任意线程中的一系列 read-modify-write 操作中的写入值，其中第一次 read-modify-write 操作读到的值来自 <code>W</code> 的写入。</li>
</ul>
<p>这得到一个最基本的认知：（在顺序标记恰当的情况下，）如果线程 B 的读取操作读到的是线程 A 的写入操作的写入值，则写入操作与读取操作同步。</p>
<p>如此一来，所有的细节就在「恰当」二字之上了。不过，我们先来讨论<ins>先于（happens-before）</ins>关系。</p>
<h2 id="先于（happens-before）关系"><a href="#先于（happens-before）关系" class="headerlink" title="先于（happens-before）关系"></a><ins>先于（happens-before）</ins>关系</h2><p><ins>先于（happens-before）</ins>关系是讨论内存顺序中最重要的基石。若 A <ins>先于（happens-before）</ins> B，则 B 能看到 A 带来的副作用。</p>
<p>在单线程里面，<ins>先于（happens-before）</ins>关系很简单。单线程当中的<ins>先于（happens-before）</ins>关系即是<ins>先序（sequenced-before）</ins>关系。一般来说，不考虑编译器优化重排和 CPU 乱序执行重排时，在代码当中，靠前的语句当中的操作<ins>先于（happens-before）</ins>靠后的语句当中的操作。但实际上，我们需要考虑编译器优化和 CPU 乱序执行对先序关系带来的影响。</p>
<p>在线程之间，若线程 A 的写入操作与线程 B 的读取操作<ins>同步（synchronizes-with）</ins>，则该写入操作<ins>线程间先于（inter-thread happens-before）</ins>该读取操作，也因此该写入操作<ins>先于（happens-before）</ins>该读取操作。</p>
<h2 id="三种顺序模型"><a href="#三种顺序模型" class="headerlink" title="三种顺序模型"></a>三种顺序模型</h2><p>按前文，顺序标记共有六种：</p>
<ul>
<li><code>std::memory_order_relaxed</code></li>
<li><code>std::memory_order_consume</code></li>
<li><code>std::memory_order_acquire</code></li>
<li><code>std::memory_order_release</code></li>
<li><code>std::memory_order_acq_rel</code></li>
<li><code>std::memory_order_seq_cst</code></li>
</ul>
<p>六种标记又能组成三种顺序模型：</p>
<ul>
<li>顺序一致模型（sequentially consistent ordering）：最强的顺序模型。对编译器优化限制最多，所需额外 CPU 同步指令最多，性能也最差；但最符合直觉。涉及到的顺序标记是 <code>std::memory_order_seq_cst</code>。</li>
<li>宽松模型（relaxed ordering）：最弱的顺序模型。对编译器优化限制最少（几乎没有），所需额外 CPU 同步指令最少（几乎没有），性能也最好；但无法建立线程间的同步关系。涉及到的顺序标记是 <code>std::memory_order_relaxed</code>。</li>
<li>获取-释放模型（acquire-release ordering）：介于二者之间。对编译器优化限制适中，所需额外的 CPU 同步指令也适中（在部分平台上，不许额外同步指令），性能也适中；可以建立线程间的同步关系。涉及到的顺序标记是 <code>std::memory_order_acq_rel</code>, <code>std::memory_order_acquire</code>, <code>std::memory_order_release</code> 和 <code>std::memory_order_consume</code>。</li>
</ul>
<blockquote>
<p>注意，<code>std::memory_order_consume</code> 与 <code>std::memory_order_acquire</code> 相似，但比后者更弱。但完整地实现 <code>std::memory_order_consume</code> 的语义，需要追踪变量之间的依赖链。目前，还没有已知的编译器实现了它。现有的编译器，都将 <code>std::memory_order_consume</code> 提升为 <code>std::memory_order_acquire</code>。故而此处也将 <code>std::memory_order_consume</code> 归在获取-释放模型当中。此外，考虑 <code>std::memory_order_consume</code> 的语义可能发生变化，目前标准也不建议使用 <code>std::memory_order_consume</code>。</p>
</blockquote>
<h3 id="顺序一致模型（sequentially-consistent-ordering）"><a href="#顺序一致模型（sequentially-consistent-ordering）" class="headerlink" title="顺序一致模型（sequentially consistent ordering）"></a>顺序一致模型（sequentially consistent ordering）</h3><p>默认的顺序模型是「顺序一致模型」。如果所有原子操作的顺序标记都是 <code>std::memory_order_seq_cst</code>，那么多线程程序的行为就好像这些操作以某一特定的顺序在单一的线程中执行一样。特别地，站在所有被打上 <code>std::memory_order_seq_cst</code> 标记的操作上来看，所有先于该操作发生的原子操作（<code>std::memory_order_seq_cst</code>），都具有同样的顺序。</p>
<p>这是最符合直觉的模型。多数人第一次接触到多线程，会假定多线程中的各个操作是可能并发执行的，因此将他们理解为按照某个不确定的顺序穿插执行。然后在脑海中想象并构建这一固定的顺序，并按照这一顺序假定各个线程会如何工作。但这种符合直觉的模型并不总是成立。这种多线程之间全局统一的顺序，即是顺序一致性带来的保证。一旦保证不了顺序一致性，则这种基于「穿插执行」假定出来的全局统一顺序也就不成立了。</p>
<!-- From the point of view of synchronization, a sequentially consistent store synchronizes-with a sequentially consistent load of the same variable that reads the value stored. This provides one ordering constraint on the operation of two (or more) threads, but sequential consistency is more powerful than that. Any sequentially con- sistent atomic operations done after that load must also appear after the store to other threads in the system using sequentially consistent atomic operations. The example in listing 5.4 demonstrates this ordering constraint in action. This constraint doesn’t carry forward to threads that use atomic operations with relaxed memory orderings; they can still see the operations in a different order, so you must use sequentially con- sistent operations on all your threads in order to get the benefit. -->

<p>站在同步的角度来看，顺序一致 store 操作与读到本次写入值的顺序一致的 load 操作<ins>同步（synchronizes-with）</ins>。如前所述，这种同步关系在线程之间提供了一定的顺序限制。但顺序一致模型还保证，在这一顺序一致的 load 操作之后的顺序一致操作，在其他所有使用顺序一致原子操作的线程看来，也是发生在此次顺序一致 store 之后的。注意，如若某一线程中的某个原子操作没有使用 <code>std::memory_order_seq_cst</code> 标记，则在该操作看来，顺序一致的诸多操作的顺序可能与其他线程看到的不同。</p>
<p>前作当中的<a href="/2021/12/11/memory-order-cpp-02/#%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E9%A1%BA%E5%BA%8F%EF%BC%88Sequentially-consistent-ordering%EF%BC%89">例子</a>很好地说明了顺序一致性的效果。</p>
<!-- This ease of understanding can come at a price, though. On a weakly ordered machine with many processors, it can impose a noticeable performance penalty, because the overall sequence of operations must be kept consistent between the pro- cessors, possibly requiring extensive (and expensive!) synchronization operations between the processors. That said, some processor architectures (such as the common x86 and x86-64 architectures) offer sequential consistency relatively cheaply, so if you’re concerned about the performance implications of using sequentially consis- tent ordering, check the documentation for your target processor architectures. -->

<p>这种便利是有代价的。在默认的顺序保证相对较弱的平台上（如 ARM），顺序一致模型会引入可观的性能代价。这是因为，全局顺序一致需要在 CPU 逻辑核心之间保持一致性，这使得 CPU 逻辑核心之间需要使用代价高昂的同步操作。相较而言，部分处理器架构（例如 x86 和 x86-64）保证顺序一致性的代价较低。为避免这种同步代价，我们需要拥抱非顺序一致性模型。</p>
<hr>
<p>在处理非顺序一致性模型时，我们就要丢弃脑海中那种简洁漂亮的交替执行的思维模型。<strong>它不存在了</strong>。在没有顺序一致性保障的情况下，各个线程看到的原子操作的顺序并不保证统一。也就是说，虽然依旧是并发（所以穿插执行），但是每个线程看到的穿插的顺序可能是不一样的。在非顺序一致模型下写代码时，要时刻关注这一点。</p>
<p>不过，也有一致的地方。虽说各个线程观察到的原子操作发生的顺序可能不一致，但是，对于<strong>每一个特定的原子变量</strong>，作用在其上的原子操作的修改顺序（modification-order），在各个线程看来是统一的。</p>
<p>为了充分理解非顺序一致性模型，我们可以先考虑宽松模型。待对非顺序一致性有足够了解之后，再回到获取-释放模型。</p>
<h3 id="宽松模型（relaxed-ordering）"><a href="#宽松模型（relaxed-ordering）" class="headerlink" title="宽松模型（relaxed ordering）"></a>宽松模型（relaxed ordering）</h3><p>顺序标记为 <code>std::memory_order_relaxed</code> 的原子操作不参与构建<ins>同步（synchronizes-with）</ins>关系。在同一线程中，对<strong>同一</strong>原子变量的原子操作的顺序遵循源代码中的<ins>先序（sequenced-before）</ins>关系（从而有<ins>先于（happens-before）</ins>关系）。但是，在另外的线程看来，这种顺序无法保证。由于未加任何同步限制，顺序标记为 <code>std::memory_order_relaxed</code> 的原子操作只是简单地遵循各个原子变量自身的修改顺序（modification-order）而已。</p>
<p>首先看一段简单的代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x&#123;<span class="literal">false</span>&#125;, y&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);  <span class="comment">// 1.</span></span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);  <span class="comment">// 2.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_relaxed));  <span class="comment">// 3.</span></span><br><span class="line">  <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;  <span class="comment">// 4.</span></span><br><span class="line">    z.<span class="built_in">fetch_add</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y)</span>, <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>();</span><br><span class="line">  b.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(<span class="number">0</span> != z.<span class="built_in">load</span>());  <span class="comment">// 5.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照经典的「穿插思维模型」（即顺序一致性模型），(3) 处循环等待直到 <code>y</code> 为真，那么<strong>由于 (1) 先于 (2) 发生，(3) 先于 (4) 发生</strong>，所以 (4) 必然为真，因此 (5) 的断言永不失效。但实际上，由于 (1) -- (4) 的顺序标记都是 <code>std::memory_order_relaxed</code>，此处并无同步保证，也没有单线程中的先序关系保证。这也就是说，上述两个先于关系不一定成立；即便成立，(2) 不必然与 (3) <ins>同步（synchronizes-with）</ins>，因此也就无法传递上述两个先于关系。所以站在 (4) 的角度看，并不保证 (1) <ins>先于（happens-before）</ins> (4) 发生。所以 (4) 可能读到 <code>false</code> 导致断言失败。</p>
<p>接下来再看一个更加复杂的例子。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; x&#123;<span class="number">0</span>&#125;, y&#123;<span class="number">0</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; ready&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> upper&#123;<span class="number">10UL</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Snapshot</span> &#123;</span><br><span class="line">  <span class="type">int</span> x&#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">int</span> y&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Snapshot t1[upper];</span><br><span class="line">Snapshot t2[upper];</span><br><span class="line">Snapshot t3[upper];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increase</span><span class="params">(std::atomic&lt;<span class="type">int</span>&gt;* var, Snapshot* snapshots)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!ready) &#123;  <span class="comment">// 1.a.</span></span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != upper; ++i) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; snapshot = snapshots[i];</span><br><span class="line">    snapshot.x = x.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">// 2.a.</span></span><br><span class="line">    snapshot.y = y.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">// 3.a.</span></span><br><span class="line">    var-&gt;<span class="built_in">store</span>(i + <span class="number">1</span>, std::memory_order_relaxed);  <span class="comment">// 4.</span></span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">observe</span><span class="params">(Snapshot* snapshots)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!ready) &#123;  <span class="comment">// 1.b.</span></span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != upper; ++i) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; snapshot = snapshots[i];</span><br><span class="line">    snapshot.x = x.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">// 2.b.</span></span><br><span class="line">    snapshot.y = y.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">// 3.b.</span></span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> Snapshot* snapshots)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != upper; ++i) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; snapshot = snapshots[i];</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; snapshot.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; snapshot.y &lt;&lt; <span class="string">&quot;)&quot;</span>;  <span class="comment">// 5.</span></span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">T1</span><span class="params">(increase, &amp;x, t1)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">T2</span><span class="params">(increase, &amp;y, t2)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">T3</span><span class="params">(observe, t3)</span></span>;</span><br><span class="line"></span><br><span class="line">  ready.<span class="built_in">store</span>(<span class="literal">true</span>);  <span class="comment">// 1.c.</span></span><br><span class="line"></span><br><span class="line">  T3.<span class="built_in">join</span>();</span><br><span class="line">  T2.<span class="built_in">join</span>();</span><br><span class="line">  T1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(t1);</span><br><span class="line">  <span class="built_in">print</span>(t2);</span><br><span class="line">  <span class="built_in">print</span>(t3);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能的输出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">(0,2),(1,4),(2,5),(3,6),(4,7),(5,8),(6,9),(7,10),(8,10),(9,10)</span><br><span class="line">(0,0),(0,1),(0,2),(1,3),(2,4),(3,5),(4,6),(5,7),(6,8),(7,9)</span><br><span class="line">(1,3),(2,4),(2,5),(3,6),(4,7),(5,8),(6,8),(7,9),(8,10),(8,10)</span><br></pre></td></tr></table></figure>

<p>我们首先来观察一下代码和结果。</p>
<p>代码部分，</p>
<ul>
<li><code>increase</code> 等待 <code>ready</code> 信号之后 (1)，开始执行 <code>upper</code> 次循环。每次循环以 <code>std::memory_order_relaxed</code> 的顺序标记读取 <code>x</code>(2) 和 <code>y</code>(3) 的值，并记录在快照 <code>snapshot</code> 当中，而后以 <code>std::memory_order_relaxed</code> 的顺序标记更新 <code>var</code> 指向的原子变量（要么是 <code>x</code>，要么是 <code>y</code>）。</li>
<li><code>observe</code> 等待 <code>ready</code> 信号之后 (1)，开始执行 <code>upper</code> 词循环。每次循环以 <code>std::memory_order_relaxed</code> 的顺序标记读取 <code>x</code>(2) 和 <code>y</code>(3) 的值，并记录在快照 <code>snapshot</code> 当中。</li>
<li><code>print</code> 打印历次循环得到的快照 (5)。每个二元组中，第一个数是当次循环读到的 <code>x</code> 的值；第二个数是对应的 <code>y</code> 的值。</li>
<li><code>ready</code> 变量确保三个线程在几乎相同的时间开始，以防（例如说）<code>T1</code> 已经执行完毕而 <code>T3</code> 还尚未开始执行。</li>
</ul>
<p>结果部分，</p>
<ul>
<li>第一行、第二行、第三行分别记录了 <code>T1</code>, <code>T2</code>, <code>T3</code> 在历次循环过程中记录下来的 <code>x</code> 和 <code>y</code> 的值的快照。</li>
<li>关于写<ul>
<li>对于 <code>T1</code> 来说，只有该线程修改 <code>x</code> 的值，每次读到它，都恰好自增 <code>1</code>；</li>
<li>同样对于 <code>T2</code> 来说，<code>y</code> 每次自增 <code>1</code>。</li>
</ul>
</li>
<li>关于读<ul>
<li>对于 <code>T1</code> 和 <code>T3</code> 来说，它们只读 <code>y</code> 的值。因为 <code>y</code> 的修改序列中，<code>y</code> 的值是递增的；因此 <code>T1</code> 和 <code>T3</code> 每次读到的 <code>y</code> 的值都不小于前一次读到的 <code>y</code> 的值；但递增的步长不一定均衡。</li>
<li>对于 <code>T2</code> 和 <code>T3</code> 来说，它们只读 <code>x</code> 的值。基于同样的理由，它们每次读到的 <code>x</code> 的值都是非递减的；但递增的步长不一定均衡。</li>
</ul>
</li>
</ul>
<p>这里我们只给出了一个可能的结果，实际上，符合上述规律的结果，都是可能出现的。</p>
<p>接下来我们正式地描述宽松模型下的规律。</p>
<ul>
<li>对于任意给定的原子变量，其<ins>修改顺序（modification-order）</ins>是全局唯一的。</li>
<li>对于任意线程，<ul>
<li>若未曾读取过该变量的值，则可能读取到修改顺序上任意可能的值。</li>
<li>一旦读取了某个原子变量在修改顺序上的某个值，将来再读取时，要么读取相同的值，要么读取到在修改顺序上更靠后的值，而不可能读到在修改顺序上更靠前的值。</li>
</ul>
</li>
<li>对于任意线程，一旦写入了某个原子变量，将来再读取时，要么读取到此次写入的值，要么读取到修改顺序上相对此次写入更靠后的值。</li>
</ul>
<p>我们可以使用这一规律来回顾本节第一段代码。对于变量 <code>x</code> 来说，其修改顺序是：默认值 <code>false</code>，由 <code>write_x_then_y</code> 写入的值 <code>true</code>。在 <code>read_y_then_x</code> 线程当中，由于从未读取过 <code>x</code> 的值，因此可能读到 <code>x</code> 的修改顺序上的任意值。——可能是 <code>false</code>，亦可能是 <code>true</code>。故而断言可能失败。</p>
<h3 id="获取-释放模型（acquire-release-ordering）"><a href="#获取-释放模型（acquire-release-ordering）" class="headerlink" title="获取-释放模型（acquire-release ordering）"></a>获取-释放模型（acquire-release ordering）</h3><p>接下来，我们讨论居于宽松模型和顺序一致模型当中的获取-释放模型（acquire-release ordering）。</p>
<p>获取-释放模型当中，依然不存在顺序一致模型当中那样的全局唯一操作顺序，但相较宽松模型，增加了部分同步能力。在获取-释放模型当中，</p>
<ul>
<li>原子-store 操作是<ins>释放操作（release-operation）</ins>（<code>std::memory_order_acquire</code>）；</li>
<li>原子-load 操作是<ins>获取操作（acquire-operation）</ins>（<code>std::memory_order_release</code>）；</li>
<li>原子-read-modify-write 操作（例如 <code>fetch_add</code> 或是 <code>exchange</code>）则要么是释放操作，要么是获取操作，要么同时是释放-获取操作（<code>std::memory_order_acq_rel</code>）。</li>
</ul>
<p>同步总是在线程之间成对出现的。一个线程中的释放操作与另一个线程中读到该次写入的获取操作<ins>同步（synchronizes-with）</ins>。这意味着，不同线程可能观察到不同的操作顺序，但这些顺序是有所限制的。</p>
<p>同样地，我们来看一个示例。这个例子是从顺序一致性模型的例子上稍加修改而来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; y = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);  <span class="comment">// 1.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);  <span class="comment">// 2.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!x.<span class="built_in">load</span>(std::memory_order_acquire));  <span class="comment">// 3.</span></span><br><span class="line">  <span class="keyword">if</span> (y.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;  <span class="comment">// 4.</span></span><br><span class="line">    ++z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_acquire));  <span class="comment">// 5.</span></span><br><span class="line">  <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;  <span class="comment">// 6.</span></span><br><span class="line">    ++z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">b</span><span class="params">(write_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">c</span><span class="params">(read_x_then_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">d</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>(); b.<span class="built_in">join</span>(); c.<span class="built_in">join</span>(); d.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z.<span class="built_in">load</span>() != <span class="number">0</span>);  <span class="comment">// can fire</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在本例中，断言可能失败。我们来做进一步分析。</p>
<p>(1) 处是释放操作；(3) 处通过循环确保读到 (1) 写入的值。因而 (1) 的释放操作与 (3) 的获取操作配对，建立<ins>同步（synchronizes-with）</ins>关系，于是 (1) 顺势与 (4) 建立<ins>先于（happens-before）</ins> 关系。同理，(2) 与 (5) 之间也有同步关系，(2) 顺势与 (6) 建立<ins>先于（happens-before）</ins> 关系。</p>
<p>然而，我们无法建立 (1) <ins>先于（happens-before）</ins> (6) 的关系。故而 (6) 可能读到变量 <code>x</code> 的修改序列上的任意值。例如说，可能读到 <code>false</code>。同理 (4) 也可能读到 <code>false</code>。二者同时发生时，断言失败。</p>
<p>因为 store 操作发生在不同的线程，故而我们无法借助一个原子变量的同步关系，构造另一个原子变量的写与读之间的先于关系。这告诉我们两件事情。一是，对于多写多读的场景，我们往往需要顺序一致性模型。二是，若要应用获取-释放模型，store 操作应当发生在同一线程。</p>
<p>接下来我们再看一例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> x&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; y&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">int</span> z&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x = <span class="literal">true</span>;  <span class="comment">// 1.</span></span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);  <span class="comment">// 2.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;  <span class="comment">// 3.</span></span><br><span class="line">    std::this_thread::yield;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x) &#123;  <span class="comment">// 4.</span></span><br><span class="line">    ++z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y)</span>, <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>(); b.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z != <span class="number">0</span>):  <span class="comment">// 5.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑 (1) 和 (2) 在同一线程中，有<ins>先序（sequenced-before）</ins>关系（release 语义保证不乱序）；(3) 处的 spin-wait 保证读到 (2) 的写入，因而 (2) 与 (3) <ins>同步（synchronizes-with）</ins>，再有 (3) 与 (4) 在同一线程中，也有先序关系（acquire 语义保证不乱序）。故而 (1) 必须先于 (4)，从而 (4) 的判断必定成立，而 (5) 的断言永不失败。</p>
<h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>C++ 标准库也提供了内存屏障 <code>std::atomic_thread_fence</code>，它也可以打上顺序标签。</p>
<p>理解起来，带上 <code>std::memory_order_release</code> 的内存屏障，倾向于向下结合一个 store 操作，将它的内存顺序提升为 <code>std::memory_order_release</code>（如果原本是 <code>std::memory_order_relaxed</code> 的话）。带上 <code>std::memory_order_acquire</code> 的内存屏障，倾向于向上结合一个 load 操作，将它的内存顺序提升为 <code>std::memory_order_acquire</code>（如果原本是 <code>std::memory_order_relaxed</code> 的话）。从而建立获取-释放的同步关系。</p>
<p>我们可以将上例稍加修改得到：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> x&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; y&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">int</span> z&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x = <span class="literal">true</span>;  <span class="comment">// 1.</span></span><br><span class="line">  std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_release);  <span class="comment">// 2.a.</span></span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);  <span class="comment">// 2.b.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;  <span class="comment">// 3.a.</span></span><br><span class="line">    std::this_thread::yield;</span><br><span class="line">  &#125;</span><br><span class="line">  std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_acquire);  <span class="comment">// 3.b.</span></span><br><span class="line">  <span class="keyword">if</span> (x) &#123;  <span class="comment">// 4.</span></span><br><span class="line">    ++z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y)</span>, <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>(); b.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z != <span class="number">0</span>):  <span class="comment">// 5.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，(2.a) 的 release-屏障向下与 (2.b) 的宽松-store 操作结合，使得该操作提升为 release-store；(3.b) 的 acquire-屏障向上与 (3.a) 的宽松-load 操作结合，使得该操作提升为 acquire-load。reloease-store 和 acquire-load 构成<ins>同步（synchronizes-with）</ins>，又有 release&#x2F;acquire 语义保证局部顺序，因此有 (1) <ins>先于（happens-before）</ins> (4)，从而 (5) 的断言不会失败。</p>

    </div>

    
    
    <div class="post-widgets">
      <div id="needsharebutton-postbottom">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    </div>
        <div class="reward-container">
  <div>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/reward/wechatpay-cropped.png" alt="Liam Huang 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/reward/alipay-cropped.png" alt="Liam Huang 支付宝">
        <p>支付宝</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/reward/paypal.jpeg" alt="Liam Huang 贝宝">
        <p>贝宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Liam Huang
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://liam.page/2021/12/14/memory-order-cpp-03/" title="程序员的自我修养（⑬）：C++ 的内存顺序·下">https://liam.page/2021/12/14/memory-order-cpp-03/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Atomics/" rel="tag"># Atomics</a>
              <a href="/tags/Memory-Model/" rel="tag"># Memory Model</a>
              <a href="/tags/Memory-Order/" rel="tag"># Memory Order</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/12/11/memory-order-cpp-02/" rel="prev" title="程序员的自我修养（⑫）：C++ 的内存顺序·中">
      <i class="fa fa-chevron-left"></i> 程序员的自我修养（⑫）：C++ 的内存顺序·中
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/04/01/fix-missing-Python2-7-on-macOS-Monterey-12-3/" rel="next" title="解决 macOS Monterey 12.3 上因缺失 Python 2.7 导致的问题">
      解决 macOS Monterey 12.3 上因缺失 Python 2.7 导致的问题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-number">1.</span> <span class="nav-text">最简单的例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E5%85%B3%E7%B3%BB"><span class="nav-number">2.</span> <span class="nav-text">两种关系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%EF%BC%88synchronizes-with%EF%BC%89%E5%85%B3%E7%B3%BB"><span class="nav-number">2.1.</span> <span class="nav-text">同步（synchronizes-with）关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%88%E4%BA%8E%EF%BC%88happens-before%EF%BC%89%E5%85%B3%E7%B3%BB"><span class="nav-number">3.</span> <span class="nav-text">先于（happens-before）关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E9%A1%BA%E5%BA%8F%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.</span> <span class="nav-text">三种顺序模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%A8%A1%E5%9E%8B%EF%BC%88sequentially-consistent-ordering%EF%BC%89"><span class="nav-number">4.1.</span> <span class="nav-text">顺序一致模型（sequentially consistent ordering）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%BD%E6%9D%BE%E6%A8%A1%E5%9E%8B%EF%BC%88relaxed-ordering%EF%BC%89"><span class="nav-number">4.2.</span> <span class="nav-text">宽松模型（relaxed ordering）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96-%E9%87%8A%E6%94%BE%E6%A8%A1%E5%9E%8B%EF%BC%88acquire-release-ordering%EF%BC%89"><span class="nav-number">4.3.</span> <span class="nav-text">获取-释放模型（acquire-release ordering）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="nav-number">5.</span> <span class="nav-text">内存屏障</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Liam Huang"
      src="/images/avatar/avatar-3.jpg">
  <p class="site-author-name" itemprop="name">Liam Huang</p>
  <div class="site-description" itemprop="description">虚室生白，吉祥止止</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">404</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">773</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://dennybritz.com/" title="https:&#x2F;&#x2F;dennybritz.com&#x2F;" rel="noopener" target="_blank">Denny</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://chattymoney.com/" title="http:&#x2F;&#x2F;chattymoney.com&#x2F;" rel="noopener" target="_blank">ChattyMoney</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://qixinbo.info/" title="http:&#x2F;&#x2F;qixinbo.info&#x2F;" rel="noopener" target="_blank">XinboQi</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://ionizing.page/" title="https:&#x2F;&#x2F;ionizing.page&#x2F;" rel="noopener" target="_blank">ChenLinjie</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://yihui.name/" title="https:&#x2F;&#x2F;yihui.name&#x2F;" rel="noopener" target="_blank">Yihui</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.felixc.at/" title="https:&#x2F;&#x2F;blog.felixc.at&#x2F;" rel="noopener" target="_blank">Felix</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://wyydsb.xin/" title="https:&#x2F;&#x2F;wyydsb.xin&#x2F;" rel="noopener" target="_blank">Gunjianpan</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://joselynzhao.top/" title="https:&#x2F;&#x2F;joselynzhao.top&#x2F;" rel="noopener" target="_blank">JoselynZhao</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.dang.fan/" title="https:&#x2F;&#x2F;blog.dang.fan&#x2F;" rel="noopener" target="_blank">DangFan</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://harrychen.xyz/" title="https:&#x2F;&#x2F;harrychen.xyz" rel="noopener" target="_blank">HarryChen</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.echen.me/" title="https:&#x2F;&#x2F;blog.echen.me&#x2F;" rel="noopener" target="_blank">EdwinChen</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://fengweiustc.github.io/" title="https:&#x2F;&#x2F;fengweiustc.github.io&#x2F;" rel="noopener" target="_blank">WayneFung</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cyningsun.com/" title="https:&#x2F;&#x2F;www.cyningsun.com&#x2F;" rel="noopener" target="_blank">CyningSun</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://0o0blog.com/" title="https:&#x2F;&#x2F;0o0blog.com&#x2F;" rel="noopener" target="_blank">Francis</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2013 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liam Huang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">1.5m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">45:11</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>


<script>
  window.addEventListener('DOMContentLoaded', function() {
    
    
    var intervalTotalViews = setInterval(fixTotalViews, 100);
    var offsetTotalViews   = parseInt(100000);
    function fixTotalViews() {
      if (document.getElementById('busuanzi_container_site_pv').style.display != "none") {
        clearInterval(intervalTotalViews);
        var el = document.getElementById("busuanzi_value_site_pv");
        var value = parseInt(el.innerHTML) + offsetTotalViews;
        el.innerHTML = '' + value;
      }
    }
    
  });
</script>










      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>














<script type="text/javascript">
var crashSwitched = false;
var originalTitle = document.title;
var titleTime;
document.addEventListener('visibilitychange', function () {
  if (document.hidden) {
    if (Math.random() < parseFloat(0.25)) {
      crashSwitched = true;
      document.title = '╭(°A°`)╮ 页面崩溃啦~' + originalTitle;
      clearTimeout(titleTime);
    }
  } else {
    if (crashSwitched == true) {
      crashSwitched = false;
      document.title = '(ฅ>ω<*ฅ) 咦，又好了~' + originalTitle;
      titleTime = setTimeout(function () {
        document.title = originalTitle;
      }, 2000);
    }
  }
});
</script>



    <div id="pjax">
  

  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://liam.page/2021/12/14/memory-order-cpp-03/',]
      });
      });
  </script>

  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script>
  <script>
      pbOptions = {};
        pbOptions.iconStyle = "default";
        pbOptions.boxForm = "horizontal";
        pbOptions.position = "topCenter";
        pbOptions.networks = "Wechat,Weibo,renren,Twitter,Facebook,Douban,QQZone,Evernote,Mailto";
      new needShareButton('#needsharebutton-postbottom', pbOptions);
  </script>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'a3d846b3392f468b5746',
      clientSecret: '61bc947cad0ec7078e800e05b1e3c78b763b2c55',
      repo        : 'liam0205.github.io',
      owner       : 'Liam0205',
      admin       : ['Liam0205'],
      id          : '2bca316902b435cc2ec03ef4499cc17a',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
</body>
</html>

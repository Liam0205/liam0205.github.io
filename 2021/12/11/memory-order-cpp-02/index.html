<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png">
  <link rel="mask-icon" href="/images/favicon/safari-pinned-tab.svg" color="#222">
  <link rel="manifest" href="/images/favicon/site.webmanifest">
  <meta name="msapplication-config" content="/images/favicon/browserconfig.xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="google-site-verification" content="TYuJQFuiVqfbFfJAkHfXigSDRIMibztxXxgl_iAaQhA">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liam.page","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前两篇（内存模型与内存顺序·上）翻译了 CPPreference 上关于内存模型和内存顺序的概念，务虚伦理较多。此篇继续相关讨论，虽仍主要是对应页面的翻译，但会展开做一些讨论。">
<meta property="og:type" content="article">
<meta property="og:title" content="程序员的自我修养（⑫）：C++ 的内存顺序·中">
<meta property="og:url" content="https://liam.page/2021/12/11/memory-order-cpp-02/index.html">
<meta property="og:site_name" content="始终">
<meta property="og:description" content="前两篇（内存模型与内存顺序·上）翻译了 CPPreference 上关于内存模型和内存顺序的概念，务虚伦理较多。此篇继续相关讨论，虽仍主要是对应页面的翻译，但会展开做一些讨论。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-12-11T00:27:42.000Z">
<meta property="article:modified_time" content="2021-12-13T16:05:00.905Z">
<meta property="article:author" content="Liam Huang">
<meta property="article:tag" content="Atomics">
<meta property="article:tag" content="Memory Model">
<meta property="article:tag" content="Memory Order">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://liam.page/2021/12/11/memory-order-cpp-02/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><style>
#needsharebutton-postbottom {
  cursor: pointer;
  height: 26px;
  margin-top: 10px;
  position: relative;
}
#needsharebutton-postbottom .btn {
  border: 1px solid $btn-default-border-color;
  border-radius: 3px;
  display: initial;
  padding: 1px 4px;
}
</style>
  <title>程序员的自我修养（⑫）：C++ 的内存顺序·中 | 始终</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-44836433-1"></script>
    <script data-pjax>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-44836433-1');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">始终</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">不忘初心</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">404</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">15</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">773</span></a>

  </li>
        <li class="menu-item menu-item-系列">

    <a href="/series/" rel="section"><i class="fa fa-fw fa-book"></i>系列</a>

  </li>
        <li class="menu-item menu-item-札记-&-留言板">

    <a href="/notes/" rel="section"><i class="fa fa-fw fa-sticky-note"></i>札记 & 留言板</a>

  </li>
        <li class="menu-item menu-item-英文">

    <a href="/en/" rel="section"><i class="fa fa-fw fa-link"></i>英文</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liam.page/2021/12/11/memory-order-cpp-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar/avatar-3.jpg">
      <meta itemprop="name" content="Liam Huang">
      <meta itemprop="description" content="虚室生白，吉祥止止">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="始终">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          程序员的自我修养（⑫）：C++ 的内存顺序·中
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021 年 12 月 11 日 08:27:42" itemprop="dateCreated datePublished" datetime="2021-12-11T08:27:42+08:00">2021 年 12 月 11 日</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021 年 12 月 14 日 00:05:00" itemprop="dateModified" datetime="2021-12-14T00:05:00+08:00">2021 年 12 月 14 日</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm-and-Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Algorithm and Computer Science</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>前两篇（<a href="/2021/06/05/memory-model-cpp/">内存模型</a>与<a href="/2021/06/06/memory-order-cpp-01/">内存顺序·上</a>）翻译了 CPPreference 上关于内存模型和内存顺序的概念，务虚伦理较多。此篇继续相关讨论，虽仍主要是<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/atomic/memory_order">对应页面</a>的翻译，但会展开做一些讨论。</p>
<span id="more"></span>

<h2 id="六种内存顺序标记"><a href="#六种内存顺序标记" class="headerlink" title="六种内存顺序标记"></a>六种内存顺序标记</h2><p>C++ 标准库定义了六中内存顺序标记（memory order tag）。他们被定义为一个枚举类型。在 C++11 之后、C++20 之前，定义为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">memory_order</span> &#123;</span><br><span class="line">    memory_order_relaxed,</span><br><span class="line">    memory_order_consume,</span><br><span class="line">    memory_order_acquire,</span><br><span class="line">    memory_order_release,</span><br><span class="line">    memory_order_acq_rel,</span><br><span class="line">    memory_order_seq_cst</span><br><span class="line">&#125; memory_order;</span><br></pre></td></tr></table></figure>

<p>在 C++20 中，则使用新的 <code>enum class</code> 重新定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">memory_order</span> : <span class="comment">/*unspecified*/</span> &#123;</span><br><span class="line">    relaxed, consume, acquire, release, acq_rel, seq_cst</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_relaxed = memory_order::relaxed;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_consume = memory_order::consume;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_acquire = memory_order::acquire;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_release = memory_order::release;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_acq_rel = memory_order::acq_rel;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> memory_order memory_order_seq_cst = memory_order::seq_cst;</span><br></pre></td></tr></table></figure>

<p>我们知道，原子变量上没有数据竞争，从而提供了良定义的多线程并发读写能力。因此，原子变量有可能实际上建立了线程间的同步关系，于是建立了某种<ins>先于（happens-before）</ins>关系。</p>
<p>在原子操作上添加六种内存顺序标记（中的一部分），会<strong>影响（但不一定改变；视 CPU 架构）原子操作附近的内存访问顺序（包括其他原子操作，亦包含对非原子变量的读写操作）</strong>。注意，内存顺序（通过六种标记）讨论的实际上是线程内原子操作附近非原子操作访问内存的顺序，而非是多线程之间的执行顺序。只不过，因为原子变量自身可能建立了线程间的同步关系，所以<strong>两个线程内各自的内存顺序会经由原子变量的同步建立间接的顺序关系</strong>。亦即，<strong>内存顺序本质上是在讨论单线程内指令执行顺序对多线程影响</strong>的问题。显然，通过添加内存顺序标记，编译器优化和 CPU 指令多发射（multiple issue）、CPU 乱序执行（out-of-order execution）都可能受到一定影响。</p>
<p>所有原子操作默认的内存顺序标记是 <code>std::memory_order_seq_cst</code>，亦即，提供顺序一致性的顺序保证（后续讨论）。目前而言，在绝大多数 CPU 架构上，顺序一致性模型都需要或多或少地在原子操作前后加上内存屏障（memory fence）。因而，顺序一致性虽好，但会损失部分性能。使用其它内存顺序标记则或多或少降低顺序一致性的保证。</p>
<table>
<thead>
<tr>
<th>标记</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>memory_order_relaxed</code></td>
<td>宽松操作：仅保证原子操作自身的原子性，对其他读写操作不做任何同步，亦无顺序上的限制。</td>
</tr>
<tr>
<td><code>memory_order_consume</code></td>
<td>打上此标记的 load 操作对相关内存位置施加<ins><a href="/2021/06/06/memory-order-cpp-01/#%E6%B6%88%E8%B4%B9%E6%93%8D%E4%BD%9C%EF%BC%88consume-operation%EF%BC%89">消费操作（consume operation）</a></ins>：当前线程中，所有依赖当前 load 操作读取的值的读写操作不得重排序至当前操作之前。因此，其他线程中相同原子变量<ins>释放操作（release operation）</ins>依赖的变量的写入，对当前线程是可见的。多数平台上，该标记仅影响编译器优化。</td>
</tr>
<tr>
<td><code>memory_order_acquire</code></td>
<td>打上此标记的 load 操作对相关内存位置施加<ins><a href="/2021/06/06/memory-order-cpp-01/#%E5%8D%A0%E6%9C%89%E6%93%8D%E4%BD%9C%EF%BC%88aquire-operation%EF%BC%89">占有操作（aquire operation）</a></ins>：当前线程中，所有读写操作不得重排序至当前操作之前。因此，其他线程中相同原子变量<ins>释放操作（release operation）</ins>之前的写入，对当前线程是可见的。</td>
</tr>
<tr>
<td><code>memory_order_release</code></td>
<td>打上此标记的 store 操作对相关内存位置施加<ins><a href="/2021/06/06/memory-order-cpp-01/#%E9%87%8A%E6%94%BE%E6%93%8D%E4%BD%9C%EF%BC%88release-operation%EF%BC%89">释放操作（release operation）</a></ins>：当前线程中，所有读写操作不得重排至当前操作之后。因此，当前操作所在线程之前的写入操作，在其他线程中，对该原子变量施加<ins>占有操作（aquire operation）</ins>之后是可见的。也因此，当前操作所在线程中，当前操作所依赖的写入操作，在其他线程中，对该原子变量施加<ins>消费操作（consume operation）</ins>之后是可见的。</td>
</tr>
<tr>
<td><code>memory_order_acq_rel</code></td>
<td>打上此标记的 read-modify-write 操作既是<ins>占有操作（aquire operation）</ins>又是<ins>释放操作（release operation）</ins>：当前线程中的读写操作不能重排至当前操作之后（如果原本在之前），亦不能重排至当前操作之前（如果原本在之后）。因此，其他线程中相同原子变量<ins>释放操作（release operation）</ins>之前的写入，对当前 modification 是可见的；该 modification 对其他线程中相同原子变量<ins>占有操作（aquire operation）</ins>之后亦是可见的。</td>
</tr>
<tr>
<td><code>memory_order_seq_cst</code></td>
<td>打上此标记的 load 操作对相关内存位置施加<ins>占有操作（aquire operation）</ins>；打上此标记的 store 操作对相关内存位置施加<ins>释放操作（release operation）</ins>；打上此标记的 read-modify-write 对相关内存位置施加<ins>占有操作（aquire operation）</ins>和<ins>释放操作（release operation）</ins>。此外，对所有线程来说，所有打上该标记的写操作，存在一个全局修改顺序（尽管具体顺序在执行时才确定）。也就是说，对于所有线程来说，看见的这些写操作的顺序是一致的。</td>
</tr>
</tbody></table>
<h2 id="宽松顺序（Relaxed-ordering）"><a href="#宽松顺序（Relaxed-ordering）" class="headerlink" title="宽松顺序（Relaxed ordering）"></a>宽松顺序（Relaxed ordering）</h2><p>宽松顺序仅保证原子操作自身的原子性，对其他读写操作不做任何同步，亦无顺序上的限制。因此，它们不是同步操作，仅保证原子变量上读写操作的原子性，以及各个原子变量自身修改顺序的一致性（对于同一个变量的两次修改，虽然顺序不一定，但是所有其他线程观察到的修改顺序都是相同的）。</p>
<p>假定 <code>x</code> 和 <code>y</code> 是两个全局变量，均被初始化为零，则下列代码执行完毕之后，存在 <code>r1 == r2 == 42</code> 的可能性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// global</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; x&#123;<span class="number">0</span>&#125;, y&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread 1:</span></span><br><span class="line">r1 = y.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">// A</span></span><br><span class="line">x.<span class="built_in">store</span>(r1, std::memory_order_relaxed);  <span class="comment">// B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread 2:</span></span><br><span class="line">r2 = x.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">// C</span></span><br><span class="line">y.<span class="built_in">store</span>(<span class="number">42</span>, std::memory_order_relaxed);  <span class="comment">// D</span></span><br></pre></td></tr></table></figure>

<p>这是因为，虽然在线程 1 和线程 2 之间没有任何同步；于是，对于原子变量 <code>y</code> 的<ins>修改顺序（Modification Order）</ins>来说，D 可能先于 A 发生；同样，对于原子变量 <code>x</code> 的<ins>修改顺序（Modification Order）</ins>来说，B 可能先于 C 发生。</p>
<p>宽松顺序的典型场景是不断增加的计数器。计数器的增加只需有原子性的保证，而对同步或是内存顺序没有要去。例如，<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/memory/shared_ptr"><code>std::shared_ptr</code></a> 当中的引用计数的增加。实例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; cnt = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">1000</span>; ++n) &#123;</span><br><span class="line">        cnt.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; ++n) &#123;</span><br><span class="line">        v.<span class="built_in">emplace_back</span>(f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : v) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final counter value is &quot;</span> &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其输出应该是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Final counter value is 10000</span><br></pre></td></tr></table></figure>

<p>不过，对于 <code>std::shard_ptr</code> 当中的引用计数来说，其减少需要与析构函数当中的 load 操作有 acquire-release 的同步。</p>
<h2 id="释放-获取顺序（Release-Acquire-ordering）"><a href="#释放-获取顺序（Release-Acquire-ordering）" class="headerlink" title="释放-获取顺序（Release-Acquire ordering）"></a>释放-获取顺序（Release-Acquire ordering）</h2><p>若在线程 A 当中的原子 store 操作被标记上 <code>std::memory_order_release</code>，而若在线程 B 当中相同原子变量的 load 操作被标记上 <code>std::memory_order_acquire</code>，则所有在线程 A 看来<ins>先于（happens-before）</ins>该 store 操作的那些内存写入（包括非原子变量写入和宽松顺序的原子变量写入），在线程 B 中都有<ins>可见副作用（Visible side-effects）</ins>。也就是说，一旦线程 B 的原子 load 操作完成，线程 B 可见线程 A 写入内存的所有内容。</p>
<p>这一同步仅只建立在对同一原子变量执行释放操作和获取操作的线程中。其他线程观察到的内存访问顺序可能异于同步的线程之中的任意一个。</p>
<p>在部分强顺序的 CPU 架构中（例如 <code>x86</code>, SPARC TSO, IBM mainframe 等），释放-获取顺序对大多数操作来说都是自动保证的。因此，对于释放-获取顺序的同步来说，无需引入额外的 CPU 指令（来确保内存顺序）；但在编译器优化阶段，仍需加入一些限制（例如：编译器不能将非原子的 store 操作挪到原子 store-release 操作之后；亦不能将非原子的 load 操作挪到原子 load-acquire 操作之前）。</p>
<p>在弱顺序的 CPU 架构中（例如 ARM,Itanium, PowerPC），则需加入额外的 CPU 指令或是内存屏障。</p>
<p>互斥锁（例如 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/mutex"><code>std::mutex</code></a>&#x2F;<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/atomic/atomic_flag">atomic spinlock</a>）亦属于释放-获取同步：当锁被线程 A 释放而后被线程 B 获取，则在锁被释放之前临界区中所有对共享变量的写入操作在线程 B 获取锁之后均可见。</p>
<p>下例中，通过原子变量 <code>ptr</code> 建立起了 <code>producer</code> 线程和 <code>consumer</code> 线程之间的获取-释放同步，因此两个 <code>assert</code> 永远不会失败。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;std::string*&gt; ptr&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"><span class="type">int</span> data&#123;<span class="number">42</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string* p  = <span class="keyword">new</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    data = <span class="number">42</span>;</span><br><span class="line">    ptr.<span class="built_in">store</span>(p, std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string* p2;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">nullptr</span> == (p2 = ptr.<span class="built_in">load</span>(std::memory_order_acquire)));</span><br><span class="line">    <span class="built_in">assert</span>(*p2 == <span class="string">&quot;Hello&quot;</span>); <span class="comment">// never fires</span></span><br><span class="line">    <span class="built_in">assert</span>(data == <span class="number">42</span>); <span class="comment">// never fires</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>(); t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下例则展示了在三个线程之中，获取-释放顺序的传递。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; flag = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    data.<span class="built_in">push_back</span>(<span class="number">42</span>);</span><br><span class="line">    flag.<span class="built_in">store</span>(<span class="number">1</span>, std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> expected = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!flag.<span class="built_in">compare_exchange_strong</span>(expected, <span class="number">2</span>, std::memory_order_acq_rel)) &#123;</span><br><span class="line">        expected = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (flag.<span class="built_in">load</span>(std::memory_order_acquire) &lt; <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">assert</span>(data.<span class="built_in">at</span>(<span class="number">0</span>) == <span class="number">42</span>); <span class="comment">// will never fire</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">a</span><span class="params">(thread_1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">b</span><span class="params">(thread_2)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">c</span><span class="params">(thread_3)</span></span>;</span><br><span class="line">    a.<span class="built_in">join</span>(); b.<span class="built_in">join</span>(); c.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="释放-消费顺序（Release-Consume-ordering）"><a href="#释放-消费顺序（Release-Consume-ordering）" class="headerlink" title="释放-消费顺序（Release-Consume ordering）"></a>释放-消费顺序（Release-Consume ordering）</h2><p>若在线程 A 当中的原子 store 操作被标记上 <code>std::memory_order_release</code>，而若在线程 B 当中相同原子变量的 load 操作被标记上 <code>std::memory_order_consume</code>，则所有在线程 A 看来<ins>先于（happens-before）</ins>该 store 操作的那些内存写入（包括非原子变量写入和宽松顺序的原子变量写入），在线程 B 中依赖该原子变量的表达式和函数看来都有<ins>可见副作用（Visible side-effects）</ins>。也就是说，一旦线程 B 的原子 load 操作完成，线程 B 中依赖该原子变量的表达式和函数可见线程 A 写入内存的所有内容。</p>
<p>这一同步仅只建立在对同一原子变量执行消费操作和获取操作的线程中。其他线程观察到的内存访问顺序可能异于同步的线程之中的任意一个。</p>
<p>在除 DEC Alpha 之外的主流 CPU 上，释放-消费顺序（亦称：依赖顺序）是自动保证的。因此，对于释放-获取顺序的同步来说，无需引入额外的 CPU 指令（来确保内存顺序）；但在编译器优化阶段，仍需加入一些限制（例如：编译器不能将非原子的 store 操作挪到原子 store-release 操作之后；亦不能将涉及到依赖链的非原子的 load 操作挪到原子 load-consume 操作之前）。</p>
<p>该顺序的使用，往往见于对并发共享数据结构有频繁读取而极少写入的场景（例如路由表、安全策略、防火墙规则等）。</p>
<p>注意，截至 2015 年 2 月，尚未有编译器追踪了依赖链条，因此，消费操作被提升为获取操作。</p>
<p>下例中，通过原子变量 <code>ptr</code> 建立起了 <code>producer</code> 线程和 <code>consumer</code> 线程之间的释放-消费同步，因此第一个 <code>assert</code> 永远不会失败，但第二个 <code>assert</code> 可能失败。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;std::string*&gt; ptr;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string* p  = <span class="keyword">new</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    data = <span class="number">42</span>;</span><br><span class="line">    ptr.<span class="built_in">store</span>(p, std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string* p2;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">nullptr</span> == (p2 = ptr.<span class="built_in">load</span>(std::memory_order_consume)));</span><br><span class="line">    <span class="built_in">assert</span>(*p2 == <span class="string">&quot;Hello&quot;</span>); <span class="comment">// never fires: *p2 carries dependency from ptr</span></span><br><span class="line">    <span class="built_in">assert</span>(data == <span class="number">42</span>); <span class="comment">// may or may not fire: data does not carry dependency from ptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>(); t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="顺序一致顺序（Sequentially-consistent-ordering）"><a href="#顺序一致顺序（Sequentially-consistent-ordering）" class="headerlink" title="顺序一致顺序（Sequentially-consistent ordering）"></a>顺序一致顺序（Sequentially-consistent ordering）</h2><p>标记上 <code>std::memory_order_seq_cst</code> 的原子操作不仅满足释放-获取顺序的要求（一个线程中 store-release 之前的写入操作在另一个 load-acquire 之后都可见），而且为所有如此标记的原子操作建立了<strong>唯一的全局统一修改顺序（single total modification order）</strong>。</p>
<p>正式地说，在不考虑 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/atomic/atomic_thread_fence"><code>std::atomic_thread_fence</code></a> 的情况下，对于每个 load 原子变量 M 的操作 B（标记为 <code>std::memory_order_seq_cst</code>），它读取到的值来自以下三种可能：</p>
<ul>
<li>在上述<strong>唯一的全局统一修改顺序</strong>中的上一个修改了 M 的操作 A 的结果；</li>
<li>若存在这样的 A，B 还可能读到另一个修改了 M 的操作 C，它没有标记为 <code>std::memory_order_seq_cst</code>，并且不<ins>先于（happens-before）</ins> A；</li>
<li>若不存在这样的 A，B 读取的结果来自另一个修改了 M 的没有标记为 <code>std::memory_order_seq_cst</code>的操作 D。</li>
</ul>
<!-- Sequential ordering may be necessary for multiple producer-multiple consumer situations where all consumers must observe the actions of all producers occurring in the same order. -->

<p>顺序一致对于多生产者多消费者的情形是必要的。这是因为，所有消费者必须能够以相同的顺序观察到所有生产者的行为。</p>
<!-- Total sequential ordering requires a full memory fence CPU instruction on all multi-core systems. This may become a performance bottleneck since it forces the affected memory accesses to propagate to every core. -->

<p>在所有多核系统中（注：逻辑核），完全的顺序一致都会插入大量内存屏障指令。这使得相应的内存访问需要对所有核心进行广播，因而可能成为性能瓶颈。</p>
<!-- This example demonstrates a situation where sequential ordering is necessary. Any other ordering may trigger the assert because it would be possible for the threads c and d to observe changes to the atomics x and y in opposite order. -->

<p>下例中，顺序一致即是必要的。其他更弱的顺序模型可能导致线程 C 和线程 D 观察到原子变量 <code>x</code> 和 <code>y</code> 以不同的顺序修改，从而导致 <code>assert</code> 失败。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; y = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_seq_cst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_seq_cst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!x.<span class="built_in">load</span>(std::memory_order_seq_cst));</span><br><span class="line">    <span class="keyword">if</span> (y.<span class="built_in">load</span>(std::memory_order_seq_cst)) &#123;</span><br><span class="line">        ++z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_seq_cst));</span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_seq_cst)) &#123;</span><br><span class="line">        ++z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">a</span><span class="params">(write_x)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">b</span><span class="params">(write_y)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">c</span><span class="params">(read_x_then_y)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">d</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">    a.<span class="built_in">join</span>(); b.<span class="built_in">join</span>(); c.<span class="built_in">join</span>(); d.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">assert</span>(z.<span class="built_in">load</span>() != <span class="number">0</span>);  <span class="comment">// will never happen</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="与-volatile-的关系"><a href="#与-volatile-的关系" class="headerlink" title="与 volatile 的关系"></a>与 <code>volatile</code> 的关系</h2><!-- Within a thread of execution, accesses (reads and writes) through volatile glvalues cannot be reordered past observable side-effects (including other volatile accesses) that are sequenced-before or sequenced-after within the same thread, but this order is not guaranteed to be observed by another thread, since volatile access does not establish inter-thread synchronization. -->

<p>在<strong>同一线程</strong>中，对 <code>volatile</code> 修饰的<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/value_category#glvalue">泛左值</a>（包括左值和将亡值）的访问（包括读写）不允许被重排序至<ins>先序于（sequenced-before）</ins>该操作的可观测的副作用（包括其他 <code>volatile</code> 访问）之前，亦不允许被重排序至<ins>后序于（sequenced-after）</ins>该操作的可观测的副作用（同上）之后。然而，<code>volatile</code> 访问并未建立线程之间的同步，故而在其他线程中，上述顺序无法得到保证。</p>
<!-- In addition, volatile accesses are not atomic (concurrent read and write is a data race) and do not order memory (non-volatile memory accesses may be freely reordered around the volatile access). -->

<p>此外，对 <code>volatile</code> 修饰的泛左值的访问不是原子的（这意味着读写同一内存位置上的 <code>volatile</code> 变量属于<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/memory_model">数据竞争</a>），同时也不影响内存顺序（非 <code>volatile</code>-访问可以在 <code>volatile</code>-访问附近自由重排序）。</p>
<!-- One notable exception is Visual Studio, where, with default settings, every volatile write has release semantics and every volatile read has acquire semantics (Microsoft Docs), and thus volatiles may be used for inter-thread synchronization. Standard volatile semantics are not applicable to multithreaded programming, although they are sufficient for e.g. communication with a std::signal handler that runs in the same thread when applied to sig_atomic_t variables. -->

<p>一个例外是 Visual Studio。根据<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/cpp/volatile-cpp">微软提供的文档</a>，在默认设置下，<code>volatile</code>-读自带 acquire 语义而 <code>volatile</code>-写自带 release 语义。因此，这些 <code>volatile</code>-访问可被用来建立线程间的同步。但要注意，标准的 <code>volatile</code> 语义不应被用于多线程编程。（这一点在<a href="/2018/01/18/volatile-in-C-and-Cpp/">前作</a>中也有讨论）</p>

    </div>

    
    
    <div class="post-widgets">
      <div id="needsharebutton-postbottom">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    </div>
        <div class="reward-container">
  <div>俗话说，投资效率是最好的投资。 如果您感觉我的文章质量不错，读后收获很大，预计能为您提高 10% 的工作效率，不妨小额捐助我一下，让我有动力继续写出更多好文章。</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/reward/wechatpay-cropped.png" alt="Liam Huang 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/reward/alipay-cropped.png" alt="Liam Huang 支付宝">
        <p>支付宝</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/reward/paypal.jpeg" alt="Liam Huang 贝宝">
        <p>贝宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Liam Huang
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://liam.page/2021/12/11/memory-order-cpp-02/" title="程序员的自我修养（⑫）：C++ 的内存顺序·中">https://liam.page/2021/12/11/memory-order-cpp-02/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Atomics/" rel="tag"># Atomics</a>
              <a href="/tags/Memory-Model/" rel="tag"># Memory Model</a>
              <a href="/tags/Memory-Order/" rel="tag"># Memory Order</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/06/17/discussion-on-kind/" rel="prev" title="论善良">
      <i class="fa fa-chevron-left"></i> 论善良
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/12/14/memory-order-cpp-03/" rel="next" title="程序员的自我修养（⑬）：C++ 的内存顺序·下">
      程序员的自我修养（⑬）：C++ 的内存顺序·下 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E7%A7%8D%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F%E6%A0%87%E8%AE%B0"><span class="nav-number">1.</span> <span class="nav-text">六种内存顺序标记</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%BD%E6%9D%BE%E9%A1%BA%E5%BA%8F%EF%BC%88Relaxed-ordering%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">宽松顺序（Relaxed ordering）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8A%E6%94%BE-%E8%8E%B7%E5%8F%96%E9%A1%BA%E5%BA%8F%EF%BC%88Release-Acquire-ordering%EF%BC%89"><span class="nav-number">3.</span> <span class="nav-text">释放-获取顺序（Release-Acquire ordering）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8A%E6%94%BE-%E6%B6%88%E8%B4%B9%E9%A1%BA%E5%BA%8F%EF%BC%88Release-Consume-ordering%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">释放-消费顺序（Release-Consume ordering）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E9%A1%BA%E5%BA%8F%EF%BC%88Sequentially-consistent-ordering%EF%BC%89"><span class="nav-number">5.</span> <span class="nav-text">顺序一致顺序（Sequentially-consistent ordering）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8E-volatile-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">6.</span> <span class="nav-text">与 volatile 的关系</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Liam Huang"
      src="/images/avatar/avatar-3.jpg">
  <p class="site-author-name" itemprop="name">Liam Huang</p>
  <div class="site-description" itemprop="description">虚室生白，吉祥止止</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">404</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">773</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://dennybritz.com/" title="https:&#x2F;&#x2F;dennybritz.com&#x2F;" rel="noopener" target="_blank">Denny</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://chattymoney.com/" title="http:&#x2F;&#x2F;chattymoney.com&#x2F;" rel="noopener" target="_blank">ChattyMoney</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://qixinbo.info/" title="http:&#x2F;&#x2F;qixinbo.info&#x2F;" rel="noopener" target="_blank">XinboQi</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://ionizing.page/" title="https:&#x2F;&#x2F;ionizing.page&#x2F;" rel="noopener" target="_blank">ChenLinjie</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://yihui.name/" title="https:&#x2F;&#x2F;yihui.name&#x2F;" rel="noopener" target="_blank">Yihui</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.felixc.at/" title="https:&#x2F;&#x2F;blog.felixc.at&#x2F;" rel="noopener" target="_blank">Felix</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://wyydsb.xin/" title="https:&#x2F;&#x2F;wyydsb.xin&#x2F;" rel="noopener" target="_blank">Gunjianpan</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://joselynzhao.top/" title="https:&#x2F;&#x2F;joselynzhao.top&#x2F;" rel="noopener" target="_blank">JoselynZhao</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.dang.fan/" title="https:&#x2F;&#x2F;blog.dang.fan&#x2F;" rel="noopener" target="_blank">DangFan</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://harrychen.xyz/" title="https:&#x2F;&#x2F;harrychen.xyz" rel="noopener" target="_blank">HarryChen</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.echen.me/" title="https:&#x2F;&#x2F;blog.echen.me&#x2F;" rel="noopener" target="_blank">EdwinChen</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://fengweiustc.github.io/" title="https:&#x2F;&#x2F;fengweiustc.github.io&#x2F;" rel="noopener" target="_blank">WayneFung</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cyningsun.com/" title="https:&#x2F;&#x2F;www.cyningsun.com&#x2F;" rel="noopener" target="_blank">CyningSun</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://0o0blog.com/" title="https:&#x2F;&#x2F;0o0blog.com&#x2F;" rel="noopener" target="_blank">Francis</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2013 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liam Huang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">1.5m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">45:11</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>


<script>
  window.addEventListener('DOMContentLoaded', function() {
    
    
    var intervalTotalViews = setInterval(fixTotalViews, 100);
    var offsetTotalViews   = parseInt(100000);
    function fixTotalViews() {
      if (document.getElementById('busuanzi_container_site_pv').style.display != "none") {
        clearInterval(intervalTotalViews);
        var el = document.getElementById("busuanzi_value_site_pv");
        var value = parseInt(el.innerHTML) + offsetTotalViews;
        el.innerHTML = '' + value;
      }
    }
    
  });
</script>










      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>














<script type="text/javascript">
var crashSwitched = false;
var originalTitle = document.title;
var titleTime;
document.addEventListener('visibilitychange', function () {
  if (document.hidden) {
    if (Math.random() < parseFloat(0.25)) {
      crashSwitched = true;
      document.title = '╭(°A°`)╮ 页面崩溃啦~' + originalTitle;
      clearTimeout(titleTime);
    }
  } else {
    if (crashSwitched == true) {
      crashSwitched = false;
      document.title = '(ฅ>ω<*ฅ) 咦，又好了~' + originalTitle;
      titleTime = setTimeout(function () {
        document.title = originalTitle;
      }, 2000);
    }
  }
});
</script>



    <div id="pjax">
  

  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://liam.page/2021/12/11/memory-order-cpp-02/',]
      });
      });
  </script>

  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script>
  <script>
      pbOptions = {};
        pbOptions.iconStyle = "default";
        pbOptions.boxForm = "horizontal";
        pbOptions.position = "topCenter";
        pbOptions.networks = "Wechat,Weibo,renren,Twitter,Facebook,Douban,QQZone,Evernote,Mailto";
      new needShareButton('#needsharebutton-postbottom', pbOptions);
  </script>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'a3d846b3392f468b5746',
      clientSecret: '61bc947cad0ec7078e800e05b1e3c78b763b2c55',
      repo        : 'liam0205.github.io',
      owner       : 'Liam0205',
      admin       : ['Liam0205'],
      id          : '21fc0f0137c446cd153eade21553cd22',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
</body>
</html>
